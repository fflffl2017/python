filename:/usr/lib/python2.7/json/scanner.py
__doc__
"""JSON token scanner
"""

filename:/usr/lib/python2.7/json/decoder.py
__doc__
"""Implementation of JSONDecoder
"""

filename:/usr/lib/python2.7/json/encoder.py
__doc__
"""Implementation of JSONEncoder
"""

filename:/usr/lib/python2.7/symtable.py
__doc__
"""Interface to the compiler's internal symbol tables"""

import _symtable
from _symtable import (USE, DEF_GLOBAL, DEF_LOCAL, DEF_PARAM,
     DEF_IMPORT, DEF_BOUND, OPT_IMPORT_STAR, OPT_EXEC, OPT_BARE_EXEC,
     SCOPE_OFF, SCOPE_MASK, FREE, GLOBAL_IMPLICIT, GLOBAL_EXPLICIT, CELL, LOCAL)

import weakref

__all__ = ["symtable", "SymbolTable", "Class", "Function", "Symbol"]

def symtable(code, filename, compile_type):
    top = _symtable.symtable(code, filename, compile_type)
    return _newSymbolTable(top, filename)

class SymbolTableFactory:
    def __init__(self):
        self.__memo = weakref.WeakValueDictionary()

    def new(self, table, filename):
        if table.type == _symtable.TYPE_FUNCTION:
            return Function(table, filename)
        if table.type == _symtable.TYPE_CLASS:
            return Class(table, filename)
        return SymbolTable(table, filename)

    def __call__(self, table, filename):
        key = table, filename
        obj = self.__memo.get(key, None)
        if obj is None:
            obj = self.__memo[key] = self.new(table, filename)
        return obj

_newSymbolTable = SymbolTableFactory()


class SymbolTable(object):

    def __init__(self, raw_table, filename):
        self._table = raw_table
        self._filename = filename
        self._symbols = {}

    def __repr__(self):
        if self.__class__ == SymbolTable:
            kind = ""
        else:
            kind = "%s " % self.__class__.__name__

        if self._table.name == "global":
            return "<{0}SymbolTable for module {1}>".format(kind, self._filename)
        else:
            return "<{0}SymbolTable for {1} in {2}>".format(kind,
                                                            self._table.name,
                                                            self._filename)

    def get_type(self):
        if self._table.type == _symtable.TYPE_MODULE:
            return "module"
        if self._table.type == _symtable.TYPE_FUNCTION:
            return "function"
        if self._table.type == _symtable.TYPE_CLASS:
            return "class"
        assert self._table.type in (1, 2, 3), \
               "unexpected type: {0}".format(self._table.type)

    def get_id(self):
        return self._table.id

    def get_name(self):
        return self._table.name

    def get_lineno(self):
        return self._table.lineno

    def is_optimized(self):
        return bool(self._table.type == _symtable.TYPE_FUNCTION
                    and not self._table.optimized)

    def is_nested(self):
        return bool(self._table.nested)

    def has_children(self):
        return bool(self._table.children)

    def has_exec(self):
        """Return true if the scope uses exec"""
        return bool(self._table.optimized & (OPT_EXEC | OPT_BARE_EXEC))

    def has_import_star(self):
        """Return true if the scope uses import *"""
        return bool(self._table.optimized & OPT_IMPORT_STAR)

    def get_identifiers(self):
        return self._table.symbols.keys()

    def lookup(self, name):
        sym = self._symbols.get(name)
        if sym is None:
            flags = self._table.symbols[name]
            namespaces = self.__check_children(name)
            sym = self._symbols[name] = Symbol(name, flags, namespaces)
        return sym

    def get_symbols(self):
        return [self.lookup(ident) for ident in self.get_identifiers()]

    def __check_children(self, name):
        return [_newSymbolTable(st, self._filename)
                for st in self._table.children
                if st.name == name]

    def get_children(self):
        return [_newSymbolTable(st, self._filename)
                for st in self._table.children]


class Function(SymbolTable):

    # Default values for instance variables
    __params = None
    __locals = None
    __frees = None
    __globals = None

    def __idents_matching(self, test_func):
        return tuple([ident for ident in self.get_identifiers()
                      if test_func(self._table.symbols[ident])])

    def get_parameters(self):
        if self.__params is None:
            self.__params = self.__idents_matching(lambda x:x & DEF_PARAM)
        return self.__params

    def get_locals(self):
        if self.__locals is None:
            locs = (LOCAL, CELL)
            test = lambda x: ((x >> SCOPE_OFF) & SCOPE_MASK) in locs
            self.__locals = self.__idents_matching(test)
        return self.__locals

    def get_globals(self):
        if self.__globals is None:
            glob = (GLOBAL_IMPLICIT, GLOBAL_EXPLICIT)
            test = lambda x:((x >> SCOPE_OFF) & SCOPE_MASK) in glob
            self.__globals = self.__idents_matching(test)
        return self.__globals

    def get_frees(self):
        if self.__frees is None:
            is_free = lambda x:((x >> SCOPE_OFF) & SCOPE_MASK) == FREE
            self.__frees = self.__idents_matching(is_free)
        return self.__frees


class Class(SymbolTable):

    __methods = None

    def get_methods(self):
        if self.__methods is None:
            d = {}
            for st in self._table.children:
                d[st.name] = 1
            self.__methods = tuple(d)
        return self.__methods


class Symbol(object):

    def __init__(self, name, flags, namespaces=None):
        self.__name = name
        self.__flags = flags
        self.__scope = (flags >> SCOPE_OFF) & SCOPE_MASK # like PyST_GetScope()
        self.__namespaces = namespaces or ()

    def __repr__(self):
        return "<symbol {0!r}>".format(self.__name)

    def get_name(self):
        return self.__name

    def is_referenced(self):
        return bool(self.__flags & _symtable.USE)

    def is_parameter(self):
        return bool(self.__flags & DEF_PARAM)

    def is_global(self):
        return bool(self.__scope in (GLOBAL_IMPLICIT, GLOBAL_EXPLICIT))

    def is_declared_global(self):
        return bool(self.__scope == GLOBAL_EXPLICIT)

    def is_local(self):
        return bool(self.__flags & DEF_BOUND)

    def is_free(self):
        return bool(self.__scope == FREE)

    def is_imported(self):
        return bool(self.__flags & DEF_IMPORT)

    def is_assigned(self):
        return bool(self.__flags & DEF_LOCAL)

    def is_namespace(self):
        """Returns true if name binding introduces new namespace.

        If the name is used as the target of a function or class
        statement, this will be true.

        Note that a single name can be bound to multiple objects.  If
        is_namespace() is true, the name may also be bound to other
        objects, like an int or list, that does not introduce a new
        namespace.
        """
        return bool(self.__namespaces)

    def get_namespaces(self):
        """Return a list of namespaces bound to this name"""
        return self.__namespaces

    def get_namespace(self):
        """Returns the single namespace bound to this name.

        Raises ValueError if the name is bound to multiple namespaces.
        """
        if len(self.__namespaces) != 1:
            raise ValueError, "name is bound to multiple namespaces"
        return self.__namespaces[0]

if __name__ == "__main__":
    import os, sys
    src = open(sys.argv[0]).read()
    mod = symtable(src, os.path.split(sys.argv[0])[1], "exec")
    for ident in mod.get_identifiers():
        info = mod.lookup(ident)
        print info, info.is_local(), info.is_namespace()

filename:/usr/lib/python2.7/SimpleHTTPServer.py
__doc__
"""Simple HTTP Server.

filename:/usr/lib/python2.7/ftplib.py
__doc__
"""An FTP client class and some helper functions.

Based on RFC 959: File Transfer Protocol (FTP), by J. Postel and J. Reynolds

Example:

>>> from ftplib import FTP
>>> ftp = FTP('ftp.python.org') # connect to host, default port
>>> ftp.login() # default, i.e.: user anonymous, passwd anonymous@
'230 Guest login ok, access restrictions apply.'
>>> ftp.retrlines('LIST') # list directory contents
total 9
drwxr-xr-x   8 root     wheel        1024 Jan  3  1994 .
drwxr-xr-x   8 root     wheel        1024 Jan  3  1994 ..
drwxr-xr-x   2 root     wheel        1024 Jan  3  1994 bin
drwxr-xr-x   2 root     wheel        1024 Jan  3  1994 etc
d-wxrwxr-x   2 ftp      wheel        1024 Sep  5 13:43 incoming
drwxr-xr-x   2 root     wheel        1024 Nov 17  1993 lib
drwxr-xr-x   6 1094     wheel        1024 Sep 13 19:07 pub
drwxr-xr-x   3 root     wheel        1024 Jan  3  1994 usr
-rw-r--r--   1 root     root          312 Aug  1  1994 welcome.msg
'226 Transfer complete.'
>>> ftp.quit()
'221 Goodbye.'
>>>

A nice test that reveals some of the network dialogue would be:
python ftplib.py -d localhost -l -p -l
"""

filename:/usr/lib/python2.7/optparse.py
__doc__
"""A powerful, extensible, and easy-to-use option parser.

By Greg Ward <gward@python.net>

Originally distributed as Optik.

For support, use the optik-users@lists.sourceforge.net mailing list
(http://lists.sourceforge.net/lists/listinfo/optik-users).

Simple usage example:

   from optparse import OptionParser

   parser = OptionParser()
   parser.add_option("-f", "--file", dest="filename",
                     help="write report to FILE", metavar="FILE")
   parser.add_option("-q", "--quiet",
                     action="store_false", dest="verbose", default=True,
                     help="don't print status messages to stdout")

   (options, args) = parser.parse_args()
"""

filename:/usr/lib/python2.7/htmlentitydefs.py
__doc__
"""HTML character entity references."""

# maps the HTML entity name to the Unicode code point
name2codepoint = {
    'AElig':    0x00c6, # latin capital letter AE = latin capital ligature AE, U+00C6 ISOlat1
    'Aacute':   0x00c1, # latin capital letter A with acute, U+00C1 ISOlat1
    'Acirc':    0x00c2, # latin capital letter A with circumflex, U+00C2 ISOlat1
    'Agrave':   0x00c0, # latin capital letter A with grave = latin capital letter A grave, U+00C0 ISOlat1
    'Alpha':    0x0391, # greek capital letter alpha, U+0391
    'Aring':    0x00c5, # latin capital letter A with ring above = latin capital letter A ring, U+00C5 ISOlat1
    'Atilde':   0x00c3, # latin capital letter A with tilde, U+00C3 ISOlat1
    'Auml':     0x00c4, # latin capital letter A with diaeresis, U+00C4 ISOlat1
    'Beta':     0x0392, # greek capital letter beta, U+0392
    'Ccedil':   0x00c7, # latin capital letter C with cedilla, U+00C7 ISOlat1
    'Chi':      0x03a7, # greek capital letter chi, U+03A7
    'Dagger':   0x2021, # double dagger, U+2021 ISOpub
    'Delta':    0x0394, # greek capital letter delta, U+0394 ISOgrk3
    'ETH':      0x00d0, # latin capital letter ETH, U+00D0 ISOlat1
    'Eacute':   0x00c9, # latin capital letter E with acute, U+00C9 ISOlat1
    'Ecirc':    0x00ca, # latin capital letter E with circumflex, U+00CA ISOlat1
    'Egrave':   0x00c8, # latin capital letter E with grave, U+00C8 ISOlat1
    'Epsilon':  0x0395, # greek capital letter epsilon, U+0395
    'Eta':      0x0397, # greek capital letter eta, U+0397
    'Euml':     0x00cb, # latin capital letter E with diaeresis, U+00CB ISOlat1
    'Gamma':    0x0393, # greek capital letter gamma, U+0393 ISOgrk3
    'Iacute':   0x00cd, # latin capital letter I with acute, U+00CD ISOlat1
    'Icirc':    0x00ce, # latin capital letter I with circumflex, U+00CE ISOlat1
    'Igrave':   0x00cc, # latin capital letter I with grave, U+00CC ISOlat1
    'Iota':     0x0399, # greek capital letter iota, U+0399
    'Iuml':     0x00cf, # latin capital letter I with diaeresis, U+00CF ISOlat1
    'Kappa':    0x039a, # greek capital letter kappa, U+039A
    'Lambda':   0x039b, # greek capital letter lambda, U+039B ISOgrk3
    'Mu':       0x039c, # greek capital letter mu, U+039C
    'Ntilde':   0x00d1, # latin capital letter N with tilde, U+00D1 ISOlat1
    'Nu':       0x039d, # greek capital letter nu, U+039D
    'OElig':    0x0152, # latin capital ligature OE, U+0152 ISOlat2
    'Oacute':   0x00d3, # latin capital letter O with acute, U+00D3 ISOlat1
    'Ocirc':    0x00d4, # latin capital letter O with circumflex, U+00D4 ISOlat1
    'Ograve':   0x00d2, # latin capital letter O with grave, U+00D2 ISOlat1
    'Omega':    0x03a9, # greek capital letter omega, U+03A9 ISOgrk3
    'Omicron':  0x039f, # greek capital letter omicron, U+039F
    'Oslash':   0x00d8, # latin capital letter O with stroke = latin capital letter O slash, U+00D8 ISOlat1
    'Otilde':   0x00d5, # latin capital letter O with tilde, U+00D5 ISOlat1
    'Ouml':     0x00d6, # latin capital letter O with diaeresis, U+00D6 ISOlat1
    'Phi':      0x03a6, # greek capital letter phi, U+03A6 ISOgrk3
    'Pi':       0x03a0, # greek capital letter pi, U+03A0 ISOgrk3
    'Prime':    0x2033, # double prime = seconds = inches, U+2033 ISOtech
    'Psi':      0x03a8, # greek capital letter psi, U+03A8 ISOgrk3
    'Rho':      0x03a1, # greek capital letter rho, U+03A1
    'Scaron':   0x0160, # latin capital letter S with caron, U+0160 ISOlat2
    'Sigma':    0x03a3, # greek capital letter sigma, U+03A3 ISOgrk3
    'THORN':    0x00de, # latin capital letter THORN, U+00DE ISOlat1
    'Tau':      0x03a4, # greek capital letter tau, U+03A4
    'Theta':    0x0398, # greek capital letter theta, U+0398 ISOgrk3
    'Uacute':   0x00da, # latin capital letter U with acute, U+00DA ISOlat1
    'Ucirc':    0x00db, # latin capital letter U with circumflex, U+00DB ISOlat1
    'Ugrave':   0x00d9, # latin capital letter U with grave, U+00D9 ISOlat1
    'Upsilon':  0x03a5, # greek capital letter upsilon, U+03A5 ISOgrk3
    'Uuml':     0x00dc, # latin capital letter U with diaeresis, U+00DC ISOlat1
    'Xi':       0x039e, # greek capital letter xi, U+039E ISOgrk3
    'Yacute':   0x00dd, # latin capital letter Y with acute, U+00DD ISOlat1
    'Yuml':     0x0178, # latin capital letter Y with diaeresis, U+0178 ISOlat2
    'Zeta':     0x0396, # greek capital letter zeta, U+0396
    'aacute':   0x00e1, # latin small letter a with acute, U+00E1 ISOlat1
    'acirc':    0x00e2, # latin small letter a with circumflex, U+00E2 ISOlat1
    'acute':    0x00b4, # acute accent = spacing acute, U+00B4 ISOdia
    'aelig':    0x00e6, # latin small letter ae = latin small ligature ae, U+00E6 ISOlat1
    'agrave':   0x00e0, # latin small letter a with grave = latin small letter a grave, U+00E0 ISOlat1
    'alefsym':  0x2135, # alef symbol = first transfinite cardinal, U+2135 NEW
    'alpha':    0x03b1, # greek small letter alpha, U+03B1 ISOgrk3
    'amp':      0x0026, # ampersand, U+0026 ISOnum
    'and':      0x2227, # logical and = wedge, U+2227 ISOtech
    'ang':      0x2220, # angle, U+2220 ISOamso
    'aring':    0x00e5, # latin small letter a with ring above = latin small letter a ring, U+00E5 ISOlat1
    'asymp':    0x2248, # almost equal to = asymptotic to, U+2248 ISOamsr
    'atilde':   0x00e3, # latin small letter a with tilde, U+00E3 ISOlat1
    'auml':     0x00e4, # latin small letter a with diaeresis, U+00E4 ISOlat1
    'bdquo':    0x201e, # double low-9 quotation mark, U+201E NEW
    'beta':     0x03b2, # greek small letter beta, U+03B2 ISOgrk3
    'brvbar':   0x00a6, # broken bar = broken vertical bar, U+00A6 ISOnum
    'bull':     0x2022, # bullet = black small circle, U+2022 ISOpub
    'cap':      0x2229, # intersection = cap, U+2229 ISOtech
    'ccedil':   0x00e7, # latin small letter c with cedilla, U+00E7 ISOlat1
    'cedil':    0x00b8, # cedilla = spacing cedilla, U+00B8 ISOdia
    'cent':     0x00a2, # cent sign, U+00A2 ISOnum
    'chi':      0x03c7, # greek small letter chi, U+03C7 ISOgrk3
    'circ':     0x02c6, # modifier letter circumflex accent, U+02C6 ISOpub
    'clubs':    0x2663, # black club suit = shamrock, U+2663 ISOpub
    'cong':     0x2245, # approximately equal to, U+2245 ISOtech
    'copy':     0x00a9, # copyright sign, U+00A9 ISOnum
    'crarr':    0x21b5, # downwards arrow with corner leftwards = carriage return, U+21B5 NEW
    'cup':      0x222a, # union = cup, U+222A ISOtech
    'curren':   0x00a4, # currency sign, U+00A4 ISOnum
    'dArr':     0x21d3, # downwards double arrow, U+21D3 ISOamsa
    'dagger':   0x2020, # dagger, U+2020 ISOpub
    'darr':     0x2193, # downwards arrow, U+2193 ISOnum
    'deg':      0x00b0, # degree sign, U+00B0 ISOnum
    'delta':    0x03b4, # greek small letter delta, U+03B4 ISOgrk3
    'diams':    0x2666, # black diamond suit, U+2666 ISOpub
    'divide':   0x00f7, # division sign, U+00F7 ISOnum
    'eacute':   0x00e9, # latin small letter e with acute, U+00E9 ISOlat1
    'ecirc':    0x00ea, # latin small letter e with circumflex, U+00EA ISOlat1
    'egrave':   0x00e8, # latin small letter e with grave, U+00E8 ISOlat1
    'empty':    0x2205, # empty set = null set = diameter, U+2205 ISOamso
    'emsp':     0x2003, # em space, U+2003 ISOpub
    'ensp':     0x2002, # en space, U+2002 ISOpub
    'epsilon':  0x03b5, # greek small letter epsilon, U+03B5 ISOgrk3
    'equiv':    0x2261, # identical to, U+2261 ISOtech
    'eta':      0x03b7, # greek small letter eta, U+03B7 ISOgrk3
    'eth':      0x00f0, # latin small letter eth, U+00F0 ISOlat1
    'euml':     0x00eb, # latin small letter e with diaeresis, U+00EB ISOlat1
    'euro':     0x20ac, # euro sign, U+20AC NEW
    'exist':    0x2203, # there exists, U+2203 ISOtech
    'fnof':     0x0192, # latin small f with hook = function = florin, U+0192 ISOtech
    'forall':   0x2200, # for all, U+2200 ISOtech
    'frac12':   0x00bd, # vulgar fraction one half = fraction one half, U+00BD ISOnum
    'frac14':   0x00bc, # vulgar fraction one quarter = fraction one quarter, U+00BC ISOnum
    'frac34':   0x00be, # vulgar fraction three quarters = fraction three quarters, U+00BE ISOnum
    'frasl':    0x2044, # fraction slash, U+2044 NEW
    'gamma':    0x03b3, # greek small letter gamma, U+03B3 ISOgrk3
    'ge':       0x2265, # greater-than or equal to, U+2265 ISOtech
    'gt':       0x003e, # greater-than sign, U+003E ISOnum
    'hArr':     0x21d4, # left right double arrow, U+21D4 ISOamsa
    'harr':     0x2194, # left right arrow, U+2194 ISOamsa
    'hearts':   0x2665, # black heart suit = valentine, U+2665 ISOpub
    'hellip':   0x2026, # horizontal ellipsis = three dot leader, U+2026 ISOpub
    'iacute':   0x00ed, # latin small letter i with acute, U+00ED ISOlat1
    'icirc':    0x00ee, # latin small letter i with circumflex, U+00EE ISOlat1
    'iexcl':    0x00a1, # inverted exclamation mark, U+00A1 ISOnum
    'igrave':   0x00ec, # latin small letter i with grave, U+00EC ISOlat1
    'image':    0x2111, # blackletter capital I = imaginary part, U+2111 ISOamso
    'infin':    0x221e, # infinity, U+221E ISOtech
    'int':      0x222b, # integral, U+222B ISOtech
    'iota':     0x03b9, # greek small letter iota, U+03B9 ISOgrk3
    'iquest':   0x00bf, # inverted question mark = turned question mark, U+00BF ISOnum
    'isin':     0x2208, # element of, U+2208 ISOtech
    'iuml':     0x00ef, # latin small letter i with diaeresis, U+00EF ISOlat1
    'kappa':    0x03ba, # greek small letter kappa, U+03BA ISOgrk3
    'lArr':     0x21d0, # leftwards double arrow, U+21D0 ISOtech
    'lambda':   0x03bb, # greek small letter lambda, U+03BB ISOgrk3
    'lang':     0x2329, # left-pointing angle bracket = bra, U+2329 ISOtech
    'laquo':    0x00ab, # left-pointing double angle quotation mark = left pointing guillemet, U+00AB ISOnum
    'larr':     0x2190, # leftwards arrow, U+2190 ISOnum
    'lceil':    0x2308, # left ceiling = apl upstile, U+2308 ISOamsc
    'ldquo':    0x201c, # left double quotation mark, U+201C ISOnum
    'le':       0x2264, # less-than or equal to, U+2264 ISOtech
    'lfloor':   0x230a, # left floor = apl downstile, U+230A ISOamsc
    'lowast':   0x2217, # asterisk operator, U+2217 ISOtech
    'loz':      0x25ca, # lozenge, U+25CA ISOpub
    'lrm':      0x200e, # left-to-right mark, U+200E NEW RFC 2070
    'lsaquo':   0x2039, # single left-pointing angle quotation mark, U+2039 ISO proposed
    'lsquo':    0x2018, # left single quotation mark, U+2018 ISOnum
    'lt':       0x003c, # less-than sign, U+003C ISOnum
    'macr':     0x00af, # macron = spacing macron = overline = APL overbar, U+00AF ISOdia
    'mdash':    0x2014, # em dash, U+2014 ISOpub
    'micro':    0x00b5, # micro sign, U+00B5 ISOnum
    'middot':   0x00b7, # middle dot = Georgian comma = Greek middle dot, U+00B7 ISOnum
    'minus':    0x2212, # minus sign, U+2212 ISOtech
    'mu':       0x03bc, # greek small letter mu, U+03BC ISOgrk3
    'nabla':    0x2207, # nabla = backward difference, U+2207 ISOtech
    'nbsp':     0x00a0, # no-break space = non-breaking space, U+00A0 ISOnum
    'ndash':    0x2013, # en dash, U+2013 ISOpub
    'ne':       0x2260, # not equal to, U+2260 ISOtech
    'ni':       0x220b, # contains as member, U+220B ISOtech
    'not':      0x00ac, # not sign, U+00AC ISOnum
    'notin':    0x2209, # not an element of, U+2209 ISOtech
    'nsub':     0x2284, # not a subset of, U+2284 ISOamsn
    'ntilde':   0x00f1, # latin small letter n with tilde, U+00F1 ISOlat1
    'nu':       0x03bd, # greek small letter nu, U+03BD ISOgrk3
    'oacute':   0x00f3, # latin small letter o with acute, U+00F3 ISOlat1
    'ocirc':    0x00f4, # latin small letter o with circumflex, U+00F4 ISOlat1
    'oelig':    0x0153, # latin small ligature oe, U+0153 ISOlat2
    'ograve':   0x00f2, # latin small letter o with grave, U+00F2 ISOlat1
    'oline':    0x203e, # overline = spacing overscore, U+203E NEW
    'omega':    0x03c9, # greek small letter omega, U+03C9 ISOgrk3
    'omicron':  0x03bf, # greek small letter omicron, U+03BF NEW
    'oplus':    0x2295, # circled plus = direct sum, U+2295 ISOamsb
    'or':       0x2228, # logical or = vee, U+2228 ISOtech
    'ordf':     0x00aa, # feminine ordinal indicator, U+00AA ISOnum
    'ordm':     0x00ba, # masculine ordinal indicator, U+00BA ISOnum
    'oslash':   0x00f8, # latin small letter o with stroke, = latin small letter o slash, U+00F8 ISOlat1
    'otilde':   0x00f5, # latin small letter o with tilde, U+00F5 ISOlat1
    'otimes':   0x2297, # circled times = vector product, U+2297 ISOamsb
    'ouml':     0x00f6, # latin small letter o with diaeresis, U+00F6 ISOlat1
    'para':     0x00b6, # pilcrow sign = paragraph sign, U+00B6 ISOnum
    'part':     0x2202, # partial differential, U+2202 ISOtech
    'permil':   0x2030, # per mille sign, U+2030 ISOtech
    'perp':     0x22a5, # up tack = orthogonal to = perpendicular, U+22A5 ISOtech
    'phi':      0x03c6, # greek small letter phi, U+03C6 ISOgrk3
    'pi':       0x03c0, # greek small letter pi, U+03C0 ISOgrk3
    'piv':      0x03d6, # greek pi symbol, U+03D6 ISOgrk3
    'plusmn':   0x00b1, # plus-minus sign = plus-or-minus sign, U+00B1 ISOnum
    'pound':    0x00a3, # pound sign, U+00A3 ISOnum
    'prime':    0x2032, # prime = minutes = feet, U+2032 ISOtech
    'prod':     0x220f, # n-ary product = product sign, U+220F ISOamsb
    'prop':     0x221d, # proportional to, U+221D ISOtech
    'psi':      0x03c8, # greek small letter psi, U+03C8 ISOgrk3
    'quot':     0x0022, # quotation mark = APL quote, U+0022 ISOnum
    'rArr':     0x21d2, # rightwards double arrow, U+21D2 ISOtech
    'radic':    0x221a, # square root = radical sign, U+221A ISOtech
    'rang':     0x232a, # right-pointing angle bracket = ket, U+232A ISOtech
    'raquo':    0x00bb, # right-pointing double angle quotation mark = right pointing guillemet, U+00BB ISOnum
    'rarr':     0x2192, # rightwards arrow, U+2192 ISOnum
    'rceil':    0x2309, # right ceiling, U+2309 ISOamsc
    'rdquo':    0x201d, # right double quotation mark, U+201D ISOnum
    'real':     0x211c, # blackletter capital R = real part symbol, U+211C ISOamso
    'reg':      0x00ae, # registered sign = registered trade mark sign, U+00AE ISOnum
    'rfloor':   0x230b, # right floor, U+230B ISOamsc
    'rho':      0x03c1, # greek small letter rho, U+03C1 ISOgrk3
    'rlm':      0x200f, # right-to-left mark, U+200F NEW RFC 2070
    'rsaquo':   0x203a, # single right-pointing angle quotation mark, U+203A ISO proposed
    'rsquo':    0x2019, # right single quotation mark, U+2019 ISOnum
    'sbquo':    0x201a, # single low-9 quotation mark, U+201A NEW
    'scaron':   0x0161, # latin small letter s with caron, U+0161 ISOlat2
    'sdot':     0x22c5, # dot operator, U+22C5 ISOamsb
    'sect':     0x00a7, # section sign, U+00A7 ISOnum
    'shy':      0x00ad, # soft hyphen = discretionary hyphen, U+00AD ISOnum
    'sigma':    0x03c3, # greek small letter sigma, U+03C3 ISOgrk3
    'sigmaf':   0x03c2, # greek small letter final sigma, U+03C2 ISOgrk3
    'sim':      0x223c, # tilde operator = varies with = similar to, U+223C ISOtech
    'spades':   0x2660, # black spade suit, U+2660 ISOpub
    'sub':      0x2282, # subset of, U+2282 ISOtech
    'sube':     0x2286, # subset of or equal to, U+2286 ISOtech
    'sum':      0x2211, # n-ary sumation, U+2211 ISOamsb
    'sup':      0x2283, # superset of, U+2283 ISOtech
    'sup1':     0x00b9, # superscript one = superscript digit one, U+00B9 ISOnum
    'sup2':     0x00b2, # superscript two = superscript digit two = squared, U+00B2 ISOnum
    'sup3':     0x00b3, # superscript three = superscript digit three = cubed, U+00B3 ISOnum
    'supe':     0x2287, # superset of or equal to, U+2287 ISOtech
    'szlig':    0x00df, # latin small letter sharp s = ess-zed, U+00DF ISOlat1
    'tau':      0x03c4, # greek small letter tau, U+03C4 ISOgrk3
    'there4':   0x2234, # therefore, U+2234 ISOtech
    'theta':    0x03b8, # greek small letter theta, U+03B8 ISOgrk3
    'thetasym': 0x03d1, # greek small letter theta symbol, U+03D1 NEW
    'thinsp':   0x2009, # thin space, U+2009 ISOpub
    'thorn':    0x00fe, # latin small letter thorn with, U+00FE ISOlat1
    'tilde':    0x02dc, # small tilde, U+02DC ISOdia
    'times':    0x00d7, # multiplication sign, U+00D7 ISOnum
    'trade':    0x2122, # trade mark sign, U+2122 ISOnum
    'uArr':     0x21d1, # upwards double arrow, U+21D1 ISOamsa
    'uacute':   0x00fa, # latin small letter u with acute, U+00FA ISOlat1
    'uarr':     0x2191, # upwards arrow, U+2191 ISOnum
    'ucirc':    0x00fb, # latin small letter u with circumflex, U+00FB ISOlat1
    'ugrave':   0x00f9, # latin small letter u with grave, U+00F9 ISOlat1
    'uml':      0x00a8, # diaeresis = spacing diaeresis, U+00A8 ISOdia
    'upsih':    0x03d2, # greek upsilon with hook symbol, U+03D2 NEW
    'upsilon':  0x03c5, # greek small letter upsilon, U+03C5 ISOgrk3
    'uuml':     0x00fc, # latin small letter u with diaeresis, U+00FC ISOlat1
    'weierp':   0x2118, # script capital P = power set = Weierstrass p, U+2118 ISOamso
    'xi':       0x03be, # greek small letter xi, U+03BE ISOgrk3
    'yacute':   0x00fd, # latin small letter y with acute, U+00FD ISOlat1
    'yen':      0x00a5, # yen sign = yuan sign, U+00A5 ISOnum
    'yuml':     0x00ff, # latin small letter y with diaeresis, U+00FF ISOlat1
    'zeta':     0x03b6, # greek small letter zeta, U+03B6 ISOgrk3
    'zwj':      0x200d, # zero width joiner, U+200D NEW RFC 2070
    'zwnj':     0x200c, # zero width non-joiner, U+200C NEW RFC 2070
}

# maps the Unicode code point to the HTML entity name
codepoint2name = {}

# maps the HTML entity name to the character
# (or a character reference if the character is outside the Latin-1 range)
entitydefs = {}

for (name, codepoint) in name2codepoint.iteritems():
    codepoint2name[codepoint] = name
    if codepoint <= 0xff:
        entitydefs[name] = chr(codepoint)
    else:
        entitydefs[name] = '&#%d;' % codepoint

del name, codepoint

filename:/usr/lib/python2.7/sha.py
__doc__
# $Id$
#
#  Copyright (C) 2005   Gregory P. Smith (greg@krypto.org)
#  Licensed to PSF under a Contributor Agreement.

import warnings
warnings.warn("the sha module is deprecated; use the hashlib module instead",
                DeprecationWarning, 2)

from hashlib import sha1 as sha
new = sha

blocksize = 1        # legacy value (wrong in any useful sense)
digest_size = 20
digestsize = 20

filename:/usr/lib/python2.7/uuid.pyc
__doc__
Û
/0Xc           @   ss  d  Z  d d l Z d Z d d d d g \ Z Z Z Z d e f d	 Ñ  É  YZ d
 Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Z Z y=d d l Z d d l Z d d l Z d g Z e j j d É s e j d É n  xV e D]N Z y e j e j j e É É Z Wn
 q˜ n Xe  e d É r˜ e j! Z Pq˜ q˜ W[ e j d k rúd d l Z e" e j# É  d j$ d É d É d k rúd Z qún  y e j% j& Z Wn d Z n Xe' e d e' e d d É É Z Wn n Xd Ñ  Z( d Ñ  Z) d Ñ  Z* d a+ d  Ñ  Z, d a- d d d! Ñ Z. d" Ñ  Z/ d# Ñ  Z0 d$ Ñ  Z1 e d% É Z2 e d& É Z3 e d' É Z4 e d( É Z5 d S()   s(  UUID objects (universally unique identifiers) according to RFC 4122.

This module provides immutable UUID objects (class UUID) and the functions
uuid1(), uuid3(), uuid4(), uuid5() for generating version 1, 3, 4, and 5
UUIDs as specified in RFC 4122.

If all you want is a unique ID, you should probably call uuid1() or uuid4().
Note that uuid1() may compromise privacy since it creates a UUID containing
the computer's network address.  uuid4() creates a random UUID.

Typical usage:

    >>> import uuid

    # make a UUID based on the host ID and current time
    >>> uuid.uuid1()
    UUID('a8098c1a-f86e-11da-bd1a-00112444be1e')

    # make a UUID using an MD5 hash of a namespace UUID and a name
    >>> uuid.uuid3(uuid.NAMESPACE_DNS, 'python.org')
    UUID('6fa459ea-ee8a-3ca4-894e-db77e160355e')

    # make a random UUID
    >>> uuid.uuid4()
    UUID('16fd2706-8baf-433b-82eb-8c7fada847da')

    # make a UUID using a SHA-1 hash of a namespace UUID and a name
    >>> uuid.uuid5(uuid.NAMESPACE_DNS, 'python.org')
    UUID('886313e1-3b8a-5372-9b90-0c9aee199e5d')

    # make a UUID from a string of hex digits (braces and hyphens ignored)
    >>> x = uuid.UUID('{00010203-0405-0607-0809-0a0b0c0d0e0f}')

    # convert a UUID to a string of hex digits in standard form
    >>> str(x)
    '00010203-0405-0607-0809-0a0b0c0d0e0f'

    # get the raw 16 bytes of the UUID
    >>> x.bytes
    '\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f'

    # make a UUID from a 16-byte string
    >>> uuid.UUID(bytes=x.bytes)
    UUID('00010203-0405-0607-0809-0a0b0c0d0e0f')
iˇˇˇˇNs   Ka-Ping Yee <ping@zesty.ca>s   reserved for NCS compatibilitys   specified in RFC 4122s$   reserved for Microsoft compatibilitys   reserved for future definitiont   UUIDc           B   sö  e  Z d  Z d d d d d d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z e e É Z d	 Ñ  Z e e É Z d
 Ñ  Z e e É Z d Ñ  Z e e É Z d Ñ  Z e e É Z d Ñ  Z e e É Z d Ñ  Z e e É Z d Ñ  Z e e É Z d Ñ  Z e e É Z d Ñ  Z e e É Z d Ñ  Z  e e  É Z! d Ñ  Z" e e" É Z# d Ñ  Z$ e e$ É Z% d Ñ  Z& e e& É Z' d Ñ  Z( e e( É Z) RS(   s⁄  Instances of the UUID class represent UUIDs as specified in RFC 4122.
    UUID objects are immutable, hashable, and usable as dictionary keys.
    Converting a UUID to a string with str() yields something in the form
    '12345678-1234-1234-1234-123456789abc'.  The UUID constructor accepts
    five possible forms: a similar string of hexadecimal digits, or a tuple
    of six integer fields (with 32-bit, 16-bit, 16-bit, 8-bit, 8-bit, and
    48-bit values respectively) as an argument named 'fields', or a string
    of 16 bytes (with all the integer fields in big-endian order) as an
    argument named 'bytes', or a string of 16 bytes (with the first three
    fields in little-endian order) as an argument named 'bytes_le', or a
    single 128-bit integer as an argument named 'int'.

    UUIDs have these read-only attributes:

        bytes       the UUID as a 16-byte string (containing the six
                    integer fields in big-endian byte order)

        bytes_le    the UUID as a 16-byte string (with time_low, time_mid,
                    and time_hi_version in little-endian byte order)

        fields      a tuple of the six integer fields of the UUID,
                    which are also available as six individual attributes
                    and two derived attributes:

            time_low                the first 32 bits of the UUID
            time_mid                the next 16 bits of the UUID
            time_hi_version         the next 16 bits of the UUID
            clock_seq_hi_variant    the next 8 bits of the UUID
            clock_seq_low           the next 8 bits of the UUID
            node                    the last 48 bits of the UUID

            time                    the 60-bit timestamp
            clock_seq               the 14-bit sequence number

        hex         the UUID as a 32-character hexadecimal string

        int         the UUID as a 128-bit integer

        urn         the UUID as a URN as specified in RFC 4122

        variant     the UUID variant (one of the constants RESERVED_NCS,
                    RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE)

        version     the UUID version number (1 through 5, meaningful only
                    when the variant is RFC_4122)
    c         C   s™  | | | | | g j  d, É d k r3 t d É Ç n  | d, k	 r´ | j d d É j d d É } | j d É j d d É } t | É d k rô t d	 É Ç n  t | d
 É } n  | d, k	 r%t | É d
 k rÿ t d É Ç n  | d | d | d | d | d | d | d | d | d } n  | d, k	 r{t | É d
 k rRt d É Ç n  t d d
 t t	 t
 | É É d
 É } n  | d, k	 r˘t | É d k r®t d É Ç n  | \ } } }	 }
 } } d | k o◊d- k  n sÎt d É Ç n  d | k od. k  n st d É Ç n  d |	 k o-d/ k  n sAt d É Ç n  d |
 k oXd0 k  n slt d É Ç n  d | k oÉd1 k  n sót d É Ç n  d | k oÆd2 k  n s¬t d  É Ç n  |
 d >| B} | d! >| d" >B|	 d# >B| d >B| B} n  | d, k	 r3d | k od3 k  n s3t d% É Ç q3n  | d, k	 rôd | k oVd k n sjt d& É Ç n  | d5 M} | d6 O} | d8 M} | | d* >O} n  | |  j d+ <d, S(9   sm  Create a UUID from either a string of 32 hexadecimal digits,
        a string of 16 bytes as the 'bytes' argument, a string of 16 bytes
        in little-endian order as the 'bytes_le' argument, a tuple of six
        integers (32-bit time_low, 16-bit time_mid, 16-bit time_hi_version,
        8-bit clock_seq_hi_variant, 8-bit clock_seq_low, 48-bit node) as
        the 'fields' argument, or a single 128-bit integer as the 'int'
        argument.  When a string of hex digits is given, curly braces,
        hyphens, and a URN prefix are all optional.  For example, these
        expressions all yield the same UUID:

        UUID('{12345678-1234-5678-1234-567812345678}')
        UUID('12345678123456781234567812345678')
        UUID('urn:uuid:12345678-1234-5678-1234-567812345678')
        UUID(bytes='\x12\x34\x56\x78'*4)
        UUID(bytes_le='\x78\x56\x34\x12\x34\x12\x78\x56' +
                      '\x12\x34\x56\x78\x12\x34\x56\x78')
        UUID(fields=(0x12345678, 0x1234, 0x5678, 0x12, 0x34, 0x567812345678))
        UUID(int=0x12345678123456781234567812345678)

        Exactly one of 'hex', 'bytes', 'bytes_le', 'fields', or 'int' must
        be given.  The 'version' argument is optional; if given, the resulting
        UUID will have its variant and version set according to RFC 4122,
        overriding the given 'hex', 'bytes', 'bytes_le', 'fields', or 'int'.
        i   s0   need one of hex, bytes, bytes_le, fields, or ints   urn:t    s   uuid:s   {}t   -i    s$   badly formed hexadecimal UUID stringi   s    bytes_le is not a 16-char stringi   i   i   i    i   i   i   i   s   bytes is not a 16-char strings   %02xs   fields is not a 6-tuplel     s*   field 1 out of range (need a 32-bit value)l    s*   field 2 out of range (need a 16-bit value)s*   field 3 out of range (need a 16-bit value)l    s*   field 4 out of range (need an 8-bit value)s*   field 5 out of range (need an 8-bit value)l   0 s*   field 6 out of range (need a 48-bit value)l   ` l   P l   @ l   Ä s*   int is out of range (need a 128-bit value)s   illegal version numberi ¿  i Ä  i   l   L t   intNl        l      l      l    l    l          l	                    l            l˚ˇˇˇ        l            l              l˙ˇˇˇ          (   t   countt   Nonet	   TypeErrort   replacet   stript   lent
   ValueErrort   longt   tuplet   mapt   ordt   __dict__(   t   selft   hext   bytest   bytes_let   fieldsR   t   versiont   time_lowt   time_midt   time_hi_versiont   clock_seq_hi_variantt   clock_seq_lowt   nodet	   clock_seq(    (    s   /usr/lib/python2.7/uuid.pyt   __init__g   s\    $?))


c         C   s&   t  | t É r" t |  j | j É St S(   N(   t
   isinstanceR    t   cmpR   t   NotImplemented(   R   t   other(    (    s   /usr/lib/python2.7/uuid.pyt   __cmp__∂   s    c         C   s   t  |  j É S(   N(   t   hashR   (   R   (    (    s   /usr/lib/python2.7/uuid.pyt   __hash__ª   s    c         C   s   |  j  S(   N(   R   (   R   (    (    s   /usr/lib/python2.7/uuid.pyt   __int__æ   s    c         C   s   d t  |  É S(   Ns   UUID(%r)(   t   str(   R   (    (    s   /usr/lib/python2.7/uuid.pyt   __repr__¡   s    c         C   s   t  d É Ç d  S(   Ns   UUID objects are immutable(   R   (   R   t   namet   value(    (    s   /usr/lib/python2.7/uuid.pyt   __setattr__ƒ   s    c         C   sA   d |  j  } d | d  | d d !| d d !| d d !| d f S(   Ns   %032xs   %s-%s-%s-%s-%si   i   i   i   (   R   (   R   R   (    (    s   /usr/lib/python2.7/uuid.pyt   __str__«   s    c         C   sB   d } x5 t  d d d É D]! } t |  j | ?d @É | } q W| S(   NR   i    iÄ   i   iˇ   (   t   ranget   chrR   (   R   R   t   shift(    (    s   /usr/lib/python2.7/uuid.pyt	   get_bytesÃ   s    c         C   sQ   |  j  } | d | d | d | d | d | d | d | d | d	 S(
   Ni   i   i   i    i   i   i   i   i   (   R   (   R   R   (    (    s   /usr/lib/python2.7/uuid.pyt   get_bytes_le‘   s    	c         C   s(   |  j  |  j |  j |  j |  j |  j f S(   N(   R   R   R   R   R   R   (   R   (    (    s   /usr/lib/python2.7/uuid.pyt
   get_fields€   s    c         C   s   |  j  d ?S(   Nl   ` (   R   (   R   (    (    s   /usr/lib/python2.7/uuid.pyt   get_time_low·   s    c         C   s   |  j  d ?d @S(   Nl   P iˇˇ  (   R   (   R   (    (    s   /usr/lib/python2.7/uuid.pyt   get_time_midÊ   s    c         C   s   |  j  d ?d @S(   Nl   @ iˇˇ  (   R   (   R   (    (    s   /usr/lib/python2.7/uuid.pyt   get_time_hi_versionÎ   s    c         C   s   |  j  d ?d @S(   Nl   8 iˇ   (   R   (   R   (    (    s   /usr/lib/python2.7/uuid.pyt   get_clock_seq_hi_variant   s    c         C   s   |  j  d ?d @S(   Nl   0 iˇ   (   R   (   R   (    (    s   /usr/lib/python2.7/uuid.pyt   get_clock_seq_lowı   s    c         C   s!   |  j  d @d >|  j d >B|  j BS(   Nl   ˇl   0 l     (   R   R   R   (   R   (    (    s   /usr/lib/python2.7/uuid.pyt   get_time˙   s    c         C   s   |  j  d @d >|  j BS(   Nl   ? l    (   R   R   (   R   (    (    s   /usr/lib/python2.7/uuid.pyt   get_clock_seq   s    c         C   s   |  j  d @S(   NIˇˇˇˇˇˇ  (   R   (   R   (    (    s   /usr/lib/python2.7/uuid.pyt   get_node  s    c         C   s   d |  j  S(   Ns   %032x(   R   (   R   (    (    s   /usr/lib/python2.7/uuid.pyt   get_hex  s    c         C   s   d t  |  É S(   Ns	   urn:uuid:(   R&   (   R   (    (    s   /usr/lib/python2.7/uuid.pyt   get_urn  s    c         C   s;   |  j  d @s t S|  j  d @s" t S|  j  d @s3 t St Sd  S(   Ni Ä  l   0 i @  i    l            l            l            (   R   t   RESERVED_NCSt   RFC_4122t   RESERVED_MICROSOFTt   RESERVED_FUTURE(   R   (    (    s   /usr/lib/python2.7/uuid.pyt   get_variant  s    c         C   s(   |  j  t k r$ t |  j d ?d @É Sd  S(   Nl   L i   (   t   variantR=   R   (   R   (    (    s   /usr/lib/python2.7/uuid.pyt   get_version!  s    N(*   t   __name__t
   __module__t   __doc__R   R   R"   R$   R%   R'   R*   R+   R/   t   propertyR   R0   R   R1   R   R2   R   R3   R   R4   R   R5   R   R6   R   R7   t   timeR8   R   R9   R   R:   R   R;   t   urnR@   RA   RB   R   (    (    (    s   /usr/lib/python2.7/uuid.pyR    7   sN   .N																				
	c         C   s…   d d  l  } | j j d | j É j | j É } | j d É xl | D]` } | j j | |  É } | j j	 | É rD | j
 | | j | j BÉ rD | j j | É rD PqD qD Wd  Sd | | f } | j | É S(   Niˇˇˇˇt   PATHs   /sbins	   /usr/sbins   LC_ALL=C %s %s 2>/dev/null(   s   /sbins	   /usr/sbin(   t   ost   environt   gett   defpatht   splitt   pathsept   extendt   patht   joint   existst   accesst   F_OKt   X_OKt   isdirR   t   popen(   t   commandt   argsRJ   RQ   t   dirt
   executablet   cmd(    (    s   /usr/lib/python2.7/uuid.pyt   _popen(  s    $c   
      C   sÓ   y÷ t  |  | É } | s d  S| è± x© | D]° } | j É  j É  j É  } xÄ t t | É É D]l } | | | k r[ y9 | | | É } t | j d d É d É }	 |	 r© |	 SWq« t t	 f k
 r√ q« Xq[ q[ Wq* WWd  QXWn t
 k
 rÈ n Xd  S(   Nt   :R   i   (   R^   t   lowert   rstripRN   R,   R	   R   R   R
   t
   IndexErrort   IOError(
   RY   RZ   t   hw_identifierst	   get_indext   pipet   linet   wordst   it   wordt   mac(    (    s   /usr/lib/python2.7/uuid.pyt	   _find_mac:  s$    c          C   s=   x6 d	 D]. }  t  d |  d d g d Ñ  É } | r | Sq Wd S(
   s5   Get the hardware address on Unix by running ifconfig.R   s   -as   -avt   ifconfigt   hwaddrt   etherc         S   s   |  d S(   Ni   (    (   Ri   (    (    s   /usr/lib/python2.7/uuid.pyt   <lambda>W  s    N(   R   s   -as   -av(   Rl   (   RZ   Rk   (    (    s   /usr/lib/python2.7/uuid.pyt   _ifconfig_getnodeS  s    c          C   s_   d d l  }  d d l } y | j | j É  É } Wn t k
 rE d SXt d d | g d Ñ  É S(   s0   Get the hardware address on Unix by running arp.iˇˇˇˇNt   arps   -anc         S   s   d S(   Niˇˇˇˇ(    (   Ri   (    (    s   /usr/lib/python2.7/uuid.pyRp   d  s    (   RJ   t   sockett   gethostbynamet   gethostnamet   EnvironmentErrorR   Rl   (   RJ   Rs   t   ip_addr(    (    s   /usr/lib/python2.7/uuid.pyt   _arp_getnode[  s    c           C   s   t  d d d g d Ñ  É S(   s4   Get the hardware address on Unix by running lanscan.t   lanscans   -ait   lan0c         S   s   d S(   Ni    (    (   Ri   (    (    s   /usr/lib/python2.7/uuid.pyRp   i  s    (   Rl   (    (    (    s   /usr/lib/python2.7/uuid.pyt   _lanscan_getnodef  s    c          C   s  yt  d d É }  |  s d S|  èﬂ |  j É  j É  j É  } y | j d É } Wn t k
 rb d SXxó |  D]è } yo | j É  j É  } | | } t | É d k rﬁ | j d É d k rﬁ t | j	 d d É d	 É } | rﬁ | Sn  Wqj t t
 f k
 r¯ qj Xqj WWd QXWn t k
 rn Xd S(
   s4   Get the hardware address on Unix by running netstat.t   netstats   -iaNt   Addressi   R_   i   R   i   (   R^   t   readlineRa   RN   t   indexR
   R	   R   R   R   Rb   t   OSError(   Rf   Rh   Ri   Rg   Rj   Rk   (    (    s   /usr/lib/python2.7/uuid.pyt   _netstat_getnodek  s,    
'c    	   
   C   s<  d d l  }  d d l } d d d g } yQ d d l } | j d É } | j j j | d É | j d | j j	 d É É Wn n Xx≥ | D]´ } y& |  j
 |  j j | d	 É d
 É } Wn t k
 rÀ qâ n X| è` xX | D]P } | j d É d j É  j É  } | j d | É r⁄ t | j d d É d É Sq⁄ WWd QXqâ Wd S(   s<   Get the hardware address on Windows by running ipconfig.exe.iˇˇˇˇNR   s   c:\windows\system32s   c:\winnt\system32i,  i    t   mbcst   ipconfigs    /allR_   s&   ([0-9a-f][0-9a-f]-){5}[0-9a-f][0-9a-f]R   i   (   RJ   t   ret   ctypest   create_string_buffert   windllt   kernel32t   GetSystemDirectoryAt   insertR)   t   decodeRX   RQ   RR   Rc   RN   R   R`   t   matchR   R   (	   RJ   RÑ   t   dirsRÖ   t   bufferR[   Rf   Rg   R)   (    (    s   /usr/lib/python2.7/uuid.pyt   _ipconfig_getnodeÖ  s&     &c          C   sû  d d l  }  d d l } | j É  } | j | _ | j É  | _ } | j É  |  j | É d k rf d S| j	 É  x't
 | j É D]} | j É  | j | _ t | j | É | _ |  j | É d k rÕ qÄ n  | j É  | j | _ t | j | É | _ d j d É | _ | j É  | _ } |  j | É d k r9qÄ n  | j	 É  t t | j É } | d d >| d d >| d	 d
 >| d d >| d d >| d SWd S(   st   Get the hardware address on Windows using NetBIOS calls.
    See http://support.microsoft.com/kb/118623 for details.iˇˇˇˇNi    t   *i   l   ( i   l     i   l    i   l    i   l    i   (   t	   win32wnett   netbiost   NCBt   NCBENUMt   Commandt	   LANA_ENUMt   Buffert   _packt   Netbiost   _unpackR,   t   lengtht   Resett   NCBRESETR   t   lanat   Lana_numt   NCBASTATt   ljustt   Callnamet   ADAPTER_STATUSR   t   adapter_address(   Rë   Rí   t   ncbt   adaptersRi   t   statusR   (    (    s   /usr/lib/python2.7/uuid.pyt   _netbios_getnodeõ  s0    




t   uuidt   wint   ct   uuid_generate_timet   darwini   t   .i    i	   t   UuidCreateSequentialt
   UuidCreatec          C   s,   t  j d É }  t |  É t d |  j É j S(   s.   Get the hardware address on Unix using ctypes.i   R   (   RÖ   RÜ   t   _uuid_generate_timeR    t   rawR   (   t   _buffer(    (    s   /usr/lib/python2.7/uuid.pyt   _unixdll_getnodeÏ  s    
c          C   s8   t  j d É }  t |  É d k r4 t d |  j É j Sd S(   s1   Get the hardware address on Windows using ctypes.i   i    R   N(   RÖ   RÜ   t   _UuidCreateR    R≤   R   (   R≥   (    (    s   /usr/lib/python2.7/uuid.pyt   _windll_getnodeÚ  s    c          C   s    d d l  }  |  j d d É d BS(   sC   Get a random node ID, with eighth bit set as suggested by RFC 4122.iˇˇˇˇNi    i   l   0 l        l          (   t   randomt	   randrange(   R∑   (    (    s   /usr/lib/python2.7/uuid.pyt   _random_getnode¯  s    c          C   sò   t  d k	 r t  Sd d l }  |  j d k r= t t t g } n t t t	 t
 t g } x? | t g D]0 } y | É  a  Wn
 q` n Xt  d k	 r` t  Sq` Wd S(   s3  Get the hardware address as a 48-bit positive integer.

    The first time this runs, it may launch a separate program, which could
    be quite slow.  If all attempts to obtain the hardware address fail, we
    choose a random 48-bit number with its eighth bit set to 1 as recommended
    in RFC 4122.
    iˇˇˇˇNt   win32(   t   _nodeR   t   syst   platformR∂   R®   Rè   R¥   Rq   Rx   R{   RÅ   Rπ   (   Rº   t   getterst   getter(    (    s   /usr/lib/python2.7/uuid.pyt   getnodeˇ  s    
	c         C   sQ  t  rK |  | k o d k n rK t j d É } t  | É t d | j É Sd d l } t | j É  d É } t | d É d } t d k	 r¶ | t k r¶ t d } n  | a | d k r÷ d d l	 } | j
 d É } n  | d
 @} | d ?d @} | d ?d @}	 | d @}
 | d ?d @} |  d k r,t É  }  n  t d | | |	 | |
 |  f d d É S(   s  Generate a UUID from a host ID, sequence number, and the current time.
    If 'node' is not given, getnode() is used to obtain the hardware
    address.  If 'clock_seq' is given, it is used as the sequence number;
    otherwise a random 14-bit sequence number is chosen.i   R   iˇˇˇˇNg    eÕÕAid   l    @'Hwêi   l    l   ˇˇ l     l   ˇ l   0 l   ˇl   ˇ l    l   ? R   R   l    @(   R±   R   RÖ   RÜ   R    R≤   RG   R   t   _last_timestampR∑   R∏   R¿   (   R   R   R≥   RG   t   nanosecondst	   timestampR∑   R   R   R   R   R   (    (    s   /usr/lib/python2.7/uuid.pyt   uuid1  s,    "


c         C   s@   d d l  m } | |  j | É j É  } t d | d  d d É S(   sA   Generate a UUID from the MD5 hash of a namespace UUID and a name.iˇˇˇˇ(   t   md5R   i   R   i   (   t   hashlibR≈   R   t   digestR    (   t	   namespaceR(   R≈   R#   (    (    s   /usr/lib/python2.7/uuid.pyt   uuid3@  s    c           C   s   t  d t j d É d d É S(   s   Generate a random UUID.R   i   R   i   (   R    RJ   t   urandom(    (    (    s   /usr/lib/python2.7/uuid.pyt   uuid4F  s    c         C   s@   d d l  m } | |  j | É j É  } t d | d  d d É S(   sC   Generate a UUID from the SHA-1 hash of a namespace UUID and a name.iˇˇˇˇ(   t   sha1R   i   R   i   (   R∆   RÃ   R   R«   R    (   R»   R(   RÃ   R#   (    (    s   /usr/lib/python2.7/uuid.pyt   uuid5J  s    s$   6ba7b810-9dad-11d1-80b4-00c04fd430c8s$   6ba7b811-9dad-11d1-80b4-00c04fd430c8s$   6ba7b812-9dad-11d1-80b4-00c04fd430c8s$   6ba7b814-9dad-11d1-80b4-00c04fd430c8(6   RE   RJ   t
   __author__R<   R=   R>   R?   t   objectR    R^   Rl   Rq   Rx   R{   RÅ   Rè   R®   R   R±   Rµ   RÖ   t   ctypes.utilRº   t	   _libnamesRΩ   t
   startswitht   appendt   libnamet   CDLLt   utilt   find_libraryt   libt   hasattrR¨   R   t   unameRN   Rá   t   rpcrt4t   getattrR¥   R∂   Rπ   Rª   R¿   R¡   Rƒ   R…   RÀ   RÕ   t   NAMESPACE_DNSt   NAMESPACE_URLt   NAMESPACE_OIDt   NAMESPACE_X500(    (    (    s   /usr/lib/python2.7/uuid.pyt   <module>-   sn   Ò								 
			)

					#			
filename:/usr/lib/python2.7/httplib.py
__doc__
r"""HTTP/1.1 client library

<intro stuff goes here>
<other stuff, too>

HTTPConnection goes through a number of "states", which define when a client
may legally make another request or fetch the response for a particular
request. This diagram details these state transitions:

    (null)
      |
      | HTTPConnection()
      v
    Idle
      |
      | putrequest()
      v
    Request-started
      |
      | ( putheader() )*  endheaders()
      v
    Request-sent
      |
      | response = getresponse()
      v
    Unread-response   [Response-headers-read]
      |\____________________
      |                     |
      | response.read()     | putrequest()
      v                     v
    Idle                  Req-started-unread-response
                     ______/|
                   /        |
   response.read() |        | ( putheader() )*  endheaders()
                   v        v
       Request-started    Req-sent-unread-response
                            |
                            | response.read()
                            v
                          Request-sent

This diagram presents the following rules:
  -- a second request may not be started until {response-headers-read}
  -- a response [object] cannot be retrieved until {request-sent}
  -- there is no differentiation between an unread response body and a
     partially read response body

Note: this enforcement is applied by the HTTPConnection class. The
      HTTPResponse class does not enforce this state machine, which
      implies sophisticated clients may accelerate the request/response
      pipeline. Caution should be taken, though: accelerating the states
      beyond the above pattern may imply knowledge of the server's
      connection-close behavior for certain requests. For example, it
      is impossible to tell whether the server will close the connection
      UNTIL the response headers have been read; this means that further
      requests cannot be placed into the pipeline until it is known that
      the server will NOT be closing the connection.

Logical State                  __state            __response
-------------                  -------            ----------
Idle                           _CS_IDLE           None
Request-started                _CS_REQ_STARTED    None
Request-sent                   _CS_REQ_SENT       None
Unread-response                _CS_IDLE           <response_class>
Req-started-unread-response    _CS_REQ_STARTED    <response_class>
Req-sent-unread-response       _CS_REQ_SENT       <response_class>
"""

filename:/usr/lib/python2.7/linecache.py
__doc__
"""Cache lines from files.

This is intended to read lines from modules imported -- hence if a filename
is not found, it will look down the module search path for a file by
that name.
"""

filename:/usr/lib/python2.7/_strptime.py
__doc__
"""Strptime-related classes and functions.

CLASSES:
    LocaleTime -- Discovers and stores locale-specific time information
    TimeRE -- Creates regexes for pattern matching a string of text containing
                time information

FUNCTIONS:
    _getlang -- Figure out what language is being used for the locale
    strptime -- Calculates the time struct represented by the passed-in string

"""

filename:/usr/lib/python2.7/pickle.py
__doc__
"""Create portable serialized representations of Python objects.

See module cPickle for a (much) faster implementation.
See module copy_reg for a mechanism for registering custom picklers.
See module pickletools source for extensive comments.

Classes:

    Pickler
    Unpickler

Functions:

    dump(object, file)
    dumps(object) -> string
    load(file) -> object
    loads(string) -> object

Misc variables:

    __version__
    format_version
    compatible_formats

"""

filename:/usr/lib/python2.7/dis.py
__doc__
"""Disassembler of Python byte code into mnemonics."""

import sys
import types

from opcode import *
from opcode import __all__ as _opcodes_all

__all__ = ["dis", "disassemble", "distb", "disco",
           "findlinestarts", "findlabels"] + _opcodes_all
del _opcodes_all

_have_code = (types.MethodType, types.FunctionType, types.CodeType,
              types.ClassType, type)

def dis(x=None):
    """Disassemble classes, methods, functions, or code.

    With no argument, disassemble the last traceback.

    """
    if x is None:
        distb()
        return
    if isinstance(x, types.InstanceType):
        x = x.__class__
    if hasattr(x, 'im_func'):
        x = x.im_func
    if hasattr(x, 'func_code'):
        x = x.func_code
    if hasattr(x, '__dict__'):
        items = x.__dict__.items()
        items.sort()
        for name, x1 in items:
            if isinstance(x1, _have_code):
                print "Disassembly of %s:" % name
                try:
                    dis(x1)
                except TypeError, msg:
                    print "Sorry:", msg
                print
    elif hasattr(x, 'co_code'):
        disassemble(x)
    elif isinstance(x, str):
        disassemble_string(x)
    else:
        raise TypeError, \
              "don't know how to disassemble %s objects" % \
              type(x).__name__

def distb(tb=None):
    """Disassemble a traceback (default: last traceback)."""
    if tb is None:
        try:
            tb = sys.last_traceback
        except AttributeError:
            raise RuntimeError, "no last traceback to disassemble"
        while tb.tb_next: tb = tb.tb_next
    disassemble(tb.tb_frame.f_code, tb.tb_lasti)

def disassemble(co, lasti=-1):
    """Disassemble a code object."""
    code = co.co_code
    labels = findlabels(code)
    linestarts = dict(findlinestarts(co))
    n = len(code)
    i = 0
    extended_arg = 0
    free = None
    while i < n:
        c = code[i]
        op = ord(c)
        if i in linestarts:
            if i > 0:
                print
            print "%3d" % linestarts[i],
        else:
            print '   ',

        if i == lasti: print '-->',
        else: print '   ',
        if i in labels: print '>>',
        else: print '  ',
        print repr(i).rjust(4),
        print opname[op].ljust(20),
        i = i+1
        if op >= HAVE_ARGUMENT:
            oparg = ord(code[i]) + ord(code[i+1])*256 + extended_arg
            extended_arg = 0
            i = i+2
            if op == EXTENDED_ARG:
                extended_arg = oparg*65536L
            print repr(oparg).rjust(5),
            if op in hasconst:
                print '(' + repr(co.co_consts[oparg]) + ')',
            elif op in hasname:
                print '(' + co.co_names[oparg] + ')',
            elif op in hasjrel:
                print '(to ' + repr(i + oparg) + ')',
            elif op in haslocal:
                print '(' + co.co_varnames[oparg] + ')',
            elif op in hascompare:
                print '(' + cmp_op[oparg] + ')',
            elif op in hasfree:
                if free is None:
                    free = co.co_cellvars + co.co_freevars
                print '(' + free[oparg] + ')',
        print

def disassemble_string(code, lasti=-1, varnames=None, names=None,
                       constants=None):
    labels = findlabels(code)
    n = len(code)
    i = 0
    while i < n:
        c = code[i]
        op = ord(c)
        if i == lasti: print '-->',
        else: print '   ',
        if i in labels: print '>>',
        else: print '  ',
        print repr(i).rjust(4),
        print opname[op].ljust(15),
        i = i+1
        if op >= HAVE_ARGUMENT:
            oparg = ord(code[i]) + ord(code[i+1])*256
            i = i+2
            print repr(oparg).rjust(5),
            if op in hasconst:
                if constants:
                    print '(' + repr(constants[oparg]) + ')',
                else:
                    print '(%d)'%oparg,
            elif op in hasname:
                if names is not None:
                    print '(' + names[oparg] + ')',
                else:
                    print '(%d)'%oparg,
            elif op in hasjrel:
                print '(to ' + repr(i + oparg) + ')',
            elif op in haslocal:
                if varnames:
                    print '(' + varnames[oparg] + ')',
                else:
                    print '(%d)' % oparg,
            elif op in hascompare:
                print '(' + cmp_op[oparg] + ')',
        print

disco = disassemble                     # XXX For backwards compatibility

def findlabels(code):
    """Detect all offsets in a byte code which are jump targets.

    Return the list of offsets.

    """
    labels = []
    n = len(code)
    i = 0
    while i < n:
        c = code[i]
        op = ord(c)
        i = i+1
        if op >= HAVE_ARGUMENT:
            oparg = ord(code[i]) + ord(code[i+1])*256
            i = i+2
            label = -1
            if op in hasjrel:
                label = i+oparg
            elif op in hasjabs:
                label = oparg
            if label >= 0:
                if label not in labels:
                    labels.append(label)
    return labels

def findlinestarts(code):
    """Find the offsets in a byte code which are start of lines in the source.

    Generate pairs (offset, lineno) as described in Python/compile.c.

    """
    byte_increments = [ord(c) for c in code.co_lnotab[0::2]]
    line_increments = [ord(c) for c in code.co_lnotab[1::2]]

    lastlineno = None
    lineno = code.co_firstlineno
    addr = 0
    for byte_incr, line_incr in zip(byte_increments, line_increments):
        if byte_incr:
            if lineno != lastlineno:
                yield (addr, lineno)
                lastlineno = lineno
            addr += byte_incr
        lineno += line_incr
    if lineno != lastlineno:
        yield (addr, lineno)

def _test():
    """Simple test program to disassemble a file."""
    if sys.argv[1:]:
        if sys.argv[2:]:
            sys.stderr.write("usage: python dis.py [-|file]\n")
            sys.exit(2)
        fn = sys.argv[1]
        if not fn or fn == "-":
            fn = None
    else:
        fn = None
    if fn is None:
        f = sys.stdin
    else:
        f = open(fn)
    source = f.read()
    if fn is not None:
        f.close()
    else:
        fn = "<stdin>"
    code = compile(source, fn, "exec")
    dis(code)

if __name__ == "__main__":
    _test()

filename:/usr/lib/python2.7/pydoc.py
__doc__
#! /usr/bin/python2.7
# -*- coding: latin-1 -*-
"""Generate Python documentation in HTML or text for interactive use.

filename:/usr/lib/python2.7/shelve.py
__doc__
"""Manage shelves of pickled objects.

A "shelf" is a persistent, dictionary-like object.  The difference
with dbm databases is that the values (not the keys!) in a shelf can
be essentially arbitrary Python objects -- anything that the "pickle"
module can handle.  This includes most class instances, recursive data
types, and objects containing lots of shared sub-objects.  The keys
are ordinary strings.

To summarize the interface (key is a string, data is an arbitrary
object):

        import shelve
        d = shelve.open(filename) # open, with (g)dbm filename -- no suffix

        d[key] = data   # store data at key (overwrites old data if
                        # using an existing key)
        data = d[key]   # retrieve a COPY of the data at key (raise
                        # KeyError if no such key) -- NOTE that this
                        # access returns a *copy* of the entry!
        del d[key]      # delete data stored at key (raises KeyError
                        # if no such key)
        flag = d.has_key(key)   # true if the key exists; same as "key in d"
        list = d.keys() # a list of all existing keys (slow!)

        d.close()       # close it

Dependent on the implementation, closing a persistent dictionary may
or may not be necessary to flush changes to disk.

Normally, d[key] returns a COPY of the entry.  This needs care when
mutable entries are mutated: for example, if d[key] is a list,
        d[key].append(anitem)
does NOT modify the entry d[key] itself, as stored in the persistent
mapping -- it only modifies the copy, which is then immediately
discarded, so that the append has NO effect whatsoever.  To append an
item to d[key] in a way that will affect the persistent mapping, use:
        data = d[key]
        data.append(anitem)
        d[key] = data

To avoid the problem with mutable entries, you may pass the keyword
argument writeback=True in the call to shelve.open.  When you use:
        d = shelve.open(filename, writeback=True)
then d keeps a cache of all entries you access, and writes them all back
to the persistent mapping when you call d.close().  This ensures that
such usage as d[key].append(anitem) works as intended.

However, using keyword argument writeback=True may consume vast amount
of memory for the cache, and it may make d.close() very slow, if you
access many of d's entries after opening it in this way: d has no way to
check which of the entries you access are mutable and/or which ones you
actually mutate, so it must cache, and write back at close, all of the
entries that you access.  You can call d.sync() to write back all the
entries in the cache, and empty the cache (d.sync() also synchronizes
the persistent dictionary on disk, if feasible).
"""

filename:/usr/lib/python2.7/dummy_thread.py
__doc__
"""Drop-in replacement for the thread module.

Meant to be used as a brain-dead substitute so that threaded code does
not need to be rewritten for when the thread module is not present.

Suggested usage is::

    try:
        import thread
    except ImportError:
        import dummy_thread as thread

"""

filename:/usr/lib/python2.7/dircache.py
__doc__
"""Read and cache directory listings.

The listdir() routine returns a sorted list of the files in a directory,
using a cache to avoid reading the directory more often than necessary.
The annotate() routine appends slashes to directories."""
from warnings import warnpy3k
warnpy3k("the dircache module has been removed in Python 3.0", stacklevel=2)
del warnpy3k

import os

__all__ = ["listdir", "opendir", "annotate", "reset"]

cache = {}

def reset():
    """Reset the cache completely."""
    global cache
    cache = {}

def listdir(path):
    """List directory contents, using cache."""
    try:
        cached_mtime, list = cache[path]
        del cache[path]
    except KeyError:
        cached_mtime, list = -1, []
    mtime = os.stat(path).st_mtime
    if mtime != cached_mtime:
        list = os.listdir(path)
        list.sort()
    cache[path] = mtime, list
    return list

opendir = listdir # XXX backward compatibility

def annotate(head, list):
    """Add '/' suffixes to directories."""
    for i in range(len(list)):
        if os.path.isdir(os.path.join(head, list[i])):
            list[i] = list[i] + '/'

filename:/usr/lib/python2.7/abc.pyc
__doc__
Û
/0Xc           @   s}   d  Z  d d l Z d d l m Z d d d Ñ  É  YZ e e É  É Z d Ñ  Z d e f d Ñ  É  YZ	 d	 e f d
 Ñ  É  YZ
 d S(   s3   Abstract Base Classes (ABCs) according to PEP 3119.iˇˇˇˇN(   t   WeakSett   _Cc           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s   /usr/lib/python2.7/abc.pyR      s    c         C   s   t  |  _ |  S(   sÔ  A decorator indicating abstract methods.

    Requires that the metaclass is ABCMeta or derived from it.  A
    class that has a metaclass derived from ABCMeta cannot be
    instantiated unless all of its abstract methods are overridden.
    The abstract methods can be called using any of the normal
    'super' call mechanisms.

    Usage:

        class C:
            __metaclass__ = ABCMeta
            @abstractmethod
            def my_abstract_method(self, ...):
                ...
    (   t   Truet   __isabstractmethod__(   t   funcobj(    (    s   /usr/lib/python2.7/abc.pyt   abstractmethod   s    	t   abstractpropertyc           B   s   e  Z d  Z e Z RS(   s/  A decorator indicating abstract properties.

    Requires that the metaclass is ABCMeta or derived from it.  A
    class that has a metaclass derived from ABCMeta cannot be
    instantiated unless all of its abstract properties are overridden.
    The abstract properties can be called using any of the normal
    'super' call mechanisms.

    Usage:

        class C:
            __metaclass__ = ABCMeta
            @abstractproperty
            def my_abstract_property(self):
                ...

    This defines a read-only property; you can also define a read-write
    abstract property using the 'long' form of property declaration:

        class C:
            __metaclass__ = ABCMeta
            def getx(self): ...
            def setx(self, value): ...
            x = abstractproperty(getx, setx)
    (   R   R   t   __doc__R   R   (    (    (    s   /usr/lib/python2.7/abc.pyR   $   s   t   ABCMetac           B   sD   e  Z d  Z d Z d Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z	 RS(   si  Metaclass for defining Abstract Base Classes (ABCs).

    Use this metaclass to create an ABC.  An ABC can be subclassed
    directly, and then acts as a mix-in class.  You can also register
    unrelated concrete classes (even built-in classes) and unrelated
    ABCs as 'virtual subclasses' -- these and their descendants will
    be considered subclasses of the registering ABC by the built-in
    issubclass() function, but the registering ABC won't show up in
    their MRO (Method Resolution Order) nor will method
    implementations defined by the registering ABC be callable (not
    even via super()).

    i    c         C   sÂ   t  t |  É j |  | | | É } t d Ñ  | j É  DÉ É } xb | D]Z } xQ t | d t É  É D]: } t | | d  É } t | d t É r` | j | É q` q` WqD Wt	 | É | _
 t É  | _ t É  | _ t É  | _ t j | _ | S(   Nc         s   s-   |  ]# \ } } t  | d  t É r | Vq d S(   R   N(   t   getattrt   False(   t   .0t   namet   value(    (    s   /usr/lib/python2.7/abc.pys	   <genexpr>Y   s   	t   __abstractmethods__R   (   t   superR
   t   __new__t   sett   itemsR   t   NoneR   t   addt	   frozensetR   R    t   _abc_registryt
   _abc_cachet   _abc_negative_cachet   _abc_invalidation_countert   _abc_negative_cache_version(   t   mclsR   t   basest	   namespacet   clst	   abstractst   baseR   (    (    s   /usr/lib/python2.7/abc.pyR   V   s    !	c         C   s{   t  | t t j f É s' t d É Ç n  t | |  É r: d St |  | É rX t d É Ç n  |  j j | É t	 j
 d 7_
 d S(   s&   Register a virtual subclass of an ABC.s   Can only register classesNs'   Refusing to create an inheritance cyclei   (   t
   isinstancet   typet   typest	   ClassTypet	   TypeErrort
   issubclasst   RuntimeErrorR   R   R
   R   (   R    t   subclass(    (    s   /usr/lib/python2.7/abc.pyt   registeri   s    c         C   sÑ   | d |  j  |  j f IJ| d t j IJxR t |  j j É  É D]; } | j d É rA t |  | É } | d | | f IJqA qA Wd S(   s'   Debug helper to print the ABC registry.s   Class: %s.%ss   Inv.counter: %st   _abc_s   %s: %rN(	   R   R   R
   R   t   sortedt   __dict__t   keyst
   startswithR   (   R    t   fileR   R   (    (    s   /usr/lib/python2.7/abc.pyt   _dump_registryw   s    c         C   s∏   t  | d d É } | d k	 r1 | |  j k r1 t St | É } | t k rR | } n  | | k sj | d k rú |  j t j k rè | |  j	 k rè t
 S|  j | É S|  j | É p∑ |  j | É S(   s'   Override for isinstance(instance, cls).t	   __class__N(   R   R   R   R   R$   t   _InstanceTypeR   R
   R   R   R   t   __subclasscheck__(   R    t   instanceR*   t   subtype(    (    s   /usr/lib/python2.7/abc.pyt   __instancecheck__Ä   s    	c         C   sa  | |  j  k r t S|  j t j k  r@ t É  |  _ t j |  _ n | |  j k rS t S|  j | É } | t	 k	 r∞ t
 | t É sÉ t Ç | rú |  j  j | É n |  j j | É | S|  t | d d É k r‹ |  j  j | É t Sx4 |  j D]) } t | | É rÊ |  j  j | É t SqÊ Wx7 |  j É  D]) } t | | É r |  j  j | É t Sq W|  j j | É t S(   s'   Override for issubclass(subclass, cls).t   __mro__(    (   R   R   R   R
   R   R    R   R   t   __subclasshook__t   NotImplementedR#   t   boolt   AssertionErrorR   R   R   R(   t   __subclasses__(   R    R*   t   okt   rclst   scls(    (    s   /usr/lib/python2.7/abc.pyR5   î   s6    N(
   R   R   R	   R   R   R+   R   R2   R8   R5   (    (    (    s   /usr/lib/python2.7/abc.pyR
   A   s   				(    (   R	   R%   t   _weakrefsetR    R   R$   R4   R   t   propertyR   R
   (    (    (    s   /usr/lib/python2.7/abc.pyt   <module>   s   	
filename:/usr/lib/python2.7/tokenize.py
__doc__
"""Tokenization help for Python programs.

filename:/usr/lib/python2.7/fpformat.py
__doc__
"""General floating point formatting functions.

Functions:
fix(x, digits_behind)
sci(x, digits_behind)

Each takes a number or a string and a number of digits as arguments.

Parameters:
x:             number to be formatted; or a string resembling a number
digits_behind: number of digits behind the decimal point
"""

filename:/usr/lib/python2.7/SocketServer.py
__doc__
"""Generic socket server classes.

This module tries to capture the various aspects of defining a server:

For socket-based servers:

- address family:
        - AF_INET{,6}: IP (Internet Protocol) sockets (default)
        - AF_UNIX: Unix domain sockets
        - others, e.g. AF_DECNET are conceivable (see <socket.h>
- socket type:
        - SOCK_STREAM (reliable stream, e.g. TCP)
        - SOCK_DGRAM (datagrams, e.g. UDP)

For request-based servers (including socket-based):

- client address verification before further looking at the request
        (This is actually a hook for any processing that needs to look
         at the request before anything else, e.g. logging)
- how to handle multiple requests:
        - synchronous (one request is handled at a time)
        - forking (each request is handled by a new process)
        - threading (each request is handled by a new thread)

The classes in this module favor the server type that is simplest to
write: a synchronous TCP/IP server.  This is bad class design, but
save some typing.  (There's also the issue that a deep class hierarchy
slows down method lookups.)

There are five classes in an inheritance diagram, four of which represent
synchronous servers of four types:

        +------------+
        | BaseServer |
        +------------+
              |
              v
        +-----------+        +------------------+
        | TCPServer |------->| UnixStreamServer |
        +-----------+        +------------------+
              |
              v
        +-----------+        +--------------------+
        | UDPServer |------->| UnixDatagramServer |
        +-----------+        +--------------------+

Note that UnixDatagramServer derives from UDPServer, not from
UnixStreamServer -- the only difference between an IP and a Unix
stream server is the address family, which is simply repeated in both
unix server classes.

Forking and threading versions of each type of server can be created
using the ForkingMixIn and ThreadingMixIn mix-in classes.  For
instance, a threading UDP server class is created as follows:

        class ThreadingUDPServer(ThreadingMixIn, UDPServer): pass

The Mix-in class must come first, since it overrides a method defined
in UDPServer! Setting the various member variables also changes
the behavior of the underlying server mechanism.

To implement a service, you must derive a class from
BaseRequestHandler and redefine its handle() method.  You can then run
various versions of the service by combining one of the server classes
with your request handler class.

The request handler class must be different for datagram or stream
services.  This can be hidden by using the request handler
subclasses StreamRequestHandler or DatagramRequestHandler.

Of course, you still have to use your head!

For instance, it makes no sense to use a forking server if the service
contains state in memory that can be modified by requests (since the
modifications in the child process would never reach the initial state
kept in the parent process and passed to each child).  In this case,
you can use a threading server, but you will probably have to use
locks to avoid two requests that come in nearly simultaneous to apply
conflicting changes to the server state.

On the other hand, if you are building e.g. an HTTP server, where all
data is stored externally (e.g. in the file system), a synchronous
class will essentially render the service "deaf" while one request is
being handled -- which may be for a very long time if a client is slow
to read all the data it has requested.  Here a threading or forking
server is appropriate.

In some cases, it may be appropriate to process part of a request
synchronously, but to finish processing in a forked child depending on
the request data.  This can be implemented by using a synchronous
server and doing an explicit fork in the request handler class
handle() method.

Another approach to handling multiple simultaneous requests in an
environment that supports neither threads nor fork (or where these are
too expensive or inappropriate for the service) is to maintain an
explicit table of partially finished requests and to use select() to
decide which request to work on next (or whether to handle a new
incoming request).  This is particularly important for stream services
where each client can potentially be connected for a long time (if
threads or subprocesses cannot be used).

Future work:
- Standard classes for Sun RPC (which uses either UDP or TCP)
- Standard mix-in classes to implement various authentication
  and encryption schemes
- Standard framework for select-based multiplexing

XXX Open problems:
- What to do with out-of-band data?

BaseServer:
- split generic "request" functionality out into BaseServer class.
  Copyright (C) 2000  Luke Kenneth Casson Leighton <lkcl@samba.org>

  example: read entries from a SQL database (requires overriding
  get_request() to return a table entry from the database).
  entry is processed by a RequestHandlerClass.

"""

filename:/usr/lib/python2.7/threading.py
__doc__
"""Thread module emulating a subset of Java's threading model."""

import sys as _sys

try:
    import thread
except ImportError:
    del _sys.modules[__name__]
    raise

import warnings

from collections import deque as _deque
from itertools import count as _count
from time import time as _time, sleep as _sleep
from traceback import format_exc as _format_exc

# Note regarding PEP 8 compliant aliases
#  This threading model was originally inspired by Java, and inherited
# the convention of camelCase function and method names from that
# language. While those names are not in any imminent danger of being
# deprecated, starting with Python 2.6, the module now provides a
# PEP 8 compliant alias for any such method name.
# Using the new PEP 8 compliant names also facilitates substitution
# with the multiprocessing module, which doesn't provide the old
# Java inspired names.


# Rename some stuff so "from threading import *" is safe
__all__ = ['activeCount', 'active_count', 'Condition', 'currentThread',
           'current_thread', 'enumerate', 'Event',
           'Lock', 'RLock', 'Semaphore', 'BoundedSemaphore', 'Thread',
           'Timer', 'setprofile', 'settrace', 'local', 'stack_size']

_start_new_thread = thread.start_new_thread
_allocate_lock = thread.allocate_lock
_get_ident = thread.get_ident
ThreadError = thread.error
del thread


# sys.exc_clear is used to work around the fact that except blocks
# don't fully clear the exception until 3.0.
warnings.filterwarnings('ignore', category=DeprecationWarning,
                        module='threading', message='sys.exc_clear')

# Debug support (adapted from ihooks.py).
# All the major classes here derive from _Verbose.  We force that to
# be a new-style class so that all the major classes here are new-style.
# This helps debugging (type(instance) is more revealing for instances
# of new-style classes).

_VERBOSE = False

if __debug__:

    class _Verbose(object):

        def __init__(self, verbose=None):
            if verbose is None:
                verbose = _VERBOSE
            self.__verbose = verbose

        def _note(self, format, *args):
            if self.__verbose:
                format = format % args
                # Issue #4188: calling current_thread() can incur an infinite
                # recursion if it has to create a DummyThread on the fly.
                ident = _get_ident()
                try:
                    name = _active[ident].name
                except KeyError:
                    name = "<OS thread %d>" % ident
                format = "%s: %s\n" % (name, format)
                _sys.stderr.write(format)

else:
    # Disable this when using "python -O"
    class _Verbose(object):
        def __init__(self, verbose=None):
            pass
        def _note(self, *args):
            pass

# Support for profile and trace hooks

_profile_hook = None
_trace_hook = None

def setprofile(func):
    """Set a profile function for all threads started from the threading module.

    The func will be passed to sys.setprofile() for each thread, before its
    run() method is called.

    """
    global _profile_hook
    _profile_hook = func

def settrace(func):
    """Set a trace function for all threads started from the threading module.

    The func will be passed to sys.settrace() for each thread, before its run()
    method is called.

    """
    global _trace_hook
    _trace_hook = func

# Synchronization classes

Lock = _allocate_lock

def RLock(*args, **kwargs):
    """Factory function that returns a new reentrant lock.

    A reentrant lock must be released by the thread that acquired it. Once a
    thread has acquired a reentrant lock, the same thread may acquire it again
    without blocking; the thread must release it once for each time it has
    acquired it.

    """
    return _RLock(*args, **kwargs)

class _RLock(_Verbose):
    """A reentrant lock must be released by the thread that acquired it. Once a
       thread has acquired a reentrant lock, the same thread may acquire it
       again without blocking; the thread must release it once for each time it
       has acquired it.
    """

    def __init__(self, verbose=None):
        _Verbose.__init__(self, verbose)
        self.__block = _allocate_lock()
        self.__owner = None
        self.__count = 0

    def __repr__(self):
        owner = self.__owner
        try:
            owner = _active[owner].name
        except KeyError:
            pass
        return "<%s owner=%r count=%d>" % (
                self.__class__.__name__, owner, self.__count)

    def acquire(self, blocking=1):
        """Acquire a lock, blocking or non-blocking.

        When invoked without arguments: if this thread already owns the lock,
        increment the recursion level by one, and return immediately. Otherwise,
        if another thread owns the lock, block until the lock is unlocked. Once
        the lock is unlocked (not owned by any thread), then grab ownership, set
        the recursion level to one, and return. If more than one thread is
        blocked waiting until the lock is unlocked, only one at a time will be
        able to grab ownership of the lock. There is no return value in this
        case.

        When invoked with the blocking argument set to true, do the same thing
        as when called without arguments, and return true.

        When invoked with the blocking argument set to false, do not block. If a
        call without an argument would block, return false immediately;
        otherwise, do the same thing as when called without arguments, and
        return true.

        """
        me = _get_ident()
        if self.__owner == me:
            self.__count = self.__count + 1
            if __debug__:
                self._note("%s.acquire(%s): recursive success", self, blocking)
            return 1
        rc = self.__block.acquire(blocking)
        if rc:
            self.__owner = me
            self.__count = 1
            if __debug__:
                self._note("%s.acquire(%s): initial success", self, blocking)
        else:
            if __debug__:
                self._note("%s.acquire(%s): failure", self, blocking)
        return rc

    __enter__ = acquire

    def release(self):
        """Release a lock, decrementing the recursion level.

        If after the decrement it is zero, reset the lock to unlocked (not owned
        by any thread), and if any other threads are blocked waiting for the
        lock to become unlocked, allow exactly one of them to proceed. If after
        the decrement the recursion level is still nonzero, the lock remains
        locked and owned by the calling thread.

        Only call this method when the calling thread owns the lock. A
        RuntimeError is raised if this method is called when the lock is
        unlocked.

        There is no return value.

        """
        if self.__owner != _get_ident():
            raise RuntimeError("cannot release un-acquired lock")
        self.__count = count = self.__count - 1
        if not count:
            self.__owner = None
            self.__block.release()
            if __debug__:
                self._note("%s.release(): final release", self)
        else:
            if __debug__:
                self._note("%s.release(): non-final release", self)

    def __exit__(self, t, v, tb):
        self.release()

    # Internal methods used by condition variables

    def _acquire_restore(self, count_owner):
        count, owner = count_owner
        self.__block.acquire()
        self.__count = count
        self.__owner = owner
        if __debug__:
            self._note("%s._acquire_restore()", self)

    def _release_save(self):
        if __debug__:
            self._note("%s._release_save()", self)
        count = self.__count
        self.__count = 0
        owner = self.__owner
        self.__owner = None
        self.__block.release()
        return (count, owner)

    def _is_owned(self):
        return self.__owner == _get_ident()


def Condition(*args, **kwargs):
    """Factory function that returns a new condition variable object.

    A condition variable allows one or more threads to wait until they are
    notified by another thread.

    If the lock argument is given and not None, it must be a Lock or RLock
    object, and it is used as the underlying lock. Otherwise, a new RLock object
    is created and used as the underlying lock.

    """
    return _Condition(*args, **kwargs)

class _Condition(_Verbose):
    """Condition variables allow one or more threads to wait until they are
       notified by another thread.
    """

    def __init__(self, lock=None, verbose=None):
        _Verbose.__init__(self, verbose)
        if lock is None:
            lock = RLock()
        self.__lock = lock
        # Export the lock's acquire() and release() methods
        self.acquire = lock.acquire
        self.release = lock.release
        # If the lock defines _release_save() and/or _acquire_restore(),
        # these override the default implementations (which just call
        # release() and acquire() on the lock).  Ditto for _is_owned().
        try:
            self._release_save = lock._release_save
        except AttributeError:
            pass
        try:
            self._acquire_restore = lock._acquire_restore
        except AttributeError:
            pass
        try:
            self._is_owned = lock._is_owned
        except AttributeError:
            pass
        self.__waiters = []

    def __enter__(self):
        return self.__lock.__enter__()

    def __exit__(self, *args):
        return self.__lock.__exit__(*args)

    def __repr__(self):
        return "<Condition(%s, %d)>" % (self.__lock, len(self.__waiters))

    def _release_save(self):
        self.__lock.release()           # No state to save

    def _acquire_restore(self, x):
        self.__lock.acquire()           # Ignore saved state

    def _is_owned(self):
        # Return True if lock is owned by current_thread.
        # This method is called only if __lock doesn't have _is_owned().
        if self.__lock.acquire(0):
            self.__lock.release()
            return False
        else:
            return True

    def wait(self, timeout=None):
        """Wait until notified or until a timeout occurs.

        If the calling thread has not acquired the lock when this method is
        called, a RuntimeError is raised.

        This method releases the underlying lock, and then blocks until it is
        awakened by a notify() or notifyAll() call for the same condition
        variable in another thread, or until the optional timeout occurs. Once
        awakened or timed out, it re-acquires the lock and returns.

        When the timeout argument is present and not None, it should be a
        floating point number specifying a timeout for the operation in seconds
        (or fractions thereof).

        When the underlying lock is an RLock, it is not released using its
        release() method, since this may not actually unlock the lock when it
        was acquired multiple times recursively. Instead, an internal interface
        of the RLock class is used, which really unlocks it even when it has
        been recursively acquired several times. Another internal interface is
        then used to restore the recursion level when the lock is reacquired.

        """
        if not self._is_owned():
            raise RuntimeError("cannot wait on un-acquired lock")
        waiter = _allocate_lock()
        waiter.acquire()
        self.__waiters.append(waiter)
        saved_state = self._release_save()
        try:    # restore state no matter what (e.g., KeyboardInterrupt)
            if timeout is None:
                waiter.acquire()
                if __debug__:
                    self._note("%s.wait(): got it", self)
            else:
                # Balancing act:  We can't afford a pure busy loop, so we
                # have to sleep; but if we sleep the whole timeout time,
                # we'll be unresponsive.  The scheme here sleeps very
                # little at first, longer as time goes on, but never longer
                # than 20 times per second (or the timeout time remaining).
                endtime = _time() + timeout
                delay = 0.0005 # 500 us -> initial delay of 1 ms
                while True:
                    gotit = waiter.acquire(0)
                    if gotit:
                        break
                    remaining = endtime - _time()
                    if remaining <= 0:
                        break
                    delay = min(delay * 2, remaining, .05)
                    _sleep(delay)
                if not gotit:
                    if __debug__:
                        self._note("%s.wait(%s): timed out", self, timeout)
                    try:
                        self.__waiters.remove(waiter)
                    except ValueError:
                        pass
                else:
                    if __debug__:
                        self._note("%s.wait(%s): got it", self, timeout)
        finally:
            self._acquire_restore(saved_state)

    def notify(self, n=1):
        """Wake up one or more threads waiting on this condition, if any.

        If the calling thread has not acquired the lock when this method is
        called, a RuntimeError is raised.

        This method wakes up at most n of the threads waiting for the condition
        variable; it is a no-op if no threads are waiting.

        """
        if not self._is_owned():
            raise RuntimeError("cannot notify on un-acquired lock")
        __waiters = self.__waiters
        waiters = __waiters[:n]
        if not waiters:
            if __debug__:
                self._note("%s.notify(): no waiters", self)
            return
        self._note("%s.notify(): notifying %d waiter%s", self, n,
                   n!=1 and "s" or "")
        for waiter in waiters:
            waiter.release()
            try:
                __waiters.remove(waiter)
            except ValueError:
                pass

    def notifyAll(self):
        """Wake up all threads waiting on this condition.

        If the calling thread has not acquired the lock when this method
        is called, a RuntimeError is raised.

        """
        self.notify(len(self.__waiters))

    notify_all = notifyAll


def Semaphore(*args, **kwargs):
    """A factory function that returns a new semaphore.

    Semaphores manage a counter representing the number of release() calls minus
    the number of acquire() calls, plus an initial value. The acquire() method
    blocks if necessary until it can return without making the counter
    negative. If not given, value defaults to 1.

    """
    return _Semaphore(*args, **kwargs)

class _Semaphore(_Verbose):
    """Semaphores manage a counter representing the number of release() calls
       minus the number of acquire() calls, plus an initial value. The acquire()
       method blocks if necessary until it can return without making the counter
       negative. If not given, value defaults to 1.

    """

    # After Tim Peters' semaphore class, but not quite the same (no maximum)

    def __init__(self, value=1, verbose=None):
        if value < 0:
            raise ValueError("semaphore initial value must be >= 0")
        _Verbose.__init__(self, verbose)
        self.__cond = Condition(Lock())
        self.__value = value

    def acquire(self, blocking=1):
        """Acquire a semaphore, decrementing the internal counter by one.

        When invoked without arguments: if the internal counter is larger than
        zero on entry, decrement it by one and return immediately. If it is zero
        on entry, block, waiting until some other thread has called release() to
        make it larger than zero. This is done with proper interlocking so that
        if multiple acquire() calls are blocked, release() will wake exactly one
        of them up. The implementation may pick one at random, so the order in
        which blocked threads are awakened should not be relied on. There is no
        return value in this case.

        When invoked with blocking set to true, do the same thing as when called
        without arguments, and return true.

        When invoked with blocking set to false, do not block. If a call without
        an argument would block, return false immediately; otherwise, do the
        same thing as when called without arguments, and return true.

        """
        rc = False
        with self.__cond:
            while self.__value == 0:
                if not blocking:
                    break
                if __debug__:
                    self._note("%s.acquire(%s): blocked waiting, value=%s",
                            self, blocking, self.__value)
                self.__cond.wait()
            else:
                self.__value = self.__value - 1
                if __debug__:
                    self._note("%s.acquire: success, value=%s",
                            self, self.__value)
                rc = True
        return rc

    __enter__ = acquire

    def release(self):
        """Release a semaphore, incrementing the internal counter by one.

        When the counter is zero on entry and another thread is waiting for it
        to become larger than zero again, wake up that thread.

        """
        with self.__cond:
            self.__value = self.__value + 1
            if __debug__:
                self._note("%s.release: success, value=%s",
                        self, self.__value)
            self.__cond.notify()

    def __exit__(self, t, v, tb):
        self.release()


def BoundedSemaphore(*args, **kwargs):
    """A factory function that returns a new bounded semaphore.

    A bounded semaphore checks to make sure its current value doesn't exceed its
    initial value. If it does, ValueError is raised. In most situations
    semaphores are used to guard resources with limited capacity.

    If the semaphore is released too many times it's a sign of a bug. If not
    given, value defaults to 1.

    Like regular semaphores, bounded semaphores manage a counter representing
    the number of release() calls minus the number of acquire() calls, plus an
    initial value. The acquire() method blocks if necessary until it can return
    without making the counter negative. If not given, value defaults to 1.

    """
    return _BoundedSemaphore(*args, **kwargs)

class _BoundedSemaphore(_Semaphore):
    """A bounded semaphore checks to make sure its current value doesn't exceed
       its initial value. If it does, ValueError is raised. In most situations
       semaphores are used to guard resources with limited capacity.
    """

    def __init__(self, value=1, verbose=None):
        _Semaphore.__init__(self, value, verbose)
        self._initial_value = value

    def release(self):
        """Release a semaphore, incrementing the internal counter by one.

        When the counter is zero on entry and another thread is waiting for it
        to become larger than zero again, wake up that thread.

        If the number of releases exceeds the number of acquires,
        raise a ValueError.

        """
        with self._Semaphore__cond:
            if self._Semaphore__value >= self._initial_value:
                raise ValueError("Semaphore released too many times")
            self._Semaphore__value += 1
            self._Semaphore__cond.notify()


def Event(*args, **kwargs):
    """A factory function that returns a new event.

    Events manage a flag that can be set to true with the set() method and reset
    to false with the clear() method. The wait() method blocks until the flag is
    true.

    """
    return _Event(*args, **kwargs)

class _Event(_Verbose):
    """A factory function that returns a new event object. An event manages a
       flag that can be set to true with the set() method and reset to false
       with the clear() method. The wait() method blocks until the flag is true.

    """

    # After Tim Peters' event class (without is_posted())

    def __init__(self, verbose=None):
        _Verbose.__init__(self, verbose)
        self.__cond = Condition(Lock())
        self.__flag = False

    def _reset_internal_locks(self):
        # private!  called by Thread._reset_internal_locks by _after_fork()
        self.__cond.__init__(Lock())

    def isSet(self):
        'Return true if and only if the internal flag is true.'
        return self.__flag

    is_set = isSet

    def set(self):
        """Set the internal flag to true.

        All threads waiting for the flag to become true are awakened. Threads
        that call wait() once the flag is true will not block at all.

        """
        with self.__cond:
            self.__flag = True
            self.__cond.notify_all()

    def clear(self):
        """Reset the internal flag to false.

        Subsequently, threads calling wait() will block until set() is called to
        set the internal flag to true again.

        """
        with self.__cond:
            self.__flag = False

    def wait(self, timeout=None):
        """Block until the internal flag is true.

        If the internal flag is true on entry, return immediately. Otherwise,
        block until another thread calls set() to set the flag to true, or until
        the optional timeout occurs.

        When the timeout argument is present and not None, it should be a
        floating point number specifying a timeout for the operation in seconds
        (or fractions thereof).

        This method returns the internal flag on exit, so it will always return
        True except if a timeout is given and the operation times out.

        """
        with self.__cond:
            if not self.__flag:
                self.__cond.wait(timeout)
            return self.__flag

# Helper to generate new thread names
_counter = _count().next
_counter() # Consume 0 so first non-main thread has id 1.
def _newname(template="Thread-%d"):
    return template % _counter()

# Active thread administration
_active_limbo_lock = _allocate_lock()
_active = {}    # maps thread id to Thread object
_limbo = {}


# Main class for threads

class Thread(_Verbose):
    """A class that represents a thread of control.

    This class can be safely subclassed in a limited fashion.

    """
    __initialized = False
    # Need to store a reference to sys.exc_info for printing
    # out exceptions when a thread tries to use a global var. during interp.
    # shutdown and thus raises an exception about trying to perform some
    # operation on/with a NoneType
    __exc_info = _sys.exc_info
    # Keep sys.exc_clear too to clear the exception just before
    # allowing .join() to return.
    __exc_clear = _sys.exc_clear

    def __init__(self, group=None, target=None, name=None,
                 args=(), kwargs=None, verbose=None):
        """This constructor should always be called with keyword arguments. Arguments are:

        *group* should be None; reserved for future extension when a ThreadGroup
        class is implemented.

        *target* is the callable object to be invoked by the run()
        method. Defaults to None, meaning nothing is called.

        *name* is the thread name. By default, a unique name is constructed of
        the form "Thread-N" where N is a small decimal number.

        *args* is the argument tuple for the target invocation. Defaults to ().

        *kwargs* is a dictionary of keyword arguments for the target
        invocation. Defaults to {}.

        If a subclass overrides the constructor, it must make sure to invoke
        the base class constructor (Thread.__init__()) before doing anything
        else to the thread.

"""

filename:/usr/lib/python2.7/binhex.py
__doc__
"""Macintosh binhex compression/decompression.

easy interface:
binhex(inputfilename, outputfilename)
hexbin(inputfilename, outputfilename)
"""

filename:/usr/lib/python2.7/posixfile.py
__doc__
"""Extended file operations available in POSIX.

f = posixfile.open(filename, [mode, [bufsize]])
      will create a new posixfile object

f = posixfile.fileopen(fileobject)
      will create a posixfile object from a builtin file object

f.file()
      will return the original builtin file object

f.dup()
      will return a new file object based on a new filedescriptor

f.dup2(fd)
      will return a new file object based on the given filedescriptor

f.flags(mode)
      will turn on the associated flag (merge)
      mode can contain the following characters:

  (character representing a flag)
      a       append only flag
      c       close on exec flag
      n       no delay flag
      s       synchronization flag
  (modifiers)
      !       turn flags 'off' instead of default 'on'
      =       copy flags 'as is' instead of default 'merge'
      ?       return a string in which the characters represent the flags
              that are set

      note: - the '!' and '=' modifiers are mutually exclusive.
            - the '?' modifier will return the status of the flags after they
              have been changed by other characters in the mode string

f.lock(mode [, len [, start [, whence]]])
      will (un)lock a region
      mode can contain the following characters:

  (character representing type of lock)
      u       unlock
      r       read lock
      w       write lock
  (modifiers)
      |       wait until the lock can be granted
      ?       return the first lock conflicting with the requested lock
              or 'None' if there is no conflict. The lock returned is in the
              format (mode, len, start, whence, pid) where mode is a
              character representing the type of lock ('r' or 'w')

      note: - the '?' modifier prevents a region from being locked; it is
              query only
"""

filename:/usr/lib/python2.7/ctypes/__init__.py
__doc__
"""create and manipulate C data types in Python"""

import os as _os, sys as _sys

__version__ = "1.1.0"

from _ctypes import Union, Structure, Array
from _ctypes import _Pointer
from _ctypes import CFuncPtr as _CFuncPtr
from _ctypes import __version__ as _ctypes_version
from _ctypes import RTLD_LOCAL, RTLD_GLOBAL
from _ctypes import ArgumentError

from struct import calcsize as _calcsize

if __version__ != _ctypes_version:
    raise Exception("Version number mismatch", __version__, _ctypes_version)

if _os.name in ("nt", "ce"):
    from _ctypes import FormatError

DEFAULT_MODE = RTLD_LOCAL
if _os.name == "posix" and _sys.platform == "darwin":
    # On OS X 10.3, we use RTLD_GLOBAL as default mode
    # because RTLD_LOCAL does not work at least on some
    # libraries.  OS X 10.3 is Darwin 7, so we check for
    # that.

    if int(_os.uname()[2].split('.')[0]) < 8:
        DEFAULT_MODE = RTLD_GLOBAL

from _ctypes import FUNCFLAG_CDECL as _FUNCFLAG_CDECL, \
     FUNCFLAG_PYTHONAPI as _FUNCFLAG_PYTHONAPI, \
     FUNCFLAG_USE_ERRNO as _FUNCFLAG_USE_ERRNO, \
     FUNCFLAG_USE_LASTERROR as _FUNCFLAG_USE_LASTERROR

"""

filename:/usr/lib/python2.7/sets.py
__doc__
"""Classes to represent arbitrary sets (including sets of sets).

This module implements sets using dictionaries whose values are
ignored.  The usual operations (union, intersection, deletion, etc.)
are provided as both methods and operators.

Important: sets are not sequences!  While they support 'x in s',
'len(s)', and 'for x in s', none of those operations are unique for
sequences; for example, mappings support all three as well.  The
characteristic operation for sequences is subscripting with small
integers: s[i], for i in range(len(s)).  Sets don't support
subscripting at all.  Also, sequences allow multiple occurrences and
their elements have a definite order; sets on the other hand don't
record multiple occurrences and don't remember the order of element
insertion (which is why they don't support s[i]).

The following classes are provided:

BaseSet -- All the operations common to both mutable and immutable
    sets. This is an abstract class, not meant to be directly
    instantiated.

Set -- Mutable sets, subclass of BaseSet; not hashable.

ImmutableSet -- Immutable sets, subclass of BaseSet; hashable.
    An iterable argument is mandatory to create an ImmutableSet.

_TemporarilyImmutableSet -- A wrapper around a Set, hashable,
    giving the same hash value as the immutable set equivalent
    would have.  Do not use this class directly.

Only hashable objects can be added to a Set. In particular, you cannot
really add a Set as an element to another Set; if you try, what is
actually added is an ImmutableSet built from it (it compares equal to
the one you tried adding).

When you ask if `x in y' where x is a Set and y is a Set or
ImmutableSet, x is wrapped into a _TemporarilyImmutableSet z, and
what's tested is actually `z in y'.

"""

filename:/usr/lib/python2.7/copy.py
__doc__
"""Generic (shallow and deep) copying operations.

Interface summary:

        import copy

        x = copy.copy(y)        # make a shallow copy of y
        x = copy.deepcopy(y)    # make a deep copy of y

For module specific errors, copy.Error is raised.

The difference between shallow and deep copying is only relevant for
compound objects (objects that contain other objects, like lists or
class instances).

- A shallow copy constructs a new compound object and then (to the
  extent possible) inserts *the same objects* into it that the
  original contains.

- A deep copy constructs a new compound object and then, recursively,
  inserts *copies* into it of the objects found in the original.

Two problems often exist with deep copy operations that don't exist
with shallow copy operations:

 a) recursive objects (compound objects that, directly or indirectly,
    contain a reference to themselves) may cause a recursive loop

 b) because deep copy copies *everything* it may copy too much, e.g.
    administrative data structures that should be shared even between
    copies

Python's deep copy operation avoids these problems by:

 a) keeping a table of objects already copied during the current
    copying pass

 b) letting user-defined classes override the copying operation or the
    set of components copied

This version does not copy types like module, class, function, method,
nor stack trace, stack frame, nor file, socket, window, nor array, nor
any similar types.

Classes can use the same interfaces to control copying that they use
to control pickling: they can define methods called __getinitargs__(),
__getstate__() and __setstate__().  See the documentation for module
"pickle" for information on these methods.
"""

filename:/usr/lib/python2.7/getpass.py
__doc__
"""Utilities to get a password and/or the current user name.

getpass(prompt[, stream]) - Prompt for a password, with echo turned off.
getuser() - Get the user name from the environment or password database.

GetPassWarning - This UserWarning is issued when getpass() cannot prevent
                 echoing of the password contents while reading.

On Windows, the msvcrt module will be used.
On the Mac EasyDialogs.AskPassword is used, if available.

"""

filename:/usr/lib/python2.7/gettext.py
__doc__
"""Internationalization and localization support.

This module provides internationalization (I18N) and localization (L10N)
support for your Python programs by providing an interface to the GNU gettext
message catalog library.

I18N refers to the operation by which a program is made aware of multiple
languages.  L10N refers to the adaptation of your program, once
internationalized, to the local language and cultural habits.

"""

filename:/usr/lib/python2.7/pyclbr.py
__doc__
"""Parse a Python module and describe its classes and methods.

Parse enough of a Python file to recognize imports and class and
method definitions, and to find out the superclasses of a class.

The interface consists of a single function:
        readmodule_ex(module [, path])
where module is the name of a Python module, and path is an optional
list of directories where the module is to be searched.  If present,
path is prepended to the system search path sys.path.  The return
value is a dictionary.  The keys of the dictionary are the names of
the classes defined in the module (including classes that are defined
via the from XXX import YYY construct).  The values are class
instances of the class Class defined here.  One special key/value pair
is present for packages: the key '__path__' has a list as its value
which contains the package search path.

A class is described by the class Class in this module.  Instances
of this class have the following instance variables:
        module -- the module name
        name -- the name of the class
        super -- a list of super classes (Class instances)
        methods -- a dictionary of methods
        file -- the file in which the class was defined
        lineno -- the line in the file on which the class statement occurred
The dictionary of methods uses the method names as keys and the line
numbers on which the method was defined as values.
If the name of a super class is not recognized, the corresponding
entry in the list of super classes is not a class instance but a
string giving the name of the super class.  Since import statements
are recognized and imported modules are scanned as well, this
shouldn't happen often.

A function is described by the class Function in this module.
Instances of this class have the following instance variables:
        module -- the module name
        name -- the name of the class
        file -- the file in which the class was defined
        lineno -- the line in the file on which the class statement occurred
"""

filename:/usr/lib/python2.7/mailbox.py
__doc__
"""Read/write support for Maildir, mbox, MH, Babyl, and MMDF mailboxes."""

# Notes for authors of new mailbox subclasses:
#
# Remember to fsync() changes to disk before closing a modified file
# or returning from a flush() method.  See functions _sync_flush() and
# _sync_close().

import sys
import os
import time
import calendar
import socket
import errno
import copy
import email
import email.message
import email.generator
import StringIO
try:
    if sys.platform == 'os2emx':
        # OS/2 EMX fcntl() not adequate
        raise ImportError
    import fcntl
except ImportError:
    fcntl = None

import warnings
with warnings.catch_warnings():
    if sys.py3kwarning:
        warnings.filterwarnings("ignore", ".*rfc822 has been removed",
                                DeprecationWarning)
    import rfc822

__all__ = [ 'Mailbox', 'Maildir', 'mbox', 'MH', 'Babyl', 'MMDF',
            'Message', 'MaildirMessage', 'mboxMessage', 'MHMessage',
            'BabylMessage', 'MMDFMessage', 'UnixMailbox',
            'PortableUnixMailbox', 'MmdfMailbox', 'MHMailbox', 'BabylMailbox' ]

class Mailbox:
    """A group of messages in a particular place."""

    def __init__(self, path, factory=None, create=True):
        """Initialize a Mailbox instance."""
        self._path = os.path.abspath(os.path.expanduser(path))
        self._factory = factory

    def add(self, message):
        """Add message and return assigned key."""
        raise NotImplementedError('Method must be implemented by subclass')

    def remove(self, key):
        """Remove the keyed message; raise KeyError if it doesn't exist."""
        raise NotImplementedError('Method must be implemented by subclass')

    def __delitem__(self, key):
        self.remove(key)

    def discard(self, key):
        """If the keyed message exists, remove it."""
        try:
            self.remove(key)
        except KeyError:
            pass

    def __setitem__(self, key, message):
        """Replace the keyed message; raise KeyError if it doesn't exist."""
        raise NotImplementedError('Method must be implemented by subclass')

    def get(self, key, default=None):
        """Return the keyed message, or default if it doesn't exist."""
        try:
            return self.__getitem__(key)
        except KeyError:
            return default

    def __getitem__(self, key):
        """Return the keyed message; raise KeyError if it doesn't exist."""
        if not self._factory:
            return self.get_message(key)
        else:
            return self._factory(self.get_file(key))

    def get_message(self, key):
        """Return a Message representation or raise a KeyError."""
        raise NotImplementedError('Method must be implemented by subclass')

    def get_string(self, key):
        """Return a string representation or raise a KeyError."""
        raise NotImplementedError('Method must be implemented by subclass')

    def get_file(self, key):
        """Return a file-like representation or raise a KeyError."""
        raise NotImplementedError('Method must be implemented by subclass')

    def iterkeys(self):
        """Return an iterator over keys."""
        raise NotImplementedError('Method must be implemented by subclass')

    def keys(self):
        """Return a list of keys."""
        return list(self.iterkeys())

    def itervalues(self):
        """Return an iterator over all messages."""
        for key in self.iterkeys():
            try:
                value = self[key]
            except KeyError:
                continue
            yield value

    def __iter__(self):
        return self.itervalues()

    def values(self):
        """Return a list of messages. Memory intensive."""
        return list(self.itervalues())

    def iteritems(self):
        """Return an iterator over (key, message) tuples."""
        for key in self.iterkeys():
            try:
                value = self[key]
            except KeyError:
                continue
            yield (key, value)

    def items(self):
        """Return a list of (key, message) tuples. Memory intensive."""
        return list(self.iteritems())

    def has_key(self, key):
        """Return True if the keyed message exists, False otherwise."""
        raise NotImplementedError('Method must be implemented by subclass')

    def __contains__(self, key):
        return self.has_key(key)

    def __len__(self):
        """Return a count of messages in the mailbox."""
        raise NotImplementedError('Method must be implemented by subclass')

    def clear(self):
        """Delete all messages."""
        for key in self.iterkeys():
            self.discard(key)

    def pop(self, key, default=None):
        """Delete the keyed message and return it, or default."""
        try:
            result = self[key]
        except KeyError:
            return default
        self.discard(key)
        return result

    def popitem(self):
        """Delete an arbitrary (key, message) pair and return it."""
        for key in self.iterkeys():
            return (key, self.pop(key))     # This is only run once.
        else:
            raise KeyError('No messages in mailbox')

    def update(self, arg=None):
        """Change the messages that correspond to certain keys."""
        if hasattr(arg, 'iteritems'):
            source = arg.iteritems()
        elif hasattr(arg, 'items'):
            source = arg.items()
        else:
            source = arg
        bad_key = False
        for key, message in source:
            try:
                self[key] = message
            except KeyError:
                bad_key = True
        if bad_key:
            raise KeyError('No message with key(s)')

    def flush(self):
        """Write any pending changes to the disk."""
        raise NotImplementedError('Method must be implemented by subclass')

    def lock(self):
        """Lock the mailbox."""
        raise NotImplementedError('Method must be implemented by subclass')

    def unlock(self):
        """Unlock the mailbox if it is locked."""
        raise NotImplementedError('Method must be implemented by subclass')

    def close(self):
        """Flush and close the mailbox."""
        raise NotImplementedError('Method must be implemented by subclass')

    # Whether each message must end in a newline
    _append_newline = False

    def _dump_message(self, message, target, mangle_from_=False):
        # Most files are opened in binary mode to allow predictable seeking.
        # To get native line endings on disk, the user-friendly \n line endings
        # used in strings and by email.Message are translated here.
        """Dump message contents to target file."""
        if isinstance(message, email.message.Message):
            buffer = StringIO.StringIO()
            gen = email.generator.Generator(buffer, mangle_from_, 0)
            gen.flatten(message)
            buffer.seek(0)
            data = buffer.read().replace('\n', os.linesep)
            target.write(data)
            if self._append_newline and not data.endswith(os.linesep):
                # Make sure the message ends with a newline
                target.write(os.linesep)
        elif isinstance(message, str):
            if mangle_from_:
                message = message.replace('\nFrom ', '\n>From ')
            message = message.replace('\n', os.linesep)
            target.write(message)
            if self._append_newline and not message.endswith(os.linesep):
                # Make sure the message ends with a newline
                target.write(os.linesep)
        elif hasattr(message, 'read'):
            lastline = None
            while True:
                line = message.readline()
                if line == '':
                    break
                if mangle_from_ and line.startswith('From '):
                    line = '>From ' + line[5:]
                line = line.replace('\n', os.linesep)
                target.write(line)
                lastline = line
            if self._append_newline and lastline and not lastline.endswith(os.linesep):
                # Make sure the message ends with a newline
                target.write(os.linesep)
        else:
            raise TypeError('Invalid message type: %s' % type(message))


class Maildir(Mailbox):
    """A qmail-style Maildir mailbox."""

    colon = ':'

    def __init__(self, dirname, factory=rfc822.Message, create=True):
        """Initialize a Maildir instance."""
        Mailbox.__init__(self, dirname, factory, create)
        self._paths = {
            'tmp': os.path.join(self._path, 'tmp'),
            'new': os.path.join(self._path, 'new'),
            'cur': os.path.join(self._path, 'cur'),
            }
        if not os.path.exists(self._path):
            if create:
                os.mkdir(self._path, 0700)
                for path in self._paths.values():
                    os.mkdir(path, 0o700)
            else:
                raise NoSuchMailboxError(self._path)
        self._toc = {}
        self._toc_mtimes = {'cur': 0, 'new': 0}
        self._last_read = 0         # Records last time we read cur/new
        self._skewfactor = 0.1      # Adjust if os/fs clocks are skewing

    def add(self, message):
        """Add message and return assigned key."""
        tmp_file = self._create_tmp()
        try:
            self._dump_message(message, tmp_file)
        except BaseException:
            tmp_file.close()
            os.remove(tmp_file.name)
            raise
        _sync_close(tmp_file)
        if isinstance(message, MaildirMessage):
            subdir = message.get_subdir()
            suffix = self.colon + message.get_info()
            if suffix == self.colon:
                suffix = ''
        else:
            subdir = 'new'
            suffix = ''
        uniq = os.path.basename(tmp_file.name).split(self.colon)[0]
        dest = os.path.join(self._path, subdir, uniq + suffix)
        if isinstance(message, MaildirMessage):
            os.utime(tmp_file.name,
                     (os.path.getatime(tmp_file.name), message.get_date()))
        # No file modification should be done after the file is moved to its
        # final position in order to prevent race conditions with changes
        # from other programs
        try:
            if hasattr(os, 'link'):
                os.link(tmp_file.name, dest)
                os.remove(tmp_file.name)
            else:
                os.rename(tmp_file.name, dest)
        except OSError, e:
            os.remove(tmp_file.name)
            if e.errno == errno.EEXIST:
                raise ExternalClashError('Name clash with existing message: %s'
                                         % dest)
            else:
                raise
        return uniq

    def remove(self, key):
        """Remove the keyed message; raise KeyError if it doesn't exist."""
        os.remove(os.path.join(self._path, self._lookup(key)))

    def discard(self, key):
        """If the keyed message exists, remove it."""
        # This overrides an inapplicable implementation in the superclass.
        try:
            self.remove(key)
        except KeyError:
            pass
        except OSError, e:
            if e.errno != errno.ENOENT:
                raise

    def __setitem__(self, key, message):
        """Replace the keyed message; raise KeyError if it doesn't exist."""
        old_subpath = self._lookup(key)
        temp_key = self.add(message)
        temp_subpath = self._lookup(temp_key)
        if isinstance(message, MaildirMessage):
            # temp's subdir and suffix were specified by message.
            dominant_subpath = temp_subpath
        else:
            # temp's subdir and suffix were defaults from add().
            dominant_subpath = old_subpath
        subdir = os.path.dirname(dominant_subpath)
        if self.colon in dominant_subpath:
            suffix = self.colon + dominant_subpath.split(self.colon)[-1]
        else:
            suffix = ''
        self.discard(key)
        tmp_path = os.path.join(self._path, temp_subpath)
        new_path = os.path.join(self._path, subdir, key + suffix)
        if isinstance(message, MaildirMessage):
            os.utime(tmp_path,
                     (os.path.getatime(tmp_path), message.get_date()))
        # No file modification should be done after the file is moved to its
        # final position in order to prevent race conditions with changes
        # from other programs
        os.rename(tmp_path, new_path)

    def get_message(self, key):
        """Return a Message representation or raise a KeyError."""
        subpath = self._lookup(key)
        f = open(os.path.join(self._path, subpath), 'r')
        try:
            if self._factory:
                msg = self._factory(f)
            else:
                msg = MaildirMessage(f)
        finally:
            f.close()
        subdir, name = os.path.split(subpath)
        msg.set_subdir(subdir)
        if self.colon in name:
            msg.set_info(name.split(self.colon)[-1])
        msg.set_date(os.path.getmtime(os.path.join(self._path, subpath)))
        return msg

    def get_string(self, key):
        """Return a string representation or raise a KeyError."""
        f = open(os.path.join(self._path, self._lookup(key)), 'r')
        try:
            return f.read()
        finally:
            f.close()

    def get_file(self, key):
        """Return a file-like representation or raise a KeyError."""
        f = open(os.path.join(self._path, self._lookup(key)), 'rb')
        return _ProxyFile(f)

    def iterkeys(self):
        """Return an iterator over keys."""
        self._refresh()
        for key in self._toc:
            try:
                self._lookup(key)
            except KeyError:
                continue
            yield key

    def has_key(self, key):
        """Return True if the keyed message exists, False otherwise."""
        self._refresh()
        return key in self._toc

    def __len__(self):
        """Return a count of messages in the mailbox."""
        self._refresh()
        return len(self._toc)

    def flush(self):
        """Write any pending changes to disk."""
        # Maildir changes are always written immediately, so there's nothing
        # to do.
        pass

    def lock(self):
        """Lock the mailbox."""
        return

    def unlock(self):
        """Unlock the mailbox if it is locked."""
        return

    def close(self):
        """Flush and close the mailbox."""
        return

    def list_folders(self):
        """Return a list of folder names."""
        result = []
        for entry in os.listdir(self._path):
            if len(entry) > 1 and entry[0] == '.' and \
               os.path.isdir(os.path.join(self._path, entry)):
                result.append(entry[1:])
        return result

    def get_folder(self, folder):
        """Return a Maildir instance for the named folder."""
        return Maildir(os.path.join(self._path, '.' + folder),
                       factory=self._factory,
                       create=False)

    def add_folder(self, folder):
        """Create a folder and return a Maildir instance representing it."""
        path = os.path.join(self._path, '.' + folder)
        result = Maildir(path, factory=self._factory)
        maildirfolder_path = os.path.join(path, 'maildirfolder')
        if not os.path.exists(maildirfolder_path):
            os.close(os.open(maildirfolder_path, os.O_CREAT | os.O_WRONLY,
                0666))
        return result

    def remove_folder(self, folder):
        """Delete the named folder, which must be empty."""
        path = os.path.join(self._path, '.' + folder)
        for entry in os.listdir(os.path.join(path, 'new')) + \
                     os.listdir(os.path.join(path, 'cur')):
            if len(entry) < 1 or entry[0] != '.':
                raise NotEmptyError('Folder contains message(s): %s' % folder)
        for entry in os.listdir(path):
            if entry != 'new' and entry != 'cur' and entry != 'tmp' and \
               os.path.isdir(os.path.join(path, entry)):
                raise NotEmptyError("Folder contains subdirectory '%s': %s" %
                                    (folder, entry))
        for root, dirs, files in os.walk(path, topdown=False):
            for entry in files:
                os.remove(os.path.join(root, entry))
            for entry in dirs:
                os.rmdir(os.path.join(root, entry))
        os.rmdir(path)

    def clean(self):
        """Delete old files in "tmp"."""
        now = time.time()
        for entry in os.listdir(os.path.join(self._path, 'tmp')):
            path = os.path.join(self._path, 'tmp', entry)
            if now - os.path.getatime(path) > 129600:   # 60 * 60 * 36
                os.remove(path)

    _count = 1  # This is used to generate unique file names.

    def _create_tmp(self):
        """Create a file in the tmp subdirectory and open and return it."""
        now = time.time()
        hostname = socket.gethostname()
        if '/' in hostname:
            hostname = hostname.replace('/', r'\057')
        if ':' in hostname:
            hostname = hostname.replace(':', r'\072')
        uniq = "%s.M%sP%sQ%s.%s" % (int(now), int(now % 1 * 1e6), os.getpid(),
                                    Maildir._count, hostname)
        path = os.path.join(self._path, 'tmp', uniq)
        try:
            os.stat(path)
        except OSError, e:
            if e.errno == errno.ENOENT:
                Maildir._count += 1
                try:
                    return _create_carefully(path)
                except OSError, e:
                    if e.errno != errno.EEXIST:
                        raise
            else:
                raise

        # Fall through to here if stat succeeded or open raised EEXIST.
        raise ExternalClashError('Name clash prevented file creation: %s' %
                                 path)

    def _refresh(self):
        """Update table of contents mapping."""
        # If it has been less than two seconds since the last _refresh() call,
        # we have to unconditionally re-read the mailbox just in case it has
        # been modified, because os.path.mtime() has a 2 sec resolution in the
        # most common worst case (FAT) and a 1 sec resolution typically.  This
        # results in a few unnecessary re-reads when _refresh() is called
        # multiple times in that interval, but once the clock ticks over, we
        # will only re-read as needed.  Because the filesystem might be being
        # served by an independent system with its own clock, we record and
        # compare with the mtimes from the filesystem.  Because the other
        # system's clock might be skewing relative to our clock, we add an
        # extra delta to our wait.  The default is one tenth second, but is an
        # instance variable and so can be adjusted if dealing with a
        # particularly skewed or irregular system.
        if time.time() - self._last_read > 2 + self._skewfactor:
            refresh = False
            for subdir in self._toc_mtimes:
                mtime = os.path.getmtime(self._paths[subdir])
                if mtime > self._toc_mtimes[subdir]:
                    refresh = True
                self._toc_mtimes[subdir] = mtime
            if not refresh:
                return
        # Refresh toc
        self._toc = {}
        for subdir in self._toc_mtimes:
            path = self._paths[subdir]
            for entry in os.listdir(path):
                p = os.path.join(path, entry)
                if os.path.isdir(p):
                    continue
                uniq = entry.split(self.colon)[0]
                self._toc[uniq] = os.path.join(subdir, entry)
        self._last_read = time.time()

    def _lookup(self, key):
        """Use TOC to return subpath for given key, or raise a KeyError."""
        try:
            if os.path.exists(os.path.join(self._path, self._toc[key])):
                return self._toc[key]
        except KeyError:
            pass
        self._refresh()
        try:
            return self._toc[key]
        except KeyError:
            raise KeyError('No message with key: %s' % key)

    # This method is for backward compatibility only.
    def next(self):
        """Return the next message in a one-time iteration."""
        if not hasattr(self, '_onetime_keys'):
            self._onetime_keys = self.iterkeys()
        while True:
            try:
                return self[self._onetime_keys.next()]
            except StopIteration:
                return None
            except KeyError:
                continue


class _singlefileMailbox(Mailbox):
    """A single-file mailbox."""

    def __init__(self, path, factory=None, create=True):
        """Initialize a single-file mailbox."""
        Mailbox.__init__(self, path, factory, create)
        try:
            f = open(self._path, 'rb+')
        except IOError, e:
            if e.errno == errno.ENOENT:
                if create:
                    f = open(self._path, 'wb+')
                else:
                    raise NoSuchMailboxError(self._path)
            elif e.errno in (errno.EACCES, errno.EROFS):
                f = open(self._path, 'rb')
            else:
                raise
        self._file = f
        self._toc = None
        self._next_key = 0
        self._pending = False       # No changes require rewriting the file.
        self._pending_sync = False  # No need to sync the file
        self._locked = False
        self._file_length = None    # Used to record mailbox size

    def add(self, message):
        """Add message and return assigned key."""
        self._lookup()
        self._toc[self._next_key] = self._append_message(message)
        self._next_key += 1
        # _append_message appends the message to the mailbox file. We
        # don't need a full rewrite + rename, sync is enough.
        self._pending_sync = True
        return self._next_key - 1

    def remove(self, key):
        """Remove the keyed message; raise KeyError if it doesn't exist."""
        self._lookup(key)
        del self._toc[key]
        self._pending = True

    def __setitem__(self, key, message):
        """Replace the keyed message; raise KeyError if it doesn't exist."""
        self._lookup(key)
        self._toc[key] = self._append_message(message)
        self._pending = True

    def iterkeys(self):
        """Return an iterator over keys."""
        self._lookup()
        for key in self._toc.keys():
            yield key

    def has_key(self, key):
        """Return True if the keyed message exists, False otherwise."""
        self._lookup()
        return key in self._toc

    def __len__(self):
        """Return a count of messages in the mailbox."""
        self._lookup()
        return len(self._toc)

    def lock(self):
        """Lock the mailbox."""
        if not self._locked:
            _lock_file(self._file)
            self._locked = True

    def unlock(self):
        """Unlock the mailbox if it is locked."""
        if self._locked:
            _unlock_file(self._file)
            self._locked = False

    def flush(self):
        """Write any pending changes to disk."""
        if not self._pending:
            if self._pending_sync:
                # Messages have only been added, so syncing the file
                # is enough.
                _sync_flush(self._file)
                self._pending_sync = False
            return

        # In order to be writing anything out at all, self._toc must
        # already have been generated (and presumably has been modified
        # by adding or deleting an item).
        assert self._toc is not None

        # Check length of self._file; if it's changed, some other process
        # has modified the mailbox since we scanned it.
        self._file.seek(0, 2)
        cur_len = self._file.tell()
        if cur_len != self._file_length:
            raise ExternalClashError('Size of mailbox file changed '
                                     '(expected %i, found %i)' %
                                     (self._file_length, cur_len))

        new_file = _create_temporary(self._path)
        try:
            new_toc = {}
            self._pre_mailbox_hook(new_file)
            for key in sorted(self._toc.keys()):
                start, stop = self._toc[key]
                self._file.seek(start)
                self._pre_message_hook(new_file)
                new_start = new_file.tell()
                while True:
                    buffer = self._file.read(min(4096,
                                                 stop - self._file.tell()))
                    if buffer == '':
                        break
                    new_file.write(buffer)
                new_toc[key] = (new_start, new_file.tell())
                self._post_message_hook(new_file)
            self._file_length = new_file.tell()
        except:
            new_file.close()
            os.remove(new_file.name)
            raise
        _sync_close(new_file)
        # self._file is about to get replaced, so no need to sync.
        self._file.close()
        # Make sure the new file's mode is the same as the old file's
        mode = os.stat(self._path).st_mode
        os.chmod(new_file.name, mode)
        try:
            os.rename(new_file.name, self._path)
        except OSError, e:
            if e.errno == errno.EEXIST or \
              (os.name == 'os2' and e.errno == errno.EACCES):
                os.remove(self._path)
                os.rename(new_file.name, self._path)
            else:
                raise
        self._file = open(self._path, 'rb+')
        self._toc = new_toc
        self._pending = False
        self._pending_sync = False
        if self._locked:
            _lock_file(self._file, dotlock=False)

    def _pre_mailbox_hook(self, f):
        """Called before writing the mailbox to file f."""
        return

    def _pre_message_hook(self, f):
        """Called before writing each message to file f."""
        return

    def _post_message_hook(self, f):
        """Called after writing each message to file f."""
        return

    def close(self):
        """Flush and close the mailbox."""
        try:
            self.flush()
        finally:
            try:
                if self._locked:
                    self.unlock()
            finally:
                self._file.close()  # Sync has been done by self.flush() above.

    def _lookup(self, key=None):
        """Return (start, stop) or raise KeyError."""
        if self._toc is None:
            self._generate_toc()
        if key is not None:
            try:
                return self._toc[key]
            except KeyError:
                raise KeyError('No message with key: %s' % key)

    def _append_message(self, message):
        """Append message to mailbox and return (start, stop) offsets."""
        self._file.seek(0, 2)
        before = self._file.tell()
        if len(self._toc) == 0 and not self._pending:
            # This is the first message, and the _pre_mailbox_hook
            # hasn't yet been called. If self._pending is True,
            # messages have been removed, so _pre_mailbox_hook must
            # have been called already.
            self._pre_mailbox_hook(self._file)
        try:
            self._pre_message_hook(self._file)
            offsets = self._install_message(message)
            self._post_message_hook(self._file)
        except BaseException:
            self._file.truncate(before)
            raise
        self._file.flush()
        self._file_length = self._file.tell()  # Record current length of mailbox
        return offsets



class _mboxMMDF(_singlefileMailbox):
    """An mbox or MMDF mailbox."""

    _mangle_from_ = True

    def get_message(self, key):
        """Return a Message representation or raise a KeyError."""
        start, stop = self._lookup(key)
        self._file.seek(start)
        from_line = self._file.readline().replace(os.linesep, '')
        string = self._file.read(stop - self._file.tell())
        msg = self._message_factory(string.replace(os.linesep, '\n'))
        msg.set_from(from_line[5:])
        return msg

    def get_string(self, key, from_=False):
        """Return a string representation or raise a KeyError."""
        start, stop = self._lookup(key)
        self._file.seek(start)
        if not from_:
            self._file.readline()
        string = self._file.read(stop - self._file.tell())
        return string.replace(os.linesep, '\n')

    def get_file(self, key, from_=False):
        """Return a file-like representation or raise a KeyError."""
        start, stop = self._lookup(key)
        self._file.seek(start)
        if not from_:
            self._file.readline()
        return _PartialFile(self._file, self._file.tell(), stop)

    def _install_message(self, message):
        """Format a message and blindly write to self._file."""
        from_line = None
        if isinstance(message, str) and message.startswith('From '):
            newline = message.find('\n')
            if newline != -1:
                from_line = message[:newline]
                message = message[newline + 1:]
            else:
                from_line = message
                message = ''
        elif isinstance(message, _mboxMMDFMessage):
            from_line = 'From ' + message.get_from()
        elif isinstance(message, email.message.Message):
            from_line = message.get_unixfrom()  # May be None.
        if from_line is None:
            from_line = 'From MAILER-DAEMON %s' % time.asctime(time.gmtime())
        start = self._file.tell()
        self._file.write(from_line + os.linesep)
        self._dump_message(message, self._file, self._mangle_from_)
        stop = self._file.tell()
        return (start, stop)


class mbox(_mboxMMDF):
    """A classic mbox mailbox."""

    _mangle_from_ = True

    # All messages must end in a newline character, and
    # _post_message_hooks outputs an empty line between messages.
    _append_newline = True

    def __init__(self, path, factory=None, create=True):
        """Initialize an mbox mailbox."""
        self._message_factory = mboxMessage
        _mboxMMDF.__init__(self, path, factory, create)

    def _post_message_hook(self, f):
        """Called after writing each message to file f."""
        f.write(os.linesep)

    def _generate_toc(self):
        """Generate key-to-(start, stop) table of contents."""
        starts, stops = [], []
        last_was_empty = False
        self._file.seek(0)
        while True:
            line_pos = self._file.tell()
            line = self._file.readline()
            if line.startswith('From '):
                if len(stops) < len(starts):
                    if last_was_empty:
                        stops.append(line_pos - len(os.linesep))
                    else:
                        # The last line before the "From " line wasn't
                        # blank, but we consider it a start of a
                        # message anyway.
                        stops.append(line_pos)
                starts.append(line_pos)
                last_was_empty = False
            elif not line:
                if last_was_empty:
                    stops.append(line_pos - len(os.linesep))
                else:
                    stops.append(line_pos)
                break
            elif line == os.linesep:
                last_was_empty = True
            else:
                last_was_empty = False
        self._toc = dict(enumerate(zip(starts, stops)))
        self._next_key = len(self._toc)
        self._file_length = self._file.tell()


class MMDF(_mboxMMDF):
    """An MMDF mailbox."""

    def __init__(self, path, factory=None, create=True):
        """Initialize an MMDF mailbox."""
        self._message_factory = MMDFMessage
        _mboxMMDF.__init__(self, path, factory, create)

    def _pre_message_hook(self, f):
        """Called before writing each message to file f."""
        f.write('\001\001\001\001' + os.linesep)

    def _post_message_hook(self, f):
        """Called after writing each message to file f."""
        f.write(os.linesep + '\001\001\001\001' + os.linesep)

    def _generate_toc(self):
        """Generate key-to-(start, stop) table of contents."""
        starts, stops = [], []
        self._file.seek(0)
        next_pos = 0
        while True:
            line_pos = next_pos
            line = self._file.readline()
            next_pos = self._file.tell()
            if line.startswith('\001\001\001\001' + os.linesep):
                starts.append(next_pos)
                while True:
                    line_pos = next_pos
                    line = self._file.readline()
                    next_pos = self._file.tell()
                    if line == '\001\001\001\001' + os.linesep:
                        stops.append(line_pos - len(os.linesep))
                        break
                    elif line == '':
                        stops.append(line_pos)
                        break
            elif line == '':
                break
        self._toc = dict(enumerate(zip(starts, stops)))
        self._next_key = len(self._toc)
        self._file.seek(0, 2)
        self._file_length = self._file.tell()


class MH(Mailbox):
    """An MH mailbox."""

    def __init__(self, path, factory=None, create=True):
        """Initialize an MH instance."""
        Mailbox.__init__(self, path, factory, create)
        if not os.path.exists(self._path):
            if create:
                os.mkdir(self._path, 0700)
                os.close(os.open(os.path.join(self._path, '.mh_sequences'),
                                 os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0600))
            else:
                raise NoSuchMailboxError(self._path)
        self._locked = False

    def add(self, message):
        """Add message and return assigned key."""
        keys = self.keys()
        if len(keys) == 0:
            new_key = 1
        else:
            new_key = max(keys) + 1
        new_path = os.path.join(self._path, str(new_key))
        f = _create_carefully(new_path)
        closed = False
        try:
            if self._locked:
                _lock_file(f)
            try:
                try:
                    self._dump_message(message, f)
                except BaseException:
                    # Unlock and close so it can be deleted on Windows
                    if self._locked:
                        _unlock_file(f)
                    _sync_close(f)
                    closed = True
                    os.remove(new_path)
                    raise
                if isinstance(message, MHMessage):
                    self._dump_sequences(message, new_key)
            finally:
                if self._locked:
                    _unlock_file(f)
        finally:
            if not closed:
                _sync_close(f)
        return new_key

    def remove(self, key):
        """Remove the keyed message; raise KeyError if it doesn't exist."""
        path = os.path.join(self._path, str(key))
        try:
            f = open(path, 'rb+')
        except IOError, e:
            if e.errno == errno.ENOENT:
                raise KeyError('No message with key: %s' % key)
            else:
                raise
        else:
            f.close()
            os.remove(path)

    def __setitem__(self, key, message):
        """Replace the keyed message; raise KeyError if it doesn't exist."""
        path = os.path.join(self._path, str(key))
        try:
            f = open(path, 'rb+')
        except IOError, e:
            if e.errno == errno.ENOENT:
                raise KeyError('No message with key: %s' % key)
            else:
                raise
        try:
            if self._locked:
                _lock_file(f)
            try:
                os.close(os.open(path, os.O_WRONLY | os.O_TRUNC))
                self._dump_message(message, f)
                if isinstance(message, MHMessage):
                    self._dump_sequences(message, key)
            finally:
                if self._locked:
                    _unlock_file(f)
        finally:
            _sync_close(f)

    def get_message(self, key):
        """Return a Message representation or raise a KeyError."""
        try:
            if self._locked:
                f = open(os.path.join(self._path, str(key)), 'r+')
            else:
                f = open(os.path.join(self._path, str(key)), 'r')
        except IOError, e:
            if e.errno == errno.ENOENT:
                raise KeyError('No message with key: %s' % key)
            else:
                raise
        try:
            if self._locked:
                _lock_file(f)
            try:
                msg = MHMessage(f)
            finally:
                if self._locked:
                    _unlock_file(f)
        finally:
            f.close()
        for name, key_list in self.get_sequences().iteritems():
            if key in key_list:
                msg.add_sequence(name)
        return msg

    def get_string(self, key):
        """Return a string representation or raise a KeyError."""
        try:
            if self._locked:
                f = open(os.path.join(self._path, str(key)), 'r+')
            else:
                f = open(os.path.join(self._path, str(key)), 'r')
        except IOError, e:
            if e.errno == errno.ENOENT:
                raise KeyError('No message with key: %s' % key)
            else:
                raise
        try:
            if self._locked:
                _lock_file(f)
            try:
                return f.read()
            finally:
                if self._locked:
                    _unlock_file(f)
        finally:
            f.close()

    def get_file(self, key):
        """Return a file-like representation or raise a KeyError."""
        try:
            f = open(os.path.join(self._path, str(key)), 'rb')
        except IOError, e:
            if e.errno == errno.ENOENT:
                raise KeyError('No message with key: %s' % key)
            else:
                raise
        return _ProxyFile(f)

    def iterkeys(self):
        """Return an iterator over keys."""
        return iter(sorted(int(entry) for entry in os.listdir(self._path)
                                      if entry.isdigit()))

    def has_key(self, key):
        """Return True if the keyed message exists, False otherwise."""
        return os.path.exists(os.path.join(self._path, str(key)))

    def __len__(self):
        """Return a count of messages in the mailbox."""
        return len(list(self.iterkeys()))

    def lock(self):
        """Lock the mailbox."""
        if not self._locked:
            self._file = open(os.path.join(self._path, '.mh_sequences'), 'rb+')
            _lock_file(self._file)
            self._locked = True

    def unlock(self):
        """Unlock the mailbox if it is locked."""
        if self._locked:
            _unlock_file(self._file)
            _sync_close(self._file)
            del self._file
            self._locked = False

    def flush(self):
        """Write any pending changes to the disk."""
        return

    def close(self):
        """Flush and close the mailbox."""
        if self._locked:
            self.unlock()

    def list_folders(self):
        """Return a list of folder names."""
        result = []
        for entry in os.listdir(self._path):
            if os.path.isdir(os.path.join(self._path, entry)):
                result.append(entry)
        return result

    def get_folder(self, folder):
        """Return an MH instance for the named folder."""
        return MH(os.path.join(self._path, folder),
                  factory=self._factory, create=False)

    def add_folder(self, folder):
        """Create a folder and return an MH instance representing it."""
        return MH(os.path.join(self._path, folder),
                  factory=self._factory)

    def remove_folder(self, folder):
        """Delete the named folder, which must be empty."""
        path = os.path.join(self._path, folder)
        entries = os.listdir(path)
        if entries == ['.mh_sequences']:
            os.remove(os.path.join(path, '.mh_sequences'))
        elif entries == []:
            pass
        else:
            raise NotEmptyError('Folder not empty: %s' % self._path)
        os.rmdir(path)

    def get_sequences(self):
        """Return a name-to-key-list dictionary to define each sequence."""
        results = {}
        f = open(os.path.join(self._path, '.mh_sequences'), 'r')
        try:
            all_keys = set(self.keys())
            for line in f:
                try:
                    name, contents = line.split(':')
                    keys = set()
                    for spec in contents.split():
                        if spec.isdigit():
                            keys.add(int(spec))
                        else:
                            start, stop = (int(x) for x in spec.split('-'))
                            keys.update(range(start, stop + 1))
                    results[name] = [key for key in sorted(keys) \
                                         if key in all_keys]
                    if len(results[name]) == 0:
                        del results[name]
                except ValueError:
                    raise FormatError('Invalid sequence specification: %s' %
                                      line.rstrip())
        finally:
            f.close()
        return results

    def set_sequences(self, sequences):
        """Set sequences using the given name-to-key-list dictionary."""
        f = open(os.path.join(self._path, '.mh_sequences'), 'r+')
        try:
            os.close(os.open(f.name, os.O_WRONLY | os.O_TRUNC))
            for name, keys in sequences.iteritems():
                if len(keys) == 0:
                    continue
                f.write('%s:' % name)
                prev = None
                completing = False
                for key in sorted(set(keys)):
                    if key - 1 == prev:
                        if not completing:
                            completing = True
                            f.write('-')
                    elif completing:
                        completing = False
                        f.write('%s %s' % (prev, key))
                    else:
                        f.write(' %s' % key)
                    prev = key
                if completing:
                    f.write(str(prev) + '\n')
                else:
                    f.write('\n')
        finally:
            _sync_close(f)

    def pack(self):
        """Re-name messages to eliminate numbering gaps. Invalidates keys."""
        sequences = self.get_sequences()
        prev = 0
        changes = []
        for key in self.iterkeys():
            if key - 1 != prev:
                changes.append((key, prev + 1))
                if hasattr(os, 'link'):
                    os.link(os.path.join(self._path, str(key)),
                            os.path.join(self._path, str(prev + 1)))
                    os.unlink(os.path.join(self._path, str(key)))
                else:
                    os.rename(os.path.join(self._path, str(key)),
                              os.path.join(self._path, str(prev + 1)))
            prev += 1
        self._next_key = prev + 1
        if len(changes) == 0:
            return
        for name, key_list in sequences.items():
            for old, new in changes:
                if old in key_list:
                    key_list[key_list.index(old)] = new
        self.set_sequences(sequences)

    def _dump_sequences(self, message, key):
        """Inspect a new MHMessage and update sequences appropriately."""
        pending_sequences = message.get_sequences()
        all_sequences = self.get_sequences()
        for name, key_list in all_sequences.iteritems():
            if name in pending_sequences:
                key_list.append(key)
            elif key in key_list:
                del key_list[key_list.index(key)]
        for sequence in pending_sequences:
            if sequence not in all_sequences:
                all_sequences[sequence] = [key]
        self.set_sequences(all_sequences)


class Babyl(_singlefileMailbox):
    """An Rmail-style Babyl mailbox."""

    _special_labels = frozenset(('unseen', 'deleted', 'filed', 'answered',
                                 'forwarded', 'edited', 'resent'))

    def __init__(self, path, factory=None, create=True):
        """Initialize a Babyl mailbox."""
        _singlefileMailbox.__init__(self, path, factory, create)
        self._labels = {}

    def add(self, message):
        """Add message and return assigned key."""
        key = _singlefileMailbox.add(self, message)
        if isinstance(message, BabylMessage):
            self._labels[key] = message.get_labels()
        return key

    def remove(self, key):
        """Remove the keyed message; raise KeyError if it doesn't exist."""
        _singlefileMailbox.remove(self, key)
        if key in self._labels:
            del self._labels[key]

    def __setitem__(self, key, message):
        """Replace the keyed message; raise KeyError if it doesn't exist."""
        _singlefileMailbox.__setitem__(self, key, message)
        if isinstance(message, BabylMessage):
            self._labels[key] = message.get_labels()

    def get_message(self, key):
        """Return a Message representation or raise a KeyError."""
        start, stop = self._lookup(key)
        self._file.seek(start)
        self._file.readline()   # Skip '1,' line specifying labels.
        original_headers = StringIO.StringIO()
        while True:
            line = self._file.readline()
            if line == '*** EOOH ***' + os.linesep or line == '':
                break
            original_headers.write(line.replace(os.linesep, '\n'))
        visible_headers = StringIO.StringIO()
        while True:
            line = self._file.readline()
            if line == os.linesep or line == '':
                break
            visible_headers.write(line.replace(os.linesep, '\n'))
        body = self._file.read(stop - self._file.tell()).replace(os.linesep,
                                                                 '\n')
        msg = BabylMessage(original_headers.getvalue() + body)
        msg.set_visible(visible_headers.getvalue())
        if key in self._labels:
            msg.set_labels(self._labels[key])
        return msg

    def get_string(self, key):
        """Return a string representation or raise a KeyError."""
        start, stop = self._lookup(key)
        self._file.seek(start)
        self._file.readline()   # Skip '1,' line specifying labels.
        original_headers = StringIO.StringIO()
        while True:
            line = self._file.readline()
            if line == '*** EOOH ***' + os.linesep or line == '':
                break
            original_headers.write(line.replace(os.linesep, '\n'))
        while True:
            line = self._file.readline()
            if line == os.linesep or line == '':
                break
        return original_headers.getvalue() + \
               self._file.read(stop - self._file.tell()).replace(os.linesep,
                                                                 '\n')

    def get_file(self, key):
        """Return a file-like representation or raise a KeyError."""
        return StringIO.StringIO(self.get_string(key).replace('\n',
                                                              os.linesep))

    def get_labels(self):
        """Return a list of user-defined labels in the mailbox."""
        self._lookup()
        labels = set()
        for label_list in self._labels.values():
            labels.update(label_list)
        labels.difference_update(self._special_labels)
        return list(labels)

    def _generate_toc(self):
        """Generate key-to-(start, stop) table of contents."""
        starts, stops = [], []
        self._file.seek(0)
        next_pos = 0
        label_lists = []
        while True:
            line_pos = next_pos
            line = self._file.readline()
            next_pos = self._file.tell()
            if line == '\037\014' + os.linesep:
                if len(stops) < len(starts):
                    stops.append(line_pos - len(os.linesep))
                starts.append(next_pos)
                labels = [label.strip() for label
                                        in self._file.readline()[1:].split(',')
                                        if label.strip() != '']
                label_lists.append(labels)
            elif line == '\037' or line == '\037' + os.linesep:
                if len(stops) < len(starts):
                    stops.append(line_pos - len(os.linesep))
            elif line == '':
                stops.append(line_pos - len(os.linesep))
                break
        self._toc = dict(enumerate(zip(starts, stops)))
        self._labels = dict(enumerate(label_lists))
        self._next_key = len(self._toc)
        self._file.seek(0, 2)
        self._file_length = self._file.tell()

    def _pre_mailbox_hook(self, f):
        """Called before writing the mailbox to file f."""
        f.write('BABYL OPTIONS:%sVersion: 5%sLabels:%s%s\037' %
                (os.linesep, os.linesep, ','.join(self.get_labels()),
                 os.linesep))

    def _pre_message_hook(self, f):
        """Called before writing each message to file f."""
        f.write('\014' + os.linesep)

    def _post_message_hook(self, f):
        """Called after writing each message to file f."""
        f.write(os.linesep + '\037')

    def _install_message(self, message):
        """Write message contents and return (start, stop)."""
        start = self._file.tell()
        if isinstance(message, BabylMessage):
            special_labels = []
            labels = []
            for label in message.get_labels():
                if label in self._special_labels:
                    special_labels.append(label)
                else:
                    labels.append(label)
            self._file.write('1')
            for label in special_labels:
                self._file.write(', ' + label)
            self._file.write(',,')
            for label in labels:
                self._file.write(' ' + label + ',')
            self._file.write(os.linesep)
        else:
            self._file.write('1,,' + os.linesep)
        if isinstance(message, email.message.Message):
            orig_buffer = StringIO.StringIO()
            orig_generator = email.generator.Generator(orig_buffer, False, 0)
            orig_generator.flatten(message)
            orig_buffer.seek(0)
            while True:
                line = orig_buffer.readline()
                self._file.write(line.replace('\n', os.linesep))
                if line == '\n' or line == '':
                    break
            self._file.write('*** EOOH ***' + os.linesep)
            if isinstance(message, BabylMessage):
                vis_buffer = StringIO.StringIO()
                vis_generator = email.generator.Generator(vis_buffer, False, 0)
                vis_generator.flatten(message.get_visible())
                while True:
                    line = vis_buffer.readline()
                    self._file.write(line.replace('\n', os.linesep))
                    if line == '\n' or line == '':
                        break
            else:
                orig_buffer.seek(0)
                while True:
                    line = orig_buffer.readline()
                    self._file.write(line.replace('\n', os.linesep))
                    if line == '\n' or line == '':
                        break
            while True:
                buffer = orig_buffer.read(4096) # Buffer size is arbitrary.
                if buffer == '':
                    break
                self._file.write(buffer.replace('\n', os.linesep))
        elif isinstance(message, str):
            body_start = message.find('\n\n') + 2
            if body_start - 2 != -1:
                self._file.write(message[:body_start].replace('\n',
                                                              os.linesep))
                self._file.write('*** EOOH ***' + os.linesep)
                self._file.write(message[:body_start].replace('\n',
                                                              os.linesep))
                self._file.write(message[body_start:].replace('\n',
                                                              os.linesep))
            else:
                self._file.write('*** EOOH ***' + os.linesep + os.linesep)
                self._file.write(message.replace('\n', os.linesep))
        elif hasattr(message, 'readline'):
            original_pos = message.tell()
            first_pass = True
            while True:
                line = message.readline()
                self._file.write(line.replace('\n', os.linesep))
                if line == '\n' or line == '':
                    if first_pass:
                        first_pass = False
                        self._file.write('*** EOOH ***' + os.linesep)
                        message.seek(original_pos)
                    else:
                        break
            while True:
                buffer = message.read(4096)     # Buffer size is arbitrary.
                if buffer == '':
                    break
                self._file.write(buffer.replace('\n', os.linesep))
        else:
            raise TypeError('Invalid message type: %s' % type(message))
        stop = self._file.tell()
        return (start, stop)


class Message(email.message.Message):
    """Message with mailbox-format-specific properties."""

    def __init__(self, message=None):
        """Initialize a Message instance."""
        if isinstance(message, email.message.Message):
            self._become_message(copy.deepcopy(message))
            if isinstance(message, Message):
                message._explain_to(self)
        elif isinstance(message, str):
            self._become_message(email.message_from_string(message))
        elif hasattr(message, "read"):
            self._become_message(email.message_from_file(message))
        elif message is None:
            email.message.Message.__init__(self)
        else:
            raise TypeError('Invalid message type: %s' % type(message))

    def _become_message(self, message):
        """Assume the non-format-specific state of message."""
        for name in ('_headers', '_unixfrom', '_payload', '_charset',
                     'preamble', 'epilogue', 'defects', '_default_type'):
            self.__dict__[name] = message.__dict__[name]

    def _explain_to(self, message):
        """Copy format-specific state to message insofar as possible."""
        if isinstance(message, Message):
            return  # There's nothing format-specific to explain.
        else:
            raise TypeError('Cannot convert to specified type')


class MaildirMessage(Message):
    """Message with Maildir-specific properties."""

    def __init__(self, message=None):
        """Initialize a MaildirMessage instance."""
        self._subdir = 'new'
        self._info = ''
        self._date = time.time()
        Message.__init__(self, message)

    def get_subdir(self):
        """Return 'new' or 'cur'."""
        return self._subdir

    def set_subdir(self, subdir):
        """Set subdir to 'new' or 'cur'."""
        if subdir == 'new' or subdir == 'cur':
            self._subdir = subdir
        else:
            raise ValueError("subdir must be 'new' or 'cur': %s" % subdir)

    def get_flags(self):
        """Return as a string the flags that are set."""
        if self._info.startswith('2,'):
            return self._info[2:]
        else:
            return ''

    def set_flags(self, flags):
        """Set the given flags and unset all others."""
        self._info = '2,' + ''.join(sorted(flags))

    def add_flag(self, flag):
        """Set the given flag(s) without changing others."""
        self.set_flags(''.join(set(self.get_flags()) | set(flag)))

    def remove_flag(self, flag):
        """Unset the given string flag(s) without changing others."""
        if self.get_flags() != '':
            self.set_flags(''.join(set(self.get_flags()) - set(flag)))

    def get_date(self):
        """Return delivery date of message, in seconds since the epoch."""
        return self._date

    def set_date(self, date):
        """Set delivery date of message, in seconds since the epoch."""
        try:
            self._date = float(date)
        except ValueError:
            raise TypeError("can't convert to float: %s" % date)

    def get_info(self):
        """Get the message's "info" as a string."""
        return self._info

    def set_info(self, info):
        """Set the message's "info" string."""
        if isinstance(info, str):
            self._info = info
        else:
            raise TypeError('info must be a string: %s' % type(info))

    def _explain_to(self, message):
        """Copy Maildir-specific state to message insofar as possible."""
        if isinstance(message, MaildirMessage):
            message.set_flags(self.get_flags())
            message.set_subdir(self.get_subdir())
            message.set_date(self.get_date())
        elif isinstance(message, _mboxMMDFMessage):
            flags = set(self.get_flags())
            if 'S' in flags:
                message.add_flag('R')
            if self.get_subdir() == 'cur':
                message.add_flag('O')
            if 'T' in flags:
                message.add_flag('D')
            if 'F' in flags:
                message.add_flag('F')
            if 'R' in flags:
                message.add_flag('A')
            message.set_from('MAILER-DAEMON', time.gmtime(self.get_date()))
        elif isinstance(message, MHMessage):
            flags = set(self.get_flags())
            if 'S' not in flags:
                message.add_sequence('unseen')
            if 'R' in flags:
                message.add_sequence('replied')
            if 'F' in flags:
                message.add_sequence('flagged')
        elif isinstance(message, BabylMessage):
            flags = set(self.get_flags())
            if 'S' not in flags:
                message.add_label('unseen')
            if 'T' in flags:
                message.add_label('deleted')
            if 'R' in flags:
                message.add_label('answered')
            if 'P' in flags:
                message.add_label('forwarded')
        elif isinstance(message, Message):
            pass
        else:
            raise TypeError('Cannot convert to specified type: %s' %
                            type(message))


class _mboxMMDFMessage(Message):
    """Message with mbox- or MMDF-specific properties."""

    def __init__(self, message=None):
        """Initialize an mboxMMDFMessage instance."""
        self.set_from('MAILER-DAEMON', True)
        if isinstance(message, email.message.Message):
            unixfrom = message.get_unixfrom()
            if unixfrom is not None and unixfrom.startswith('From '):
                self.set_from(unixfrom[5:])
        Message.__init__(self, message)

    def get_from(self):
        """Return contents of "From " line."""
        return self._from

    def set_from(self, from_, time_=None):
        """Set "From " line, formatting and appending time_ if specified."""
        if time_ is not None:
            if time_ is True:
                time_ = time.gmtime()
            from_ += ' ' + time.asctime(time_)
        self._from = from_

    def get_flags(self):
        """Return as a string the flags that are set."""
        return self.get('Status', '') + self.get('X-Status', '')

    def set_flags(self, flags):
        """Set the given flags and unset all others."""
        flags = set(flags)
        status_flags, xstatus_flags = '', ''
        for flag in ('R', 'O'):
            if flag in flags:
                status_flags += flag
                flags.remove(flag)
        for flag in ('D', 'F', 'A'):
            if flag in flags:
                xstatus_flags += flag
                flags.remove(flag)
        xstatus_flags += ''.join(sorted(flags))
        try:
            self.replace_header('Status', status_flags)
        except KeyError:
            self.add_header('Status', status_flags)
        try:
            self.replace_header('X-Status', xstatus_flags)
        except KeyError:
            self.add_header('X-Status', xstatus_flags)

    def add_flag(self, flag):
        """Set the given flag(s) without changing others."""
        self.set_flags(''.join(set(self.get_flags()) | set(flag)))

    def remove_flag(self, flag):
        """Unset the given string flag(s) without changing others."""
        if 'Status' in self or 'X-Status' in self:
            self.set_flags(''.join(set(self.get_flags()) - set(flag)))

    def _explain_to(self, message):
        """Copy mbox- or MMDF-specific state to message insofar as possible."""
        if isinstance(message, MaildirMessage):
            flags = set(self.get_flags())
            if 'O' in flags:
                message.set_subdir('cur')
            if 'F' in flags:
                message.add_flag('F')
            if 'A' in flags:
                message.add_flag('R')
            if 'R' in flags:
                message.add_flag('S')
            if 'D' in flags:
                message.add_flag('T')
            del message['status']
            del message['x-status']
            maybe_date = ' '.join(self.get_from().split()[-5:])
            try:
                message.set_date(calendar.timegm(time.strptime(maybe_date,
                                                      '%a %b %d %H:%M:%S %Y')))
            except (ValueError, OverflowError):
                pass
        elif isinstance(message, _mboxMMDFMessage):
            message.set_flags(self.get_flags())
            message.set_from(self.get_from())
        elif isinstance(message, MHMessage):
            flags = set(self.get_flags())
            if 'R' not in flags:
                message.add_sequence('unseen')
            if 'A' in flags:
                message.add_sequence('replied')
            if 'F' in flags:
                message.add_sequence('flagged')
            del message['status']
            del message['x-status']
        elif isinstance(message, BabylMessage):
            flags = set(self.get_flags())
            if 'R' not in flags:
                message.add_label('unseen')
            if 'D' in flags:
                message.add_label('deleted')
            if 'A' in flags:
                message.add_label('answered')
            del message['status']
            del message['x-status']
        elif isinstance(message, Message):
            pass
        else:
            raise TypeError('Cannot convert to specified type: %s' %
                            type(message))


class mboxMessage(_mboxMMDFMessage):
    """Message with mbox-specific properties."""


class MHMessage(Message):
    """Message with MH-specific properties."""

    def __init__(self, message=None):
        """Initialize an MHMessage instance."""
        self._sequences = []
        Message.__init__(self, message)

    def get_sequences(self):
        """Return a list of sequences that include the message."""
        return self._sequences[:]

    def set_sequences(self, sequences):
        """Set the list of sequences that include the message."""
        self._sequences = list(sequences)

    def add_sequence(self, sequence):
        """Add sequence to list of sequences including the message."""
        if isinstance(sequence, str):
            if not sequence in self._sequences:
                self._sequences.append(sequence)
        else:
            raise TypeError('sequence must be a string: %s' % type(sequence))

    def remove_sequence(self, sequence):
        """Remove sequence from the list of sequences including the message."""
        try:
            self._sequences.remove(sequence)
        except ValueError:
            pass

    def _explain_to(self, message):
        """Copy MH-specific state to message insofar as possible."""
        if isinstance(message, MaildirMessage):
            sequences = set(self.get_sequences())
            if 'unseen' in sequences:
                message.set_subdir('cur')
            else:
                message.set_subdir('cur')
                message.add_flag('S')
            if 'flagged' in sequences:
                message.add_flag('F')
            if 'replied' in sequences:
                message.add_flag('R')
        elif isinstance(message, _mboxMMDFMessage):
            sequences = set(self.get_sequences())
            if 'unseen' not in sequences:
                message.add_flag('RO')
            else:
                message.add_flag('O')
            if 'flagged' in sequences:
                message.add_flag('F')
            if 'replied' in sequences:
                message.add_flag('A')
        elif isinstance(message, MHMessage):
            for sequence in self.get_sequences():
                message.add_sequence(sequence)
        elif isinstance(message, BabylMessage):
            sequences = set(self.get_sequences())
            if 'unseen' in sequences:
                message.add_label('unseen')
            if 'replied' in sequences:
                message.add_label('answered')
        elif isinstance(message, Message):
            pass
        else:
            raise TypeError('Cannot convert to specified type: %s' %
                            type(message))


class BabylMessage(Message):
    """Message with Babyl-specific properties."""

    def __init__(self, message=None):
        """Initialize a BabylMessage instance."""
        self._labels = []
        self._visible = Message()
        Message.__init__(self, message)

    def get_labels(self):
        """Return a list of labels on the message."""
        return self._labels[:]

    def set_labels(self, labels):
        """Set the list of labels on the message."""
        self._labels = list(labels)

    def add_label(self, label):
        """Add label to list of labels on the message."""
        if isinstance(label, str):
            if label not in self._labels:
                self._labels.append(label)
        else:
            raise TypeError('label must be a string: %s' % type(label))

    def remove_label(self, label):
        """Remove label from the list of labels on the message."""
        try:
            self._labels.remove(label)
        except ValueError:
            pass

    def get_visible(self):
        """Return a Message representation of visible headers."""
        return Message(self._visible)

    def set_visible(self, visible):
        """Set the Message representation of visible headers."""
        self._visible = Message(visible)

    def update_visible(self):
        """Update and/or sensibly generate a set of visible headers."""
        for header in self._visible.keys():
            if header in self:
                self._visible.replace_header(header, self[header])
            else:
                del self._visible[header]
        for header in ('Date', 'From', 'Reply-To', 'To', 'CC', 'Subject'):
            if header in self and header not in self._visible:
                self._visible[header] = self[header]

    def _explain_to(self, message):
        """Copy Babyl-specific state to message insofar as possible."""
        if isinstance(message, MaildirMessage):
            labels = set(self.get_labels())
            if 'unseen' in labels:
                message.set_subdir('cur')
            else:
                message.set_subdir('cur')
                message.add_flag('S')
            if 'forwarded' in labels or 'resent' in labels:
                message.add_flag('P')
            if 'answered' in labels:
                message.add_flag('R')
            if 'deleted' in labels:
                message.add_flag('T')
        elif isinstance(message, _mboxMMDFMessage):
            labels = set(self.get_labels())
            if 'unseen' not in labels:
                message.add_flag('RO')
            else:
                message.add_flag('O')
            if 'deleted' in labels:
                message.add_flag('D')
            if 'answered' in labels:
                message.add_flag('A')
        elif isinstance(message, MHMessage):
            labels = set(self.get_labels())
            if 'unseen' in labels:
                message.add_sequence('unseen')
            if 'answered' in labels:
                message.add_sequence('replied')
        elif isinstance(message, BabylMessage):
            message.set_visible(self.get_visible())
            for label in self.get_labels():
                message.add_label(label)
        elif isinstance(message, Message):
            pass
        else:
            raise TypeError('Cannot convert to specified type: %s' %
                            type(message))


class MMDFMessage(_mboxMMDFMessage):
    """Message with MMDF-specific properties."""


class _ProxyFile:
    """A read-only wrapper of a file."""

    def __init__(self, f, pos=None):
        """Initialize a _ProxyFile."""
        self._file = f
        if pos is None:
            self._pos = f.tell()
        else:
            self._pos = pos

    def read(self, size=None):
        """Read bytes."""
        return self._read(size, self._file.read)

    def readline(self, size=None):
        """Read a line."""
        return self._read(size, self._file.readline)

    def readlines(self, sizehint=None):
        """Read multiple lines."""
        result = []
        for line in self:
            result.append(line)
            if sizehint is not None:
                sizehint -= len(line)
                if sizehint <= 0:
                    break
        return result

    def __iter__(self):
        """Iterate over lines."""
        return iter(self.readline, "")

    def tell(self):
        """Return the position."""
        return self._pos

    def seek(self, offset, whence=0):
        """Change position."""
        if whence == 1:
            self._file.seek(self._pos)
        self._file.seek(offset, whence)
        self._pos = self._file.tell()

    def close(self):
        """Close the file."""
        if hasattr(self, '_file'):
            if hasattr(self._file, 'close'):
                self._file.close()
            del self._file

    def _read(self, size, read_method):
        """Read size bytes using read_method."""
        if size is None:
            size = -1
        self._file.seek(self._pos)
        result = read_method(size)
        self._pos = self._file.tell()
        return result


class _PartialFile(_ProxyFile):
    """A read-only wrapper of part of a file."""

    def __init__(self, f, start=None, stop=None):
        """Initialize a _PartialFile."""
        _ProxyFile.__init__(self, f, start)
        self._start = start
        self._stop = stop

    def tell(self):
        """Return the position with respect to start."""
        return _ProxyFile.tell(self) - self._start

    def seek(self, offset, whence=0):
        """Change position, possibly with respect to start or stop."""
        if whence == 0:
            self._pos = self._start
            whence = 1
        elif whence == 2:
            self._pos = self._stop
            whence = 1
        _ProxyFile.seek(self, offset, whence)

    def _read(self, size, read_method):
        """Read size bytes using read_method, honoring start and stop."""
        remaining = self._stop - self._pos
        if remaining <= 0:
            return ''
        if size is None or size < 0 or size > remaining:
            size = remaining
        return _ProxyFile._read(self, size, read_method)

    def close(self):
        # do *not* close the underlying file object for partial files,
        # since it's global to the mailbox object
        if hasattr(self, '_file'):
            del self._file


def _lock_file(f, dotlock=True):
    """Lock file f using lockf and dot locking."""
    dotlock_done = False
    try:
        if fcntl:
            try:
                fcntl.lockf(f, fcntl.LOCK_EX | fcntl.LOCK_NB)
            except IOError, e:
                if e.errno in (errno.EAGAIN, errno.EACCES, errno.EROFS):
                    raise ExternalClashError('lockf: lock unavailable: %s' %
                                             f.name)
                else:
                    raise
        if dotlock:
            try:
                pre_lock = _create_temporary(f.name + '.lock')
                pre_lock.close()
            except IOError, e:
                if e.errno in (errno.EACCES, errno.EROFS):
                    return  # Without write access, just skip dotlocking.
                else:
                    raise
            try:
                if hasattr(os, 'link'):
                    os.link(pre_lock.name, f.name + '.lock')
                    dotlock_done = True
                    os.unlink(pre_lock.name)
                else:
                    os.rename(pre_lock.name, f.name + '.lock')
                    dotlock_done = True
            except OSError, e:
                if e.errno == errno.EEXIST or \
                  (os.name == 'os2' and e.errno == errno.EACCES):
                    os.remove(pre_lock.name)
                    raise ExternalClashError('dot lock unavailable: %s' %
                                             f.name)
                else:
                    raise
    except:
        if fcntl:
            fcntl.lockf(f, fcntl.LOCK_UN)
        if dotlock_done:
            os.remove(f.name + '.lock')
        raise

def _unlock_file(f):
    """Unlock file f using lockf and dot locking."""
    if fcntl:
        fcntl.lockf(f, fcntl.LOCK_UN)
    if os.path.exists(f.name + '.lock'):
        os.remove(f.name + '.lock')

def _create_carefully(path):
    """Create a file if it doesn't exist and open for reading and writing."""
    fd = os.open(path, os.O_CREAT | os.O_EXCL | os.O_RDWR, 0666)
    try:
        return open(path, 'rb+')
    finally:
        os.close(fd)

def _create_temporary(path):
    """Create a temp file based on path and open for reading and writing."""
    return _create_carefully('%s.%s.%s.%s' % (path, int(time.time()),
                                              socket.gethostname(),
                                              os.getpid()))

def _sync_flush(f):
    """Ensure changes to file f are physically on disk."""
    f.flush()
    if hasattr(os, 'fsync'):
        os.fsync(f.fileno())

def _sync_close(f):
    """Close file f, ensuring all changes are physically on disk."""
    _sync_flush(f)
    f.close()

## Start: classes from the original module (for backward compatibility).

# Note that the Maildir class, whose name is unchanged, itself offers a next()
# method for backward compatibility.

class _Mailbox:

    def __init__(self, fp, factory=rfc822.Message):
        self.fp = fp
        self.seekp = 0
        self.factory = factory

    def __iter__(self):
        return iter(self.next, None)

    def next(self):
        while 1:
            self.fp.seek(self.seekp)
            try:
                self._search_start()
            except EOFError:
                self.seekp = self.fp.tell()
                return None
            start = self.fp.tell()
            self._search_end()
            self.seekp = stop = self.fp.tell()
            if start != stop:
                break
        return self.factory(_PartialFile(self.fp, start, stop))

# Recommended to use PortableUnixMailbox instead!
class UnixMailbox(_Mailbox):

    def _search_start(self):
        while 1:
            pos = self.fp.tell()
            line = self.fp.readline()
            if not line:
                raise EOFError
            if line[:5] == 'From ' and self._isrealfromline(line):
                self.fp.seek(pos)
                return

    def _search_end(self):
        self.fp.readline()      # Throw away header line
        while 1:
            pos = self.fp.tell()
            line = self.fp.readline()
            if not line:
                return
            if line[:5] == 'From ' and self._isrealfromline(line):
                self.fp.seek(pos)
                return

    # An overridable mechanism to test for From-line-ness.  You can either
    # specify a different regular expression or define a whole new
    # _isrealfromline() method.  Note that this only gets called for lines
    # starting with the 5 characters "From ".
    #
    # BAW: According to
    #http://home.netscape.com/eng/mozilla/2.0/relnotes/demo/content-length.html
    # the only portable, reliable way to find message delimiters in a BSD (i.e
    # Unix mailbox) style folder is to search for "\n\nFrom .*\n", or at the
    # beginning of the file, "^From .*\n".  While _fromlinepattern below seems
    # like a good idea, in practice, there are too many variations for more
    # strict parsing of the line to be completely accurate.
    #
    # _strict_isrealfromline() is the old version which tries to do stricter
    # parsing of the From_ line.  _portable_isrealfromline() simply returns
    # true, since it's never called if the line doesn't already start with
    # "From ".
    #
    # This algorithm, and the way it interacts with _search_start() and
    # _search_end() may not be completely correct, because it doesn't check
    # that the two characters preceding "From " are \n\n or the beginning of
    # the file.  Fixing this would require a more extensive rewrite than is
    # necessary.  For convenience, we've added a PortableUnixMailbox class
    # which does no checking of the format of the 'From' line.

    _fromlinepattern = (r"From \s*[^\s]+\s+\w\w\w\s+\w\w\w\s+\d?\d\s+"
                        r"\d?\d:\d\d(:\d\d)?(\s+[^\s]+)?\s+\d\d\d\d\s*"
                        r"[^\s]*\s*"
                        "$")
    _regexp = None

    def _strict_isrealfromline(self, line):
        if not self._regexp:
            import re
            self._regexp = re.compile(self._fromlinepattern)
        return self._regexp.match(line)

    def _portable_isrealfromline(self, line):
        return True

    _isrealfromline = _strict_isrealfromline


class PortableUnixMailbox(UnixMailbox):
    _isrealfromline = UnixMailbox._portable_isrealfromline


class MmdfMailbox(_Mailbox):

    def _search_start(self):
        while 1:
            line = self.fp.readline()
            if not line:
                raise EOFError
            if line[:5] == '\001\001\001\001\n':
                return

    def _search_end(self):
        while 1:
            pos = self.fp.tell()
            line = self.fp.readline()
            if not line:
                return
            if line == '\001\001\001\001\n':
                self.fp.seek(pos)
                return


class MHMailbox:

    def __init__(self, dirname, factory=rfc822.Message):
        import re
        pat = re.compile('^[1-9][0-9]*$')
        self.dirname = dirname
        # the three following lines could be combined into:
        # list = map(long, filter(pat.match, os.listdir(self.dirname)))
        list = os.listdir(self.dirname)
        list = filter(pat.match, list)
        list = map(long, list)
        list.sort()
        # This only works in Python 1.6 or later;
        # before that str() added 'L':
        self.boxes = map(str, list)
        self.boxes.reverse()
        self.factory = factory

    def __iter__(self):
        return iter(self.next, None)

    def next(self):
        if not self.boxes:
            return None
        fn = self.boxes.pop()
        fp = open(os.path.join(self.dirname, fn))
        msg = self.factory(fp)
        try:
            msg._mh_msgno = fn
        except (AttributeError, TypeError):
            pass
        return msg


class BabylMailbox(_Mailbox):

    def _search_start(self):
        while 1:
            line = self.fp.readline()
            if not line:
                raise EOFError
            if line == '*** EOOH ***\n':
                return

    def _search_end(self):
        while 1:
            pos = self.fp.tell()
            line = self.fp.readline()
            if not line:
                return
            if line == '\037\014\n' or line == '\037':
                self.fp.seek(pos)
                return

## End: classes from the original module (for backward compatibility).


class Error(Exception):
    """Raised for module-specific errors."""

class NoSuchMailboxError(Error):
    """The specified mailbox does not exist and won't be created."""

class NotEmptyError(Error):
    """The specified mailbox is not empty and deletion was requested."""

class ExternalClashError(Error):
    """Another process caused an action to fail."""

class FormatError(Error):
    """A file appears to have an invalid format."""

filename:/usr/lib/python2.7/dummy_threading.py
__doc__
"""Faux ``threading`` version using ``dummy_thread`` instead of ``thread``.

filename:/usr/lib/python2.7/sched.py
__doc__
"""A generally useful event scheduler class.

Each instance of this class manages its own queue.
No multi-threading is implied; you are supposed to hack that
yourself, or use a single instance per application.

Each instance is parametrized with two functions, one that is
supposed to return the current time, one that is supposed to
implement a delay.  You can implement real-time scheduling by
substituting time and sleep from built-in module time, or you can
implement simulated time by writing your own functions.  This can
also be used to integrate scheduling with STDWIN events; the delay
function is allowed to modify the queue.  Time can be expressed as
integers or floating point numbers, as long as it is consistent.

Events are specified by tuples (time, priority, action, argument).
As in UNIX, lower priority numbers mean higher priority; in this
way the queue can be maintained as a priority queue.  Execution of the
event means calling the action function, passing it the argument
sequence in "argument" (remember that in Python, multiple function
arguments are be packed in a sequence).
The action function may be an instance method so it
has another way to reference private data (besides global variables).
"""

filename:/usr/lib/python2.7/types.py
__doc__
"""Define names for all type symbols known in the standard interpreter.

Types that are part of optional modules (e.g. array) are not listed.
"""

filename:/usr/lib/python2.7/BaseHTTPServer.py
__doc__
"""HTTP server base class.

Note: the class in this module doesn't implement any HTTP request; see
SimpleHTTPServer for simple implementations of GET, HEAD and POST
(including CGI scripts).  It does, however, optionally implement HTTP/1.1
persistent connections, as of version 0.3.

Contents:

- BaseHTTPRequestHandler: HTTP request handler base class
- test: test function

XXX To do:

- log requests even later (to capture byte count)
- log user-agent header and other interesting goodies
- send error log to separate file
"""

filename:/usr/lib/python2.7/markupbase.py
__doc__
"""Shared support for scanning document type declarations in HTML and XHTML.

This module is used as a foundation for the HTMLParser and sgmllib
modules (indirectly, for htmllib as well).  It has no documented
public API and should not be used directly.

"""

filename:/usr/lib/python2.7/nntplib.py
__doc__
"""An NNTP client class based on RFC 977: Network News Transfer Protocol.

Example:

>>> from nntplib import NNTP
>>> s = NNTP('news')
>>> resp, count, first, last, name = s.group('comp.lang.python')
>>> print 'Group', name, 'has', count, 'articles, range', first, 'to', last
Group comp.lang.python has 51 articles, range 5770 to 5821
>>> resp, subs = s.xhdr('subject', first + '-' + last)
>>> resp = s.quit()
>>>

Here 'resp' is the server response line.
Error responses are turned into exceptions.

To post an article from a file:
>>> f = open(filename, 'r') # file containing article, including header
>>> resp = s.post(f)
>>>

For descriptions of all methods, read the comments in the code below.
Note that all arguments and return values representing article numbers
are strings, not numbers, since they are rarely used for calculations.
"""

filename:/usr/lib/python2.7/imaplib.py
__doc__
"""IMAP4 client.

Based on RFC 2060.

Public class:           IMAP4
Public variable:        Debug
Public functions:       Internaldate2tuple
                        Int2AP
                        ParseFlags
                        Time2Internaldate
"""

filename:/usr/lib/python2.7/urllib.py
__doc__
"""Open an arbitrary URL.

See the following document for more info on URLs:
"Names and Addresses, URIs, URLs, URNs, URCs", at
http://www.w3.org/pub/WWW/Addressing/Overview.html

See also the HTTP spec (from which the error codes are derived):
"HTTP - Hypertext Transfer Protocol", at
http://www.w3.org/pub/WWW/Protocols/

Related standards and specs:
- RFC1808: the "relative URL" spec. (authoritative status)
- RFC1738 - the "URL standard". (authoritative status)
- RFC1630 - the "URI spec". (informational status)

The object returned by URLopener().open(file) will differ per
protocol.  All you know is that is has methods read(), readline(),
readlines(), fileno(), close() and info().  The read*(), fileno()
and close() methods work like those of open files.
The info() method returns a mimetools.Message object which can be
used to query various info about the object, if available.
(mimetools.Message objects are queried with the getheader() method.)
"""

filename:/usr/lib/python2.7/copy_reg.py
__doc__
"""Helper to provide extensibility for pickle/cPickle.

This is only useful to add pickle support for extension types defined in
C, not for instances of user-defined classes.
"""

filename:/usr/lib/python2.7/filecmp.py
__doc__
"""Utilities for comparing files and directories.

Classes:
    dircmp

Functions:
    cmp(f1, f2, shallow=1) -> int
    cmpfiles(a, b, common) -> ([], [], [])

"""

filename:/usr/lib/python2.7/anydbm.py
__doc__
"""Generic interface to all dbm clones.

Instead of

        import dbm
        d = dbm.open(file, 'w', 0666)

use

        import anydbm
        d = anydbm.open(file, 'w')

The returned object is a dbhash, gdbm, dbm or dumbdbm object,
dependent on the type of database being opened (determined by whichdb
module) in the case of an existing dbm. If the dbm does not exist and
the create or new flag ('c' or 'n') was specified, the dbm type will
be determined by the availability of the modules (tested in the above
order).

It has the following interface (key and data are strings):

        d[key] = data   # store data at key (may override data at
                        # existing key)
        data = d[key]   # retrieve data at key (raise KeyError if no
                        # such key)
        del d[key]      # delete data stored at key (raises KeyError
                        # if no such key)
        flag = key in d   # true if the key exists
        list = d.keys() # return a list of all existing keys (slow!)

Future versions may change the order in which implementations are
tested for existence, and add interfaces to other dbm-like
implementations.
"""

filename:/usr/lib/python2.7/Queue.py
__doc__
"""A multi-producer, multi-consumer queue."""

from time import time as _time
try:
    import threading as _threading
except ImportError:
    import dummy_threading as _threading
from collections import deque
import heapq

__all__ = ['Empty', 'Full', 'Queue', 'PriorityQueue', 'LifoQueue']

class Empty(Exception):
    "Exception raised by Queue.get(block=0)/get_nowait()."
    pass

class Full(Exception):
    "Exception raised by Queue.put(block=0)/put_nowait()."
    pass

class Queue:
    """Create a queue object with a given maximum size.

    If maxsize is <= 0, the queue size is infinite.
    """
    def __init__(self, maxsize=0):
        self.maxsize = maxsize
        self._init(maxsize)
        # mutex must be held whenever the queue is mutating.  All methods
        # that acquire mutex must release it before returning.  mutex
        # is shared between the three conditions, so acquiring and
        # releasing the conditions also acquires and releases mutex.
        self.mutex = _threading.Lock()
        # Notify not_empty whenever an item is added to the queue; a
        # thread waiting to get is notified then.
        self.not_empty = _threading.Condition(self.mutex)
        # Notify not_full whenever an item is removed from the queue;
        # a thread waiting to put is notified then.
        self.not_full = _threading.Condition(self.mutex)
        # Notify all_tasks_done whenever the number of unfinished tasks
        # drops to zero; thread waiting to join() is notified to resume
        self.all_tasks_done = _threading.Condition(self.mutex)
        self.unfinished_tasks = 0

    def task_done(self):
        """Indicate that a formerly enqueued task is complete.

        Used by Queue consumer threads.  For each get() used to fetch a task,
        a subsequent call to task_done() tells the queue that the processing
        on the task is complete.

        If a join() is currently blocking, it will resume when all items
        have been processed (meaning that a task_done() call was received
        for every item that had been put() into the queue).

        Raises a ValueError if called more times than there were items
        placed in the queue.
        """
        self.all_tasks_done.acquire()
        try:
            unfinished = self.unfinished_tasks - 1
            if unfinished <= 0:
                if unfinished < 0:
                    raise ValueError('task_done() called too many times')
                self.all_tasks_done.notify_all()
            self.unfinished_tasks = unfinished
        finally:
            self.all_tasks_done.release()

    def join(self):
        """Blocks until all items in the Queue have been gotten and processed.

        The count of unfinished tasks goes up whenever an item is added to the
        queue. The count goes down whenever a consumer thread calls task_done()
        to indicate the item was retrieved and all work on it is complete.

        When the count of unfinished tasks drops to zero, join() unblocks.
        """
        self.all_tasks_done.acquire()
        try:
            while self.unfinished_tasks:
                self.all_tasks_done.wait()
        finally:
            self.all_tasks_done.release()

    def qsize(self):
        """Return the approximate size of the queue (not reliable!)."""
        self.mutex.acquire()
        n = self._qsize()
        self.mutex.release()
        return n

    def empty(self):
        """Return True if the queue is empty, False otherwise (not reliable!)."""
        self.mutex.acquire()
        n = not self._qsize()
        self.mutex.release()
        return n

    def full(self):
        """Return True if the queue is full, False otherwise (not reliable!)."""
        self.mutex.acquire()
        n = 0 < self.maxsize == self._qsize()
        self.mutex.release()
        return n

    def put(self, item, block=True, timeout=None):
        """Put an item into the queue.

        If optional args 'block' is true and 'timeout' is None (the default),
        block if necessary until a free slot is available. If 'timeout' is
        a non-negative number, it blocks at most 'timeout' seconds and raises
        the Full exception if no free slot was available within that time.
        Otherwise ('block' is false), put an item on the queue if a free slot
        is immediately available, else raise the Full exception ('timeout'
        is ignored in that case).
        """
        self.not_full.acquire()
        try:
            if self.maxsize > 0:
                if not block:
                    if self._qsize() == self.maxsize:
                        raise Full
                elif timeout is None:
                    while self._qsize() == self.maxsize:
                        self.not_full.wait()
                elif timeout < 0:
                    raise ValueError("'timeout' must be a non-negative number")
                else:
                    endtime = _time() + timeout
                    while self._qsize() == self.maxsize:
                        remaining = endtime - _time()
                        if remaining <= 0.0:
                            raise Full
                        self.not_full.wait(remaining)
            self._put(item)
            self.unfinished_tasks += 1
            self.not_empty.notify()
        finally:
            self.not_full.release()

    def put_nowait(self, item):
        """Put an item into the queue without blocking.

        Only enqueue the item if a free slot is immediately available.
        Otherwise raise the Full exception.
        """
        return self.put(item, False)

    def get(self, block=True, timeout=None):
        """Remove and return an item from the queue.

        If optional args 'block' is true and 'timeout' is None (the default),
        block if necessary until an item is available. If 'timeout' is
        a non-negative number, it blocks at most 'timeout' seconds and raises
        the Empty exception if no item was available within that time.
        Otherwise ('block' is false), return an item if one is immediately
        available, else raise the Empty exception ('timeout' is ignored
        in that case).
        """
        self.not_empty.acquire()
        try:
            if not block:
                if not self._qsize():
                    raise Empty
            elif timeout is None:
                while not self._qsize():
                    self.not_empty.wait()
            elif timeout < 0:
                raise ValueError("'timeout' must be a non-negative number")
            else:
                endtime = _time() + timeout
                while not self._qsize():
                    remaining = endtime - _time()
                    if remaining <= 0.0:
                        raise Empty
                    self.not_empty.wait(remaining)
            item = self._get()
            self.not_full.notify()
            return item
        finally:
            self.not_empty.release()

    def get_nowait(self):
        """Remove and return an item from the queue without blocking.

        Only get an item if one is immediately available. Otherwise
        raise the Empty exception.
        """
        return self.get(False)

    # Override these methods to implement other queue organizations
    # (e.g. stack or priority queue).
    # These will only be called with appropriate locks held

    # Initialize the queue representation
    def _init(self, maxsize):
        self.queue = deque()

    def _qsize(self, len=len):
        return len(self.queue)

    # Put a new item in the queue
    def _put(self, item):
        self.queue.append(item)

    # Get an item from the queue
    def _get(self):
        return self.queue.popleft()


class PriorityQueue(Queue):
    '''Variant of Queue that retrieves open entries in priority order (lowest first).

    Entries are typically tuples of the form:  (priority number, data).
    '''

    def _init(self, maxsize):
        self.queue = []

    def _qsize(self, len=len):
        return len(self.queue)

    def _put(self, item, heappush=heapq.heappush):
        heappush(self.queue, item)

    def _get(self, heappop=heapq.heappop):
        return heappop(self.queue)


class LifoQueue(Queue):
    '''Variant of Queue that retrieves most recently added entries first.'''

    def _init(self, maxsize):
        self.queue = []

    def _qsize(self, len=len):
        return len(self.queue)

    def _put(self, item):
        self.queue.append(item)

    def _get(self):
        return self.queue.pop()

filename:/usr/lib/python2.7/codeop.py
__doc__
r"""Utilities to compile possibly incomplete Python source code.

This module provides two interfaces, broadly similar to the builtin
function compile(), which take program text, a filename and a 'mode'
and:

- Return code object if the command is complete and valid
- Return None if the command is incomplete
- Raise SyntaxError, ValueError or OverflowError if the command is a
  syntax error (OverflowError and ValueError can be produced by
  malformed literals).

Approach:

First, check if the source consists entirely of blank lines and
comments; if so, replace it with 'pass', because the built-in
parser doesn't always do the right thing for these.

Compile three times: as is, with \n, and with \n\n appended.  If it
compiles as is, it's complete.  If it compiles with one \n appended,
we expect more.  If it doesn't compile either way, we compare the
error we get when compiling with \n or \n\n appended.  If the errors
are the same, the code is broken.  But if the errors are different, we
expect more.  Not intuitive; not even guaranteed to hold in future
releases; but this matches the compiler's behavior from Python 1.4
through 2.2, at least.

Caveat:

It is possible (but not likely) that the parser stops parsing with a
successful outcome before reaching the end of the source; in this
case, trailing symbols may be ignored instead of causing an error.
For example, a backslash followed by two newlines may be followed by
arbitrary garbage.  This will be fixed once the API for the parser is
better.

The two interfaces are:

compile_command(source, filename, symbol):

    Compiles a single command in the manner described above.

CommandCompiler():

    Instances of this class have __call__ methods identical in
    signature to compile_command; the difference is that if the
    instance compiles program text containing a __future__ statement,
    the instance 'remembers' and compiles all subsequent program texts
    with the statement in force.

The module also provides another class:

Compile():

    Instances of this class act like the built-in function compile,
    but with 'memory' in the sense described above.
"""

filename:/usr/lib/python2.7/Bastion.py
__doc__
"""Bastionification utility.

A bastion (for another object -- the 'original') is an object that has
the same methods as the original but does not give access to its
instance variables.  Bastions have a number of uses, but the most
obvious one is to provide code executing in restricted mode with a
safe interface to an object implemented in unrestricted mode.

The bastionification routine has an optional second argument which is
a filter function.  Only those methods for which the filter method
(called with the method name as argument) returns true are accessible.
The default filter method returns true unless the method name begins
with an underscore.

There are a number of possible implementations of bastions.  We use a
'lazy' approach where the bastion's __getattr__() discipline does all
the work for a particular method the first time it is used.  This is
usually fastest, especially if the user doesn't call all available
methods.  The retrieved methods are stored as instance variables of
the bastion, so the overhead is only occurred on the first use of each
method.

Detail: the bastion class has a __repr__() discipline which includes
the repr() of the original object.  This is precomputed when the
bastion is created.

"""

filename:/usr/lib/python2.7/rlcompleter.py
__doc__
"""Word completion for GNU readline.

The completer completes keywords, built-ins and globals in a selectable
namespace (which defaults to __main__); when completing NAME.NAME..., it
evaluates (!) the expression up to the last dot and completes its attributes.

It's very cool to do "import sys" type "sys.", hit the completion key (twice),
and see the list of names defined by the sys module!

Tip: to use the tab key as the completion key, call

    readline.parse_and_bind("tab: complete")

Notes:

- Exceptions raised by the completer function are *ignored* (and generally cause
  the completion to fail).  This is a feature -- since readline sets the tty
  device in raw (or cbreak) mode, printing a traceback wouldn't work well
  without some complicated hoopla to save, reset and restore the tty state.

- The evaluation of the NAME.NAME... form may cause arbitrary application
  defined code to be executed if an object with a __getattr__ hook is found.
  Since it is the responsibility of the application (or the user) to enable this
  feature, I consider this an acceptable risk.  More complicated expressions
  (e.g. function calls or indexing operations) are *not* evaluated.

- GNU readline is also used by the built-in functions input() and
raw_input(), and thus these also benefit/suffer from the completer
features.  Clearly an interactive application can benefit by
specifying its own completer function and using raw_input() for all
its input.

- When the original stdin is not a tty device, GNU readline is never
  used, and this module (and the readline module) are silently inactive.

"""

filename:/usr/lib/python2.7/pipes.py
__doc__
"""Conversion pipeline templates.

The problem:
------------

Suppose you have some data that you want to convert to another format,
such as from GIF image format to PPM image format.  Maybe the
conversion involves several steps (e.g. piping it through compress or
uuencode).  Some of the conversion steps may require that their input
is a disk file, others may be able to read standard input; similar for
their output.  The input to the entire conversion may also be read
from a disk file or from an open file, and similar for its output.

The module lets you construct a pipeline template by sticking one or
more conversion steps together.  It will take care of creating and
removing temporary files if they are necessary to hold intermediate
data.  You can then use the template to do conversions from many
different sources to many different destinations.  The temporary
file names used are different each time the template is used.

The templates are objects so you can create templates for many
different conversion steps and store them in a dictionary, for
instance.


Directions:
-----------

To create a template:
    t = Template()

To add a conversion step to a template:
   t.append(command, kind)
where kind is a string of two characters: the first is '-' if the
command reads its standard input or 'f' if it requires a file; the
second likewise for the output. The command must be valid /bin/sh
syntax.  If input or output files are required, they are passed as
$IN and $OUT; otherwise, it must be  possible to use the command in
a pipeline.

To add a conversion step at the beginning:
   t.prepend(command, kind)

To convert a file to another file using a template:
  sts = t.copy(infile, outfile)
If infile or outfile are the empty string, standard input is read or
standard output is written, respectively.  The return value is the
exit status of the conversion pipeline.

To open a file for reading or writing through a conversion pipeline:
   fp = t.open(file, mode)
where mode is 'r' to read the file, or 'w' to write it -- just like
for the built-in function open() or for os.popen().

To create a new template object initialized to a given one:
   t2 = t.clone()
"""                                     # '

filename:/usr/lib/python2.7/traceback.py
__doc__
"""Extract, format and print information about Python stack traces."""

import linecache
import sys
import types

__all__ = ['extract_stack', 'extract_tb', 'format_exception',
           'format_exception_only', 'format_list', 'format_stack',
           'format_tb', 'print_exc', 'format_exc', 'print_exception',
           'print_last', 'print_stack', 'print_tb', 'tb_lineno']

def _print(file, str='', terminator='\n'):
    file.write(str+terminator)


def print_list(extracted_list, file=None):
    """Print the list of tuples as returned by extract_tb() or
    extract_stack() as a formatted stack trace to the given file."""
    if file is None:
        file = sys.stderr
    for filename, lineno, name, line in extracted_list:
        _print(file,
               '  File "%s", line %d, in %s' % (filename,lineno,name))
        if line:
            _print(file, '    %s' % line.strip())

def format_list(extracted_list):
    """Format a list of traceback entry tuples for printing.

    Given a list of tuples as returned by extract_tb() or
    extract_stack(), return a list of strings ready for printing.
    Each string in the resulting list corresponds to the item with the
    same index in the argument list.  Each string ends in a newline;
    the strings may contain internal newlines as well, for those items
    whose source text line is not None.
    """
    list = []
    for filename, lineno, name, line in extracted_list:
        item = '  File "%s", line %d, in %s\n' % (filename,lineno,name)
        if line:
            item = item + '    %s\n' % line.strip()
        list.append(item)
    return list


def print_tb(tb, limit=None, file=None):
    """Print up to 'limit' stack trace entries from the traceback 'tb'.

    If 'limit' is omitted or None, all entries are printed.  If 'file'
    is omitted or None, the output goes to sys.stderr; otherwise
    'file' should be an open file or file-like object with a write()
    method.
    """
    if file is None:
        file = sys.stderr
    if limit is None:
        if hasattr(sys, 'tracebacklimit'):
            limit = sys.tracebacklimit
    n = 0
    while tb is not None and (limit is None or n < limit):
        f = tb.tb_frame
        lineno = tb.tb_lineno
        co = f.f_code
        filename = co.co_filename
        name = co.co_name
        _print(file,
               '  File "%s", line %d, in %s' % (filename, lineno, name))
        linecache.checkcache(filename)
        line = linecache.getline(filename, lineno, f.f_globals)
        if line: _print(file, '    ' + line.strip())
        tb = tb.tb_next
        n = n+1

def format_tb(tb, limit = None):
    """A shorthand for 'format_list(extract_tb(tb, limit))'."""
    return format_list(extract_tb(tb, limit))

def extract_tb(tb, limit = None):
    """Return list of up to limit pre-processed entries from traceback.

    This is useful for alternate formatting of stack traces.  If
    'limit' is omitted or None, all entries are extracted.  A
    pre-processed stack trace entry is a quadruple (filename, line
    number, function name, text) representing the information that is
    usually printed for a stack trace.  The text is a string with
    leading and trailing whitespace stripped; if the source is not
    available it is None.
    """
    if limit is None:
        if hasattr(sys, 'tracebacklimit'):
            limit = sys.tracebacklimit
    list = []
    n = 0
    while tb is not None and (limit is None or n < limit):
        f = tb.tb_frame
        lineno = tb.tb_lineno
        co = f.f_code
        filename = co.co_filename
        name = co.co_name
        linecache.checkcache(filename)
        line = linecache.getline(filename, lineno, f.f_globals)
        if line: line = line.strip()
        else: line = None
        list.append((filename, lineno, name, line))
        tb = tb.tb_next
        n = n+1
    return list


def print_exception(etype, value, tb, limit=None, file=None):
    """Print exception up to 'limit' stack trace entries from 'tb' to 'file'.

    This differs from print_tb() in the following ways: (1) if
    traceback is not None, it prints a header "Traceback (most recent
    call last):"; (2) it prints the exception type and value after the
    stack trace; (3) if type is SyntaxError and value has the
    appropriate format, it prints the line where the syntax error
    occurred with a caret on the next line indicating the approximate
    position of the error.
    """
    if file is None:
        file = sys.stderr
    if tb:
        _print(file, 'Traceback (most recent call last):')
        print_tb(tb, limit, file)
    lines = format_exception_only(etype, value)
    for line in lines:
        _print(file, line, '')

def format_exception(etype, value, tb, limit = None):
    """Format a stack trace and the exception information.

    The arguments have the same meaning as the corresponding arguments
    to print_exception().  The return value is a list of strings, each
    ending in a newline and some containing internal newlines.  When
    these lines are concatenated and printed, exactly the same text is
    printed as does print_exception().
    """
    if tb:
        list = ['Traceback (most recent call last):\n']
        list = list + format_tb(tb, limit)
    else:
        list = []
    list = list + format_exception_only(etype, value)
    return list

def format_exception_only(etype, value):
    """Format the exception part of a traceback.

    The arguments are the exception type and value such as given by
    sys.last_type and sys.last_value. The return value is a list of
    strings, each ending in a newline.

    Normally, the list contains a single string; however, for
    SyntaxError exceptions, it contains several lines that (when
    printed) display detailed information about where the syntax
    error occurred.

    The message indicating which exception occurred is always the last
    string in the list.

    """

    # An instance should not have a meaningful value parameter, but
    # sometimes does, particularly for string exceptions, such as
    # >>> raise string1, string2  # deprecated
    #
    # Clear these out first because issubtype(string1, SyntaxError)
    # would raise another exception and mask the original problem.
    if (isinstance(etype, BaseException) or
        isinstance(etype, types.InstanceType) or
        etype is None or type(etype) is str):
        return [_format_final_exc_line(etype, value)]

    stype = etype.__name__

    if not issubclass(etype, SyntaxError):
        return [_format_final_exc_line(stype, value)]

    # It was a syntax error; show exactly where the problem was found.
    lines = []
    try:
        msg, (filename, lineno, offset, badline) = value.args
    except Exception:
        pass
    else:
        filename = filename or "<string>"
        lines.append('  File "%s", line %d\n' % (filename, lineno))
        if badline is not None:
            lines.append('    %s\n' % badline.strip())
            if offset is not None:
                caretspace = badline.rstrip('\n')
                offset = min(len(caretspace), offset) - 1
                caretspace = caretspace[:offset].lstrip()
                # non-space whitespace (likes tabs) must be kept for alignment
                caretspace = ((c.isspace() and c or ' ') for c in caretspace)
                lines.append('    %s^\n' % ''.join(caretspace))
        value = msg

    lines.append(_format_final_exc_line(stype, value))
    return lines

def _format_final_exc_line(etype, value):
    """Return a list of a single line -- normal case for format_exception_only"""
    valuestr = _some_str(value)
    if value is None or not valuestr:
        line = "%s\n" % etype
    else:
        line = "%s: %s\n" % (etype, valuestr)
    return line

def _some_str(value):
    try:
        return str(value)
    except Exception:
        pass
    try:
        value = unicode(value)
        return value.encode("ascii", "backslashreplace")
    except Exception:
        pass
    return '<unprintable %s object>' % type(value).__name__


def print_exc(limit=None, file=None):
    """Shorthand for 'print_exception(sys.exc_type, sys.exc_value, sys.exc_traceback, limit, file)'.
    (In fact, it uses sys.exc_info() to retrieve the same information
    in a thread-safe way.)"""
    if file is None:
        file = sys.stderr
    try:
        etype, value, tb = sys.exc_info()
        print_exception(etype, value, tb, limit, file)
    finally:
        etype = value = tb = None


def format_exc(limit=None):
    """Like print_exc() but return a string."""
    try:
        etype, value, tb = sys.exc_info()
        return ''.join(format_exception(etype, value, tb, limit))
    finally:
        etype = value = tb = None


def print_last(limit=None, file=None):
    """This is a shorthand for 'print_exception(sys.last_type,
    sys.last_value, sys.last_traceback, limit, file)'."""
    if not hasattr(sys, "last_type"):
        raise ValueError("no last exception")
    if file is None:
        file = sys.stderr
    print_exception(sys.last_type, sys.last_value, sys.last_traceback,
                    limit, file)


def print_stack(f=None, limit=None, file=None):
    """Print a stack trace from its invocation point.

    The optional 'f' argument can be used to specify an alternate
    stack frame at which to start. The optional 'limit' and 'file'
    arguments have the same meaning as for print_exception().
    """
    if f is None:
        try:
            raise ZeroDivisionError
        except ZeroDivisionError:
            f = sys.exc_info()[2].tb_frame.f_back
    print_list(extract_stack(f, limit), file)

def format_stack(f=None, limit=None):
    """Shorthand for 'format_list(extract_stack(f, limit))'."""
    if f is None:
        try:
            raise ZeroDivisionError
        except ZeroDivisionError:
            f = sys.exc_info()[2].tb_frame.f_back
    return format_list(extract_stack(f, limit))

def extract_stack(f=None, limit = None):
    """Extract the raw traceback from the current stack frame.

    The return value has the same format as for extract_tb().  The
    optional 'f' and 'limit' arguments have the same meaning as for
    print_stack().  Each item in the list is a quadruple (filename,
    line number, function name, text), and the entries are in order
    from oldest to newest stack frame.
    """
    if f is None:
        try:
            raise ZeroDivisionError
        except ZeroDivisionError:
            f = sys.exc_info()[2].tb_frame.f_back
    if limit is None:
        if hasattr(sys, 'tracebacklimit'):
            limit = sys.tracebacklimit
    list = []
    n = 0
    while f is not None and (limit is None or n < limit):
        lineno = f.f_lineno
        co = f.f_code
        filename = co.co_filename
        name = co.co_name
        linecache.checkcache(filename)
        line = linecache.getline(filename, lineno, f.f_globals)
        if line: line = line.strip()
        else: line = None
        list.append((filename, lineno, name, line))
        f = f.f_back
        n = n+1
    list.reverse()
    return list

def tb_lineno(tb):
    """Calculate correct line number of traceback given in tb.

    Obsolete in 2.3.
    """
    return tb.tb_lineno

filename:/usr/lib/python2.7/StringIO.pyc
__doc__
Û
/0Xc           @   s|   d  Z  y d d l m Z Wn e k
 r3 d Z n Xd g Z d Ñ  Z d d
 d Ñ  É  YZ d Ñ  Z e d k rx e É  n  d	 S(   s
  File-like objects that read from or write to a string buffer.

This implements (nearly) all stdio methods.

f = StringIO()      # ready for writing
f = StringIO(buf)   # ready for reading
f.close()           # explicitly release resources held
flag = f.isatty()   # always false
pos = f.tell()      # get current position
f.seek(pos)         # set current position
f.seek(pos, mode)   # mode 0: absolute; 1: relative; 2: relative to EOF
buf = f.read()      # read until EOF
buf = f.read(n)     # read up to n bytes
buf = f.readline()  # read until end of line ('\n') or EOF
list = f.readlines()# list of f.readline() results until EOF
f.truncate([size])  # truncate file at to at most size (default: current pos)
f.write(buf)        # write at current position
f.writelines(list)  # for line in list: f.write(line)
f.getvalue()        # return whole file's contents as a string

Notes:
- Using a real file is often faster (but less convenient).
- There's also a much faster implementation in C, called cStringIO, but
  it's not subclassable.
- fileno() is left unimplemented so that code which uses it triggers
  an exception early.
- Seeking far beyond EOF and then writing will insert real null
  bytes that occupy space in the buffer.
- There's a simple test set (see end of this file).
iˇˇˇˇ(   t   EINVALi   t   StringIOc         C   s   |  r t  d Ç n  d  S(   Ns   I/O operation on closed file(   t
   ValueError(   t   closed(    (    s   /usr/lib/python2.7/StringIO.pyt   _complain_ifclosed&   s    c           B   sß   e  Z d  Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z d	 Ñ  Z	 d
 d Ñ Z
 d d Ñ Z d d Ñ Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sÙ  class StringIO([buffer])

    When a StringIO object is created, it can be initialized to an existing
    string by passing the string to the constructor. If no string is given,
    the StringIO will start empty.

    The StringIO object can accept either Unicode or 8-bit strings, but
    mixing the two may take some care. If both are used, 8-bit strings that
    cannot be interpreted as 7-bit ASCII (that use the 8th bit) will cause
    a UnicodeError to be raised when getvalue() is called.
    t    c         C   s^   t  | t É s t | É } n  | |  _ t | É |  _ g  |  _ d |  _ t |  _ d |  _	 d  S(   Ni    (
   t
   isinstancet
   basestringt   strt   buft   lent   buflistt   post   FalseR   t	   softspace(   t   selfR	   (    (    s   /usr/lib/python2.7/StringIO.pyt   __init__6   s    				c         C   s   |  S(   N(    (   R   (    (    s   /usr/lib/python2.7/StringIO.pyt   __iter__A   s    c         C   s,   t  |  j É |  j É  } | s( t Ç n  | S(   s_  A file object is its own iterator, for example iter(f) returns f
        (unless f is closed). When a file is used as an iterator, typically
        in a for loop (for example, for line in f: print line), the next()
        method is called repeatedly. This method returns the next input line,
        or raises StopIteration when EOF is hit.
        (   R   R   t   readlinet   StopIteration(   R   t   r(    (    s   /usr/lib/python2.7/StringIO.pyt   nextD   s
    	c         C   s%   |  j  s! t |  _  |  ` |  ` n  d S(   s    Free the memory buffer.
        N(   R   t   TrueR	   R   (   R   (    (    s   /usr/lib/python2.7/StringIO.pyt   closeQ   s    		c         C   s   t  |  j É t S(   s_   Returns False because StringIO objects are not connected to a
        tty-like device.
        (   R   R   R   (   R   (    (    s   /usr/lib/python2.7/StringIO.pyt   isattyX   s    i    c         C   sã   t  |  j É |  j r= |  j d j |  j É 7_ g  |  _ n  | d k rY | |  j 7} n | d k ru | |  j 7} n  t d | É |  _ d S(   s  Set the file's current position.

        The mode argument is optional and defaults to 0 (absolute file
        positioning); other values are 1 (seek relative to the current
        position) and 2 (seek relative to the file's end).

        There is no return value.
        R   i   i   i    N(   R   R   R   R	   t   joinR   R
   t   max(   R   R   t   mode(    (    s   /usr/lib/python2.7/StringIO.pyt   seek_   s    		c         C   s   t  |  j É |  j S(   s#   Return the file's current position.(   R   R   R   (   R   (    (    s   /usr/lib/python2.7/StringIO.pyt   tellr   s    iˇˇˇˇc         C   sö   t  |  j É |  j r= |  j d j |  j É 7_ g  |  _ n  | d k sU | d k  ra |  j } n t |  j | |  j É } |  j |  j | !} | |  _ | S(   sE  Read at most size bytes from the file
        (less if the read hits EOF before obtaining size bytes).

        If the size argument is negative or omitted, read all data until EOF
        is reached. The bytes are returned as a string object. An empty
        string is returned when EOF is encountered immediately.
        R   i    N(	   R   R   R   R	   R   t   NoneR
   t   minR   (   R   t   nt   newposR   (    (    s   /usr/lib/python2.7/StringIO.pyt   readw   s    		c         C   s’   t  |  j É |  j r= |  j d j |  j É 7_ g  |  _ n  |  j j d |  j É } | d k  rm |  j } n
 | d } | d k	 rµ | d k rµ |  j | | k  rµ |  j | } qµ n  |  j |  j | !} | |  _ | S(   s%  Read one entire line from the file.

        A trailing newline character is kept in the string (but may be absent
        when a file ends with an incomplete line). If the size argument is
        present and non-negative, it is a maximum byte count (including the
        trailing newline) and an incomplete line may be returned.

        An empty string is returned only when EOF is encountered immediately.

        Note: Unlike stdio's fgets(), the returned string contains null
        characters ('\0') if they occurred in the input.
        R   s   
i    i   N(	   R   R   R   R	   R   t   findR   R
   R   (   R   t   lengtht   iR!   R   (    (    s   /usr/lib/python2.7/StringIO.pyR   ã   s    	
	c         C   sr   d } g  } |  j  É  } xS | rm | j | É | t | É 7} d | k  oU | k n r^ Pn  |  j  É  } q W| S(   s'  Read until EOF using readline() and return a list containing the
        lines thus read.

        If the optional sizehint argument is present, instead of reading up
        to EOF, whole lines totalling approximately sizehint bytes (or more
        to accommodate a final whole line).
        i    (   R   t   appendR
   (   R   t   sizehintt   totalt   linest   line(    (    s   /usr/lib/python2.7/StringIO.pyt	   readlines®   s    	c         C   s~   t  |  j É | d k r% |  j } n9 | d k  rC t t d É Ç n | |  j k  r^ | |  _ n  |  j É  |  |  _ | |  _ d S(   sÑ  Truncate the file's size.

        If the optional size argument is present, the file is truncated to
        (at most) that size. The size defaults to the current position.
        The current file position is not changed unless the position
        is beyond the new file size.

        If the specified size exceeds the file's current size, the
        file remains unchanged.
        i    s   Negative size not allowedN(	   R   R   R   R   t   IOErrorR    t   getvalueR	   R
   (   R   t   size(    (    s   /usr/lib/python2.7/StringIO.pyt   truncateª   s    c         C   s^  t  |  j É | s d St | t É s5 t | É } n  |  j } |  j } | | k rÅ |  j j | É | t | É |  _ |  _ d S| | k rÆ |  j j d | | É | } n  | t | É } | | k  r2|  j rÒ |  j	 d j
 |  j É 7_	 n  |  j	 |  | |  j	 | g |  _ d |  _	 | | k rH| } qHn |  j j | É | } | |  _ | |  _ d S(   sG   Write a string to the file.

        There is no return value.
        Nt    R   (   R   R   R   R   R   R   R
   R   R&   R	   R   (   R   t   st   spost   slenR!   (    (    s   /usr/lib/python2.7/StringIO.pyt   write–   s4     				 		c         C   s(   |  j  } x | D] } | | É q Wd S(   s  Write a sequence of strings to the file. The sequence can be any
        iterable object producing strings, typically a list of strings. There
        is no return value.

        (The name is intended to match readlines(); writelines() does not add
        line separators.)
        N(   R4   (   R   t   iterableR4   R*   (    (    s   /usr/lib/python2.7/StringIO.pyt
   writelinesÒ   s    	c         C   s   t  |  j É d S(   s"   Flush the internal buffer
        N(   R   R   (   R   (    (    s   /usr/lib/python2.7/StringIO.pyt   flush˝   s    c         C   sD   t  |  j É |  j r= |  j d j |  j É 7_ g  |  _ n  |  j S(   s∫  
        Retrieve the entire contents of the "file" at any time before
        the StringIO object's close() method is called.

        The StringIO object can accept either Unicode or 8-bit strings,
        but mixing the two may take some care. If both are used, 8-bit
        strings that cannot be interpreted as 7-bit ASCII (that use the
        8th bit) will cause a UnicodeError to be raised when getvalue()
        is called.
        R   (   R   R   R   R	   R   (   R   (    (    s   /usr/lib/python2.7/StringIO.pyR-     s
    	N(   t   __name__t
   __module__t   __doc__R   R   R   R   R   R   R   R"   R   R   R+   R/   R4   R6   R7   R-   (    (    (    s   /usr/lib/python2.7/StringIO.pyR   *   s    						!		c    	      C   sç  d d  l  }  |  j d r) |  j d } n d } t | d É j É  } t | d É j É  } t É  } x | d  D] } | j | É qm W| j | d É | j É  | k r≥ t	 d Ç n  | j
 É  } d G| GH| j t | d É É | j | d É | j d É d	 Gt | j É  É GHd
 G| j
 É  GH| j É  } d Gt | É GH| j t | É d É | j t | É É } | | k rÄt	 d Ç n  | j t | É d É | j É  } | d } | j | j
 É  t | É É | j É  } | | k rÌt	 d Ç n  d Gt | É Gd GHd G| j
 É  GH| j
 É  | k r-t	 d Ç n  | j | d É | j d d É d G| j
 É  GH| j
 É  | d k rt	 d Ç n  | j É  d  S(   Niˇˇˇˇi   s   /etc/passwdR   i˛ˇˇˇs   write faileds   File length =i    s   First line =s
   Position =s   Second line =s   bad result after seek backs#   bad result after seek back from EOFt   Reads
   more liness
   bad lengthi   s   Truncated length =s   truncate did not adjust length(   t   syst   argvt   openR+   R"   R   R4   R6   R-   t   RuntimeErrorR   R   R
   t   reprR   R/   R   (	   R<   t   fileR)   t   textt   fR*   R$   t   line2t   list(    (    s   /usr/lib/python2.7/StringIO.pyt   test  sT    		
t   __main__N(    (	   R:   t   errnoR    t   ImportErrort   __all__R   R   RF   R8   (    (    (    s   /usr/lib/python2.7/StringIO.pyt   <module>   s   
		Ï	-
filename:/usr/lib/python2.7/optparse.pyc
__doc__
Û
/0Xc           @   s¿  d  Z  d Z d d d d d d d d	 d
 d d d d d d d g Z d Z d d l Z d d l Z d d l Z d d l Z d Ñ  Z y d d l	 m	 Z	 Wn e
 k
 r± d Ñ  Z	 n Xe	 Z d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d
 f  d Ñ  É  YZ d e f d  Ñ  É  YZ d e f d! Ñ  É  YZ d" Ñ  Z d# Ñ  Z d$ Ñ  Z i e e d% É f d& 6e e d' É f d( 6e e d) É f d* 6e e d+ É f d+ 6Z d, Ñ  Z d- Ñ  Z d. d/ f Z d f  d0 Ñ  É  YZ d1 d2 Z  d1 d3 Z! y e" Wn e# k
 rQd4 Ñ  Z$ n
 Xd5 Ñ  Z$ d f  d6 Ñ  É  YZ% d f  d7 Ñ  É  YZ& d e& f d8 Ñ  É  YZ' d	 e& f d9 Ñ  É  YZ( d: Ñ  Z) e Z* d S(;   sß  A powerful, extensible, and easy-to-use option parser.

By Greg Ward <gward@python.net>

Originally distributed as Optik.

For support, use the optik-users@lists.sourceforge.net mailing list
(http://lists.sourceforge.net/lists/listinfo/optik-users).

Simple usage example:

   from optparse import OptionParser

   parser = OptionParser()
   parser.add_option("-f", "--file", dest="filename",
                     help="write report to FILE", metavar="FILE")
   parser.add_option("-q", "--quiet",
                     action="store_false", dest="verbose", default=True,
                     help="don't print status messages to stdout")

   (options, args) = parser.parse_args()
s   1.5.3t   Optiont   make_optiont   SUPPRESS_HELPt   SUPPRESS_USAGEt   Valuest   OptionContainert   OptionGroupt   OptionParsert   HelpFormattert   IndentedHelpFormattert   TitledHelpFormattert   OptParseErrort   OptionErrort   OptionConflictErrort   OptionValueErrort   BadOptionErrors"  
Copyright (c) 2001-2006 Gregory P. Ward.  All rights reserved.
Copyright (c) 2002-2006 Python Software Foundation.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

  * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

  * Neither the name of the author nor the names of its
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
iˇˇˇˇNc         C   s   d |  j  j t |  É |  f S(   Ns   <%s at 0x%x: %s>(   t	   __class__t   __name__t   id(   t   self(    (    s   /usr/lib/python2.7/optparse.pyt   _reprO   s    (   t   gettextc         C   s   |  S(   N(    (   t   message(    (    s   /usr/lib/python2.7/optparse.pyR   \   s    c           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c         C   s   | |  _  d  S(   N(   t   msg(   R   R   (    (    s   /usr/lib/python2.7/optparse.pyt   __init__b   s    c         C   s   |  j  S(   N(   R   (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   __str__e   s    (   R   t
   __module__R   R   (    (    (    s   /usr/lib/python2.7/optparse.pyR   a   s   	c           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   s]   
    Raised if an Option instance is created with invalid or
    inconsistent arguments.
    c         C   s   | |  _  t | É |  _ d  S(   N(   R   t   strt	   option_id(   R   R   t   option(    (    s   /usr/lib/python2.7/optparse.pyR   o   s    	c         C   s(   |  j  r d |  j  |  j f S|  j Sd  S(   Ns   option %s: %s(   R   R   (   R   (    (    s   /usr/lib/python2.7/optparse.pyR   s   s    	(   R   R   t   __doc__R   R   (    (    (    s   /usr/lib/python2.7/optparse.pyR   i   s   	c           B   s   e  Z d  Z RS(   sE   
    Raised if conflicting options are added to an OptionParser.
    (   R   R   R   (    (    (    s   /usr/lib/python2.7/optparse.pyR   y   s   c           B   s   e  Z d  Z RS(   sS   
    Raised if an invalid option value is encountered on the command
    line.
    (   R   R   R   (    (    (    s   /usr/lib/python2.7/optparse.pyR   ~   s   c           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   sB   
    Raised if an invalid option is seen on the command line.
    c         C   s   | |  _  d  S(   N(   t   opt_str(   R   R   (    (    s   /usr/lib/python2.7/optparse.pyR   à   s    c         C   s   t  d É |  j S(   Ns   no such option: %s(   t   _R   (   R   (    (    s   /usr/lib/python2.7/optparse.pyR   ã   s    (   R   R   R   R   R   (    (    (    s   /usr/lib/python2.7/optparse.pyR   Ñ   s   	t   AmbiguousOptionErrorc           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   sD   
    Raised if an ambiguous option is seen on the command line.
    c         C   s   t  j |  | É | |  _ d  S(   N(   R   R   t   possibilities(   R   R   R"   (    (    s   /usr/lib/python2.7/optparse.pyR   í   s    c         C   s#   t  d É |  j d j |  j É f S(   Ns   ambiguous option: %s (%s?)s   , (   R    R   t   joinR"   (   R   (    (    s   /usr/lib/python2.7/optparse.pyR   ñ   s    	(   R   R   R   R   R   (    (    (    s   /usr/lib/python2.7/optparse.pyR!   é   s   	c           B   sõ   e  Z d  Z d Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sÕ  
    Abstract base class for formatting option help.  OptionParser
    instances should use one of the HelpFormatter subclasses for
    formatting help; by default IndentedHelpFormatter is used.

    Instance attributes:
      parser : OptionParser
        the controlling OptionParser instance
      indent_increment : int
        the number of columns to indent per nesting level
      max_help_position : int
        the maximum starting column for option help text
      help_position : int
        the calculated starting column for option help text;
        initially the same as the maximum
      width : int
        total number of columns for output (pass None to constructor for
        this value to be taken from the $COLUMNS environment variable)
      level : int
        current indentation level
      current_indent : int
        current indentation level (in columns)
      help_width : int
        number of columns available for option help text (calculated)
      default_tag : str
        text to replace with each option's default value, "%default"
        by default.  Set to false value to disable default value expansion.
      option_strings : { Option : str }
        maps Option instances to the snippet of help text explaining
        the syntax of that option, e.g. "-h, --help" or
        "-fFILE, --file=FILE"
      _short_opt_fmt : str
        format string controlling how short options with values are
        printed in help text.  Must be either "%s%s" ("-fFILE") or
        "%s %s" ("-f FILE"), because those are the two syntaxes that
        Optik supports.
      _long_opt_fmt : str
        similar but for long options; must be either "%s %s" ("--file FILE")
        or "%s=%s" ("--file=FILE").
    t   nonec         C   s·   d  |  _ | |  _ | d  k rb y t t j d É } Wn t t f k
 rT d } n X| d 8} n  | |  _ t	 | t
 | d | d É É |  _ |  _ d |  _ d |  _ d  |  _ | |  _ d |  _ i  |  _ d |  _ d |  _ d  S(	   Nt   COLUMNSiP   i   i   i    s   %defaults   %s %ss   %s=%s(   t   Nonet   parsert   indent_incrementt   intt   ost   environt   KeyErrort
   ValueErrort   widtht   mint   maxt   help_positiont   max_help_positiont   current_indentt   levelt
   help_widtht   short_firstt   default_tagt   option_stringst   _short_opt_fmtt   _long_opt_fmt(   R   R(   R2   R.   R6   (    (    s   /usr/lib/python2.7/optparse.pyR   »   s$    		
	*							c         C   s   | |  _  d  S(   N(   R'   (   R   R'   (    (    s   /usr/lib/python2.7/optparse.pyt
   set_parser·   s    c         C   s4   | d k r t  d | É Ç n  d | d |  _ d  S(   Nt    t    s/   invalid metavar delimiter for short options: %rs   %s(   R<   R=   (   R-   R9   (   R   t   delim(    (    s   /usr/lib/python2.7/optparse.pyt   set_short_opt_delimiter‰   s    c         C   s4   | d k r t  d | É Ç n  d | d |  _ d  S(   Nt   =R=   s.   invalid metavar delimiter for long options: %rs   %s(   R@   R=   (   R-   R:   (   R   R>   (    (    s   /usr/lib/python2.7/optparse.pyt   set_long_opt_delimiterÍ   s    c         C   s%   |  j  |  j 7_  |  j d 7_ d  S(   Ni   (   R3   R(   R4   (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   indent   s    c         C   s@   |  j  |  j 8_  |  j  d k s- t d É Ç |  j d 8_ d  S(   Ni    s   Indent decreased below 0.i   (   R3   R(   t   AssertionErrorR4   (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   dedentÙ   s    c         C   s   t  d Ç d  S(   Ns   subclasses must implement(   t   NotImplementedError(   R   t   usage(    (    s   /usr/lib/python2.7/optparse.pyt   format_usage˘   s    c         C   s   t  d Ç d  S(   Ns   subclasses must implement(   RE   (   R   t   heading(    (    s   /usr/lib/python2.7/optparse.pyt   format_heading¸   s    c         C   sB   t  |  j |  j d É } d |  j } t j | | d | d | ÉS(   sÅ   
        Format a paragraph of free-form text for inclusion in the
        help output at the current indentation level.
        i   R=   t   initial_indentt   subsequent_indent(   R0   R.   R3   t   textwrapt   fill(   R   t   textt
   text_widthRB   (    (    s   /usr/lib/python2.7/optparse.pyt   _format_textˇ   s    	c         C   s   | r |  j  | É d Sd Sd  S(   Ns   
R<   (   RP   (   R   t   description(    (    s   /usr/lib/python2.7/optparse.pyt   format_description  s    c         C   s#   | r d |  j  | É d Sd Sd  S(   Ns   
R<   (   RP   (   R   t   epilog(    (    s   /usr/lib/python2.7/optparse.pyt   format_epilog  s    c         C   sx   |  j  d  k s |  j r  | j S|  j  j j | j É } | t k sP | d  k r\ |  j } n  | j j	 |  j t
 | É É S(   N(   R'   R&   R7   t   helpt   defaultst   gett   destt
   NO_DEFAULTt   NO_DEFAULT_VALUEt   replaceR   (   R   R   t   default_value(    (    s   /usr/lib/python2.7/optparse.pyt   expand_default  s    c   	      C   s6  g  } |  j  | } |  j |  j d } t | É | k r[ d |  j d | f } |  j } n d |  j d | | f } d } | j | É | j r	|  j | É } t j | |  j	 É } | j d | d | d f É | j
 g  | d D] } d |  j d | f ^ q„ É n  | d d k r)| j d É n  d j | É S(	   Ni   s   %*s%s
R<   s	   %*s%-*s  i    i   iˇˇˇˇs   
(   R8   R1   R3   t   lent   appendRU   R]   RL   t   wrapR5   t   extendR#   (	   R   R   t   resultt   optst	   opt_widtht   indent_firstt	   help_textt
   help_linest   line(    (    s   /usr/lib/python2.7/optparse.pyt   format_option"  s$    		.c         C   s  |  j  É  d } xI | j D]> } |  j | É } | |  j | <t | t | É |  j É } q W|  j  É  x] | j D]R } xI | j D]> } |  j | É } | |  j | <t | t | É |  j É } qÄ Wqp W|  j É  |  j É  t	 | d |  j
 É |  _ t |  j |  j d É |  _ d  S(   Ni    i   i   (   RB   t   option_listt   format_option_stringsR8   R0   R^   R3   t   option_groupsRD   R/   R2   R1   R.   R5   (   R   R'   t   max_lent   optt   stringst   group(    (    s   /usr/lib/python2.7/optparse.pyt   store_option_stringsE  s     
 
$

c         C   s∏   | j  É  ry | j p! | j j É  } g  | j D] } |  j | | f ^ q. } g  | j D] } |  j | | f ^ qW } n | j } | j } |  j r° | | } n
 | | } d j	 | É S(   s@   Return a comma-separated list of option strings & metavariables.s   , (
   t   takes_valuet   metavarRX   t   uppert   _short_optsR9   t
   _long_optsR:   R6   R#   (   R   R   Rs   t   soptt
   short_optst   loptt	   long_optsRc   (    (    s   /usr/lib/python2.7/optparse.pyRk   W  s    &)			
(   R   R   R   RZ   R   R;   R?   RA   RB   RD   RG   RI   RP   RR   RT   R]   Ri   Rq   Rk   (    (    (    s   /usr/lib/python2.7/optparse.pyR   õ   s"   )												
	#	c           B   s5   e  Z d  Z d d d d d Ñ Z d Ñ  Z d Ñ  Z RS(   s.   Format help with indented section bodies.
    i   i   i   c         C   s   t  j |  | | | | É d  S(   N(   R   R   (   R   R(   R2   R.   R6   (    (    s   /usr/lib/python2.7/optparse.pyR   n  s    c         C   s   t  d É | S(   Ns
   Usage: %s
(   R    (   R   RF   (    (    s   /usr/lib/python2.7/optparse.pyRG   v  s    c         C   s   d |  j  d | f S(   Ns   %*s%s:
R<   (   R3   (   R   RH   (    (    s   /usr/lib/python2.7/optparse.pyRI   y  s    N(   R   R   R   R&   R   RG   RI   (    (    (    s   /usr/lib/python2.7/optparse.pyR	   j  s   	c           B   s5   e  Z d  Z d d d d d Ñ Z d Ñ  Z d Ñ  Z RS(   s1   Format help with underlined section headers.
    i    i   c         C   s   t  j |  | | | | É d  S(   N(   R   R   (   R   R(   R2   R.   R6   (    (    s   /usr/lib/python2.7/optparse.pyR   Å  s    c         C   s   d |  j  t d É É | f S(   Ns   %s  %s
t   Usage(   RI   R    (   R   RF   (    (    s   /usr/lib/python2.7/optparse.pyRG   â  s    c         C   s   d | d |  j  t | É f S(   Ns   %s
%s
s   =-(   R4   R^   (   R   RH   (    (    s   /usr/lib/python2.7/optparse.pyRI   å  s    N(   R   R   R   R&   R   RG   RI   (    (    (    s   /usr/lib/python2.7/optparse.pyR
   }  s   	c         C   sz   |  d  j  É  d k r d } nN |  d  j  É  d k rN d } |  d pH d }  n |  d  d k rg d } n d } | |  | É S(	   Ni   t   0xi   t   0bt   0i   i   i
   (   t   lower(   t   valt   typet   radix(    (    s   /usr/lib/python2.7/optparse.pyt
   _parse_numê  s    		c         C   s   t  |  t É S(   N(   RÉ   R)   (   RÄ   (    (    s   /usr/lib/python2.7/optparse.pyt
   _parse_intù  s    c         C   s   t  |  t É S(   N(   RÉ   t   long(   RÄ   (    (    s   /usr/lib/python2.7/optparse.pyt   _parse_long†  s    t   integerR)   s   long integerRÖ   s   floating-pointt   floatt   complexc         C   sX   t  |  j \ } } y | | É SWn0 t k
 rS t t d É | | | f É Ç n Xd  S(   Ns   option %s: invalid %s value: %r(   t   _builtin_cvtRÅ   R-   R   R    (   R   Rn   t   valuet   cvtt   what(    (    s   /usr/lib/python2.7/optparse.pyt   check_builtin®  s    c         C   sQ   | |  j  k r | Sd j t t |  j  É É } t t d É | | | f É Ç d  S(   Ns   , s.   option %s: invalid choice: %r (choose from %s)(   t   choicesR#   t   mapt   reprR   R    (   R   Rn   Rã   Rè   (    (    s   /usr/lib/python2.7/optparse.pyt   check_choice∞  s    	t   NOt   DEFAULTc           B   sN  e  Z d  Z d d d d d d d d d	 d
 d d g Z d- Z d. Z d/ Z d0 Z d1 Z d2 Z	 i e
 d 6e
 d 6e
 d 6e
 d 6e d 6Z d3 Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d  Ñ  Z d! Ñ  Z d" Ñ  Z d# Ñ  Z d$ Ñ  Z d% Ñ  Z e e e e e e e g Z d& Ñ  Z e Z d' Ñ  Z d( Ñ  Z d) Ñ  Z d* Ñ  Z  d+ Ñ  Z! d, Ñ  Z" RS(4   sr  
    Instance attributes:
      _short_opts : [string]
      _long_opts : [string]

      action : string
      type : string
      dest : string
      default : any
      nargs : int
      const : any
      choices : [string]
      callback : function
      callback_args : (any*)
      callback_kwargs : { string : any }
      help : string
      metavar : string
    t   actionRÅ   RX   t   defaultt   nargst   constRè   t   callbackt   callback_argst   callback_kwargsRU   Rs   t   storet   store_constt
   store_truet   store_falseR_   t   append_constt   countt   versiont   stringR)   RÖ   Rà   Râ   t   choicec         O   s]   g  |  _  g  |  _ |  j | É } |  j | É |  j | É x |  j D] } | |  É qE Wd  S(   N(   Ru   Rv   t   _check_opt_stringst   _set_opt_stringst
   _set_attrst   CHECK_METHODS(   R   Rc   t   attrst   checker(    (    s   /usr/lib/python2.7/optparse.pyR   1  s    		c         C   s(   t  d  | É } | s$ t d É Ç n  | S(   Ns+   at least one option string must be supplied(   t   filterR&   t	   TypeError(   R   Rc   (    (    s   /usr/lib/python2.7/optparse.pyR•   D  s    c         C   s·   x⁄ | D]“ } t  | É d k  r5 t d | |  É Ç q t  | É d k rê | d d k od | d d k s} t d | |  É Ç n  |  j j | É q | d d !d k o∞ | d d k s… t d | |  É Ç n  |  j j | É q Wd  S(	   Ni   s>   invalid option string %r: must be at least two characters longi    t   -i   sM   invalid short option string %r: must be of the form -x, (x any non-dash char)s   --sG   invalid long option string %r: must start with --, followed by non-dash(   R^   R   Ru   R_   Rv   (   R   Rc   Rn   (    (    s   /usr/lib/python2.7/optparse.pyR¶   M  s$     #c         C   s¨   xj |  j  D]_ } | | k r: t |  | | | É | | =q
 | d k rY t |  | t É q
 t |  | d  É q
 W| r® | j É  } | j É  t d d j | É |  É Ç n  d  S(   NRñ   s   invalid keyword arguments: %ss   , (   t   ATTRSt   setattrRY   R&   t   keyst   sortR   R#   (   R   R©   t   attr(    (    s   /usr/lib/python2.7/optparse.pyRß   b  s    

c         C   sJ   |  j  d  k r d |  _  n+ |  j  |  j k rF t d |  j  |  É Ç n  d  S(   NRú   s   invalid action: %r(   Rï   R&   t   ACTIONSR   (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   _check_actionv  s    c         C   s)  |  j  d  k rK |  j |  j k r%|  j d  k	 r< d |  _  qH d |  _  q%n⁄ d d  l } t  |  j  É t j k s¢ t |  j  d É r¥ t	 | |  j  j
 d  É |  j  k r¥ |  j  j
 |  _  n  |  j  d k rœ d |  _  n  |  j  |  j k r˙ t d |  j  |  É Ç n  |  j |  j k r%t d |  j |  É Ç n  d  S(   NR§   R£   iˇˇˇˇR   R   s   invalid option type: %rs$   must not supply a type for action %r(   RÅ   R&   Rï   t   ALWAYS_TYPED_ACTIONSRè   t   __builtin__t   typest   TypeTypet   hasattrt   getattrR   t   TYPESR   t   TYPED_ACTIONS(   R   R∂   (    (    s   /usr/lib/python2.7/optparse.pyt   _check_type|  s"    !c         C   s≤   |  j  d k rÜ |  j d  k r0 t d |  É Ç qÆ t  |  j É t j t j f k rÆ t d t t  |  j É É j d É d |  É Ç qÆ n( |  j d  k	 rÆ t d |  j  |  É Ç n  d  S(   NR§   s/   must supply a list of choices for type 'choice's1   choices must be a list of strings ('%s' supplied)t   'i   s#   must not supply choices for type %r(	   RÅ   Rè   R&   R   R∑   t	   TupleTypet   ListTypeR   t   split(   R   (    (    s   /usr/lib/python2.7/optparse.pyt   _check_choiceö  s    !/c         C   s}   |  j  |  j k p |  j d  k	 } |  j d  k ry | ry |  j rb |  j d d j d d É |  _ qy |  j d d |  _ n  d  S(   Ni    i   R≠   R    i   (   Rï   t   STORE_ACTIONSRÅ   R&   RX   Rv   R[   Ru   (   R   Rr   (    (    s   /usr/lib/python2.7/optparse.pyt   _check_destß  s    	#c         C   s>   |  j  |  j k r: |  j d  k	 r: t d |  j  |  É Ç n  d  S(   Ns*   'const' must not be supplied for action %r(   Rï   t   CONST_ACTIONSRò   R&   R   (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   _check_const∂  s    !
c         C   s\   |  j  |  j k r0 |  j d  k rX d |  _ qX n( |  j d  k	 rX t d |  j  |  É Ç n  d  S(   Ni   s*   'nargs' must not be supplied for action %r(   Rï   Rº   Ró   R&   R   (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   _check_nargsº  s    
c         C   s+  |  j  d k rΩ t |  j d É s: t d |  j |  É Ç n  |  j d  k	 rz t |  j É t j k	 rz t d |  j |  É Ç n  |  j	 d  k	 r't |  j	 É t j
 k	 r't d |  j	 |  É Ç q'nj |  j d  k	 rÂ t d |  j |  É Ç n  |  j d  k	 rt d |  É Ç n  |  j	 d  k	 r't d |  É Ç n  d  S(	   NRô   t   __call__s   callback not callable: %rs3   callback_args, if supplied, must be a tuple: not %rs4   callback_kwargs, if supplied, must be a dict: not %rs.   callback supplied (%r) for non-callback options.   callback_args supplied for non-callback options0   callback_kwargs supplied for non-callback option(   Rï   Rπ   Rô   R   Rö   R&   RÅ   R∑   Rø   Rõ   t   DictType(   R   (    (    s   /usr/lib/python2.7/optparse.pyt   _check_callback≈  s0    c         C   s   d j  |  j |  j É S(   Nt   /(   R#   Ru   Rv   (   R   (    (    s   /usr/lib/python2.7/optparse.pyR   Ï  s    c         C   s   |  j  d  k	 S(   N(   RÅ   R&   (   R   (    (    s   /usr/lib/python2.7/optparse.pyRr   Ò  s    c         C   s#   |  j  r |  j  d S|  j d Sd  S(   Ni    (   Rv   Ru   (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   get_opt_stringÙ  s    	c         C   s9   |  j  j |  j É } | d  k r% | S| |  | | É Sd  S(   N(   t   TYPE_CHECKERRW   RÅ   R&   (   R   Rn   Rã   R™   (    (    s   /usr/lib/python2.7/optparse.pyt   check_value˝  s    c         C   s[   | d  k	 rW |  j d k r+ |  j | | É St g  | D] } |  j | | É ^ q5 É Sn  d  S(   Ni   (   R&   Ró   RŒ   t   tuple(   R   Rn   Rã   t   v(    (    s   /usr/lib/python2.7/optparse.pyt   convert_value  s    c         C   s4   |  j  | | É } |  j |  j |  j | | | | É S(   N(   R—   t   take_actionRï   RX   (   R   Rn   Rã   t   valuesR'   (    (    s   /usr/lib/python2.7/optparse.pyt   process  s    c   	      C   sß  | d k r t  | | | É nÑ| d k rA t  | | |  j É nb| d k r` t  | | t É nC| d k r t  | | t É n$| d k rß | j | g  É j | É n¸ | d k r“ | j | g  É j |  j É n— | d k rt  | | | j | d É d	 É n¢ | d
 k rJ|  j pd } |  j p(i  } |  j |  | | | | | é nY | d k rm| j	 É  | j
 É  n6 | d k rê| j É  | j
 É  n t d |  j É Ç d	 S(   NRú   Rù   Rû   Rü   R_   R†   R°   i    i   Rô   RU   R¢   s   unknown action %r(    (   RØ   Rò   t   Truet   Falset   ensure_valueR_   Rö   Rõ   Rô   t
   print_helpt   exitt   print_versionR-   Rï   (	   R   Rï   RX   Rn   Rã   R”   R'   t   argst   kwargs(    (    s   /usr/lib/python2.7/optparse.pyR“     s4    #

(
   s   stores   store_consts
   store_trues   store_falses   appends   append_consts   counts   callbacks   helps   version(   s   stores   store_consts
   store_trues   store_falses   appends   append_consts   count(   s   stores   appends   callback(   s   stores   append(   s   store_consts   append_const(   s   strings   ints   longs   floats   complexs   choiceN(#   R   R   R   RÆ   R≥   R√   Rº   Rµ   R≈   Rª   Ré   Rí   RÕ   R&   R®   R   R•   R¶   Rß   R¥   RΩ   R¬   Rƒ   R∆   R«   R    R   R   t   __repr__Rr   RÃ   RŒ   R—   R‘   R“   (    (    (    s   /usr/lib/python2.7/optparse.pyR    æ  så   	                   

																					t   SUPPRESSt   HELPt   USAGEc         C   s   t  |  t j t j f É S(   N(   t
   isinstanceR∑   t
   StringTypet   UnicodeType(   t   x(    (    s   /usr/lib/python2.7/optparse.pyt   isbasestring>  s    c         C   s   t  |  t É S(   N(   R·   t
   basestring(   R‰   (    (    s   /usr/lib/python2.7/optparse.pyRÂ   A  s    c           B   sh   e  Z d
 d  Ñ Z d Ñ  Z e Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d d Ñ Z d d Ñ Z d	 Ñ  Z RS(   c         C   s:   | r6 x- | j  É  D] \ } } t |  | | É q Wn  d  S(   N(   t   itemsRØ   (   R   RV   R≤   RÄ   (    (    s   /usr/lib/python2.7/optparse.pyR   F  s    c         C   s   t  |  j É S(   N(   R   t   __dict__(   R   (    (    s   /usr/lib/python2.7/optparse.pyR   K  s    c         C   sL   t  | t É r" t |  j | j É St  | t j É rD t |  j | É Sd Sd  S(   Niˇˇˇˇ(   R·   R   t   cmpRË   R∑   R…   (   R   t   other(    (    s   /usr/lib/python2.7/optparse.pyt   __cmp__P  s
    c         C   sS   xL t  |  É D]> } | | k r | | } | d k	 rK t |  | | É qK q q Wd S(   s˚   
        Update the option values from an arbitrary dictionary, but only
        use keys from dict that already have a corresponding attribute
        in self.  Any keys in dict without a corresponding attribute
        are silently ignored.
        N(   t   dirR&   RØ   (   R   t   dictR≤   t   dval(    (    s   /usr/lib/python2.7/optparse.pyt   _update_carefulX  s
    
c         C   s   |  j  j | É d S(   s≈   
        Update the option values from an arbitrary dictionary,
        using all keys from the dictionary regardless of whether
        they have a corresponding attribute in self or not.
        N(   RË   t   update(   R   RÌ   (    (    s   /usr/lib/python2.7/optparse.pyt   _update_loosee  s    c         C   sI   | d k r |  j  | É n) | d k r8 |  j | É n t d | Ç d  S(   Nt   carefult   looses   invalid update mode: %r(   RÔ   RÒ   R-   (   R   RÌ   t   mode(    (    s   /usr/lib/python2.7/optparse.pyt   _updatem  s
    RÚ   c         C   s1   t  | É t j | } |  j t | É | É d  S(   N(   t
   __import__t   syst   modulesRı   t   vars(   R   t   modnameRÙ   t   mod(    (    s   /usr/lib/python2.7/optparse.pyt   read_moduleu  s    
c         C   s'   i  } t  | | É |  j | | É d  S(   N(   t   execfileRı   (   R   t   filenameRÙ   R˘   (    (    s   /usr/lib/python2.7/optparse.pyt	   read_filez  s    c         C   sE   t  |  | É s% t |  | É d  k r8 t |  | | É n  t |  | É S(   N(   Rπ   R∫   R&   RØ   (   R   R≤   Rã   (    (    s   /usr/lib/python2.7/optparse.pyR◊     s    %N(   R   R   R&   R   R   R   R›   RÎ   RÔ   RÒ   Rı   R¸   Rˇ   R◊   (    (    (    s   /usr/lib/python2.7/optparse.pyR   D  s   					c           B   sû   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sí  
    Abstract base class.

    Class attributes:
      standard_option_list : [Option]
        list of standard options that will be accepted by all instances
        of this parser class (intended to be overridden by subclasses).

    Instance attributes:
      option_list : [Option]
        the list of Option objects contained by this OptionContainer
      _short_opt : { string : Option }
        dictionary mapping short option strings, eg. "-f" or "-X",
        to the Option instances that implement them.  If an Option
        has multiple short option strings, it will appear in this
        dictionary multiple times. [1]
      _long_opt : { string : Option }
        dictionary mapping long option strings, eg. "--file" or
        "--exclude", to the Option instances that implement them.
        Again, a given Option can occur multiple times in this
        dictionary. [1]
      defaults : { string : any }
        dictionary mapping option destination names to default
        values for each destination [1]

    [1] These mappings are common to (shared by) all components of the
        controlling OptionParser, where they are initially created.

    c         C   s1   |  j  É  | |  _ |  j | É |  j | É d  S(   N(   t   _create_option_listt   option_classt   set_conflict_handlert   set_description(   R   R  t   conflict_handlerRQ   (    (    s   /usr/lib/python2.7/optparse.pyR   •  s    
	c         C   s   i  |  _  i  |  _ i  |  _ d  S(   N(   t
   _short_optt	   _long_optRV   (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   _create_option_mappings∞  s    		c         C   s(   | j  |  _  | j |  _ | j |  _ d  S(   N(   R  R  RV   (   R   R'   (    (    s   /usr/lib/python2.7/optparse.pyt   _share_option_mappingsπ  s    c         C   s)   | d k r t  d | Ç n  | |  _ d  S(   Nt   errort   resolves$   invalid conflict_resolution value %r(   s   errorR
  (   R-   R  (   R   t   handler(    (    s   /usr/lib/python2.7/optparse.pyR  ¿  s    c         C   s   | |  _  d  S(   N(   RQ   (   R   RQ   (    (    s   /usr/lib/python2.7/optparse.pyR  ≈  s    c         C   s   |  j  S(   N(   RQ   (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   get_description»  s    c         C   s   |  `  |  ` |  ` d S(   s   see OptionParser.destroy().N(   R  R  RV   (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   destroyÃ  s    c         C   sr  g  } x= | j  D]2 } | |  j k r | j | |  j | f É q q Wx= | j D]2 } | |  j k rP | j | |  j | f É qP qP W| rn|  j } | d k r◊ t d d j g  | D] } | d ^ q¥ É | É Ç qn| d k rnxÖ | D]z \ } } | j d É r"| j j	 | É |  j | =n | j  j	 | É |  j | =| j  pK| j sÍ | j
 j j	 | É qÍ qÍ Wqnn  d  S(   NR	  s    conflicting option string(s): %ss   , i    R
  s   --(   Ru   R  R_   Rv   R  R  R   R#   t
   startswitht   removet	   containerRj   (   R   R   t   conflict_optsRn   R  t   cot   c_option(    (    s   /usr/lib/python2.7/optparse.pyt   _check_conflict’  s.    !!	$
c         O   sD  t  | d É t j k r. |  j | | é  } nN t | É d k rs | rs | d } t | t É s| t d | Ç q| n	 t d Ç |  j | É |  j	 j
 | É |  | _ x | j D] } | |  j | <q¨ Wx | j D] } | |  j | <qÕ W| j d k	 r@| j t k	 r| j |  j | j <q@| j |  j k r@d |  j | j <q@n  | S(   sO   add_option(Option)
           add_option(opt_str, ..., kwarg=val, ...)
        i    i   s   not an Option instance: %rs   invalid argumentsN(   RÅ   R∑   t   StringTypesR  R^   R·   R    R¨   R  Rj   R_   R  Ru   R  Rv   R  RX   R&   Rñ   RY   RV   (   R   R€   R‹   R   Rn   (    (    s   /usr/lib/python2.7/optparse.pyt
   add_option  s(    
		c         C   s"   x | D] } |  j  | É q Wd  S(   N(   R  (   R   Rj   R   (    (    s   /usr/lib/python2.7/optparse.pyt   add_options  s    c         C   s"   |  j  j | É p! |  j j | É S(   N(   R  RW   R  (   R   R   (    (    s   /usr/lib/python2.7/optparse.pyt
   get_option  s    c         C   s   | |  j  k p | |  j k S(   N(   R  R  (   R   R   (    (    s   /usr/lib/python2.7/optparse.pyt
   has_option  s    c         C   s•   |  j  j | É } | d  k r3 |  j j | É } n  | d  k rR t d | É Ç n  x | j D] } |  j  | =q\ Wx | j D] } |  j | =qz W| j j j	 | É d  S(   Ns   no such option %r(
   R  RW   R&   R  R-   Ru   Rv   R  Rj   R  (   R   R   R   Rn   (    (    s   /usr/lib/python2.7/optparse.pyt   remove_option  s    c         C   s\   |  j  s d Sg  } x9 |  j  D]. } | j t k	 r | j | j | É É q q Wd j | É S(   NR<   (   Rj   RU   R   R_   Ri   R#   (   R   t	   formatterRb   R   (    (    s   /usr/lib/python2.7/optparse.pyt   format_option_help,  s    	c         C   s   | j  |  j É  É S(   N(   RR   R  (   R   R  (    (    s   /usr/lib/python2.7/optparse.pyRR   5  s    c         C   sW   g  } |  j  r( | j |  j | É É n  |  j rJ | j |  j | É É n  d j | É S(   Ns   
(   RQ   R_   RR   Rj   R  R#   (   R   R  Rb   (    (    s   /usr/lib/python2.7/optparse.pyt   format_help8  s    		(   R   R   R   R   R  R  R  R  R  R  R  R  R  R  R  R  R  RR   R  (    (    (    s   /usr/lib/python2.7/optparse.pyR   Ö  s"   																		c           B   s8   e  Z d d  Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s2   | |  _  t j |  | j | j | É | |  _ d  S(   N(   R'   R   R   R  R  t   title(   R   R'   R  RQ   (    (    s   /usr/lib/python2.7/optparse.pyR   C  s    	c         C   s   g  |  _  |  j |  j É d  S(   N(   Rj   R  R'   (   R   (    (    s   /usr/lib/python2.7/optparse.pyR   I  s    	c         C   s   | |  _  d  S(   N(   R  (   R   R  (    (    s   /usr/lib/python2.7/optparse.pyt	   set_titleM  s    c         C   s   t  j |  É |  ` d S(   s   see OptionParser.destroy().N(   R   R  Rj   (   R   (    (    s   /usr/lib/python2.7/optparse.pyR  P  s    c         C   s@   | j  |  j É } | j É  | t j |  | É 7} | j É  | S(   N(   RI   R  RB   R   R  RD   (   R   R  Rb   (    (    s   /usr/lib/python2.7/optparse.pyR  W  s
    

N(   R   R   R&   R   R   R  R  R  (    (    (    s   /usr/lib/python2.7/optparse.pyR   A  s
   			c           B   s¶  e  Z d  Z g  Z d) d) e d) d d) d) e d) d) d Ñ
 Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z e d Ñ Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d) d) d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z  d Ñ  Z! d d) d Ñ Z" d Ñ  Z# d  Ñ  Z$ d) d! Ñ Z% d" Ñ  Z& d) d# Ñ Z' d) d$ Ñ Z( d% Ñ  Z) d) d& Ñ Z* d' Ñ  Z+ d) d( Ñ Z, RS(*   s$  
    Class attributes:
      standard_option_list : [Option]
        list of standard options that will be accepted by all instances
        of this parser class (intended to be overridden by subclasses).

    Instance attributes:
      usage : string
        a usage string for your program.  Before it is displayed
        to the user, "%prog" will be expanded to the name of
        your program (self.prog or os.path.basename(sys.argv[0])).
      prog : string
        the name of the current program (to override
        os.path.basename(sys.argv[0])).
      description : string
        A paragraph of text giving a brief overview of your program.
        optparse reformats this paragraph to fit the current terminal
        width and prints it when the user requests help (after usage,
        but before the list of options).
      epilog : string
        paragraph of help text to print after option help

      option_groups : [OptionGroup]
        list of option groups in this parser (option groups are
        irrelevant for parsing the command-line, but very useful
        for generating help)

      allow_interspersed_args : bool = true
        if true, positional arguments may be interspersed with options.
        Assuming -a and -b each take a single argument, the command-line
          -ablah foo bar -bboo baz
        will be interpreted the same as
          -ablah -bboo -- foo bar baz
        If this flag were false, that command line would be interpreted as
          -ablah -- foo bar -bboo baz
        -- ie. we stop processing options as soon as we see the first
        non-option argument.  (This is the tradition followed by
        Python's getopt module, Perl's Getopt::Std, and other argument-
        parsing libraries, but it is generally annoying to users.)

      process_default_values : bool = true
        if true, option default values are processed similarly to option
        values from the command line: that is, they are passed to the
        type-checking function for the option's type (as long as the
        default value is a string).  (This really only matters if you
        have defined custom types; see SF bug #955889.)  Set it to false
        to restore the behaviour of Optik 1.4.1 and earlier.

      rargs : [string]
        the argument list currently being parsed.  Only set when
        parse_args() is active, and continually trimmed down as
        we consume arguments.  Mainly there for the benefit of
        callback options.
      largs : [string]
        the list of leftover arguments that we have skipped while
        parsing options.  If allow_interspersed_args is false, this
        list is always empty.
      values : Values
        the set of option values currently being accumulated.  Only
        set when parse_args() is active.  Also mainly for callbacks.

    Because of the 'rargs', 'largs', and 'values' attributes,
    OptionParser is not thread-safe.  If, for some perverse reason, you
    need to parse command-line arguments simultaneously in different
    threads, use different OptionParser instances.

    R	  c         C   s¢   t  j |  | | | É |  j | É |	 |  _ | |  _ t |  _ t |  _ | d  k r_ t	 É  } n  | |  _
 |  j
 j |  É |
 |  _ |  j | d | É|  j É  d  S(   Nt   add_help(   R   R   t	   set_usaget   progR¢   R’   t   allow_interspersed_argst   process_default_valuesR&   R	   R  R;   RS   t   _populate_option_listt   _init_parsing_state(   R   RF   Rj   R  R¢   R  RQ   R  t   add_help_optionR"  RS   (    (    s   /usr/lib/python2.7/optparse.pyR   ß  s    						c         C   sA   t  j |  É x |  j D] } | j É  q W|  ` |  ` |  ` d S(   s  
        Declare that you are done with this OptionParser.  This cleans up
        reference cycles so the OptionParser (and all objects referenced by
        it) can be garbage-collected promptly.  After calling destroy(), the
        OptionParser is unusable.
        N(   R   R  Rl   Rj   R  (   R   Rp   (    (    s   /usr/lib/python2.7/optparse.pyR  …  s    c         C   s    g  |  _  g  |  _ |  j É  d  S(   N(   Rj   Rl   R  (   R   (    (    s   /usr/lib/python2.7/optparse.pyR   €  s    		c         C   s&   |  j  d d d d d t d É Éd  S(   Ns   -hs   --helpRï   RU   s   show this help message and exit(   R  R    (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   _add_help_option‡  s    c         C   s#   |  j  d d d d t d É Éd  S(   Ns	   --versionRï   R¢   RU   s&   show program's version number and exit(   R  R    (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   _add_version_optionÂ  s    c         C   s_   |  j  r |  j |  j  É n  | r2 |  j | É n  |  j rH |  j É  n  | r[ |  j É  n  d  S(   N(   t   standard_option_listR  R¢   R)  R(  (   R   Rj   R   (    (    s   /usr/lib/python2.7/optparse.pyR%  Í  s    		c         C   s   d  |  _ d  |  _ d  |  _ d  S(   N(   R&   t   rargst   largsR”   (   R   (    (    s   /usr/lib/python2.7/optparse.pyR&  Ù  s    		c         C   sh   | d  k r t d É |  _ nF | t k r6 d  |  _ n. | j É  j d É r[ | d |  _ n	 | |  _ d  S(   Ns   %prog [options]s   usage: i   (   R&   R    RF   R   R   R  (   R   RF   (    (    s   /usr/lib/python2.7/optparse.pyR!  ˝  s    c         C   s   t  |  _ d S(   s  Set parsing to not stop on the first non-option, allowing
        interspersing switches with command arguments. This is the
        default behavior. See also disable_interspersed_args() and the
        class documentation description of the attribute
        allow_interspersed_args.N(   R’   R#  (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   enable_interspersed_args  s    c         C   s   t  |  _ d S(   sÈ   Set parsing to stop on the first non-option. Use this if
        you have a command processor which runs another command that
        has options of its own and you want to make sure these options
        don't get confused.
        N(   R÷   R#  (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   disable_interspersed_args  s    c         C   s   | |  _  d  S(   N(   R$  (   R   R‘   (    (    s   /usr/lib/python2.7/optparse.pyt   set_process_default_values  s    c         C   s   | |  j  | <d  S(   N(   RV   (   R   RX   Rã   (    (    s   /usr/lib/python2.7/optparse.pyt   set_default  s    c         K   s   |  j  j | É d  S(   N(   RV   R   (   R   R‹   (    (    s   /usr/lib/python2.7/optparse.pyt   set_defaults  s    c         C   s2   |  j  } x! |  j D] } | j | j  É q W| S(   N(   Rj   Rl   Ra   (   R   t   optionsRp   (    (    s   /usr/lib/python2.7/optparse.pyt   _get_all_options!  s    
c         C   så   |  j  s t |  j É S|  j j É  } xZ |  j É  D]L } | j | j É } t | É r2 | j É  } | j	 | | É | | j <q2 q2 Wt | É S(   N(
   R$  R   RV   t   copyR3  RW   RX   RÂ   RÃ   RŒ   (   R   RV   R   Rñ   R   (    (    s   /usr/lib/python2.7/optparse.pyt   get_default_values'  s    	 c         O   s´   t  | d É t j k r. t |  | | é } ni t | É d k ré | ré | d } t | t É sp t d | Ç n  | j |  k	 ró t d Ç qó n	 t d Ç |  j	 j
 | É | S(   Ni    i   s   not an OptionGroup instance: %rs"   invalid OptionGroup (wrong parser)s   invalid arguments(   RÅ   R∑   R‚   R   R^   R·   R¨   R'   R-   Rl   R_   (   R   R€   R‹   Rp   (    (    s   /usr/lib/python2.7/optparse.pyt   add_option_group8  s    
	c         C   sD   |  j  j | É p! |  j j | É } | r@ | j |  k	 r@ | j Sd  S(   N(   R  RW   R  R  R&   (   R   R   R   (    (    s   /usr/lib/python2.7/optparse.pyt   get_option_groupH  s
    c         C   s    | d  k r t j d S| Sd  S(   Ni   (   R&   R˜   t   argv(   R   R€   (    (    s   /usr/lib/python2.7/optparse.pyt	   _get_argsR  s    c         C   s´   |  j  | É } | d k r* |  j É  } n  | |  _ g  |  _ } | |  _ y |  j | | | É } Wn, t t f k
 rê } |  j	 t
 | É É n X| | } |  j | | É S(   sR  
        parse_args(args : [string] = sys.argv[1:],
                   values : Values = None)
        -> (values : Values, args : [string])

        Parse the command-line options found in 'args' (default:
        sys.argv[1:]).  Any errors result in a call to 'error()', which
        by default prints the usage message to stderr and calls
        sys.exit() with an error message.  On success returns a pair
        (values, args) where 'values' is a Values instance (with all
        your option values) and 'args' is the list of arguments left
        over after parsing options.
        N(   R9  R&   R5  R+  R,  R”   t   _process_argsR   R   R	  R   t   check_values(   R   R€   R”   R+  R,  t   stopt   err(    (    s   /usr/lib/python2.7/optparse.pyt
   parse_argsX  s    		
c         C   s
   | | f S(   s≥  
        check_values(values : Values, args : [string])
        -> (values : Values, args : [string])

        Check that the supplied option values and leftover arguments are
        valid.  Returns the option values and leftover arguments
        (possibly adjusted, possibly completely new -- whatever you
        like).  Default implementation just returns the passed-in
        values; subclasses may override as desired.
        (    (   R   R”   R€   (    (    s   /usr/lib/python2.7/optparse.pyR;    s    c         C   s±   x™ | r¨ | d } | d k r* | d =d S| d d !d k rP |  j  | | É q | d  d k rÖ t | É d k rÖ |  j | | É q |  j r• | j | É | d =q d Sq Wd S(   sò  _process_args(largs : [string],
                         rargs : [string],
                         values : Values)

        Process command-line arguments and populate 'values', consuming
        options and arguments from 'rargs'.  If 'allow_interspersed_args' is
        false, stop at the first non-option argument.  If true, accumulate any
        interspersed non-option arguments in 'largs'.
        i    s   --Ni   i   R≠   (   t   _process_long_optR^   t   _process_short_optsR#  R_   (   R   R,  R+  R”   t   arg(    (    s   /usr/lib/python2.7/optparse.pyR:  å  s    
	
"	
c         C   s   t  | |  j É S(   s  _match_long_opt(opt : string) -> string

        Determine which long option string 'opt' matches, ie. which one
        it is an unambiguous abbreviation for.  Raises BadOptionError if
        'opt' doesn't unambiguously match any long option string.
        (   t   _match_abbrevR  (   R   Rn   (    (    s   /usr/lib/python2.7/optparse.pyt   _match_long_optø  s    c   
      C   s_  | j  d É } d | k rL | j d d É \ } } | j d | É t } n | } t } |  j | É } |  j | } | j É  r| j } t	 | É | k  r· | d k r¡ |  j
 t d É | É q|  j
 t d É | | f É qE| d k rˇ | j  d É }	 qEt | d | !É }	 | d | 5n& | r?|  j
 t d É | É n d  }	 | j | |	 | |  É d  S(   Ni    R@   i   s   %s option requires an arguments   %s option requires %d argumentss   %s option does not take a value(   t   popR¡   t   insertR’   R÷   RC  R  Rr   Ró   R^   R	  R    Rœ   R&   R‘   (
   R   R+  R”   RA  Rn   t   next_argt   had_explicit_valueR   Ró   Rã   (    (    s   /usr/lib/python2.7/optparse.pyR?  »  s0    		c         C   so  | j  d É } t } d } xM| d D]A} d | } |  j j | É } | d 7} | sg t | É Ç n  | j É  rA| t | É k  r¢ | j d | | É t } n  | j	 }	 t | É |	 k  r|	 d k r„ |  j
 t d É | É q>|  j
 t d É | |	 f É qG|	 d k r!| j  d É }
 qGt | d |	 !É }
 | d |	 5n d  }
 | j | |
 | |  É | r& Pq& q& Wd  S(   Ni    i   R≠   s   %s option requires an arguments   %s option requires %d arguments(   RD  R÷   R  RW   R   Rr   R^   RE  R’   Ró   R	  R    Rœ   R&   R‘   (   R   R+  R”   RA  R<  t   it   chRn   R   Ró   Rã   (    (    s   /usr/lib/python2.7/optparse.pyR@  Ì  s6    

		c         C   s1   |  j  d  k r& t j j t j d É S|  j  Sd  S(   Ni    (   R"  R&   R*   t   patht   basenameR˜   R8  (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   get_prog_name  s    c         C   s   | j  d |  j É  É S(   Ns   %prog(   R[   RL  (   R   t   s(    (    s   /usr/lib/python2.7/optparse.pyt   expand_prog_name  s    c         C   s   |  j  |  j É S(   N(   RN  RQ   (   R   (    (    s   /usr/lib/python2.7/optparse.pyR     s    i    c         C   s*   | r t  j j | É n  t  j | É d  S(   N(   R˜   t   stderrt   writeRŸ   (   R   t   statusR   (    (    s   /usr/lib/python2.7/optparse.pyRŸ   #  s    c         C   s4   |  j  t j É |  j d d |  j É  | f É d S(   s‹   error(msg : string)

        Print a usage message incorporating 'msg' to stderr and exit.
        If you override this in a subclass, it should not return -- it
        should either exit or raise an exception.
        i   s   %s: error: %s
N(   t   print_usageR˜   RO  RŸ   RL  (   R   R   (    (    s   /usr/lib/python2.7/optparse.pyR	  (  s    c         C   s-   |  j  r% |  j j |  j |  j  É É Sd Sd  S(   NR<   (   RF   R  RG   RN  (   R   (    (    s   /usr/lib/python2.7/optparse.pyt	   get_usage2  s    		c         C   s    |  j  r | |  j É  IJn  d S(   sa  print_usage(file : file = stdout)

        Print the usage message for the current program (self.usage) to
        'file' (default stdout).  Any occurrence of the string "%prog" in
        self.usage is replaced with the name of the current program
        (basename of sys.argv[0]).  Does nothing if self.usage is empty
        or not defined.
        N(   RF   RS  (   R   t   file(    (    s   /usr/lib/python2.7/optparse.pyRR  9  s    		c         C   s!   |  j  r |  j |  j  É Sd Sd  S(   NR<   (   R¢   RN  (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   get_versionE  s    	c         C   s    |  j  r | |  j É  IJn  d S(   sE  print_version(file : file = stdout)

        Print the version message for this program (self.version) to
        'file' (default stdout).  As with print_usage(), any occurrence
        of "%prog" in self.version is replaced by the current program's
        name.  Does nothing if self.version is empty or undefined.
        N(   R¢   RU  (   R   RT  (    (    s   /usr/lib/python2.7/optparse.pyR⁄   K  s    	c         C   s’   | d  k r |  j } n  | j |  É g  } | j | j t d É É É | j É  |  j rÉ | j t j	 |  | É É | j d É n  x4 |  j
 D]) } | j | j | É É | j d É qç W| j É  d j | d  É S(   Nt   Optionss   
R<   iˇˇˇˇ(   R&   R  Rq   R_   RI   R    RB   Rj   R   R  Rl   R  RD   R#   (   R   R  Rb   Rp   (    (    s   /usr/lib/python2.7/optparse.pyR  V  s    
	
c         C   s   | j  |  j É S(   N(   RT   RS   (   R   R  (    (    s   /usr/lib/python2.7/optparse.pyRT   g  s    c         C   s†   | d  k r |  j } n  g  } |  j rA | j |  j É  d É n  |  j rg | j |  j | É d É n  | j |  j | É É | j |  j | É É d j	 | É S(   Ns   
R<   (
   R&   R  RF   R_   RS  RQ   RR   R  RT   R#   (   R   R  Rb   (    (    s   /usr/lib/python2.7/optparse.pyR  j  s    		c         C   s+   t  | d d  É } | s' t j É  } n  | S(   Nt   encoding(   R∫   R&   R˜   t   getdefaultencoding(   R   RT  RW  (    (    s   /usr/lib/python2.7/optparse.pyt   _get_encodingw  s    c         C   sJ   | d k r t j } n  |  j | É } | j |  j É  j | d É É d S(   s∞   print_help(file : file = stdout)

        Print an extended help message, listing all options and any
        help text provided with them, to 'file' (default stdout).
        R[   N(   R&   R˜   t   stdoutRY  RP  R  t   encode(   R   RT  RW  (    (    s   /usr/lib/python2.7/optparse.pyRÿ   }  s    N(-   R   R   R   R*  R&   R    R’   R   R  R   R(  R)  R%  R&  R!  R-  R.  R/  R0  R1  R3  R5  R6  R7  R9  R>  R;  R:  RC  R?  R@  RL  RN  R  RŸ   R	  RS  RR  RU  R⁄   R  RT   R  RY  Rÿ   (    (    (    s   /usr/lib/python2.7/optparse.pyR   _  sb   D				
												
	'		3			%	*				
				c         C   sä   |  | k r |  Sg  | j  É  D] } | j |  É r | ^ q } t | É d k rX | d S| sm t |  É Ç n | j É  t |  | É Ç d S(   s˚   _match_abbrev(s : string, wordmap : {string : Option}) -> string

    Return the string key in 'wordmap' for which 's' is an unambiguous
    abbreviation.  If 's' is found to be ambiguous or doesn't match any of
    'words', raise BadOptionError.
    i   i    N(   R∞   R  R^   R   R±   R!   (   RM  t   wordmapt   wordR"   (    (    s   /usr/lib/python2.7/optparse.pyRB  ã  s    
(+   R   t   __version__t   __all__t   __copyright__R˜   R*   R∑   RL   R   R   t   ImportErrorR    t	   ExceptionR   R   R   R   R   R!   R   R	   R
   RÉ   RÑ   RÜ   Rà   Râ   Rä   Ré   Rí   RY   R    R   R   RÊ   t	   NameErrorRÂ   R   R   R   R   RB  R   (    (    (    s   /usr/lib/python2.7/optparse.pyt   <module>   s~   	 	

œ					ˇ {

	Aºˇ ˇ .	
filename:/usr/lib/python2.7/cProfile.py
__doc__
#! /usr/bin/python2.7

"""Python interface for the 'lsprof' profiler.

filename:/usr/lib/python2.7/pty.py
__doc__
"""Pseudo terminal utilities."""

# Bugs: No signal handling.  Doesn't set slave termios and window size.
#       Only tested on Linux.
# See:  W. Richard Stevens. 1992.  Advanced Programming in the
#       UNIX Environment.  Chapter 19.
# Author: Steen Lumholt -- with additions by Guido.

from select import select
import os
import tty

__all__ = ["openpty","fork","spawn"]

STDIN_FILENO = 0
STDOUT_FILENO = 1
STDERR_FILENO = 2

CHILD = 0

def openpty():
    """openpty() -> (master_fd, slave_fd)
    Open a pty master/slave pair, using os.openpty() if possible."""

    try:
        return os.openpty()
    except (AttributeError, OSError):
        pass
    master_fd, slave_name = _open_terminal()
    slave_fd = slave_open(slave_name)
    return master_fd, slave_fd

def master_open():
    """master_open() -> (master_fd, slave_name)
    Open a pty master and return the fd, and the filename of the slave end.
    Deprecated, use openpty() instead."""

    try:
        master_fd, slave_fd = os.openpty()
    except (AttributeError, OSError):
        pass
    else:
        slave_name = os.ttyname(slave_fd)
        os.close(slave_fd)
        return master_fd, slave_name

    return _open_terminal()

def _open_terminal():
    """Open pty master and return (master_fd, tty_name).
    SGI and generic BSD version, for when openpty() fails."""
    try:
        import sgi
    except ImportError:
        pass
    else:
        try:
            tty_name, master_fd = sgi._getpty(os.O_RDWR, 0666, 0)
        except IOError, msg:
            raise os.error, msg
        return master_fd, tty_name
    for x in 'pqrstuvwxyzPQRST':
        for y in '0123456789abcdef':
            pty_name = '/dev/pty' + x + y
            try:
                fd = os.open(pty_name, os.O_RDWR)
            except os.error:
                continue
            return (fd, '/dev/tty' + x + y)
    raise os.error, 'out of pty devices'

def slave_open(tty_name):
    """slave_open(tty_name) -> slave_fd
    Open the pty slave and acquire the controlling terminal, returning
    opened filedescriptor.
    Deprecated, use openpty() instead."""

    result = os.open(tty_name, os.O_RDWR)
    try:
        from fcntl import ioctl, I_PUSH
    except ImportError:
        return result
    try:
        ioctl(result, I_PUSH, "ptem")
        ioctl(result, I_PUSH, "ldterm")
    except IOError:
        pass
    return result

def fork():
    """fork() -> (pid, master_fd)
    Fork and make the child a session leader with a controlling terminal."""

    try:
        pid, fd = os.forkpty()
    except (AttributeError, OSError):
        pass
    else:
        if pid == CHILD:
            try:
                os.setsid()
            except OSError:
                # os.forkpty() already set us session leader
                pass
        return pid, fd

    master_fd, slave_fd = openpty()
    pid = os.fork()
    if pid == CHILD:
        # Establish a new session.
        os.setsid()
        os.close(master_fd)

        # Slave becomes stdin/stdout/stderr of child.
        os.dup2(slave_fd, STDIN_FILENO)
        os.dup2(slave_fd, STDOUT_FILENO)
        os.dup2(slave_fd, STDERR_FILENO)
        if (slave_fd > STDERR_FILENO):
            os.close (slave_fd)

        # Explicitly open the tty to make it become a controlling tty.
        tmp_fd = os.open(os.ttyname(STDOUT_FILENO), os.O_RDWR)
        os.close(tmp_fd)
    else:
        os.close(slave_fd)

    # Parent and child process.
    return pid, master_fd

def _writen(fd, data):
    """Write all the data to a descriptor."""
    while data != '':
        n = os.write(fd, data)
        data = data[n:]

def _read(fd):
    """Default read function."""
    return os.read(fd, 1024)

def _copy(master_fd, master_read=_read, stdin_read=_read):
    """Parent copy loop.
    Copies
            pty master -> standard output   (master_read)
            standard input -> pty master    (stdin_read)"""
    fds = [master_fd, STDIN_FILENO]
    while True:
        rfds, wfds, xfds = select(fds, [], [])
        if master_fd in rfds:
            data = master_read(master_fd)
            if not data:  # Reached EOF.
                fds.remove(master_fd)
            else:
                os.write(STDOUT_FILENO, data)
        if STDIN_FILENO in rfds:
            data = stdin_read(STDIN_FILENO)
            if not data:
                fds.remove(STDIN_FILENO)
            else:
                _writen(master_fd, data)

def spawn(argv, master_read=_read, stdin_read=_read):
    """Create a spawned process."""
    if type(argv) == type(''):
        argv = (argv,)
    pid, master_fd = fork()
    if pid == CHILD:
        os.execlp(argv[0], *argv)
    try:
        mode = tty.tcgetattr(STDIN_FILENO)
        tty.setraw(STDIN_FILENO)
        restore = 1
    except tty.error:    # This is the same as termios.error
        restore = 0
    try:
        _copy(master_fd, master_read, stdin_read)
    except (IOError, OSError):
        if restore:
            tty.tcsetattr(STDIN_FILENO, tty.TCSAFLUSH, mode)

    os.close(master_fd)

filename:/usr/lib/python2.7/_weakrefset.pyc
__doc__
Û
/0Xc           @   sI   d  d l  m Z d g Z d e f d Ñ  É  YZ d e f d Ñ  É  YZ d S(   iˇˇˇˇ(   t   reft   WeakSett   _IterationGuardc           B   s#   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s   t  | É |  _ d  S(   N(   R    t   weakcontainer(   t   selfR   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   __init__   s    c         C   s/   |  j  É  } | d  k	 r+ | j j |  É n  |  S(   N(   R   t   Nonet
   _iteratingt   add(   R   t   w(    (    s!   /usr/lib/python2.7/_weakrefset.pyt	   __enter__   s    c         C   sH   |  j  É  } | d  k	 rD | j } | j |  É | sD | j É  qD n  d  S(   N(   R   R   R   t   removet   _commit_removals(   R   t   et   tt   bR	   t   s(    (    s!   /usr/lib/python2.7/_weakrefset.pyt   __exit__   s    	(   t   __name__t
   __module__R   R
   R   (    (    (    s!   /usr/lib/python2.7/_weakrefset.pyR   
   s   		c           B   sL  e  Z d d  Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e Z d Ñ  Z d Ñ  Z d Ñ  Z e Z d Ñ  Z d Ñ  Z d Ñ  Z e Z d Ñ  Z d Ñ  Z e Z d Ñ  Z d Ñ  Z  d Ñ  Z! d Ñ  Z" e" Z# d Ñ  Z$ d Ñ  Z% d Ñ  Z& e& Z' d Ñ  Z( RS(    c         C   s\   t  É  |  _ t |  É d Ñ } | |  _ g  |  _ t  É  |  _ | d  k	 rX |  j | É n  d  S(   Nc         S   sH   | É  } | d  k	 rD | j r1 | j j |  É qD | j j |  É n  d  S(   N(   R   R   t   _pending_removalst   appendt   datat   discard(   t   itemt   selfrefR   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   _remove&   s
    		(   t   setR   R    R   R   R   R   t   update(   R   R   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR   $   s    		c         C   s6   |  j  } |  j j } x | r1 | | j É  É q Wd  S(   N(   R   R   R   t   pop(   R   t   lR   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR   4   s    		c         c   sH   t  |  É è6 x. |  j D]# } | É  } | d  k	 r | Vq q WWd  QXd  S(   N(   R   R   R   (   R   t   itemrefR   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   __iter__:   s
    	c         C   s   t  |  j É t  |  j É S(   N(   t   lenR   R   (   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   __len__C   s    c         C   s2   y t  | É } Wn t k
 r$ t SX| |  j k S(   N(   R    t	   TypeErrort   FalseR   (   R   R   t   wr(    (    s!   /usr/lib/python2.7/_weakrefset.pyt   __contains__F   s
    c         C   s%   |  j  t |  É f t |  d d  É f S(   Nt   __dict__(   t	   __class__t   listt   getattrR   (   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt
   __reduce__M   s    c         C   s6   |  j  r |  j É  n  |  j j t | |  j É É d  S(   N(   R   R   R   R   R    R   (   R   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR   S   s    	c         C   s'   |  j  r |  j É  n  |  j j É  d  S(   N(   R   R   R   t   clear(   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR,   X   s    	c         C   s   |  j  |  É S(   N(   R(   (   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   copy]   s    c         C   ss   |  j  r |  j É  n  xV t rn y |  j j É  } Wn t k
 rQ t d É Ç n X| É  } | d  k	 r | Sq Wd  S(   Ns   pop from empty WeakSet(   R   R   t   TrueR   R   t   KeyErrorR   (   R   R   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR   `   s    			c         C   s0   |  j  r |  j É  n  |  j j t | É É d  S(   N(   R   R   R   R   R    (   R   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR   l   s    	c         C   s0   |  j  r |  j É  n  |  j j t | É É d  S(   N(   R   R   R   R   R    (   R   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR   q   s    	c         C   s8   |  j  r |  j É  n  x | D] } |  j | É q Wd  S(   N(   R   R   R   (   R   t   othert   element(    (    s!   /usr/lib/python2.7/_weakrefset.pyR   v   s    	c         C   s   |  j  | É |  S(   N(   R   (   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   __ior__|   s    c         C   s   |  j  É  } | j | É | S(   N(   R-   t   difference_update(   R   R0   t   newset(    (    s!   /usr/lib/python2.7/_weakrefset.pyt
   differenceÄ   s    c         C   s   |  j  | É d  S(   N(   t   __isub__(   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR3   Ü   s    c         C   sP   |  j  r |  j É  n  |  | k r2 |  j j É  n |  j j d Ñ  | DÉ É |  S(   Nc         s   s   |  ] } t  | É Vq d  S(   N(   R    (   t   .0R   (    (    s!   /usr/lib/python2.7/_weakrefset.pys	   <genexpr>é   s    (   R   R   R   R,   R3   (   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR6   à   s    	c            s   à  j  á  f d Ü  | DÉ É S(   Nc         3   s!   |  ] } | à  k r | Vq d  S(   N(    (   R7   R   (   R   (    s!   /usr/lib/python2.7/_weakrefset.pys	   <genexpr>í   s    (   R(   (   R   R0   (    (   R   s!   /usr/lib/python2.7/_weakrefset.pyt   intersectionë   s    c         C   s   |  j  | É d  S(   N(   t   __iand__(   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   intersection_updateï   s    c         C   s4   |  j  r |  j É  n  |  j j d Ñ  | DÉ É |  S(   Nc         s   s   |  ] } t  | É Vq d  S(   N(   R    (   R7   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pys	   <genexpr>ö   s    (   R   R   R   R:   (   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR9   ó   s    	c         C   s   |  j  j d Ñ  | DÉ É S(   Nc         s   s   |  ] } t  | É Vq d  S(   N(   R    (   R7   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pys	   <genexpr>û   s    (   R   t   issubset(   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR;   ù   s    c         C   s   |  j  t d Ñ  | DÉ É k  S(   Nc         s   s   |  ] } t  | É Vq d  S(   N(   R    (   R7   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pys	   <genexpr>¢   s    (   R   R   (   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   __lt__°   s    c         C   s   |  j  j d Ñ  | DÉ É S(   Nc         s   s   |  ] } t  | É Vq d  S(   N(   R    (   R7   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pys	   <genexpr>•   s    (   R   t
   issuperset(   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyR=   §   s    c         C   s   |  j  t d Ñ  | DÉ É k S(   Nc         s   s   |  ] } t  | É Vq d  S(   N(   R    (   R7   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pys	   <genexpr>©   s    (   R   R   (   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   __gt__®   s    c         C   s3   t  | |  j É s t S|  j t d Ñ  | DÉ É k S(   Nc         s   s   |  ] } t  | É Vq d  S(   N(   R    (   R7   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pys	   <genexpr>Æ   s    (   t
   isinstanceR(   t   NotImplementedR   R   (   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   __eq__´   s    c         C   s$   |  j  | É } | t k r t S| S(   N(   RA   R@   (   R   R0   t   opposite(    (    s!   /usr/lib/python2.7/_weakrefset.pyt   __ne__∞   s    c         C   s   |  j  É  } | j | É | S(   N(   R-   t   symmetric_difference_update(   R   R0   R4   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   symmetric_difference∂   s    c         C   s   |  j  | É d  S(   N(   t   __ixor__(   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyRD   º   s    c            sV   à  j  r à  j É  n  à  | k r2 à  j j É  n  à  j j á  f d Ü  | DÉ É à  S(   Nc         3   s!   |  ] } t  | à  j É Vq d  S(   N(   R    R   (   R7   R   (   R   (    s!   /usr/lib/python2.7/_weakrefset.pys	   <genexpr>ƒ   s    (   R   R   R   R,   RD   (   R   R0   (    (   R   s!   /usr/lib/python2.7/_weakrefset.pyRF   æ   s    	 c         C   s   |  j  d Ñ  |  | f DÉ É S(   Nc         s   s"   |  ] } | D] } | Vq q d  S(   N(    (   R7   R   R   (    (    s!   /usr/lib/python2.7/_weakrefset.pys	   <genexpr>»   s    (   R(   (   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   union«   s    c         C   s   t  |  j | É É d k S(   Ni    (   R!   R8   (   R   R0   (    (    s!   /usr/lib/python2.7/_weakrefset.pyt
   isdisjointÀ   s    N()   R   R   R   R   R   R    R"   R&   R+   t   __hash__R   R,   R-   R   R   R   R   R2   R5   t   __sub__R3   R6   R8   t   __and__R:   R9   R;   t   __le__R<   R=   t   __ge__R>   RA   RC   RE   t   __xor__RD   RF   RG   t   __or__RH   (    (    (    s!   /usr/lib/python2.7/_weakrefset.pyR   #   sL   																																N(   t   _weakrefR    t   __all__t   objectR   R   (    (    (    s!   /usr/lib/python2.7/_weakrefset.pyt   <module>   s   	
filename:/usr/lib/python2.7/ensurepip/__init__.py
__doc__
#! /usr/bin/python2.7
from __future__ import print_function

import glob
import os
import os.path
import pkgutil
import shutil
import sys
import tempfile


__all__ = ["version", "bootstrap"]

def _ensurepip_is_disabled_in_debian():
    if True:
        print ('''\
ensurepip is disabled in Debian/Ubuntu for the system python.

Python modules For the system python are usually handled by dpkg and apt-get.

    apt-get install python-<module name>

Install the python-pip package to use pip itself.  Using pip together
with the system python might have unexpected results for any system installed
module, so use it on your own risk, or make sure to only use it in virtual
environments.
''')
        sys.exit(1)

# pip currently requires ssl support, so we try to provide a nicer
# error message when that is missing (http://bugs.python.org/issue19744)
_MISSING_SSL_MESSAGE = ("pip requires SSL/TLS")
try:
    import ssl
except ImportError:
    ssl = None

    def _require_ssl_for_pip():
        raise RuntimeError(_MISSING_SSL_MESSAGE)
else:
    def _require_ssl_for_pip():
        pass

_PROJECTS = [
    "setuptools",
    "pip",
]


def _run_pip(args, additional_paths=None):
    # Add our bundled software to the sys.path so we can import it
    if additional_paths is not None:
        sys.path = additional_paths + sys.path

    # Install the bundled software
    import pip
    pip.main(args)


def version():
    """
    Returns a string specifying the bundled version of pip.
    """
    _ensurepip_is_disabled_in_debian()
    whl_name = 'pip'
    wheel_names = glob.glob('/usr/share/python-wheels/%s-*.whl' % whl_name)
    if len(wheel_names) == 1:
        return os.path.basename(wheel_names[0]).split('-')[1]
    raise RuntimeError('missing dependency wheel %s. Installation of the python-%s-whl package is needed to use ensurepip.' % (whl_name, whl_name))


def _disable_pip_configuration_settings():
    # We deliberately ignore all pip environment variables
    # when invoking pip
    # See http://bugs.python.org/issue19734 for details
    keys_to_remove = [k for k in os.environ if k.startswith("PIP_")]
    for k in keys_to_remove:
        del os.environ[k]
    # We also ignore the settings in the default pip configuration file
    # See http://bugs.python.org/issue20053 for details
    os.environ['PIP_CONFIG_FILE'] = os.devnull


def bootstrap(root=None, upgrade=False, user=False,
              altinstall=False, default_pip=True,
              verbosity=0):
    """
    Bootstrap pip into the current Python installation (or the given root
    directory).

    Note that calling this function will alter both sys.path and os.environ.
    """
    _ensurepip_is_disabled_in_debian()
    if altinstall and default_pip:
        raise ValueError("Cannot use altinstall and default_pip together")

    _require_ssl_for_pip()
    _disable_pip_configuration_settings()

    # By default, installing pip and setuptools installs all of the
    # following scripts (X.Y == running Python version):
    #
    #   pip, pipX, pipX.Y, easy_install, easy_install-X.Y
    #
    # pip 1.5+ allows ensurepip to request that some of those be left out
    if altinstall:
        # omit pip, pipX and easy_install
        os.environ["ENSUREPIP_OPTIONS"] = "altinstall"
    elif not default_pip:
        # omit pip and easy_install
        os.environ["ENSUREPIP_OPTIONS"] = "install"

    # Debian: The bundled wheels are useless to us because we must use ones
    # crafted from source code in the archive.  As we build the virtual
    # environment, copy the wheels from the system location into the virtual
    # environment, and place those wheels on sys.path.
    def copy_wheels(wheels, destdir, paths):
        for project in wheels:
            wheel_names = glob.glob(
                '/usr/share/python-wheels/{}-*.whl'.format(project))
            if len(wheel_names) == 0:
                raise RuntimeError('missing dependency wheel %s. Installation of the python-%s-whl package is needed to use ensurepip.' % (project, project))
            assert len(wheel_names) == 1, wheel_names
            wheel_name = os.path.basename(wheel_names[0])
            path = os.path.join('/usr/share/python-wheels', wheel_name)
            with open(path, 'rb') as fp:
                whl = fp.read()
            dest = os.path.join(destdir, wheel_name)
            with open(dest, 'wb') as fp:
                fp.write(whl)
            paths.append(dest)

    # check that the python-{pip,setuptools}-whl packages are installed
    missing = []
    for project in reversed(_PROJECTS):
        wheel_names = glob.glob('/usr/share/python-wheels/%s-*.whl' % project)
        if len(wheel_names) != 1:
            missing.append(project)
    if missing:
        raise RuntimeError('missing wheel(s) %s. Installation of the %s package(s) is needed to use ensurepip.' \
                           % (', '.join([missing]),
                              ', '.join(['python-%s-whl' % m for m in missing])) \
                           )

    tmpdir = tempfile.mkdtemp()

    for project in _PROJECTS:
        try:
            with open('/usr/share/python-wheels/%s.dependencies' % project) as fp:
                dependencies = [line[:-1].split()[0] for line in fp.readlines()]
        except IOError:
            dependencies = []
        copy_wheels(dependencies, tmpdir, sys.path)

    try:
        # Put our bundled wheels into a temporary directory and construct the
        # additional paths that need added to sys.path
        additional_paths = []
        copy_wheels(_PROJECTS, tmpdir, additional_paths)

        # Construct the arguments to be passed to the pip command
        args = ["install", "--no-index", "--find-links", tmpdir]
        if root:
            args += ["--root", root]
        if upgrade:
            args += ["--upgrade"]
        if user:
            args += ["--user"]
        if verbosity:
            args += ["-" + "v" * verbosity]

        _run_pip(args + _PROJECTS, additional_paths)
    finally:
        shutil.rmtree(tmpdir, ignore_errors=True)


def _uninstall_helper(verbosity=0):
    """Helper to support a clean default uninstall process on Windows

    Note that calling this function may alter os.environ.
    """
    # Nothing to do if pip was never installed, or has been removed
    try:
        import pip
    except ImportError:
        return

    # If the pip version doesn't match the bundled one, leave it alone
    # Disabled for Debian, always using the version from the python3-pip package.
    if False and pip.__version__ != _PIP_VERSION:
        msg = ("ensurepip will only uninstall a matching version "
               "({!r} installed, {!r} bundled)")
        print(msg.format(pip.__version__, _PIP_VERSION), file=sys.stderr)
        return

    _require_ssl_for_pip()
    _disable_pip_configuration_settings()

    # Construct the arguments to be passed to the pip command
    args = ["uninstall", "-y", "--disable-pip-version-check"]
    if verbosity:
        args += ["-" + "v" * verbosity]

    _run_pip(args + reversed(_PROJECTS))


def _main(argv=None):
    if ssl is None:
        print("Ignoring ensurepip failure: {}".format(_MISSING_SSL_MESSAGE),
              file=sys.stderr)
        return

    import argparse
    parser = argparse.ArgumentParser(prog="python -m ensurepip")
    parser.add_argument(
        "--version",
        action="version",
        version="pip {}".format(version()),
        help="Show the version of pip that is bundled with this Python.",
    )
    parser.add_argument(
        "-v", "--verbose",
        action="count",
        default=0,
        dest="verbosity",
        help=("Give more output. Option is additive, and can be used up to 3 "
              "times."),
    )
    parser.add_argument(
        "-U", "--upgrade",
        action="store_true",
        default=False,
        help="Upgrade pip and dependencies, even if already installed.",
    )
    parser.add_argument(
        "--user",
        action="store_true",
        default=False,
        help="Install using the user scheme.",
    )
    parser.add_argument(
        "--root",
        default=None,
        help="Install everything relative to this alternate root directory.",
    )
    parser.add_argument(
        "--altinstall",
        action="store_true",
        default=False,
        help=("Make an alternate install, installing only the X.Y versioned"
              "scripts (Default: pipX, pipX.Y, easy_install-X.Y)"),
    )
    parser.add_argument(
        "--default-pip",
        action="store_true",
        default=True,
        dest="default_pip",
        help=argparse.SUPPRESS,
    )
    parser.add_argument(
        "--no-default-pip",
        action="store_false",
        dest="default_pip",
        help=("Make a non default install, installing only the X and X.Y "
              "versioned scripts."),
    )

    args = parser.parse_args(argv)

    bootstrap(
        root=args.root,
        upgrade=args.upgrade,
        user=args.user,
        verbosity=args.verbosity,
        altinstall=args.altinstall,
        default_pip=args.default_pip,
    )

filename:/usr/lib/python2.7/ensurepip/__main__.py
__doc__
import ensurepip

if __name__ == "__main__":
    ensurepip._main()

filename:/usr/lib/python2.7/ensurepip/_uninstall.py
__doc__
"""Basic pip uninstallation support, helper for the Windows uninstaller"""

filename:/usr/lib/python2.7/_pyio.py
__doc__
"""
Python implementation of the io module.
"""

filename:/usr/lib/python2.7/DocXMLRPCServer.py
__doc__
"""Self documenting XML-RPC Server.

This module can be used to create XML-RPC servers that
serve pydoc-style documentation in response to HTTP
GET requests. This documentation is dynamically generated
based on the functions and methods registered with the
server.

This module is built upon the pydoc and SimpleXMLRPCServer
modules.
"""

filename:/usr/lib/python2.7/macurl2path.py
__doc__
"""Macintosh-specific module for conversion between pathnames and URLs.

Do not import directly; use urllib instead."""

import urllib
import os

__all__ = ["url2pathname","pathname2url"]

def url2pathname(pathname):
    """OS-specific conversion from a relative URL of the 'file' scheme
    to a file system path; not recommended for general use."""
    #
    # XXXX The .. handling should be fixed...
    #
    tp = urllib.splittype(pathname)[0]
    if tp and tp != 'file':
        raise RuntimeError, 'Cannot convert non-local URL to pathname'
    # Turn starting /// into /, an empty hostname means current host
    if pathname[:3] == '///':
        pathname = pathname[2:]
    elif pathname[:2] == '//':
        raise RuntimeError, 'Cannot convert non-local URL to pathname'
    components = pathname.split('/')
    # Remove . and embedded ..
    i = 0
    while i < len(components):
        if components[i] == '.':
            del components[i]
        elif components[i] == '..' and i > 0 and \
                                  components[i-1] not in ('', '..'):
            del components[i-1:i+1]
            i = i-1
        elif components[i] == '' and i > 0 and components[i-1] != '':
            del components[i]
        else:
            i = i+1
    if not components[0]:
        # Absolute unix path, don't start with colon
        rv = ':'.join(components[1:])
    else:
        # relative unix path, start with colon. First replace
        # leading .. by empty strings (giving ::file)
        i = 0
        while i < len(components) and components[i] == '..':
            components[i] = ''
            i = i + 1
        rv = ':' + ':'.join(components)
    # and finally unquote slashes and other funny characters
    return urllib.unquote(rv)

def pathname2url(pathname):
    """OS-specific conversion from a file system path to a relative URL
    of the 'file' scheme; not recommended for general use."""
    if '/' in pathname:
        raise RuntimeError, "Cannot convert pathname containing slashes"
    components = pathname.split(':')
    # Remove empty first and/or last component
    if components[0] == '':
        del components[0]
    if components[-1] == '':
        del components[-1]
    # Replace empty string ('::') by .. (will result in '/../' later)
    for i in range(len(components)):
        if components[i] == '':
            components[i] = '..'
    # Truncate names longer than 31 bytes
    components = map(_pncomp2url, components)

    if os.path.isabs(pathname):
        return '/' + '/'.join(components)
    else:
        return '/'.join(components)

def _pncomp2url(component):
    component = urllib.quote(component[:31], safe='')  # We want to quote slashes
    return component

filename:/usr/lib/python2.7/sre_compile.pyc
__doc__
Û
/0Xc           @   sœ  d  Z  d d l Z d d l Z d d l Z d d l Te j e k sO t d É Ç e j d k rg d Z n d Z e	 e
 e g É Z e	 e e e g É Z e	 e e g É Z e	 e e g É Z d5 d6 d7 d8 d9 d: d; d< d= d> d? d@ dA f Z d# Ñ  e DÉ Z d$ Ñ  Z d d d% Ñ Z d& Ñ  Z d' Ñ  Z e j d( Z d) d* d+ Z e e  d, Ñ Z! d- Ñ  Z" d. Ñ  Z# d/ Ñ  Z$ y e% Wn  e& k
 rée' d0 É f Z( n Xe' d0 É e' e% d0 É É f Z( d1 Ñ  Z) d2 Ñ  Z* d3 d4 Ñ Z+ d S(B   s   Internal support module for sreiˇˇˇˇN(   t   *s   SRE module mismatchi   iˇˇ  l   ˇˇ ii   i1  is   i  iµ   iº  iE  iπ  iæ  i≤  i–  iµ  iı  i∏  i—  i∫  i  i¿  i÷  i¡  iÒ  i¬  i√  i∆  i’  ia  iõ  c            s<   i  |  ]2 } | D]% â  t  á  f d  Ü  | DÉ É à  ì q q S(   c         3   s!   |  ] } à  | k r | Vq d  S(   N(    (   t   .0t   j(   t   i(    s!   /usr/lib/python2.7/sre_compile.pys	   <genexpr>=   s    (   t   tuple(   R   t   t(    (   R   s!   /usr/lib/python2.7/sre_compile.pys
   <dictcomp>=   s   	c         C   s◊  |  j  } t } t } t } t } t } | t @rO | t @rO | t @rO t	 }	 n d  }	 x{| D]s\ }
 } |
 | k rv| t @r[t j | | É } |	 r<| |	 k r<| t t É | |  É } | d É |
 t k r„ | t t É n  x1 | f |	 | D] } | t t É | | É qı W| t t É | |  É | |  | <qs| t t |
 É | | É qœ| t |
 É | | É q\ |
 t k r| t @r≠| t t |
 É | d Ñ } n | t |
 É d  } | |  É } | d É t | | |  | |	 É | |  É | |  | <q\ |
 t k r<| t @r+| t t É qœ| t t É q\ |
 | k r| t @r‘t d Ç | t t É | |  É } | d É | | d É | | d É t |  | d | É | t t É | |  É | |  | <qœt | É rÇ|
 t k	 rÇ|
 t k r	| t t  É n | t t! É | |  É } | d É | | d É | | d É t |  | d | É | t t É | |  É | |  | <qœ| t t É | |  É } | d É | | d É | | d É t |  | d | É | |  É | |  | <|
 t k r| t t" É qœ| t t# É q\ |
 t$ k r°| d rU| t t% É | | d d d É n  t |  | d | É | d rœ| t t% É | | d d d d É qœq\ |
 | k ræ| t |
 É q\ |
 | k r|| t |
 É | |  É } | d É | d d k r| d É n8 | d j& É  \ } } | | k r9t d Ç n  | | É t |  | d | É | t t É | |  É | |  | <q\ |
 t' k r·| t |
 É | |  É } | d É t |  | | É | t t É | |  É | |  | <q\ |
 t( k ri| t |
 É | t) @rt* j+ | | É } n  | t @r9t, j+ | | É } n | t @rXt- j+ | | É } n  | t. | É q\ |
 t/ k r;| t |
 É g  } | j  } xt | d D]h } | |  É } | d É t |  | | É | t t0 É | | |  É É | d É | |  É | |  | <qùW| d É xπ| D] } | |  É | |  | <qWq\ |
 t1 k rî| t |
 É | t @rlt2 | } n | t @rÉt3 | } n  | t4 | É q\ |
 t5 k rﬁ| t @rø| t t |
 É n | t |
 É | | d É q\ |
 t6 k r¿| t |
 É | | d d É | |  É } | d É t |  | d | É | d r•| t t0 É | |  É } | d É | |  É | d |  | <t |  | d | É | |  É | |  | <qœ| |  É | d |  | <q\ t7 d |
 f Ç q\ Wd  S(   Ni    c         S   s   t  j |  | É S(   N(   t   _sret   getlower(   t   literalt   flags(    (    s!   /usr/lib/python2.7/sre_compile.pyt   fixupe   s    s'   internal: unsupported template operatori   i   s(   look-behind requires fixed-width patterns   unsupported operand type(8   t   appendt   lent   _LITERAL_CODESt   _REPEATING_CODESt   _SUCCESS_CODESt   _ASSERT_CODESt   SRE_FLAG_IGNORECASEt   SRE_FLAG_LOCALEt   SRE_FLAG_UNICODEt   _ignorecase_fixest   NoneR   R   t   OPCODESt	   IN_IGNOREt   NOT_LITERALt   NEGATEt   LITERALt   FAILUREt	   OP_IGNOREt   INt   _compile_charsett   ANYt   SRE_FLAG_DOTALLt   ANY_ALLt   SRE_FLAG_TEMPLATEt   errort   REPEATt   _compilet   SUCCESSt   _simplet
   MAX_REPEATt
   REPEAT_ONEt   MIN_REPEAT_ONEt	   MAX_UNTILt	   MIN_UNTILt
   SUBPATTERNt   MARKt   getwidtht   CALLt   ATt   SRE_FLAG_MULTILINEt   AT_MULTILINEt   gett	   AT_LOCALEt
   AT_UNICODEt   ATCODESt   BRANCHt   JUMPt   CATEGORYt	   CH_LOCALEt
   CH_UNICODEt   CHCODESt   GROUPREFt   GROUPREF_EXISTSt
   ValueError(   t   codet   patternR	   t   emitt   _lent   LITERAL_CODESt   REPEATING_CODESt   SUCCESS_CODESt   ASSERT_CODESt   fixest   opt   avt   lot   skipt   kR
   t   hit   tailt
   tailappendt   skipyest   skipno(    (    s!   /usr/lib/python2.7/sre_compile.pyR%   @   s:   	

	
 

 


	 
 
 


  

 



	 
 




 

 
c         C   sB  | j  } x$t |  | | | t @É D]	\ } } | t | É | t k rL q# | t k re | | É q# | t k rê | | d É | | d É q# | t k r¨ | j | É q# | t	 k r» | j | É q# | t
 k r#| t @rÛ | t t | É q,| t @r| t t | É q,| t | É q# t d Ç q# W| t t É d  S(   Ni    i   s"   internal: unsupported set operator(   R   t   _optimize_charsetR   R   R   R   t   RANGEt   CHARSETt   extendt
   BIGCHARSETR:   R   R=   R;   R<   R#   R   (   t   charsetR	   RA   R
   RI   RC   RJ   RK   (    (    s!   /usr/lib/python2.7/sre_compile.pyR   ‰   s.    	

c         C   sÚ  g  } g  } t  d É } xp|  D]h\ } } xYt rÜyZ| t k r£ | rñ | | É }	 d | |	 <| r† |	 | k r† x | |	 D] }
 d | |
 <q| Wq† qçd | | <nÍ | t k rXt | d | d d É } | r‚ t | | É } n  | r:| r:xd | D]> }	 d | |	 <|	 | k rı x | |	 D] }
 d | |
 <qWqı qı WqçxP | D] }	 d | |	 <qAWn5 | t k rz| j | | f É n | j | | f É WnÒ t k
 rÅt	 | É d k rƒ| d d 7} q. n  | rk| rk| t k rk| \ } } | g } t
 t d | É t d | É | | É xe | D]G \ } } | | k rK| j t | f É q| j t | | f f É qWqÇ| j | | f É n XPq. Wq Wg  } d } xñ t r/| j d | É } | d k  r¬Pn  t	 | É d	 k rﬁd  } Pn  | j d | É } | d k  r| j | t	 | É f É Pn  | j | | f É qöW| d  k	 r∆xW | D]O \ } } | | d k ru| j t | f É qC| j t | | d f f É qCW| | 7} | sæt	 | É t	 |  É k  r¬| S|  St	 | É d k rt | É } | j t | f É | | 7} | St | É } i  } t  d É } d } t  É  } xv t d d d É D]b }	 | |	 |	 d !} | | k r}| | | |	 d <qE| | |	 d <| | <| d 7} | | 7} qEWt | É } | g t | É | d d +| j t | f É | | 7} | S(
   Ni   i   i    t    i ˇ  i   iˇ s   i   (   t	   bytearrayt   TrueR   RU   t   ranget   mapR   R   t
   IndexErrorR   t   _fixup_ranget   maxt   mint   findR   t
   _mk_bitmapRV   t   bytest   _bytes_to_codesRX   (   RY   R
   RI   t	   isunicodet   outRP   t   charmapRJ   RK   R   RN   t   rRL   RO   t   rangest   runst   qt   pt   datat   compst   mappingt   blockt   chunk(    (    s!   /usr/lib/python2.7/sre_compile.pyRT      s≤    	

	
 		!

	

c         C   sﬁ   x◊ t  | t |  | d É É D]π } x∞ t | É D]è \ } \ }  } | |  k  rã t |  d k rq | | f | | <n | j | | | f É Pq0 | | k ræ | | d k rø |  | f | | <Pqø q0 Pq0 W| j | | f É q Wd  S(   Ni   (   R^   R]   t	   enumeratet   lt   insertR   (   RL   RO   Rk   R
   R   RN   (    (    s!   /usr/lib/python2.7/sre_compile.pyR`   á  s    #i   t   0t   1iˇ   c         C   s`   t  |  É j t É d  d  d Ö } g  t t | É d | É D]  } | | | | | !d É ^ q< S(   Niˇˇˇˇi    i   (   Re   t	   translatet   _BITS_TRANSR]   R   (   t   bitst	   _CODEBITSt   _intt   sR   (    (    s!   /usr/lib/python2.7/sre_compile.pyRd   õ  s    "c         C   sâ   d d  l  } t j d k r$ d } n d } | j  | t |  É É } | j t j k sZ t Ç t | É | j t |  É k s t Ç | j É  S(   Niˇˇˇˇi   t   Ht   I(   t   arrayR   t   CODESIZERe   t   itemsizet   AssertionErrorR   t   tolist(   t   bRÅ   RA   t   a(    (    s!   /usr/lib/python2.7/sre_compile.pyRf   †  s    	%c         C   sH   |  d j  É  \ } } | | k o- d k n oG |  d d d t k S(   Ni   i   i    (   R/   R-   (   RK   RL   RO   (    (    s!   /usr/lib/python2.7/sre_compile.pyR'   ¨  s    c         C   si  | j  É  \ } } | d k r" d  Sg  } | j } d } g  } | j }	 | t @sfx£ | j D]ò \ }
 } |
 t k rû t | É | k rë | d } n  | | É qZ |
 t k rÒ t | d É d k rÒ | d d \ }
 } |
 t k rÌ | | É qÚ PqZ PqZ W| rf| j rf| j d \ }
 } |
 t k rÿ| d rÿ| d d \ }
 } |
 t k rb|	 |
 | f É q`|
 t k r`g  } | j } xU | d D]@ } | sòPn  | d \ }
 } |
 t k r«| |
 | f É qàPqàW| } q`qc|
 t k rKg  } | j } xj | d D]@ } | sPn  | d \ }
 } |
 t k r=| |
 | f É q˛Pq˛W| } qc|
 t k rc| } qcqfn  |  j } | t	 t
 É t |  É } | d É d } | r‡t } t | É | k oÀt | j É k n rÛ| t } qÛn | rÛ| t } n  | | É | t k  r| | É n | t É | t  } | t k  rC| | É n
 | d É | r8| t | É É | | É |  j | É d g d g t | É } xç t t | É É D]y } | | d | | d <xZ | | d d k r| | | | | d d k r| | | d d d | | d <q∆WqßW|  j | d É n | rQt | | |  É n  t |  É | |  | <d  S(   Ni    i   iˇˇˇˇ(   R/   R   R   Ro   R   R   R-   R8   R   R   t   INFOt   SRE_INFO_PREFIXt   SRE_INFO_LITERALt   SRE_INFO_CHARSETt   MAXCODERW   t   xrangeR   (   RA   RB   R	   RL   RO   t   prefixt   prefixappendt   prefix_skipRY   t   charsetappendRJ   RK   t   ct   cappendRn   RC   RM   t   maskt   tableR   (    (    s!   /usr/lib/python2.7/sre_compile.pyt   _compile_info±  s§    		
"				 
+




7*t    c         C   s(   x! t  D] } t |  | É r d Sq Wd S(   Ni   i    (   t   STRING_TYPESt
   isinstance(   t   objt   tp(    (    s!   /usr/lib/python2.7/sre_compile.pyt   isstring"  s    c         C   sN   |  j  j | B} g  } t | |  | É t | |  j | É | j t t É | S(   N(   RB   R	   Rñ   R%   Ro   R   R   R&   (   Rn   R	   RA   (    (    s!   /usr/lib/python2.7/sre_compile.pyt   _code(  s    i    c         C   s”   t  |  É r' |  } t j |  | É }  n d  } t |  | É } |  j j d k r] t d É Ç n  |  j j } d  g |  j j } x$ | j	 É  D] \ } } | | | <qâ Wt
 j | | |  j j B| |  j j d | | É S(   Nid   s6   sorry, but this version only supports 100 named groupsi   (   Rú   t	   sre_parset   parseR   Rù   RB   t   groupsRÑ   t	   groupdictt   itemsR   t   compileR	   (   Rn   R	   RB   RA   t
   groupindext
   indexgroupRN   R   (    (    s!   /usr/lib/python2.7/sre_compile.pyR£   7  s     (   ii   i1  (   is   i  (   iµ   iº  (   iE  iπ  iæ  (   i≤  i–  (   iµ  iı  (   i∏  i—  (   i∫  i  (   i¿  i÷  (   i¡  iÒ  (   i¬  i√  (   i∆  i’  (   ia  iõ  (,   t   __doc__R   t   sysRû   t   sre_constantst   MAGICRÑ   RÇ   Rå   t   setR   R   R   R$   t
   MIN_REPEATR(   R   R&   R   R   t   ASSERTt
   ASSERT_NOTR   t   _equivalencesR   R%   R   R   RT   R`   R|   Rz   t   intRd   Rf   R'   Rñ   t   unicodet	   NameErrort   typeRò   Rú   Rù   R£   (    (    (    s!   /usr/lib/python2.7/sre_compile.pyt   <module>   sX   
		
	§	á				j		
filename:/usr/lib/python2.7/struct.pyc
__doc__
Û
/0Xc           @   s.   d  d l  Td  d l  m Z d  d l  m Z d S(   iˇˇˇˇ(   t   *(   t   _clearcache(   t   __doc__N(   t   _structR   R   (    (    (    s   /usr/lib/python2.7/struct.pyt   <module>   s   

filename:/usr/lib/python2.7/inspect.pyc
__doc__
Û
/0Xc        	   @   sŒ  d  Z  d Z d Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l	 Z	 d d l
 Z
 d d l Z d d l m Z d d l m Z d^ \ Z Z Z Z d_ \ Z Z Z d` Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e e d É rd Ñ  Z n	 d Ñ  Z e e d É r1d Ñ  Z n	 d Ñ  Z d Ñ  Z  d Ñ  Z! d Ñ  Z" d Ñ  Z# d Ñ  Z$ d Ñ  Z% d  Ñ  Z& d! Ñ  Z' d" Ñ  Z( d d# Ñ Z* e d$ d% É Z+ d& Ñ  Z, d' Ñ  Z- d( Ñ  Z. d) Ñ  Z/ d* Ñ  Z0 d+ Ñ  Z1 d, Ñ  Z2 e d- d. É Z3 d/ Ñ  Z4 d0 Ñ  Z5 d1 Ñ  Z6 d d2 Ñ Z7 i  Z8 i  Z9 d d3 Ñ Z: d4 Ñ  Z; d5 Ñ  Z< d6 e= f d7 Ñ  É  YZ> d8 da d9 Ñ  É  YZ? d: Ñ  Z@ d; Ñ  ZA d< Ñ  ZB d= Ñ  ZC d> d? Ñ ZD e d@ dA É ZE dB Ñ  ZF e dC dD É ZG dE Ñ  ZH e dF dG É ZI dH Ñ  ZJ dI Ñ  ZK eK dJ Ñ ZL d d d eM dK Ñ  dL Ñ  dM Ñ  eK dN Ñ ZN eM dO Ñ  dP Ñ  dQ Ñ  eK dR Ñ ZO dS Ñ  ZP e dT dU É ZQ d dV Ñ ZR dW Ñ  ZS d dX Ñ ZT d dY Ñ ZU e e dZ É r¶e jV ZW n d d[ Ñ ZW d d\ Ñ ZX d d] Ñ ZY d S(b   s≤  Get useful information from live Python objects.

This module encapsulates the interface provided by the internal special
attributes (func_*, co_*, im_*, tb_*, etc.) in a friendlier fashion.
It also provides some help for examining source code and class layout.

Here are some of the useful functions provided by this module:

    ismodule(), isclass(), ismethod(), isfunction(), isgeneratorfunction(),
        isgenerator(), istraceback(), isframe(), iscode(), isbuiltin(),
        isroutine() - check object types
    getmembers() - get members of an object that satisfy a given condition

    getfile(), getsourcefile(), getsource() - find an object's source code
    getdoc(), getcomments() - get documentation on an object
    getmodule() - determine the module that an object came from
    getclasstree() - arrange classes so as to represent their hierarchy

    getargspec(), getargvalues(), getcallargs() - get info about function arguments
    formatargspec(), formatargvalues() - format an argument spec
    getouterframes(), getinnerframes() - get info about frames
    currentframe() - get the current stack frame
    stack(), trace() - get info about frames on the stack or in a traceback
s   Ka-Ping Yee <ping@lfw.org>s
   1 Jan 2001iˇˇˇˇN(   t
   attrgetter(   t
   namedtuplei   i   i   i   i   i    i@   i   c         C   s   t  |  t j É S(   s¡   Return true if the object is a module.

    Module objects provide these attributes:
        __doc__         documentation string
        __file__        filename (missing for built-in modules)(   t
   isinstancet   typest
   ModuleType(   t   object(    (    s   /usr/lib/python2.7/inspect.pyt   ismodule3   s    c         C   s   t  |  t t j f É S(   s∆   Return true if the object is a class.

    Class objects provide these attributes:
        __doc__         documentation string
        __module__      name of module in which this class was defined(   R   t   typeR   t	   ClassType(   R   (    (    s   /usr/lib/python2.7/inspect.pyt   isclass;   s    c         C   s   t  |  t j É S(   s™  Return true if the object is an instance method.

    Instance method objects provide these attributes:
        __doc__         documentation string
        __name__        name with which this method was defined
        im_class        class object in which this method belongs
        im_func         function object containing implementation of method
        im_self         instance to which this method is bound, or None(   R   R   t
   MethodType(   R   (    (    s   /usr/lib/python2.7/inspect.pyt   ismethodC   s    	c         C   sD   t  |  d É oC t  |  d É oC t |  É oC t |  É oC t |  É S(   sï  Return true if the object is a method descriptor.

    But not if ismethod() or isclass() or isfunction() are true.

    This is new in Python 2.2, and, for example, is true of int.__add__.
    An object passing this test has a __get__ attribute but not a __set__
    attribute, but beyond that the set of attributes varies.  __name__ is
    usually sensible, and __doc__ often is.

    Methods implemented via descriptors that also pass one of the other
    tests return false from the ismethoddescriptor() test, simply because
    the other tests promise more -- you can, e.g., count on having the
    im_func attribute (etc) when an object passes ismethod().t   __get__t   __set__(   t   hasattrR   t
   isfunctionR	   (   R   (    (    s   /usr/lib/python2.7/inspect.pyt   ismethoddescriptorN   s
    c         C   s   t  |  d É o t  |  d É S(   sÄ  Return true if the object is a data descriptor.

    Data descriptors have both a __get__ and a __set__ attribute.  Examples are
    properties (defined in Python) and getsets and members (defined in C).
    Typically, data descriptors will also have __name__ and __doc__ attributes
    (properties, getsets, and members have both of these attributes), but this
    is not guaranteed.R   R   (   R   (   R   (    (    s   /usr/lib/python2.7/inspect.pyt   isdatadescriptorb   s    t   MemberDescriptorTypec         C   s   t  |  t j É S(   sè   Return true if the object is a member descriptor.

        Member descriptors are specialized descriptors defined in extension
        modules.(   R   R   R   (   R   (    (    s   /usr/lib/python2.7/inspect.pyt   ismemberdescriptorn   s    c         C   s   t  S(   sè   Return true if the object is a member descriptor.

        Member descriptors are specialized descriptors defined in extension
        modules.(   t   False(   R   (    (    s   /usr/lib/python2.7/inspect.pyR   v   s    t   GetSetDescriptorTypec         C   s   t  |  t j É S(   sè   Return true if the object is a getset descriptor.

        getset descriptors are specialized descriptors defined in extension
        modules.(   R   R   R   (   R   (    (    s   /usr/lib/python2.7/inspect.pyt   isgetsetdescriptor   s    c         C   s   t  S(   sè   Return true if the object is a getset descriptor.

        getset descriptors are specialized descriptors defined in extension
        modules.(   R   (   R   (    (    s   /usr/lib/python2.7/inspect.pyR   á   s    c         C   s   t  |  t j É S(   s  Return true if the object is a user-defined function.

    Function objects provide these attributes:
        __doc__         documentation string
        __name__        name with which this function was defined
        func_code       code object containing compiled function bytecode
        func_defaults   tuple of any default values for arguments
        func_doc        (same as __doc__)
        func_globals    global namespace in which this function was defined
        func_name       (same as __name__)(   R   R   t   FunctionType(   R   (    (    s   /usr/lib/python2.7/inspect.pyR   é   s    c         C   s,   t  t |  É s t |  É o( |  j j t @É S(   s∏   Return true if the object is a user-defined generator function.

    Generator function objects provides same attributes as functions.

    See help(isfunction) for attributes listing.(   t   boolR   R   t	   func_codet   co_flagst   CO_GENERATOR(   R   (    (    s   /usr/lib/python2.7/inspect.pyt   isgeneratorfunctionõ   s    c         C   s   t  |  t j É S(   s  Return true if the object is a generator.

    Generator objects provide these attributes:
        __iter__        defined to support iteration over container
        close           raises a new GeneratorExit exception inside the
                        generator to terminate the iteration
        gi_code         code object
        gi_frame        frame object or possibly None once the generator has
                        been exhausted
        gi_running      set to 1 when generator is executing, 0 otherwise
        next            return the next item from the container
        send            resumes the generator and "sends" a value that becomes
                        the result of the current yield-expression
        throw           used to raise an exception inside the generator(   R   R   t   GeneratorType(   R   (    (    s   /usr/lib/python2.7/inspect.pyt   isgenerator§   s    c         C   s   t  |  t j É S(   sb  Return true if the object is a traceback.

    Traceback objects provide these attributes:
        tb_frame        frame object at this level
        tb_lasti        index of last attempted instruction in bytecode
        tb_lineno       current line number in Python source code
        tb_next         next inner traceback object (called by this level)(   R   R   t   TracebackType(   R   (    (    s   /usr/lib/python2.7/inspect.pyt   istracebackµ   s    c         C   s   t  |  t j É S(   s|  Return true if the object is a frame object.

    Frame objects provide these attributes:
        f_back          next outer frame object (this frame's caller)
        f_builtins      built-in namespace seen by this frame
        f_code          code object being executed in this frame
        f_exc_traceback traceback if raised in this frame, or None
        f_exc_type      exception type if raised in this frame, or None
        f_exc_value     exception value if raised in this frame, or None
        f_globals       global namespace seen by this frame
        f_lasti         index of last attempted instruction in bytecode
        f_lineno        current line number in Python source code
        f_locals        local namespace seen by this frame
        f_restricted    0 or 1 if frame is in restricted execution mode
        f_trace         tracing function for this frame, or None(   R   R   t	   FrameType(   R   (    (    s   /usr/lib/python2.7/inspect.pyt   isframeø   s    c         C   s   t  |  t j É S(   su  Return true if the object is a code object.

    Code objects provide these attributes:
        co_argcount     number of arguments (not including * or ** args)
        co_code         string of raw compiled bytecode
        co_consts       tuple of constants used in the bytecode
        co_filename     name of file in which this code object was created
        co_firstlineno  number of first line in Python source code
        co_flags        bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg
        co_lnotab       encoded mapping of line numbers to bytecode indices
        co_name         name with which this code object was defined
        co_names        tuple of names of local variables
        co_nlocals      number of local variables
        co_stacksize    virtual machine stack space required
        co_varnames     tuple of names of arguments and local variables(   R   R   t   CodeType(   R   (    (    s   /usr/lib/python2.7/inspect.pyt   iscode—   s    c         C   s   t  |  t j É S(   s,  Return true if the object is a built-in function or method.

    Built-in functions and methods provide these attributes:
        __doc__         documentation string
        __name__        original name of this function or method
        __self__        instance to which a method is bound, or None(   R   R   t   BuiltinFunctionType(   R   (    (    s   /usr/lib/python2.7/inspect.pyt	   isbuiltin„   s    c         C   s.   t  |  É p- t |  É p- t |  É p- t |  É S(   s<   Return true if the object is any kind of function or method.(   R&   R   R   R   (   R   (    (    s   /usr/lib/python2.7/inspect.pyt	   isroutineÏ   s    c         C   s    t  t |  t É o |  j t @É S(   s:   Return true if the object is an abstract base class (ABC).(   R   R   R   t	   __flags__t   TPFLAGS_IS_ABSTRACT(   R   (    (    s   /usr/lib/python2.7/inspect.pyt
   isabstractÛ   s    c         C   s~   g  } xg t  |  É D]Y } y t |  | É } Wn t k
 rB q n X| sV | | É r | j | | f É q q W| j É  | S(   sä   Return all members of an object as (name, value) pairs sorted by name.
    Optionally, only return members that satisfy a given predicate.(   t   dirt   getattrt   AttributeErrort   appendt   sort(   R   t	   predicatet   resultst   keyt   value(    (    s   /usr/lib/python2.7/inspect.pyt
   getmembers˜   s    
t	   Attributes   name kind defining_class objectc   
      C   sb  t  |  É } t |  É } g  } x=| D]5} d } x\ |  f | D], } | | j k r? | j | } | } Pq? q? Wt |  | É } t | d | É } t | t É r® d } nñ t | t É r¿ d } n~ t | t É rÿ d } nf t	 | É rÌ d } nQ t
 | É rd } n< t |  | É }	 t |	 É s)t	 |	 É r2d } n d } |	 } | j t | | | | É É q% W| S(   sÅ  Return list of attribute-descriptor tuples.

    For each name in dir(cls), the return list contains a 4-tuple
    with these elements:

        0. The name (a string).

        1. The kind of attribute this is, one of these strings:
               'class method'    created via classmethod()
               'static method'   created via staticmethod()
               'property'        created via property()
               'method'          any other flavor of method
               'data'            not a method

        2. The class which defined this attribute (a class).

        3. The object as obtained directly from the defining class's
           __dict__, not via getattr.  This is especially important for
           data attributes:  C.data is just a data object, but
           C.__dict__['data'] may be a data descriptor with additional
           info, like a __doc__ string.
    t   __objclass__s   static methods   class methodt   propertyt   methodt   dataN(   t   getmroR+   t   Nonet   __dict__R,   R   t   staticmethodt   classmethodR7   R   R   R   R.   R5   (
   t   clst   mrot   namest   resultt   namet   homeclst   baset   objt   kindt   obj_via_getattr(    (    s   /usr/lib/python2.7/inspect.pyt   classify_class_attrs  s<    						 c         C   sB   |  | k r d  S| j  |  É x |  j D] } t | | É q' Wd  S(   N(   R.   t	   __bases__t   _searchbases(   R?   t   accumRE   (    (    s   /usr/lib/python2.7/inspect.pyRK   L  s
    c         C   s7   t  |  d É r |  j Sg  } t |  | É t | É Sd S(   sH   Return tuple of base classes (including cls) in method resolution order.t   __mro__N(   R   RM   RK   t   tuple(   R?   RB   (    (    s   /usr/lib/python2.7/inspect.pyR:   T  s
    c         C   s,   t  j |  É } t | É t t  j | É É S(   sB   Return the indent size, in spaces, at the start of a line of text.(   t   stringt
   expandtabst   lent   lstrip(   t   linet   expline(    (    s   /usr/lib/python2.7/inspect.pyt
   indentsize^  s    c         C   sB   y |  j  } Wn t k
 r! d SXt | t j É s8 d St | É S(   s˘   Get the documentation string for an object.

    All tabs are expanded to spaces.  To clean up docstrings that are
    indented to line up with blocks of code, any whitespace than can be
    uniformly removed from the second line onwards is removed.N(   t   __doc__R-   R;   R   R   t   StringTypest   cleandoc(   R   t   doc(    (    s   /usr/lib/python2.7/inspect.pyt   getdocc  s    c         C   sK  y t  j t  j |  É d É } Wn t k
 r3 d SXt j } xO | d D]C } t t  j | É É } | rH t | É | } t	 | | É } qH qH W| r¨ | d j É  | d <n  | t j k  r x2 t
 d t | É É D] } | | | | | <q— Wn  x | r| d r| j É  qÛ Wx" | r6| d r6| j d É qWt  j | d É Sd S(   sÑ   Clean up indentation from docstrings.

    Any whitespace that can be uniformly removed from the second line
    onwards is removed.s   
i   i    iˇˇˇˇN(   RO   t   splitRP   t   UnicodeErrorR;   t   syst   maxintRQ   RR   t   mint   ranget   popt   join(   RY   t   linest   marginRS   t   contentt   indentt   i(    (    s   /usr/lib/python2.7/inspect.pyRX   q  s(    	 c         C   s  t  |  É r: t |  d É r" |  j St d j |  É É Ç n  t |  É râ t j j |  j	 É }  t |  d É rq |  j St d j |  É É Ç n  t
 |  É r° |  j }  n  t |  É rπ |  j }  n  t |  É r— |  j }  n  t |  É rÈ |  j }  n  t |  É r¸ |  j St d j |  É É Ç d S(   s@   Work out which source or compiled file an object was defined in.t   __file__s   {!r} is a built-in modules   {!r} is a built-in classsO   {!r} is not a module, class, method, function, traceback, frame, or code objectN(   R   R   Rh   t	   TypeErrort   formatR	   R]   t   modulest   gett
   __module__R   t   im_funcR   R   R    t   tb_frameR"   t   f_codeR$   t   co_filename(   R   (    (    s   /usr/lib/python2.7/inspect.pyt   getfileé  s*    	t
   ModuleInfos   name suffix mode module_typec         C   s|   t  j j |  É } t d Ñ  t j É  É } | j É  xA | D]9 \ } } } } | | | k r; t | |  | | | É Sq; Wd S(   sD   Get the module name, suffix, mode, and module type for a given file.c         S   s'   t  |  d É |  d |  d |  d f S(   Ni    i   i   (   RQ   (   t   info(    (    s   /usr/lib/python2.7/inspect.pyt   <lambda>´  s    N(   t   ost   patht   basenamet   mapt   impt   get_suffixesR/   Rs   (   Rw   t   filenamet   suffixest   neglent   suffixt   modet   mtype(    (    s   /usr/lib/python2.7/inspect.pyt   getmoduleinfo®  s    	
c         C   s   t  |  É } | r | d Sd S(   s1   Return the module name for a given file, or None.i    N(   RÇ   (   Rw   Rt   (    (    s   /usr/lib/python2.7/inspect.pyt   getmodulename≥  s     c         C   sœ   t  |  É } t j | d É d k r6 | d  d } n  xM t j É  D]? \ } } } d | k rC t j | t | É É | k rC d SqC Wt j j	 | É rú | St
 t |  | É d É r∏ | S| t j k rÀ | Sd S(	   sÜ   Return the filename that can be used to locate an object's source.
    Return None if no way can be identified to get the source.
    i¸ˇˇˇs   .pycs   .pyos   .pyt   bt
   __loader__N(   s   .pycs   .pyo(   Rr   RO   t   lowerRz   R{   RQ   R;   Rv   Rw   t   existsR   t	   getmodulet	   linecachet   cache(   R   R|   R   RÄ   RG   (    (    s   /usr/lib/python2.7/inspect.pyt   getsourcefile∏  s    ,c         C   sC   | d k r' t |  É p! t |  É } n  t j j t j j | É É S(   sæ   Return an absolute path to the source or compiled file for an object.

    The idea is for each object to have a unique origin, so this routine
    normalizes the result as much as possible.N(   R;   Rã   Rr   Rv   Rw   t   normcaset   abspath(   R   t	   _filename(    (    s   /usr/lib/python2.7/inspect.pyt
   getabsfileÃ  s    c   
      C   s  t  |  É r |  St |  d É r2 t j j |  j É S| d k	 r^ | t k r^ t j j t | É Sy t |  | É } Wn t	 k
 rÖ d SX| t k r¶ t j j t | É Sxô t j j
 É  D]à \ } } t  | É r∂ t | d É r∂ | j } | t j | d É k rq∂ n  | t | <t | É } | j t | <t t j j | É <q∂ q∂ W| t k rbt j j t | É St j d } t |  d É sÇd St | |  j É rπt | |  j É } | |  k rπ| Sn  t j d } t | |  j É r˝t | |  j É }	 |	 |  k r˝| Sn  d S(   sA   Return the module an object was defined in, or None if not found.Rm   Rh   t   __main__t   __name__t   __builtin__N(   R   R   R]   Rk   Rl   Rm   R;   t   modulesbyfileRè   Ri   t   itemsRh   t   _filesbymodnameRë   Rv   Rw   t   realpathR,   (
   R   Ré   t   filet   modnamet   modulet   ft   maint
   mainobjectt   builtint   builtinobject(    (    s   /usr/lib/python2.7/inspect.pyRà   ÿ  sD    	
(c         C   sâ  t  |  É } t |  É } | rF | d  | d d k rF t d É Ç n  | rR | n | } t |  | É } | rÖ t j | | j É } n t j | É } | s© t d É Ç n  t |  É rø | d f St |  É rï|  j	 } t
 j d | d É } g  } xp t t | É É D]\ } | j | | É }	 |	 r| | d d	 k rA| | f S| j |	 j d É | f É qqW| rÜ| j É  | | d d f St d
 É Ç n  t |  É r≠|  j }  n  t |  É r≈|  j }  n  t |  É r›|  j }  n  t |  É rı|  j }  n  t |  É ryt |  d É st d É Ç n  |  j d }
 t
 j d É } x1 |
 d k rn| j | |
 É raPn  |
 d }
 q>W| |
 f St d É Ç d S(   sb  Return the entire source file and starting line number for an object.

    The argument may be a module, class, method, function, traceback, frame,
    or code object.  The source code is returned as a list of all the lines
    in the file and the line number indexes a line in that list.  An IOError
    is raised if the source code cannot be retrieved.i   iˇˇˇˇs   <>s   source code not availables   could not get source codei    s   ^(\s*)class\s*s   \bt   cs   could not find class definitiont   co_firstlinenos"   could not find function definitions+   ^(\s*def\s)|(.*(?<!\w)lambda(:|\s))|^(\s*@)s   could not find code objectN(   Rr   Rã   t   IOErrorRà   Râ   t   getlinesR<   R   R	   Rë   t   ret   compileR`   RQ   t   matchR.   t   groupR/   R   Rn   R   R   R    Ro   R"   Rp   R$   R   R†   (   R   Ró   t
   sourcefileRô   Rc   RC   t   patt
   candidatesRg   R•   t   lnum(    (    s   /usr/lib/python2.7/inspect.pyt
   findsource  s\    
	
#
 
c         C   sÿ  y t  |  É \ } } Wn t t f k
 r0 d SXt |  É r8d } | rf | d d  d k rf d } n  x9 | t | É k  r° t j | | É d	 k r° | d } qi W| t | É k  r‘| | d  d k r‘g  } | } xN | t | É k  r$| | d  d k r$| j t j	 | | É É | d } q◊ Wt j
 | d É Snú| d k r‘t | | É } | d } | d k r‘t j | | É d  d k r‘t | | É | k r‘t j t j	 | | É É g } | d k ra| d } t j t j	 | | É É } xp | d  d k r]t | | É | k r]| g | d *| d } | d k  r>Pn  t j t j	 | | É É } qÒWn  x- | rêt j | d É d k rêg  | d *qdWx- | r¿t j | d É d k r¿g  | d )qîWt j
 | d É Sn  d S(
   sw   Get lines of comments immediately preceding an object's source code.

    Returns None when source can't be found.
    i    i   s   #!i   t    t   #iˇˇˇˇN(   R¨   R≠   (   R´   R°   Ri   R;   R   RQ   RO   t   stripR.   RP   Rb   RU   RR   (   R   Rc   R™   t   startt   commentst   endRf   t   comment(    (    s   /usr/lib/python2.7/inspect.pyt   getcommentsI  sJ     	.&)
)
)
 #""t
   EndOfBlockc           B   s   e  Z RS(    (   Rë   Rm   (    (    (    s   /usr/lib/python2.7/inspect.pyR¥   v  s    t   BlockFinderc           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   s@   Provide a tokeneater() method to detect the end of a code block.c         C   s1   d |  _  t |  _ t |  _ t |  _ d |  _ d  S(   Ni    i   (   Rf   R   t   islambdat   startedt   passlinet   last(   t   self(    (    s   /usr/lib/python2.7/inspect.pyt   __init__z  s
    				c   
      C   s8  | \ } } | \ } }	 |  j  s] | d k rQ | d k rE t |  _ n  t |  _  n  t |  _ n◊ | t j k rì t |  _ | |  _ |  j r4t Ç q4n° |  j rü nï | t j	 k r  |  j
 d |  _
 t |  _ nj | t j k r|  j
 d |  _
 |  j
 d k r4t Ç q4n0 |  j
 d k r4| t j t j f k r4t Ç n  d  S(   Nt   deft   classt   lambdai   i    (   s   defs   classs   lambda(   R∑   t   TrueR∂   R∏   t   tokenizet   NEWLINER   Rπ   R¥   t   INDENTRf   t   DEDENTt   COMMENTt   NL(
   R∫   R   t   tokent	   srow_scolt	   erow_ecolRS   t   srowt   scolt   erowt   ecol(    (    s   /usr/lib/python2.7/inspect.pyt
   tokeneaterÅ  s0    					'(   Rë   Rm   RV   Rª   RÕ   (    (    (    s   /usr/lib/python2.7/inspect.pyRµ   x  s   	c         C   sN   t  É  } y  t j t |  É j | j É Wn t t f k
 rB n X|  | j  S(   s@   Extract the block of code at the top of the given list of lines.(   Rµ   R¿   t   itert   nextRÕ   R¥   t   IndentationErrorRπ   (   Rc   t   blockfinder(    (    s   /usr/lib/python2.7/inspect.pyt   getblock°  s    	 c         C   sD   t  |  É \ } } t |  É r( | d f St | | É | d f Sd S(   s£  Return a list of source lines and starting line number for an object.

    The argument may be a module, class, method, function, traceback, frame,
    or code object.  The source code is returned as a list of the lines
    corresponding to the object and the line number indicates where in the
    original source file the first line of code was found.  An IOError is
    raised if the source code cannot be retrieved.i    i   N(   R´   R   R“   (   R   Rc   R™   (    (    s   /usr/lib/python2.7/inspect.pyt   getsourcelines™  s     
c         C   s"   t  |  É \ } } t j | d É S(   s  Return the text of the source code for an object.

    The argument may be a module, class, method, function, traceback, frame,
    or code object.  The source code is returned as a single string.  An
    IOError is raised if the source code cannot be retrieved.R¨   (   R”   RO   Rb   (   R   Rc   R™   (    (    s   /usr/lib/python2.7/inspect.pyt	   getsource∑  s    c         C   sv   g  } |  j  d t d d É É xP |  D]H } | j | | j f É | | k r& | j t | | | | É É q& q& W| S(   s-   Recursive helper function for getclasstree().R2   Rm   Rë   (   R/   R    R.   RJ   t   walktree(   t   classest   childrent   parentR1   Rü   (    (    s   /usr/lib/python2.7/inspect.pyR’   ¡  s    $i    c         C   sÈ   i  } g  } xù |  D]ï } | j  rå xÉ | j  D]Y } | | k rK g  | | <n  | | | k ro | | j | É n  | r, | |  k r, Pq, q, Wq | | k r | j | É q q Wx* | D]" } | |  k r≥ | j | É q≥ q≥ Wt | | d É S(   sˆ  Arrange the given list of classes into a hierarchy of nested lists.

    Where a nested list appears, it contains classes derived from the class
    whose entry immediately precedes the list.  Each entry is a 2-tuple
    containing a class and a tuple of its base classes.  If the 'unique'
    argument is true, exactly one entry appears in the returned structure
    for each class in the given list.  Otherwise, classes using multiple
    inheritance and their descendants will appear multiple times.N(   RJ   R.   R’   R;   (   R÷   t   uniqueR◊   t   rootsRü   Rÿ   (    (    s   /usr/lib/python2.7/inspect.pyt   getclasstreeÀ  s"    		 t	   Argumentss   args varargs keywordsc         C   sf  t  |  É s$ t d j |  É É Ç n  |  j } |  j } t | |  É } d } x∑t | É D]©} | | d  d k rY g  g  g  } } } xg| t |  j É k  rt	 |  j | É }	 | d } |	 t
 j k rä t
 j |	 }
 t	 |  j | É t	 |  j | d É d } | d } |
 d k r7| j | É | j | É qÌ|
 d
 k rÌ| j | | É | so| d g | d <PqÍ| d d | d <xY | d d k r‹| j É  | j É  } | | g | | )| s«Pn  | d d | d <qÑW| sÍPqÍqÌqä qä W| d | | <qY qY Wd } |  j t @r3|  j | } | d } n  d } |  j t @rV|  j | } n  t | | | É S(   s  Get information about the arguments accepted by a code object.

    Three things are returned: (args, varargs, varkw), where 'args' is
    a list of argument names (possibly containing nested lists), and
    'varargs' and 'varkw' are the names of the * and ** arguments or None.s   {!r} is not a code objecti    i   R¨   t   .i   i   t   UNPACK_TUPLEt   UNPACK_SEQUENCEt
   STORE_FASTiˇˇˇˇ(   R¨   R›   (   Rﬁ   Rﬂ   N(   R$   Ri   Rj   t   co_argcountt   co_varnamest   listR`   RQ   t   co_codet   ordt   dist   HAVE_ARGUMENTt   opnameR.   Ra   R;   R   t
   CO_VARARGSt   CO_VARKEYWORDSR‹   (   t   cot   nargsRA   t   argst   stepRg   t   stackt   remaint   countt   opRË   R3   t   sizet   varargst   varkw(    (    s   /usr/lib/python2.7/inspect.pyt   getargsË  sV    		
,

  t   ArgSpecs   args varargs keywords defaultsc         C   sj   t  |  É r |  j }  n  t |  É s< t d j |  É É Ç n  t |  j É \ } } } t | | | |  j É S(   sl  Get the names and default values of a function's arguments.

    A tuple of four things is returned: (args, varargs, varkw, defaults).
    'args' is a list of the argument names (it may contain nested lists).
    'varargs' and 'varkw' are the names of the * and ** arguments or None.
    'defaults' is an n-tuple of the default values of the last n arguments.
    s   {!r} is not a Python function(	   R   Rn   R   Ri   Rj   Rˆ   R   R˜   t   func_defaults(   t   funcRÌ   RÙ   Rı   (    (    s   /usr/lib/python2.7/inspect.pyt
   getargspec$  s    	t   ArgInfos   args varargs keywords localsc         C   s.   t  |  j É \ } } } t | | | |  j É S(   sW  Get information about arguments passed into a particular frame.

    A tuple of four things is returned: (args, varargs, varkw, locals).
    'args' is a list of the argument names (it may contain nested lists).
    'varargs' and 'varkw' are the names of the * and ** arguments or None.
    'locals' is the locals dictionary of the given frame.(   Rˆ   Rp   R˚   t   f_locals(   t   frameRÌ   RÙ   Rı   (    (    s   /usr/lib/python2.7/inspect.pyt   getargvalues6  s    c         C   s>   t  |  É d k r" d |  d d Sd t j |  d É d Sd  S(   Ni   t   (i    s   ,)s   , t   )(   RQ   RO   Rb   (   t   seq(    (    s   /usr/lib/python2.7/inspect.pyt   joinseq@  s    c         C   sB   t  |  É t t f k r4 | t | | d Ñ |  É É S| |  É Sd S(   s7   Recursively walk a sequence, stringifying each element.c         S   s   t  |  | | É S(   N(   t   strseq(   t   oRü   t   j(    (    s   /usr/lib/python2.7/inspect.pyRu   I  s    N(   R   R„   RN   Ry   (   R   t   convertRb   (    (    s   /usr/lib/python2.7/inspect.pyR  F  s    c         C   s   d |  S(   Nt   *(    (   RC   (    (    s   /usr/lib/python2.7/inspect.pyRu   O  s    c         C   s   d |  S(   Ns   **(    (   RC   (    (    s   /usr/lib/python2.7/inspect.pyRu   P  s    c         C   s   d t  |  É S(   Nt   =(   t   repr(   R3   (    (    s   /usr/lib/python2.7/inspect.pyRu   Q  s    c	         C   sÍ   g  }	 | r% t  |  É t  | É }
 n  xf t |  É D]X \ } } t | | | É } | r} | |
 k r} | | | | |
 É } n  |	 j | É q2 W| d k	 r∞ |	 j | | É É n  | d k	 r“ |	 j | | É É n  d t j |	 d É d S(   sg  Format an argument spec from the 4 values returned by getargspec.

    The first four arguments are (args, varargs, varkw, defaults).  The
    other four arguments are the corresponding optional formatting functions
    that are called to turn names and values into strings.  The ninth
    argument is an optional function to format the sequence of arguments.Rˇ   s   , R   N(   RQ   t	   enumerateR  R.   R;   RO   Rb   (   RÌ   RÙ   Rı   t   defaultst	   formatargt   formatvarargst   formatvarkwt   formatvalueRb   t   specst   firstdefaultRg   t   argt   spec(    (    s   /usr/lib/python2.7/inspect.pyt   formatargspecM  s    c         C   s   d |  S(   NR  (    (   RC   (    (    s   /usr/lib/python2.7/inspect.pyRu   i  s    c         C   s   d |  S(   Ns   **(    (   RC   (    (    s   /usr/lib/python2.7/inspect.pyRu   j  s    c         C   s   d t  |  É S(   NR  (   R	  (   R3   (    (    s   /usr/lib/python2.7/inspect.pyRu   k  s    c	         C   sæ   | | | d Ñ }	 g  }
 x7 t  t |  É É D]# } |
 j t |  | |	 | É É q+ W| r| |
 j | | É | | | É É n  | r¶ |
 j | | É | | | É É n  d t j |
 d É d S(   sf  Format an argument spec from the 4 values returned by getargvalues.

    The first four arguments are (args, varargs, varkw, locals).  The
    next four arguments are the corresponding optional formatting functions
    that are called to turn names and values into strings.  The ninth
    argument is an optional function to format the sequence of arguments.c         S   s   | |  É | | |  É S(   N(    (   RC   t   localsR  R  (    (    s   /usr/lib/python2.7/inspect.pyR  s  s    Rˇ   s   , R   (   R`   RQ   R.   R  RO   Rb   (   RÌ   RÙ   Rı   R  R  R  R  R  Rb   R  R  Rg   (    (    s   /usr/lib/python2.7/inspect.pyt   formatargvaluesg  s    !$$c            sù  t  |  É \ } } } } |  j } i  â  g  â á  á á f d Ü  â á  á f d Ü  } t |  É rÇ |  j d k	 rÇ |  j f | } n  t | É }	 |	 t | É }
 t | É } | rº t | É n d } x* t | | É D] \ } } à | | É q“ W| r*|	 | k rà | | |	 | É qŸà | d É nØ d | k  oA|	 k  n rÜt d | | r[d n d | | d k rsd n d	 |
 f É Ç nS | d k rŸ|
 rŸ| r¿|	 r÷t d
 | |
 f É Ç q÷qŸt d | |
 f É Ç n  xg | D]_ } t | t	 É r‡| | k r‡| | É r&t d | | f É Ç q?à | | j
 | É É q‡q‡W| rçxA t | | | É D]( \ } } | | É s^à | | É q^q^Wn  | r£à | | É nw | rt t | É É } y t Wn t k
 r÷n+ Xt | t É r| j t j É  d É } n  t d | | f É Ç n  | t g  | D] } | | É r'| ^ q'É } | rô| | } t d | | rnd n d | | d k rÜd n d	 |
 f É Ç n  à  S(   sÌ   Get the mapping of arguments to values.

    A dict is returned, with keys the function argument names (including the
    names of the * and ** arguments, if any), and values the respective bound
    values from 'positional' and 'named'.c            s›   t  |  t É r | à  |  <nΩ à j |  É t | É } xs t |  É D]e \ } } y t | É } Wn9 t k
 rô t d | | d k râ d n d f É Ç n Xà | | É qB Wy t | É Wn t k
 rÃ n Xt d É Ç d  S(   Ns   need more than %d %s to unpacki   t   valuesR3   s   too many values to unpack(   R   t   strR.   RŒ   R
  Rœ   t   StopIterationt
   ValueError(   R  R3   Rg   t   subargt   subvalue(   t	   arg2valuet   assignt   assigned_tuple_params(    s   /usr/lib/python2.7/inspect.pyR  ã  s     &c            s#   t  |  t É r |  à  k S|  à k S(   N(   R   R  (   R  (   R  R  (    s   /usr/lib/python2.7/inspect.pyt   is_assignedû  s    
i    s   %s() takes %s %d %s (%d given)s   at mostt   exactlyi   t	   argumentst   arguments)   %s() takes exactly 0 arguments (%d given)s"   %s() takes no arguments (%d given)s2   %s() got multiple values for keyword argument '%s't   replaces,   %s() got an unexpected keyword argument '%s's   at leastN(    (   R˙   Rë   R   t   im_selfR;   RQ   t   zipRi   R   R  Ra   Rœ   RŒ   t   unicodet	   NameErrort   encodeR]   t   getdefaultencoding(   R˘   t
   positionalt   namedRÌ   RÙ   Rı   R  t   f_nameR   t   num_post	   num_totalt   num_argst   num_defaultsR  R3   t
   unexpectedt
   unassignedt   num_required(    (   R  R  R  s   /usr/lib/python2.7/inspect.pyt   getcallargs  st    	%!/
%t	   Tracebacks+   filename lineno function code_context indexc         C   s1  t  |  É r! |  j } |  j }  n	 |  j } t |  É sN t d j |  É É Ç n  t |  É pc t |  É } | d k r| d | d } y t	 |  É \ } } Wn t
 k
 r∑ d } } qXt | d É } t d t | t | É | É É } | | | | !} | d | } n
 d } } t | | |  j j | | É S(   sì  Get information about a frame or traceback object.

    A tuple of five things is returned: the filename, the line number of
    the current line, the function name, a list of lines of context from
    the source code, and the index of the current line within that list.
    The optional second argument specifies the number of lines of context
    to return, which are centered around the current line.s'   {!r} is not a frame or traceback objecti    i   i   N(   R    t	   tb_linenoRo   t   f_linenoR"   Ri   Rj   Rã   Rr   R´   R°   R;   t   maxR_   RQ   R6  Rp   t   co_name(   R˝   t   contextt   linenoR|   RØ   Rc   R™   t   index(    (    s   /usr/lib/python2.7/inspect.pyt   getframeinfo·  s&    		"
c         C   s   |  j  S(   sC   Get the line number from a frame object, allowing for optimization.(   R8  (   R˝   (    (    s   /usr/lib/python2.7/inspect.pyt	   getlineno  s    c         C   s=   g  } x0 |  r8 | j  |  f t |  | É É |  j }  q	 W| S(   s–   Get a list of records for a frame and all higher (calling) frames.

    Each record contains a frame object, filename, line number, function
    name, a list of lines of context, and index within the context.(   R.   R>  t   f_back(   R˝   R;  t	   framelist(    (    s   /usr/lib/python2.7/inspect.pyt   getouterframes  s
    	c         C   s@   g  } x3 |  r; | j  |  j f t |  | É É |  j }  q	 W| S(   s—   Get a list of records for a traceback's frame and all lower frames.

    Each record contains a frame object, filename, line number, function
    name, a list of lines of context, and index within the context.(   R.   Ro   R>  t   tb_next(   t   tbR;  RA  (    (    s   /usr/lib/python2.7/inspect.pyt   getinnerframes  s
    	 t	   _getframec         C   s   d  S(   N(   R;   (   t   _(    (    s   /usr/lib/python2.7/inspect.pyRu      s    c         C   s   t  t j d É |  É S(   s@   Return a list of records for the stack above the caller's frame.i   (   RB  R]   RF  (   R;  (    (    s   /usr/lib/python2.7/inspect.pyRÔ   "  s    c         C   s   t  t j É  d |  É S(   sC   Return a list of records for the stack below the current exception.i   (   RE  R]   t   exc_info(   R;  (    (    s   /usr/lib/python2.7/inspect.pyt   trace&  s    (   i   i   i   i   (   i   i    i@   i   (    (Z   RV   t
   __author__t   __date__R]   Rv   R   RO   R£   RÊ   Rz   R¿   Râ   t   operatorR    t   collectionsR   t   CO_OPTIMIZEDt   CO_NEWLOCALSRÈ   RÍ   t	   CO_NESTEDR   t	   CO_NOFREER)   R   R	   R   R   R   R   R   R   R   R   R   R    R"   R$   R&   R'   R*   R;   R4   R5   RI   RK   R:   RU   RZ   RX   Rr   Rs   RÇ   RÉ   Rã   Rè   Rì   Rï   Rà   R´   R≥   t	   ExceptionR¥   Rµ   R“   R”   R‘   R’   R€   R‹   Rˆ   R˜   R˙   R˚   R˛   R  R  R  R  R  R5  R6  R>  R?  RB  RE  RF  t   currentframeRÔ   RI  (    (    (    s   /usr/lib/python2.7/inspect.pyt   <module>   s∏   					
							
							E		
								.	C	-)				
	
	:		
			`!	
filename:/usr/lib/python2.7/_MozillaCookieJar.pyc
__doc__
Û
/0Xc           @   s`   d  Z  d d l Z d d l Z d d l m Z m Z m Z m Z m Z d e f d Ñ  É  YZ	 d S(   s+   Mozilla / Netscape cookie loading / saving.iˇˇˇˇN(   t   _warn_unhandled_exceptiont   FileCookieJart	   LoadErrort   Cookiet   MISSING_FILENAME_TEXTt   MozillaCookieJarc           B   s5   e  Z d  Z d Z d Z d Ñ  Z d e e d Ñ Z RS(   sí  

    WARNING: you may want to backup your browser's cookies file if you use
    this class to save cookies.  I *think* it works, but there have been
    bugs in the past!

    This class differs from CookieJar only in the format it uses to save and
    load cookies to and from a file.  This class uses the Mozilla/Netscape
    `cookies.txt' format.  lynx uses this file format, too.

    Don't expect cookies saved while the browser is running to be noticed by
    the browser (in fact, Mozilla on unix will overwrite your saved cookies if
    you change them on disk while it's running; on Windows, you probably can't
    save at all while the browser is running).

    Note that the Mozilla/Netscape format will downgrade RFC2965 cookies to
    Netscape cookies on saving.

    In particular, the cookie version and port number information is lost,
    together with information about whether or not Path, Port and Discard were
    specified by the Set-Cookie2 (or Set-Cookie) header, and whether or not the
    domain as set in the HTTP header started with a dot (yes, I'm aware some
    domains in Netscape files start with a dot and some don't -- trust me, you
    really don't want to know any more about this).

    Note that though Mozilla and Netscape use the same format, they use
    slightly different headers.  The class saves cookies using the Netscape
    header by default (Mozilla can cope with that).

    s   #( Netscape)? HTTP Cookie Filesr   # Netscape HTTP Cookie File
# http://curl.haxx.se/rfc/cookie_spec.html
# This is a generated file!  Do not edit.

c         C   s  t  j  É  } | j É  } t j |  j | É sJ | j É  t d | É Ç n  yÅxz| j É  } | d k rl Pn  | j d É rà | d  } n  | j É  j	 d É sP | j É  d k rµ qP n  | j
 d É \ } }	 }
 } } } } | d k } |	 d k }	 | d k r| } d  } n  | j	 d	 É } |	 | k s-t Ç t } | d k rNd  } t } n  t d
 | | d  t | |	 | |
 t | | | d  d  i  É } | rù| j rùqP n  | rπ| j | É rπqP n  |  j | É qP WWnA t k
 r·Ç  n. t k
 rt É  t d | | f É Ç n Xd  S(   Ns4   %r does not look like a Netscape format cookies filet    s   
iˇˇˇˇt   #t   $s   	t   TRUEt   .i    s+   invalid Netscape format cookies file %r: %r(   R   R   (   t   timet   readlinet   ret   searcht   magic_ret   closeR   t   endswitht   stript
   startswitht   splitt   Nonet   AssertionErrort   Falset   TrueR   t   discardt
   is_expiredt
   set_cookiet   IOErrort	   ExceptionR    (   t   selft   ft   filenamet   ignore_discardt   ignore_expirest   nowt   magict   linet   domaint   domain_specifiedt   patht   securet   expirest   namet   valuet   initial_dotR   t   c(    (    s'   /usr/lib/python2.7/_MozillaCookieJar.pyt   _really_load/   sd    
  $				c      
   C   sÇ  | d  k r6 |  j d  k	 r' |  j } q6 t t É Ç n  t | d É } z+| j |  j É t j É  } x|  D] } | rá | j rá qk n  | r£ | j	 | É r£ qk n  | j
 rµ d } n d } | j j d É r÷ d } n d } | j d  k	 r˝ t | j É }	 n d }	 | j d  k r$d }
 | j } n | j }
 | j } | j d j | j | | j | |	 |
 | g É d É qk WWd  | j É  Xd  S(   Nt   wR	   t   FALSER
   R   s   	s   
(   R   R    t
   ValueErrorR   t   opent   writet   headerR   R   R   R)   R&   R   R*   t   strR,   R+   t   joinR(   R   (   R   R    R!   R"   R   R#   t   cookieR)   R-   R*   R+   R,   (    (    s'   /usr/lib/python2.7/_MozillaCookieJar.pyt   saveq   s@     	 	 			N(	   t   __name__t
   __module__t   __doc__R   R5   R/   R   R   R9   (    (    (    s'   /usr/lib/python2.7/_MozillaCookieJar.pyR      s
   	B(
   R<   R   R   t	   cookielibR    R   R   R   R   R   (    (    (    s'   /usr/lib/python2.7/_MozillaCookieJar.pyt   <module>   s   (
filename:/usr/lib/python2.7/random.py
__doc__
"""Random variable generators.

filename:/usr/lib/python2.7/imputil.py
__doc__
"""
Import utilities

Exported classes:
    ImportManager   Manage the import process

    Importer        Base class for replacing standard import functions
    BuiltinImporter Emulate the import mechanism for builtin and frozen modules

    DynLoadSuffixImporter
"""

filename:/usr/lib/python2.7/popen2.py
__doc__
"""Spawn a command with pipes to its stdin, stdout, and optionally stderr.

The normal os.popen(cmd, mode) call spawns a shell command and provides a
file interface to just the input or output of the process depending on
whether mode is 'r' or 'w'.  This module provides the functions popen2(cmd)
and popen3(cmd) which return two or three pipes to the spawned command.
"""

filename:/usr/lib/python2.7/UserDict.py
__doc__
"""A more or less complete user-defined wrapper around dictionary objects."""

class UserDict:
    def __init__(*args, **kwargs):
        if not args:
            raise TypeError("descriptor '__init__' of 'UserDict' object "
                            "needs an argument")
        self = args[0]
        args = args[1:]
        if len(args) > 1:
            raise TypeError('expected at most 1 arguments, got %d' % len(args))
        if args:
            dict = args[0]
        elif 'dict' in kwargs:
            dict = kwargs.pop('dict')
            import warnings
            warnings.warn("Passing 'dict' as keyword argument is "
                          "deprecated", PendingDeprecationWarning,
                          stacklevel=2)
        else:
            dict = None
        self.data = {}
        if dict is not None:
            self.update(dict)
        if len(kwargs):
            self.update(kwargs)
    def __repr__(self): return repr(self.data)
    def __cmp__(self, dict):
        if isinstance(dict, UserDict):
            return cmp(self.data, dict.data)
        else:
            return cmp(self.data, dict)
    __hash__ = None # Avoid Py3k warning
    def __len__(self): return len(self.data)
    def __getitem__(self, key):
        if key in self.data:
            return self.data[key]
        if hasattr(self.__class__, "__missing__"):
            return self.__class__.__missing__(self, key)
        raise KeyError(key)
    def __setitem__(self, key, item): self.data[key] = item
    def __delitem__(self, key): del self.data[key]
    def clear(self): self.data.clear()
    def copy(self):
        if self.__class__ is UserDict:
            return UserDict(self.data.copy())
        import copy
        data = self.data
        try:
            self.data = {}
            c = copy.copy(self)
        finally:
            self.data = data
        c.update(self)
        return c
    def keys(self): return self.data.keys()
    def items(self): return self.data.items()
    def iteritems(self): return self.data.iteritems()
    def iterkeys(self): return self.data.iterkeys()
    def itervalues(self): return self.data.itervalues()
    def values(self): return self.data.values()
    def has_key(self, key): return key in self.data
    def update(*args, **kwargs):
        if not args:
            raise TypeError("descriptor 'update' of 'UserDict' object "
                            "needs an argument")
        self = args[0]
        args = args[1:]
        if len(args) > 1:
            raise TypeError('expected at most 1 arguments, got %d' % len(args))
        if args:
            dict = args[0]
        elif 'dict' in kwargs:
            dict = kwargs.pop('dict')
            import warnings
            warnings.warn("Passing 'dict' as keyword argument is deprecated",
                          PendingDeprecationWarning, stacklevel=2)
        else:
            dict = None
        if dict is None:
            pass
        elif isinstance(dict, UserDict):
            self.data.update(dict.data)
        elif isinstance(dict, type({})) or not hasattr(dict, 'items'):
            self.data.update(dict)
        else:
            for k, v in dict.items():
                self[k] = v
        if len(kwargs):
            self.data.update(kwargs)
    def get(self, key, failobj=None):
        if key not in self:
            return failobj
        return self[key]
    def setdefault(self, key, failobj=None):
        if key not in self:
            self[key] = failobj
        return self[key]
    def pop(self, key, *args):
        return self.data.pop(key, *args)
    def popitem(self):
        return self.data.popitem()
    def __contains__(self, key):
        return key in self.data
    @classmethod
    def fromkeys(cls, iterable, value=None):
        d = cls()
        for key in iterable:
            d[key] = value
        return d

class IterableUserDict(UserDict):
    def __iter__(self):
        return iter(self.data)

import _abcoll
_abcoll.MutableMapping.register(IterableUserDict)


class DictMixin:
    # Mixin defining all dictionary methods for classes that already have
    # a minimum dictionary interface including getitem, setitem, delitem,
    # and keys. Without knowledge of the subclass constructor, the mixin
    # does not define __init__() or copy().  In addition to the four base
    # methods, progressively more efficiency comes with defining
    # __contains__(), __iter__(), and iteritems().

    # second level definitions support higher levels
    def __iter__(self):
        for k in self.keys():
            yield k
    def has_key(self, key):
        try:
            self[key]
        except KeyError:
            return False
        return True
    def __contains__(self, key):
        return self.has_key(key)

    # third level takes advantage of second level definitions
    def iteritems(self):
        for k in self:
            yield (k, self[k])
    def iterkeys(self):
        return self.__iter__()

    # fourth level uses definitions from lower levels
    def itervalues(self):
        for _, v in self.iteritems():
            yield v
    def values(self):
        return [v for _, v in self.iteritems()]
    def items(self):
        return list(self.iteritems())
    def clear(self):
        for key in self.keys():
            del self[key]
    def setdefault(self, key, default=None):
        try:
            return self[key]
        except KeyError:
            self[key] = default
        return default
    def pop(self, key, *args):
        if len(args) > 1:
            raise TypeError, "pop expected at most 2 arguments, got "\
                              + repr(1 + len(args))
        try:
            value = self[key]
        except KeyError:
            if args:
                return args[0]
            raise
        del self[key]
        return value
    def popitem(self):
        try:
            k, v = self.iteritems().next()
        except StopIteration:
            raise KeyError, 'container is empty'
        del self[k]
        return (k, v)
    def update(self, other=None, **kwargs):
        # Make progressively weaker assumptions about "other"
        if other is None:
            pass
        elif hasattr(other, 'iteritems'):  # iteritems saves memory and lookups
            for k, v in other.iteritems():
                self[k] = v
        elif hasattr(other, 'keys'):
            for k in other.keys():
                self[k] = other[k]
        else:
            for k, v in other:
                self[k] = v
        if kwargs:
            self.update(kwargs)
    def get(self, key, default=None):
        try:
            return self[key]
        except KeyError:
            return default
    def __repr__(self):
        return repr(dict(self.iteritems()))
    def __cmp__(self, other):
        if other is None:
            return 1
        if isinstance(other, DictMixin):
            other = dict(other.iteritems())
        return cmp(dict(self.iteritems()), other)
    def __len__(self):
        return len(self.keys())

filename:/usr/lib/python2.7/fileinput.py
__doc__
"""Helper class to quickly write a loop over all standard input files.

filename:/usr/lib/python2.7/locale.py
__doc__
"""Locale support module.

The module provides low-level access to the C lib's locale APIs and adds high
level number formatting APIs as well as a locale aliasing engine to complement
these.

The aliasing engine includes support for many commonly used locale names and
maps them to values suitable for passing to the C lib's setlocale() function. It
also includes default encodings for all supported locale names.
"""

filename:/usr/lib/python2.7/io.py
__doc__
"""The io module provides the Python interfaces to stream handling. The
builtin open function is defined in this module.

At the top of the I/O hierarchy is the abstract base class IOBase. It
defines the basic interface to a stream. Note, however, that there is no
separation between reading and writing to streams; implementations are
allowed to raise an IOError if they do not support a given operation.

Extending IOBase is RawIOBase which deals simply with the reading and
writing of raw bytes to a stream. FileIO subclasses RawIOBase to provide
an interface to OS files.

BufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its
subclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer
streams that are readable, writable, and both respectively.
BufferedRandom provides a buffered interface to random access
streams. BytesIO is a simple stream of in-memory bytes.

Another IOBase subclass, TextIOBase, deals with the encoding and decoding
of streams into text. TextIOWrapper, which extends it, is a buffered text
interface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO
is a in-memory stream for text.

Argument names are not part of the specification, and only the arguments
of open() are intended to be used as keyword arguments.

data:

DEFAULT_BUFFER_SIZE

   An int containing the default buffer size used by the module's buffered
   I/O classes. open() uses the file's blksize (as obtained by os.stat) if
   possible.
"""

filename:/usr/lib/python2.7/tty.py
__doc__
"""Terminal utilities."""

# Author: Steen Lumholt.

from termios import *

__all__ = ["setraw", "setcbreak"]

# Indexes for termios list.
IFLAG = 0
OFLAG = 1
CFLAG = 2
LFLAG = 3
ISPEED = 4
OSPEED = 5
CC = 6

def setraw(fd, when=TCSAFLUSH):
    """Put terminal into a raw mode."""
    mode = tcgetattr(fd)
    mode[IFLAG] = mode[IFLAG] & ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON)
    mode[OFLAG] = mode[OFLAG] & ~(OPOST)
    mode[CFLAG] = mode[CFLAG] & ~(CSIZE | PARENB)
    mode[CFLAG] = mode[CFLAG] | CS8
    mode[LFLAG] = mode[LFLAG] & ~(ECHO | ICANON | IEXTEN | ISIG)
    mode[CC][VMIN] = 1
    mode[CC][VTIME] = 0
    tcsetattr(fd, when, mode)

def setcbreak(fd, when=TCSAFLUSH):
    """Put terminal into a cbreak mode."""
    mode = tcgetattr(fd)
    mode[LFLAG] = mode[LFLAG] & ~(ECHO | ICANON)
    mode[CC][VMIN] = 1
    mode[CC][VTIME] = 0
    tcsetattr(fd, when, mode)

filename:/usr/lib/python2.7/bdb.py
__doc__
"""Debugger basics"""

filename:/usr/lib/python2.7/stat.py
__doc__
"""Constants/functions for interpreting results of os.stat() and os.lstat().

Suggested usage: from stat import *
"""

filename:/usr/lib/python2.7/new.py
__doc__
"""Create new objects of various types.  Deprecated.

This module is no longer required except for backward compatibility.
Objects of most types can now be created by calling the type object.
"""

filename:/usr/lib/python2.7/difflib.py
__doc__
"""
Module difflib -- helpers for computing deltas between objects.

Function get_close_matches(word, possibilities, n=3, cutoff=0.6):
    Use SequenceMatcher to return list of the best "good enough" matches.

Function context_diff(a, b):
    For two lists of strings, return a delta in context diff format.

Function ndiff(a, b):
    Return a delta: the difference between `a` and `b` (lists of strings).

Function restore(delta, which):
    Return one of the two sequences that generated an ndiff delta.

Function unified_diff(a, b):
    For two lists of strings, return a delta in unified diff format.

Class SequenceMatcher:
    A flexible class for comparing pairs of sequences of any type.

Class Differ:
    For producing human-readable deltas from sequences of lines of text.

Class HtmlDiff:
    For producing HTML side by side comparison with change highlights.
"""

filename:/usr/lib/python2.7/mimetools.py
__doc__
"""Various tools used by MIME-reading or MIME-writing programs."""


import os
import sys
import tempfile
from warnings import filterwarnings, catch_warnings
with catch_warnings():
    if sys.py3kwarning:
        filterwarnings("ignore", ".*rfc822 has been removed", DeprecationWarning)
    import rfc822

from warnings import warnpy3k
warnpy3k("in 3.x, mimetools has been removed in favor of the email package",
         stacklevel=2)

__all__ = ["Message","choose_boundary","encode","decode","copyliteral",
           "copybinary"]

class Message(rfc822.Message):
    """A derived class of rfc822.Message that knows about MIME headers and
    contains some hooks for decoding encoded and multipart messages."""

    def __init__(self, fp, seekable = 1):
        rfc822.Message.__init__(self, fp, seekable)
        self.encodingheader = \
                self.getheader('content-transfer-encoding')
        self.typeheader = \
                self.getheader('content-type')
        self.parsetype()
        self.parseplist()

    def parsetype(self):
        str = self.typeheader
        if str is None:
            str = 'text/plain'
        if ';' in str:
            i = str.index(';')
            self.plisttext = str[i:]
            str = str[:i]
        else:
            self.plisttext = ''
        fields = str.split('/')
        for i in range(len(fields)):
            fields[i] = fields[i].strip().lower()
        self.type = '/'.join(fields)
        self.maintype = fields[0]
        self.subtype = '/'.join(fields[1:])

    def parseplist(self):
        str = self.plisttext
        self.plist = []
        while str[:1] == ';':
            str = str[1:]
            if ';' in str:
                # XXX Should parse quotes!
                end = str.index(';')
            else:
                end = len(str)
            f = str[:end]
            if '=' in f:
                i = f.index('=')
                f = f[:i].strip().lower() + \
                        '=' + f[i+1:].strip()
            self.plist.append(f.strip())
            str = str[end:]

    def getplist(self):
        return self.plist

    def getparam(self, name):
        name = name.lower() + '='
        n = len(name)
        for p in self.plist:
            if p[:n] == name:
                return rfc822.unquote(p[n:])
        return None

    def getparamnames(self):
        result = []
        for p in self.plist:
            i = p.find('=')
            if i >= 0:
                result.append(p[:i].lower())
        return result

    def getencoding(self):
        if self.encodingheader is None:
            return '7bit'
        return self.encodingheader.lower()

    def gettype(self):
        return self.type

    def getmaintype(self):
        return self.maintype

    def getsubtype(self):
        return self.subtype




# Utility functions
# -----------------

try:
    import thread
except ImportError:
    import dummy_thread as thread
_counter_lock = thread.allocate_lock()
del thread

_counter = 0
def _get_next_counter():
    global _counter
    _counter_lock.acquire()
    _counter += 1
    result = _counter
    _counter_lock.release()
    return result

_prefix = None

def choose_boundary():
    """Return a string usable as a multipart boundary.

    The string chosen is unique within a single program run, and
    incorporates the user id (if available), process id (if available),
    and current time.  So it's very unlikely the returned string appears
    in message text, but there's no guarantee.

    The boundary contains dots so you have to quote it in the header."""

    global _prefix
    import time
    if _prefix is None:
        import socket
        try:
            hostid = socket.gethostbyname(socket.gethostname())
        except socket.gaierror:
            hostid = '127.0.0.1'
        try:
            uid = repr(os.getuid())
        except AttributeError:
            uid = '1'
        try:
            pid = repr(os.getpid())
        except AttributeError:
            pid = '1'
        _prefix = hostid + '.' + uid + '.' + pid
    return "%s.%.3f.%d" % (_prefix, time.time(), _get_next_counter())


# Subroutines for decoding some common content-transfer-types

def decode(input, output, encoding):
    """Decode common content-transfer-encodings (base64, quopri, uuencode)."""
    if encoding == 'base64':
        import base64
        return base64.decode(input, output)
    if encoding == 'quoted-printable':
        import quopri
        return quopri.decode(input, output)
    if encoding in ('uuencode', 'x-uuencode', 'uue', 'x-uue'):
        import uu
        return uu.decode(input, output)
    if encoding in ('7bit', '8bit'):
        return output.write(input.read())
    if encoding in decodetab:
        pipethrough(input, decodetab[encoding], output)
    else:
        raise ValueError, \
              'unknown Content-Transfer-Encoding: %s' % encoding

def encode(input, output, encoding):
    """Encode common content-transfer-encodings (base64, quopri, uuencode)."""
    if encoding == 'base64':
        import base64
        return base64.encode(input, output)
    if encoding == 'quoted-printable':
        import quopri
        return quopri.encode(input, output, 0)
    if encoding in ('uuencode', 'x-uuencode', 'uue', 'x-uue'):
        import uu
        return uu.encode(input, output)
    if encoding in ('7bit', '8bit'):
        return output.write(input.read())
    if encoding in encodetab:
        pipethrough(input, encodetab[encoding], output)
    else:
        raise ValueError, \
              'unknown Content-Transfer-Encoding: %s' % encoding

# The following is no longer used for standard encodings

# XXX This requires that uudecode and mmencode are in $PATH

uudecode_pipe = '''(
TEMP=/tmp/@uu.$$
sed "s%^begin [0-7][0-7]* .*%begin 600 $TEMP%" | uudecode
cat $TEMP
rm $TEMP
)'''

decodetab = {
        'uuencode':             uudecode_pipe,
        'x-uuencode':           uudecode_pipe,
        'uue':                  uudecode_pipe,
        'x-uue':                uudecode_pipe,
        'quoted-printable':     'mmencode -u -q',
        'base64':               'mmencode -u -b',
}

encodetab = {
        'x-uuencode':           'uuencode tempfile',
        'uuencode':             'uuencode tempfile',
        'x-uue':                'uuencode tempfile',
        'uue':                  'uuencode tempfile',
        'quoted-printable':     'mmencode -q',
        'base64':               'mmencode -b',
}

def pipeto(input, command):
    pipe = os.popen(command, 'w')
    copyliteral(input, pipe)
    pipe.close()

def pipethrough(input, command, output):
    (fd, tempname) = tempfile.mkstemp()
    temp = os.fdopen(fd, 'w')
    copyliteral(input, temp)
    temp.close()
    pipe = os.popen(command + ' <' + tempname, 'r')
    copybinary(pipe, output)
    pipe.close()
    os.unlink(tempname)

def copyliteral(input, output):
    while 1:
        line = input.readline()
        if not line: break
        output.write(line)

def copybinary(input, output):
    BUFSIZE = 8192
    while 1:
        line = input.read(BUFSIZE)
        if not line: break
        output.write(line)

filename:/usr/lib/python2.7/smtpd.py
__doc__
#! /usr/bin/python2.7
"""An RFC 2821 smtp proxy.

filename:/usr/lib/python2.7/sunau.py
__doc__
"""Stuff to parse Sun and NeXT audio files.

An audio file consists of a header followed by the data.  The structure
of the header is as follows.

        +---------------+
        | magic word    |
        +---------------+
        | header size   |
        +---------------+
        | data size     |
        +---------------+
        | encoding      |
        +---------------+
        | sample rate   |
        +---------------+
        | # of channels |
        +---------------+
        | info          |
        |               |
        +---------------+

The magic word consists of the 4 characters '.snd'.  Apart from the
info field, all header fields are 4 bytes in size.  They are all
32-bit unsigned integers encoded in big-endian byte order.

The header size really gives the start of the data.
The data size is the physical size of the data.  From the other
parameters the number of frames can be calculated.
The encoding gives the way in which audio samples are encoded.
Possible values are listed below.
The info field currently consists of an ASCII string giving a
human-readable description of the audio file.  The info field is
padded with NUL bytes to the header size.

Usage.

Reading audio files:
        f = sunau.open(file, 'r')
where file is either the name of a file or an open file pointer.
The open file pointer must have methods read(), seek(), and close().
When the setpos() and rewind() methods are not used, the seek()
method is not  necessary.

This returns an instance of a class with the following public methods:
        getnchannels()  -- returns number of audio channels (1 for
                           mono, 2 for stereo)
        getsampwidth()  -- returns sample width in bytes
        getframerate()  -- returns sampling frequency
        getnframes()    -- returns number of audio frames
        getcomptype()   -- returns compression type ('NONE' or 'ULAW')
        getcompname()   -- returns human-readable version of
                           compression type ('not compressed' matches 'NONE')
        getparams()     -- returns a tuple consisting of all of the
                           above in the above order
        getmarkers()    -- returns None (for compatibility with the
                           aifc module)
        getmark(id)     -- raises an error since the mark does not
                           exist (for compatibility with the aifc module)
        readframes(n)   -- returns at most n frames of audio
        rewind()        -- rewind to the beginning of the audio stream
        setpos(pos)     -- seek to the specified position
        tell()          -- return the current position
        close()         -- close the instance (make it unusable)
The position returned by tell() and the position given to setpos()
are compatible and have nothing to do with the actual position in the
file.
The close() method is called automatically when the class instance
is destroyed.

Writing audio files:
        f = sunau.open(file, 'w')
where file is either the name of a file or an open file pointer.
The open file pointer must have methods write(), tell(), seek(), and
close().

This returns an instance of a class with the following public methods:
        setnchannels(n) -- set the number of channels
        setsampwidth(n) -- set the sample width
        setframerate(n) -- set the frame rate
        setnframes(n)   -- set the number of frames
        setcomptype(type, name)
                        -- set the compression type and the
                           human-readable compression type
        setparams(tuple)-- set all parameters at once
        tell()          -- return current position in output file
        writeframesraw(data)
                        -- write audio frames without pathing up the
                           file header
        writeframes(data)
                        -- write audio frames and patch up the file header
        close()         -- patch up the file header and close the
                           output file
You should set the parameters before the first writeframesraw or
writeframes.  The total number of frames does not need to be set,
but when it is set to the correct value, the header does not have to
be patched up.
It is best to first set all parameters, perhaps possibly the
compression type, and then write audio frames using writeframesraw.
When all frames have been written, either call writeframes('') or
close() to patch up the sizes in the header.
The close() method is called automatically when the class instance
is destroyed.
"""

filename:/usr/lib/python2.7/commands.py
__doc__
"""Execute shell commands via os.popen() and return status, output.

Interface summary:

       import commands

       outtext = commands.getoutput(cmd)
       (exitstatus, outtext) = commands.getstatusoutput(cmd)
       outtext = commands.getstatus(file)  # returns output of "ls -ld file"

A trailing newline is removed from the output string.

Encapsulates the basic operation:

      pipe = os.popen('{ ' + cmd + '; } 2>&1', 'r')
      text = pipe.read()
      sts = pipe.close()

 [Note:  it would be nice to add functions to interpret the exit status.]
"""

filename:/usr/lib/python2.7/compiler/__init__.py
__doc__
"""Package for parsing and compiling Python source code

There are several functions defined at the top level that are imported
from modules contained in the package.

parse(buf, mode="exec") -> AST
    Converts a string containing Python source code to an abstract
    syntax tree (AST).  The AST is defined in compiler.ast.

parseFile(path) -> AST
    The same as parse(open(path))

walk(ast, visitor, verbose=None)
    Does a pre-order walk over the ast using the visitor instance.
    See compiler.visitor for details.

compile(source, filename, mode, flags=None, dont_inherit=None)
    Returns a code object.  A replacement for the builtin compile() function.

compileFile(filename)
    Generates a .pyc file by compiling filename.
"""

filename:/usr/lib/python2.7/compiler/future.py
__doc__
"""Parser for future statements

"""

filename:/usr/lib/python2.7/compiler/pyassem.py
__doc__
"""A flow graph representation for Python bytecode"""

import dis
import types
import sys

from compiler import misc
from compiler.consts \
     import CO_OPTIMIZED, CO_NEWLOCALS, CO_VARARGS, CO_VARKEYWORDS

class FlowGraph:
    def __init__(self):
        self.current = self.entry = Block()
        self.exit = Block("exit")
        self.blocks = misc.Set()
        self.blocks.add(self.entry)
        self.blocks.add(self.exit)

    def startBlock(self, block):
        if self._debug:
            if self.current:
                print "end", repr(self.current)
                print "    next", self.current.next
                print "    prev", self.current.prev
                print "   ", self.current.get_children()
            print repr(block)
        self.current = block

    def nextBlock(self, block=None):
        # XXX think we need to specify when there is implicit transfer
        # from one block to the next.  might be better to represent this
        # with explicit JUMP_ABSOLUTE instructions that are optimized
        # out when they are unnecessary.
        #
        # I think this strategy works: each block has a child
        # designated as "next" which is returned as the last of the
        # children.  because the nodes in a graph are emitted in
        # reverse post order, the "next" block will always be emitted
        # immediately after its parent.
        # Worry: maintaining this invariant could be tricky
        if block is None:
            block = self.newBlock()

        # Note: If the current block ends with an unconditional control
        # transfer, then it is techically incorrect to add an implicit
        # transfer to the block graph. Doing so results in code generation
        # for unreachable blocks.  That doesn't appear to be very common
        # with Python code and since the built-in compiler doesn't optimize
        # it out we don't either.
        self.current.addNext(block)
        self.startBlock(block)

    def newBlock(self):
        b = Block()
        self.blocks.add(b)
        return b

    def startExitBlock(self):
        self.startBlock(self.exit)

    _debug = 0

    def _enable_debug(self):
        self._debug = 1

    def _disable_debug(self):
        self._debug = 0

    def emit(self, *inst):
        if self._debug:
            print "\t", inst
        if len(inst) == 2 and isinstance(inst[1], Block):
            self.current.addOutEdge(inst[1])
        self.current.emit(inst)

    def getBlocksInOrder(self):
        """Return the blocks in reverse postorder

        i.e. each node appears before all of its successors
        """
        order = order_blocks(self.entry, self.exit)
        return order

    def getBlocks(self):
        return self.blocks.elements()

    def getRoot(self):
        """Return nodes appropriate for use with dominator"""
        return self.entry

    def getContainedGraphs(self):
        l = []
        for b in self.getBlocks():
            l.extend(b.getContainedGraphs())
        return l


def order_blocks(start_block, exit_block):
    """Order blocks so that they are emitted in the right order"""
    # Rules:
    # - when a block has a next block, the next block must be emitted just after
    # - when a block has followers (relative jumps), it must be emitted before
    #   them
    # - all reachable blocks must be emitted
    order = []

    # Find all the blocks to be emitted.
    remaining = set()
    todo = [start_block]
    while todo:
        b = todo.pop()
        if b in remaining:
            continue
        remaining.add(b)
        for c in b.get_children():
            if c not in remaining:
                todo.append(c)

    # A block is dominated by another block if that block must be emitted
    # before it.
    dominators = {}
    for b in remaining:
        if __debug__ and b.next:
            assert b is b.next[0].prev[0], (b, b.next)
        # Make sure every block appears in dominators, even if no
        # other block must precede it.
        dominators.setdefault(b, set())
        # preceding blocks dominate following blocks
        for c in b.get_followers():
            while 1:
                dominators.setdefault(c, set()).add(b)
                # Any block that has a next pointer leading to c is also
                # dominated because the whole chain will be emitted at once.
                # Walk backwards and add them all.
                if c.prev and c.prev[0] is not b:
                    c = c.prev[0]
                else:
                    break

    def find_next():
        # Find a block that can be emitted next.
        for b in remaining:
            for c in dominators[b]:
                if c in remaining:
                    break # can't emit yet, dominated by a remaining block
            else:
                return b
        assert 0, 'circular dependency, cannot find next block'

    b = start_block
    while 1:
        order.append(b)
        remaining.discard(b)
        if b.next:
            b = b.next[0]
            continue
        elif b is not exit_block and not b.has_unconditional_transfer():
            order.append(exit_block)
        if not remaining:
            break
        b = find_next()
    return order


class Block:
    _count = 0

    def __init__(self, label=''):
        self.insts = []
        self.outEdges = set()
        self.label = label
        self.bid = Block._count
        self.next = []
        self.prev = []
        Block._count = Block._count + 1

    def __repr__(self):
        if self.label:
            return "<block %s id=%d>" % (self.label, self.bid)
        else:
            return "<block id=%d>" % (self.bid)

    def __str__(self):
        insts = map(str, self.insts)
        return "<block %s %d:\n%s>" % (self.label, self.bid,
                                       '\n'.join(insts))

    def emit(self, inst):
        op = inst[0]
        self.insts.append(inst)

    def getInstructions(self):
        return self.insts

    def addOutEdge(self, block):
        self.outEdges.add(block)

    def addNext(self, block):
        self.next.append(block)
        assert len(self.next) == 1, map(str, self.next)
        block.prev.append(self)
        assert len(block.prev) == 1, map(str, block.prev)

    _uncond_transfer = ('RETURN_VALUE', 'RAISE_VARARGS',
                        'JUMP_ABSOLUTE', 'JUMP_FORWARD', 'CONTINUE_LOOP',
                        )

    def has_unconditional_transfer(self):
        """Returns True if there is an unconditional transfer to an other block
        at the end of this block. This means there is no risk for the bytecode
        executer to go past this block's bytecode."""
        try:
            op, arg = self.insts[-1]
        except (IndexError, ValueError):
            return
        return op in self._uncond_transfer

    def get_children(self):
        return list(self.outEdges) + self.next

    def get_followers(self):
        """Get the whole list of followers, including the next block."""
        followers = set(self.next)
        # Blocks that must be emitted *after* this one, because of
        # bytecode offsets (e.g. relative jumps) pointing to them.
        for inst in self.insts:
            if inst[0] in PyFlowGraph.hasjrel:
                followers.add(inst[1])
        return followers

    def getContainedGraphs(self):
        """Return all graphs contained within this block.

        For example, a MAKE_FUNCTION block will contain a reference to
        the graph for the function body.
        """
        contained = []
        for inst in self.insts:
            if len(inst) == 1:
                continue
            op = inst[1]
            if hasattr(op, 'graph'):
                contained.append(op.graph)
        return contained

# flags for code objects

# the FlowGraph is transformed in place; it exists in one of these states
RAW = "RAW"
FLAT = "FLAT"
CONV = "CONV"
DONE = "DONE"

class PyFlowGraph(FlowGraph):
    super_init = FlowGraph.__init__

    def __init__(self, name, filename, args=(), optimized=0, klass=None):
        self.super_init()
        self.name = name
        self.filename = filename
        self.docstring = None
        self.args = args # XXX
        self.argcount = getArgCount(args)
        self.klass = klass
        if optimized:
            self.flags = CO_OPTIMIZED | CO_NEWLOCALS
        else:
            self.flags = 0
        self.consts = []
        self.names = []
        # Free variables found by the symbol table scan, including
        # variables used only in nested scopes, are included here.
        self.freevars = []
        self.cellvars = []
        # The closure list is used to track the order of cell
        # variables and free variables in the resulting code object.
        # The offsets used by LOAD_CLOSURE/LOAD_DEREF refer to both
        # kinds of variables.
        self.closure = []
        self.varnames = list(args) or []
        for i in range(len(self.varnames)):
            var = self.varnames[i]
            if isinstance(var, TupleArg):
                self.varnames[i] = var.getName()
        self.stage = RAW

    def setDocstring(self, doc):
        self.docstring = doc

    def setFlag(self, flag):
        self.flags = self.flags | flag
        if flag == CO_VARARGS:
            self.argcount = self.argcount - 1

    def checkFlag(self, flag):
        if self.flags & flag:
            return 1

    def setFreeVars(self, names):
        self.freevars = list(names)

    def setCellVars(self, names):
        self.cellvars = names

    def getCode(self):
        """Get a Python code object"""
        assert self.stage == RAW
        self.computeStackDepth()
        self.flattenGraph()
        assert self.stage == FLAT
        self.convertArgs()
        assert self.stage == CONV
        self.makeByteCode()
        assert self.stage == DONE
        return self.newCodeObject()

    def dump(self, io=None):
        if io:
            save = sys.stdout
            sys.stdout = io
        pc = 0
        for t in self.insts:
            opname = t[0]
            if opname == "SET_LINENO":
                print
            if len(t) == 1:
                print "\t", "%3d" % pc, opname
                pc = pc + 1
            else:
                print "\t", "%3d" % pc, opname, t[1]
                pc = pc + 3
        if io:
            sys.stdout = save

    def computeStackDepth(self):
        """Compute the max stack depth.

        Approach is to compute the stack effect of each basic block.
        Then find the path through the code with the largest total
        effect.
        """
        depth = {}
        exit = None
        for b in self.getBlocks():
            depth[b] = findDepth(b.getInstructions())

        seen = {}

        def max_depth(b, d):
            if b in seen:
                return d
            seen[b] = 1
            d = d + depth[b]
            children = b.get_children()
            if children:
                return max([max_depth(c, d) for c in children])
            else:
                if not b.label == "exit":
                    return max_depth(self.exit, d)
                else:
                    return d

        self.stacksize = max_depth(self.entry, 0)

    def flattenGraph(self):
        """Arrange the blocks in order and resolve jumps"""
        assert self.stage == RAW
        self.insts = insts = []
        pc = 0
        begin = {}
        end = {}
        for b in self.getBlocksInOrder():
            begin[b] = pc
            for inst in b.getInstructions():
                insts.append(inst)
                if len(inst) == 1:
                    pc = pc + 1
                elif inst[0] != "SET_LINENO":
                    # arg takes 2 bytes
                    pc = pc + 3
            end[b] = pc
        pc = 0
        for i in range(len(insts)):
            inst = insts[i]
            if len(inst) == 1:
                pc = pc + 1
            elif inst[0] != "SET_LINENO":
                pc = pc + 3
            opname = inst[0]
            if opname in self.hasjrel:
                oparg = inst[1]
                offset = begin[oparg] - pc
                insts[i] = opname, offset
            elif opname in self.hasjabs:
                insts[i] = opname, begin[inst[1]]
        self.stage = FLAT

    hasjrel = set()
    for i in dis.hasjrel:
        hasjrel.add(dis.opname[i])
    hasjabs = set()
    for i in dis.hasjabs:
        hasjabs.add(dis.opname[i])

    def convertArgs(self):
        """Convert arguments from symbolic to concrete form"""
        assert self.stage == FLAT
        self.consts.insert(0, self.docstring)
        self.sort_cellvars()
        for i in range(len(self.insts)):
            t = self.insts[i]
            if len(t) == 2:
                opname, oparg = t
                conv = self._converters.get(opname, None)
                if conv:
                    self.insts[i] = opname, conv(self, oparg)
        self.stage = CONV

    def sort_cellvars(self):
        """Sort cellvars in the order of varnames and prune from freevars.
        """
        cells = {}
        for name in self.cellvars:
            cells[name] = 1
        self.cellvars = [name for name in self.varnames
                         if name in cells]
        for name in self.cellvars:
            del cells[name]
        self.cellvars = self.cellvars + cells.keys()
        self.closure = self.cellvars + self.freevars

    def _lookupName(self, name, list):
        """Return index of name in list, appending if necessary

        This routine uses a list instead of a dictionary, because a
        dictionary can't store two different keys if the keys have the
        same value but different types, e.g. 2 and 2L.  The compiler
        must treat these two separately, so it does an explicit type
        comparison before comparing the values.
        """
        t = type(name)
        for i in range(len(list)):
            if t == type(list[i]) and list[i] == name:
                return i
        end = len(list)
        list.append(name)
        return end

    _converters = {}
    def _convert_LOAD_CONST(self, arg):
        if hasattr(arg, 'getCode'):
            arg = arg.getCode()
        return self._lookupName(arg, self.consts)

    def _convert_LOAD_FAST(self, arg):
        self._lookupName(arg, self.names)
        return self._lookupName(arg, self.varnames)
    _convert_STORE_FAST = _convert_LOAD_FAST
    _convert_DELETE_FAST = _convert_LOAD_FAST

    def _convert_LOAD_NAME(self, arg):
        if self.klass is None:
            self._lookupName(arg, self.varnames)
        return self._lookupName(arg, self.names)

    def _convert_NAME(self, arg):
        if self.klass is None:
            self._lookupName(arg, self.varnames)
        return self._lookupName(arg, self.names)
    _convert_STORE_NAME = _convert_NAME
    _convert_DELETE_NAME = _convert_NAME
    _convert_IMPORT_NAME = _convert_NAME
    _convert_IMPORT_FROM = _convert_NAME
    _convert_STORE_ATTR = _convert_NAME
    _convert_LOAD_ATTR = _convert_NAME
    _convert_DELETE_ATTR = _convert_NAME
    _convert_LOAD_GLOBAL = _convert_NAME
    _convert_STORE_GLOBAL = _convert_NAME
    _convert_DELETE_GLOBAL = _convert_NAME

    def _convert_DEREF(self, arg):
        self._lookupName(arg, self.names)
        self._lookupName(arg, self.varnames)
        return self._lookupName(arg, self.closure)
    _convert_LOAD_DEREF = _convert_DEREF
    _convert_STORE_DEREF = _convert_DEREF

    def _convert_LOAD_CLOSURE(self, arg):
        self._lookupName(arg, self.varnames)
        return self._lookupName(arg, self.closure)

    _cmp = list(dis.cmp_op)
    def _convert_COMPARE_OP(self, arg):
        return self._cmp.index(arg)

    # similarly for other opcodes...

    for name, obj in locals().items():
        if name[:9] == "_convert_":
            opname = name[9:]
            _converters[opname] = obj
    del name, obj, opname

    def makeByteCode(self):
        assert self.stage == CONV
        self.lnotab = lnotab = LineAddrTable()
        for t in self.insts:
            opname = t[0]
            if len(t) == 1:
                lnotab.addCode(self.opnum[opname])
            else:
                oparg = t[1]
                if opname == "SET_LINENO":
                    lnotab.nextLine(oparg)
                    continue
                hi, lo = twobyte(oparg)
                try:
                    lnotab.addCode(self.opnum[opname], lo, hi)
                except ValueError:
                    print opname, oparg
                    print self.opnum[opname], lo, hi
                    raise
        self.stage = DONE

    opnum = {}
    for num in range(len(dis.opname)):
        opnum[dis.opname[num]] = num
    del num

    def newCodeObject(self):
        assert self.stage == DONE
        if (self.flags & CO_NEWLOCALS) == 0:
            nlocals = 0
        else:
            nlocals = len(self.varnames)
        argcount = self.argcount
        if self.flags & CO_VARKEYWORDS:
            argcount = argcount - 1
        return types.CodeType(argcount, nlocals, self.stacksize, self.flags,
                        self.lnotab.getCode(), self.getConsts(),
                        tuple(self.names), tuple(self.varnames),
                        self.filename, self.name, self.lnotab.firstline,
                        self.lnotab.getTable(), tuple(self.freevars),
                        tuple(self.cellvars))

    def getConsts(self):
        """Return a tuple for the const slot of the code object

        Must convert references to code (MAKE_FUNCTION) to code
        objects recursively.
        """
        l = []
        for elt in self.consts:
            if isinstance(elt, PyFlowGraph):
                elt = elt.getCode()
            l.append(elt)
        return tuple(l)

def isJump(opname):
    if opname[:4] == 'JUMP':
        return 1

class TupleArg:
    """Helper for marking func defs with nested tuples in arglist"""
    def __init__(self, count, names):
        self.count = count
        self.names = names
    def __repr__(self):
        return "TupleArg(%s, %s)" % (self.count, self.names)
    def getName(self):
        return ".%d" % self.count

def getArgCount(args):
    argcount = len(args)
    if args:
        for arg in args:
            if isinstance(arg, TupleArg):
                numNames = len(misc.flatten(arg.names))
                argcount = argcount - numNames
    return argcount

def twobyte(val):
    """Convert an int argument into high and low bytes"""
    assert isinstance(val, int)
    return divmod(val, 256)

class LineAddrTable:
    """lnotab

    This class builds the lnotab, which is documented in compile.c.
    Here's a brief recap:

    For each SET_LINENO instruction after the first one, two bytes are
    added to lnotab.  (In some cases, multiple two-byte entries are
    added.)  The first byte is the distance in bytes between the
    instruction for the last SET_LINENO and the current SET_LINENO.
    The second byte is offset in line numbers.  If either offset is
    greater than 255, multiple two-byte entries are added -- see
    compile.c for the delicate details.
    """

    def __init__(self):
        self.code = []
        self.codeOffset = 0
        self.firstline = 0
        self.lastline = 0
        self.lastoff = 0
        self.lnotab = []

    def addCode(self, *args):
        for arg in args:
            self.code.append(chr(arg))
        self.codeOffset = self.codeOffset + len(args)

    def nextLine(self, lineno):
        if self.firstline == 0:
            self.firstline = lineno
            self.lastline = lineno
        else:
            # compute deltas
            addr = self.codeOffset - self.lastoff
            line = lineno - self.lastline
            # Python assumes that lineno always increases with
            # increasing bytecode address (lnotab is unsigned char).
            # Depending on when SET_LINENO instructions are emitted
            # this is not always true.  Consider the code:
            #     a = (1,
            #          b)
            # In the bytecode stream, the assignment to "a" occurs
            # after the loading of "b".  This works with the C Python
            # compiler because it only generates a SET_LINENO instruction
            # for the assignment.
            if line >= 0:
                push = self.lnotab.append
                while addr > 255:
                    push(255); push(0)
                    addr -= 255
                while line > 255:
                    push(addr); push(255)
                    line -= 255
                    addr = 0
                if addr > 0 or line > 0:
                    push(addr); push(line)
                self.lastline = lineno
                self.lastoff = self.codeOffset

    def getCode(self):
        return ''.join(self.code)

    def getTable(self):
        return ''.join(map(chr, self.lnotab))

class StackDepthTracker:
    # XXX 1. need to keep track of stack depth on jumps
    # XXX 2. at least partly as a result, this code is broken

    def findDepth(self, insts, debug=0):
        depth = 0
        maxDepth = 0
        for i in insts:
            opname = i[0]
            if debug:
                print i,
            delta = self.effect.get(opname, None)
            if delta is not None:
                depth = depth + delta
            else:
                # now check patterns
                for pat, pat_delta in self.patterns:
                    if opname[:len(pat)] == pat:
                        delta = pat_delta
                        depth = depth + delta
                        break
                # if we still haven't found a match
                if delta is None:
                    meth = getattr(self, opname, None)
                    if meth is not None:
                        depth = depth + meth(i[1])
            if depth > maxDepth:
                maxDepth = depth
            if debug:
                print depth, maxDepth
        return maxDepth

    effect = {
        'POP_TOP': -1,
        'DUP_TOP': 1,
        'LIST_APPEND': -1,
        'SET_ADD': -1,
        'MAP_ADD': -2,
        'SLICE+1': -1,
        'SLICE+2': -1,
        'SLICE+3': -2,
        'STORE_SLICE+0': -1,
        'STORE_SLICE+1': -2,
        'STORE_SLICE+2': -2,
        'STORE_SLICE+3': -3,
        'DELETE_SLICE+0': -1,
        'DELETE_SLICE+1': -2,
        'DELETE_SLICE+2': -2,
        'DELETE_SLICE+3': -3,
        'STORE_SUBSCR': -3,
        'DELETE_SUBSCR': -2,
        # PRINT_EXPR?
        'PRINT_ITEM': -1,
        'RETURN_VALUE': -1,
        'YIELD_VALUE': -1,
        'EXEC_STMT': -3,
        'BUILD_CLASS': -2,
        'STORE_NAME': -1,
        'STORE_ATTR': -2,
        'DELETE_ATTR': -1,
        'STORE_GLOBAL': -1,
        'BUILD_MAP': 1,
        'COMPARE_OP': -1,
        'STORE_FAST': -1,
        'IMPORT_STAR': -1,
        'IMPORT_NAME': -1,
        'IMPORT_FROM': 1,
        'LOAD_ATTR': 0, # unlike other loads
        # close enough...
        'SETUP_EXCEPT': 3,
        'SETUP_FINALLY': 3,
        'FOR_ITER': 1,
        'WITH_CLEANUP': -1,
        }
    # use pattern match
    patterns = [
        ('BINARY_', -1),
        ('LOAD_', 1),
        ]

    def UNPACK_SEQUENCE(self, count):
        return count-1
    def BUILD_TUPLE(self, count):
        return -count+1
    def BUILD_LIST(self, count):
        return -count+1
    def BUILD_SET(self, count):
        return -count+1
    def CALL_FUNCTION(self, argc):
        hi, lo = divmod(argc, 256)
        return -(lo + hi * 2)
    def CALL_FUNCTION_VAR(self, argc):
        return self.CALL_FUNCTION(argc)-1
    def CALL_FUNCTION_KW(self, argc):
        return self.CALL_FUNCTION(argc)-1
    def CALL_FUNCTION_VAR_KW(self, argc):
        return self.CALL_FUNCTION(argc)-2
    def MAKE_FUNCTION(self, argc):
        return -argc
    def MAKE_CLOSURE(self, argc):
        # XXX need to account for free variables too!
        return -argc
    def BUILD_SLICE(self, argc):
        if argc == 2:
            return -1
        elif argc == 3:
            return -2
    def DUP_TOPX(self, argc):
        return argc

findDepth = StackDepthTracker().findDepth

filename:/usr/lib/python2.7/compiler/symbols.py
__doc__
"""Module symbol-table generator"""

filename:/usr/lib/python2.7/compiler/syntax.py
__doc__
"""Check for errs in the AST.

The Python parser does not catch all syntax errors.  Others, like
assignments with invalid targets, are caught in the code generation
phase.

The compiler package catches some errors in the transformer module.
But it seems clearer to write checkers that use the AST to detect
errors.
"""

filename:/usr/lib/python2.7/compiler/transformer.py
__doc__
"""Parse tree transformation module.

Transforms Python source code into an abstract syntax tree (AST)
defined in the ast module.

The simplest ways to invoke this module are via parse and parseFile.
parse(buf) -> AST
parseFile(path) -> AST
"""

filename:/usr/lib/python2.7/compiler/ast.py
__doc__
"""Python abstract syntax node definitions

This file is automatically generated by Tools/compiler/astgen.py
"""

filename:/usr/lib/python2.7/imghdr.py
__doc__
"""Recognize image file formats based on their first few bytes."""

__all__ = ["what"]

#-------------------------#
# Recognize image headers #
#-------------------------#

def what(file, h=None):
    f = None
    try:
        if h is None:
            if isinstance(file, basestring):
                f = open(file, 'rb')
                h = f.read(32)
            else:
                location = file.tell()
                h = file.read(32)
                file.seek(location)
        for tf in tests:
            res = tf(h, f)
            if res:
                return res
    finally:
        if f: f.close()
    return None


#---------------------------------#
# Subroutines per image file type #
#---------------------------------#

tests = []

def test_jpeg(h, f):
    """JPEG data in JFIF format"""
    if h[6:10] == 'JFIF':
        return 'jpeg'

tests.append(test_jpeg)

def test_exif(h, f):
    """JPEG data in Exif format"""
    if h[6:10] == 'Exif':
        return 'jpeg'

tests.append(test_exif)

def test_png(h, f):
    if h[:8] == "\211PNG\r\n\032\n":
        return 'png'

tests.append(test_png)

def test_gif(h, f):
    """GIF ('87 and '89 variants)"""
    if h[:6] in ('GIF87a', 'GIF89a'):
        return 'gif'

tests.append(test_gif)

def test_tiff(h, f):
    """TIFF (can be in Motorola or Intel byte order)"""
    if h[:2] in ('MM', 'II'):
        return 'tiff'

tests.append(test_tiff)

def test_rgb(h, f):
    """SGI image library"""
    if h[:2] == '\001\332':
        return 'rgb'

tests.append(test_rgb)

def test_pbm(h, f):
    """PBM (portable bitmap)"""
    if len(h) >= 3 and \
        h[0] == 'P' and h[1] in '14' and h[2] in ' \t\n\r':
        return 'pbm'

tests.append(test_pbm)

def test_pgm(h, f):
    """PGM (portable graymap)"""
    if len(h) >= 3 and \
        h[0] == 'P' and h[1] in '25' and h[2] in ' \t\n\r':
        return 'pgm'

tests.append(test_pgm)

def test_ppm(h, f):
    """PPM (portable pixmap)"""
    if len(h) >= 3 and \
        h[0] == 'P' and h[1] in '36' and h[2] in ' \t\n\r':
        return 'ppm'

tests.append(test_ppm)

def test_rast(h, f):
    """Sun raster file"""
    if h[:4] == '\x59\xA6\x6A\x95':
        return 'rast'

tests.append(test_rast)

def test_xbm(h, f):
    """X bitmap (X10 or X11)"""
    s = '#define '
    if h[:len(s)] == s:
        return 'xbm'

tests.append(test_xbm)

def test_bmp(h, f):
    if h[:2] == 'BM':
        return 'bmp'

tests.append(test_bmp)

#--------------------#
# Small test program #
#--------------------#

def test():
    import sys
    recursive = 0
    if sys.argv[1:] and sys.argv[1] == '-r':
        del sys.argv[1:2]
        recursive = 1
    try:
        if sys.argv[1:]:
            testall(sys.argv[1:], recursive, 1)
        else:
            testall(['.'], recursive, 1)
    except KeyboardInterrupt:
        sys.stderr.write('\n[Interrupted]\n')
        sys.exit(1)

def testall(list, recursive, toplevel):
    import sys
    import os
    for filename in list:
        if os.path.isdir(filename):
            print filename + '/:',
            if recursive or toplevel:
                print 'recursing down:'
                import glob
                names = glob.glob(os.path.join(filename, '*'))
                testall(names, recursive, 0)
            else:
                print '*** directory (use -r) ***'
        else:
            print filename + ':',
            sys.stdout.flush()
            try:
                print what(filename)
            except IOError:
                print '*** not found ***'

filename:/usr/lib/python2.7/tokenize.pyc
__doc__
Û
/0Xc           @   s¯  d  Z  d Z d Z d d l m Z d d l Z d d l Z d d l Td d l Z g  e e É D] Z	 e	 j
 d É s] e	 ^ q] Z e d d	 d
 d d g 7Z [	 [ e Z d e e <e d Z d e e <e d 7Z d Ñ  Z d Ñ  Z d Ñ  Z d Z d Z e e d e É e e É Z d Z d Z d Z d Z d Z e e e e e É Z d Z e d d É e e É Z d e Z e e e É Z e d e d É Z  e e  e e É Z! d  Z" d! Z# d" Z$ d# Z% e d$ d% É Z& e d& d' É Z' e d( d) d* d+ d, d- d. d/ É Z( d0 Z) e d1 d2 É Z* e e( e) e* É Z+ e e! e+ e' e É Z, e e, Z- e d3 e d4 d É d5 e d6 d É É Z. e d7 e e& É Z/ e e e/ e! e+ e. e É Z0 e1 e j2 e- e0 e$ e% f É \ Z3 Z4 Z5 Z6 i& e j2 e" É d4 6e j2 e# É d6 6e5 d8 6e6 d9 6e5 d: 6e6 d; 6e5 d< 6e6 d= 6e5 d> 6e6 d? 6e5 d@ 6e6 dA 6e5 dB 6e6 dC 6e5 dD 6e6 dE 6e5 dF 6e6 dG 6e5 dH 6e6 dI 6e5 dJ 6e6 dK 6e5 dL 6e6 dM 6e5 dN 6e6 dO 6e5 dP 6e6 dQ 6e5 dR 6e6 dS 6e5 dT 6e6 dU 6d dV 6d dW 6d dX 6d dY 6d dZ 6d d[ 6Z8 i  Z9 x dÖ D] Z: e: e9 e: <qÌWi  Z; x dÜ D] Z: e: e; e: <qWdx Z< dy e= f dz Ñ  É  YZ> d{ e= f d| Ñ  É  YZ? d} Ñ  Z@ e@ d~ Ñ ZA d Ñ  ZB dÄ dá dÅ Ñ  É  YZC dÇ Ñ  ZD dÉ Ñ  ZE eF dÑ k rÙd d lG ZG eH eG jI É d k r·eA eJ eG jI d É jK É qÙeA eG jL jK É n  d S(à   s¿  Tokenization help for Python programs.

generate_tokens(readline) is a generator that breaks a stream of
text into Python tokens.  It accepts a readline-like method which is called
repeatedly to get the next line of input (or "" for EOF).  It generates
5-tuples with these members:

    the token type (see token.py)
    the token (a string)
    the starting (row, column) indices of the token (a 2-tuple of ints)
    the ending (row, column) indices of the token (a 2-tuple of ints)
    the original line (string)

It is designed to match the working of the Python tokenizer exactly, except
that it produces COMMENT tokens for comments and gives type OP for all
operators

Older entry points
    tokenize_loop(readline, tokeneater)
    tokenize(readline, tokeneater=printtoken)
are the same, except instead of generating tokens, tokeneater is a callback
function to which the 5 fields described above are passed as 5 arguments,
each time a new token is found.s   Ka-Ping Yee <ping@lfw.org>sS   GvR, ESR, Tim Peters, Thomas Wouters, Fred Drake, Skip Montanaro, Raymond Hettingeriˇˇˇˇ(   t   chainN(   t   *t   _t   COMMENTt   tokenizet   generate_tokenst   NLt
   untokenizei   i   c          G   s   d d j  |  É d S(   Nt   (t   |t   )(   t   join(   t   choices(    (    s   /usr/lib/python2.7/tokenize.pyt   group-   s    c          G   s   t  |  å  d S(   NR   (   R   (   R   (    (    s   /usr/lib/python2.7/tokenize.pyt   any.   s    c          G   s   t  |  å  d S(   Nt   ?(   R   (   R   (    (    s   /usr/lib/python2.7/tokenize.pyt   maybe/   s    s   [ \f\t]*s	   #[^\r\n]*s   \\\r?\ns   [a-zA-Z_]\w*s   0[xX][\da-fA-F]+[lL]?s   (0[oO][0-7]+)|(0[0-7]*)[lL]?s   0[bB][01]+[lL]?s   [1-9]\d*[lL]?s   [eE][-+]?\d+s   \d+\.\d*s   \.\d+s   \d+s   \d+[jJ]s   [jJ]s   [^'\\]*(?:\\.[^'\\]*)*'s   [^"\\]*(?:\\.[^"\\]*)*"s%   [^'\\]*(?:(?:\\.|'(?!''))[^'\\]*)*'''s%   [^"\\]*(?:(?:\\.|"(?!""))[^"\\]*)*"""s   [uUbB]?[rR]?'''s   [uUbB]?[rR]?"""s(   [uUbB]?[rR]?'[^\n'\\]*(?:\\.[^\n'\\]*)*'s(   [uUbB]?[rR]?"[^\n"\\]*(?:\\.[^\n"\\]*)*"s   \*\*=?s   >>=?s   <<=?s   <>s   !=s   //=?s   [+\-*/%&|^=<>]=?t   ~s   [][(){}]s   \r?\ns   [:;.,`@]s'   [uUbB]?[rR]?'[^\n'\\]*(?:\\.[^\n'\\]*)*t   's'   [uUbB]?[rR]?"[^\n"\\]*(?:\\.[^\n"\\]*)*t   "s
   \\\r?\n|\Zs   '''s   """s   r'''s   r"""s   u'''s   u"""s   ur'''s   ur"""s   R'''s   R"""s   U'''s   U"""s   uR'''s   uR"""s   Ur'''s   Ur"""s   UR'''s   UR"""s   b'''s   b"""s   br'''s   br"""s   B'''s   B"""s   bR'''s   bR"""s   Br'''s   Br"""s   BR'''s   BR"""t   rt   Rt   ut   Ut   bt   Bs   r's   r"s   R's   R"s   u's   u"s   U's   U"s   ur's   ur"s   Ur's   Ur"s   uR's   uR"s   UR's   UR"s   b's   b"s   B's   B"s   br's   br"s   Br's   Br"s   bR's   bR"s   BR's   BR"i   t
   TokenErrorc           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s   /usr/lib/python2.7/tokenize.pyR   í   s    t   StopTokenizingc           B   s   e  Z RS(    (   R   R   (    (    (    s   /usr/lib/python2.7/tokenize.pyR   î   s    c   	      C   sA   | \ } } | \ } } d | | | | t  |  t | É f GHd  S(   Ns   %d,%d-%d,%d:	%s	%s(   t   tok_namet   repr(	   t   typet   tokent	   srow_scolt	   erow_ecolt   linet   srowt   scolt   erowt   ecol(    (    s   /usr/lib/python2.7/tokenize.pyt
   printtokenñ   s    c         C   s)   y t  |  | É Wn t k
 r$ n Xd S(   s:  
    The tokenize() function accepts two parameters: one representing the
    input stream, and one providing an output mechanism for tokenize().

    The first parameter, readline, must be a callable object which provides
    the same interface as the readline() method of built-in file objects.
    Each call to the function should return one line of input as a string.

    The second parameter, tokeneater, must also be a callable object. It is
    called once for each token, with five arguments, corresponding to the
    tuples generated by generate_tokens().
    N(   t   tokenize_loopR   (   t   readlinet
   tokeneater(    (    s   /usr/lib/python2.7/tokenize.pyR   ú   s    c         C   s%   x t  |  É D] } | | å  q Wd  S(   N(   R   (   R+   R,   t
   token_info(    (    s   /usr/lib/python2.7/tokenize.pyR*   Ø   s    t   Untokenizerc           B   s,   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s   g  |  _  d |  _ d |  _ d  S(   Ni   i    (   t   tokenst   prev_rowt   prev_col(   t   self(    (    s   /usr/lib/python2.7/tokenize.pyt   __init__µ   s    		c         C   s¡   | \ } } | |  j  k  s9 | |  j  k r` | |  j k  r` t d j | | |  j  |  j É É Ç n  | |  j  } | rì |  j j d | É d |  _ n  | |  j } | rΩ |  j j d | É n  d  S(   Ns+   start ({},{}) precedes previous end ({},{})s   \
i    t    (   R0   R1   t
   ValueErrort   formatR/   t   append(   R2   t   startt   rowt   colt
   row_offsett
   col_offset(    (    s   /usr/lib/python2.7/tokenize.pyt   add_whitespace∫   s    -	c         C   sü  t  | É } g  } t } xt| D]l} t | É d k rK |  j | | É Pn  | \ } } } }	 }
 | t k rp Pn  | t k rè | j | É q n† | t k rΩ | j É  |	 \ |  _	 |  _
 q nr | t t f k rÿ t } nW | r/| r/| d } | d t | É k r&|  j j | É t | É |  _
 n  t } n  |  j | É |  j j | É |	 \ |  _	 |  _
 | t t f k r |  j	 d 7_	 d |  _
 q q Wd j |  j É S(   Ni   iˇˇˇˇi   i    t    (   t   itert   Falset   lent   compatt	   ENDMARKERt   INDENTR7   t   DEDENTt   popR0   R1   t   NEWLINER   t   TrueR/   R=   R   (   R2   t   iterablet   itt   indentst	   startlinet   tt   tok_typeR!   R8   t   endR$   t   indent(    (    s   /usr/lib/python2.7/tokenize.pyR   «   s@    
	
	c   
      C   s/  g  } |  j  j } | d t t f k } t } x˙ t | g | É D]Ê } | d  \ } }	 | t t f k rv |	 d 7}	 n  | t k rû | rï d |	 }	 n  t	 } n t } | t
 k r√ | j |	 É qA nZ | t k rﬂ | j É  qA n> | t t f k r˙ t	 } n# | r| r| | d É t } n  | |	 É qA Wd  S(   Ni    i   R4   iˇˇˇˇ(   R/   R7   RG   R   R@   R    t   NAMEt   NUMBERt   STRINGRH   RD   RE   RF   (
   R2   R!   RI   RK   t   toks_appendRL   t
   prevstringt   tokt   toknumt   tokval(    (    s   /usr/lib/python2.7/tokenize.pyRB   È   s2    	
		(   R   R   R3   R=   R   RB   (    (    (    s   /usr/lib/python2.7/tokenize.pyR.   ≥   s   			"c         C   s   t  É  } | j |  É S(   s≠  Transform tokens back into Python source code.

    Each element returned by the iterable must be a token sequence
    with at least two elements, a token number and token value.  If
    only two tokens are passed, the resulting output is poor.

    Round-trip invariant for full input:
        Untokenized source will match input source exactly

    Round-trip invariant for limited intput:
        # Output text will tokenize the back to the input
        t1 = [tok[:2] for tok in generate_tokens(f.readline)]
        newcode = untokenize(t1)
        readline = iter(newcode.splitlines(1)).next
        t2 = [tok[:2] for tok in generate_tokens(readline)]
        assert t1 == t2
    (   R.   R   (   RI   t   ut(    (    s   /usr/lib/python2.7/tokenize.pyR   
  s    	c         c   sE  d } } } t  j d d } } d \ } } d } d g }	 x¨y |  É  }
 Wn t k
 rf d }
 n X| d 7} d t |
 É } } | r{|
 s¢ t d | f Ç n  | j |
 É } | r| j d É } } t | |
 |  | | | f | |
 f Vd \ } } d } q€| ra|
 d d k ra|
 d	 d
 k rat	 | |
 | | t |
 É f | f Vd } d } q@ q€| |
 } | |
 } q@ n`| d k r∑| r∑|
 sòPn  d } xv | | k  r|
 | d k r | d 7} n? |
 | d k rÔ| t
 d t
 } n |
 | d k rd } n P| d 7} q°W| | k r'Pn  |
 | d k r|
 | d k r¡|
 | j d É } | t | É } t | | | f | | t | É f |
 f Vt |
 | | | f | t |
 É f |
 f Vq@ t t f |
 | d k |
 | | | f | t |
 É f |
 f Vq@ n  | |	 d k rI|	 j | É t |
 |  | d f | | f |
 f Vn  xè | |	 d k  r≥| |	 k rÜt d d | | |
 f É Ç n  |	 d  }	 t d | | f | | f |
 f VqLWn$ |
 s’t d | d f f Ç n  d } x
| | k  rÁt j |
 | É } | r≤| j d É \ } } | | f | | f | } } } | | k rIqﬁn  |
 | | !|
 | } } | | k sÖ| d k rú| d k rút | | | |
 f Vq‰| d k r—| d k r∫t n t | | | |
 f Vq‰| d k r
| j d É sÛt Ç t | | | |
 f Vq‰| t k rët | } | j |
 | É } | rq| j d É } |
 | | !} t | | | | f |
 f VqØ| | f } |
 | } |
 } Pq‰| t k sΩ| d  t k sΩ| d  t k r1| d d k r| | f } t | p¸t | d p¸t | d } |
 | d } } |
 } PqØt | | | |
 f Vq‰| | k rTt | | | |
 f Vq‰| d k rid } q‰| d k rÇ| d 7} n | d k rõ| d 8} n  t | | | |
 f Vqﬁt	 |
 | | | f | | d f |
 f V| d 7} qﬁWq@ Wx2 |	 d D]& } t d | d f | d f d f Vq˜Wt d | d f | d f d f Vd S(   sT  
    The generate_tokens() generator requires one argument, readline, which
    must be a callable object which provides the same interface as the
    readline() method of built-in file objects. Each call to the function
    should return one line of input as a string.  Alternately, readline
    can be a callable function terminating with StopIteration:
        readline = open(myfile).next    # Example of alternate readline

    The generator produces 5-tuples with these members: the token type; the
    token string; a 2-tuple (srow, scol) of ints specifying the row and
    column where the token begins in the source; a 2-tuple (erow, ecol) of
    ints specifying the row and column where the token ends in the source;
    and the line on which the token was found. The line passed is the
    logical line; continuation lines are included.
    i    R   t
   0123456789R>   i   s   EOF in multi-line stringi˛ˇˇˇs   \
i˝ˇˇˇs   \
R4   s   	s   s   #
t   #s   
iˇˇˇˇs3   unindent does not match any outer indentation levels
   <tokenize>s   EOF in multi-line statementt   .s   
i   i   s   \s   ([{s   )]}N(   R>   i    (   R>   i    (   t   stringt   ascii_letterst   Nonet   StopIterationRA   R   t   matchRO   RS   t
   ERRORTOKENt   tabsizet   rstripR   R   R7   RD   t   IndentationErrorRE   t
   pseudoprogt   spanRR   RG   t   endswitht   AssertionErrort   triple_quotedt   endprogst   single_quotedRQ   t   OPRC   (   R+   t   lnumt   parenlevt	   continuedt	   namecharst   numcharst   contstrt   needcontt   contlineRK   R$   t   post   maxt   strstartt   endprogt   endmatchRO   t   columnt   comment_tokent   nl_post   pseudomatchR8   t   spost   eposR!   t   initialRP   (    (    s   /usr/lib/python2.7/tokenize.pyR     s¯    	

	&


 	$
# '
' 

	
$t   __main__(   s   '''s   """s   r'''s   r"""s   R'''s   R"""s   u'''s   u"""s   U'''s   U"""s   ur'''s   ur"""s   Ur'''s   Ur"""s   uR'''s   uR"""s   UR'''s   UR"""s   b'''s   b"""s   B'''s   B"""s   br'''s   br"""s   Br'''s   Br"""s   bR'''s   bR"""s   BR'''s   BR"""(   R   R   s   r's   r"s   R's   R"s   u's   u"s   U's   U"s   ur's   ur"s   Ur's   Ur"s   uR's   uR"s   UR's   UR"s   b's   b"s   B's   B"s   br's   br"s   Br's   Br"s   bR's   bR"s   BR's   BR"(    (M   t   __doc__t
   __author__t   __credits__t	   itertoolsR    R]   t   reR!   t   dirt   xt
   startswitht   __all__t   N_TOKENSR   R   R   R   R   R   t
   Whitespacet   Commentt   Ignoret   Namet	   Hexnumbert	   Octnumbert	   Binnumbert	   Decnumbert	   Intnumbert   Exponentt
   Pointfloatt   Expfloatt   Floatnumbert
   Imagnumbert   Numbert   Singlet   Doublet   Single3t   Double3t   Triplet   Stringt   Operatort   Brackett   Specialt   Funnyt
   PlainTokent   Tokent   ContStrt   PseudoExtrast   PseudoTokent   mapt   compilet	   tokenprogRf   t   single3progt   double3progR_   Rk   Rj   RM   Rl   Rc   t	   ExceptionR   R   R)   R   R*   R.   R   R   R   t   sysRA   t   argvt   openR+   t   stdin(    (    (    s   /usr/lib/python2.7/tokenize.pyt   <module>   s⁄   
.



			
		
'#      
      
		W		ù
filename:/usr/lib/python2.7/lib2to3/__init__.py
__doc__
#empty

filename:/usr/lib/python2.7/lib2to3/btm_matcher.py
__doc__
"""A bottom-up tree matching algorithm implementation meant to speed

filename:/usr/lib/python2.7/lib2to3/fixes/fix_except.py
__doc__
"""Fixer for except statements with named exceptions.

The following cases will be converted:

- "except E, T:" where T is a name:

    except E as T:

- "except E, T:" where T is not a name, tuple or list:

        except E as t:
            T = t

    This is done because the target of an "except" clause must be a
    name.

- "except E, T:" where T is a tuple or list literal:

        except E as t:
            T = t.args
"""

filename:/usr/lib/python2.7/lib2to3/fixes/fix_metaclass.py
__doc__
"""Fixer for __metaclass__ = X -> (metaclass=X) methods.

   The various forms of classef (inherits nothing, inherits once, inherints
   many) don't parse the same in the CST so we look at ALL classes for
   a __metaclass__ and if we find one normalize the inherits to all be
   an arglist.

   For one-liner classes ('class X: pass') there is no indent/dedent so
   we normalize those into having a suite.

   Moving the __metaclass__ into the classdef can also cause the class
   body to be empty so there is some special casing for that as well.

   This fixer also tries very hard to keep original indenting and spacing
   in all those corner cases.

"""

filename:/usr/lib/python2.7/lib2to3/fixes/fix_throw.py
__doc__
"""Fixer for generator.throw(E, V, T).

g.throw(E)       -> g.throw(E)
g.throw(E, V)    -> g.throw(E(V))
g.throw(E, V, T) -> g.throw(E(V).with_traceback(T))

g.throw("foo"[, V[, T]]) will warn about string exceptions."""
# Author: Collin Winter

# Local imports
from .. import pytree
from ..pgen2 import token
from .. import fixer_base
from ..fixer_util import Name, Call, ArgList, Attr, is_tuple

class FixThrow(fixer_base.BaseFix):
    BM_compatible = True
    PATTERN = """
    power< any trailer< '.' 'throw' >
           trailer< '(' args=arglist< exc=any ',' val=any [',' tb=any] > ')' >
    >
    |
    power< any trailer< '.' 'throw' > trailer< '(' exc=any ')' > >
    """

    def transform(self, node, results):
        syms = self.syms

        exc = results["exc"].clone()
        if exc.type is token.STRING:
            self.cannot_convert(node, "Python 3 does not support string exceptions")
            return

        # Leave "g.throw(E)" alone
        val = results.get(u"val")
        if val is None:
            return

        val = val.clone()
        if is_tuple(val):
            args = [c.clone() for c in val.children[1:-1]]
        else:
            val.prefix = u""
            args = [val]

        throw_args = results["args"]

        if "tb" in results:
            tb = results["tb"].clone()
            tb.prefix = u""

            e = Call(exc, args)
            with_tb = Attr(e, Name(u'with_traceback')) + [ArgList([tb])]
            throw_args.replace(pytree.Node(syms.power, with_tb))
        else:
            throw_args.replace(Call(exc, args))

filename:/usr/lib/python2.7/lib2to3/fixes/fix_raise.py
__doc__
"""Fixer for 'raise E, V, T'

filename:/usr/lib/python2.7/lib2to3/fixes/fix_itertools_imports.py
__doc__
""" Fixer for imports of itertools.(imap|ifilter|izip|ifilterfalse) """

# Local imports
from lib2to3 import fixer_base
from lib2to3.fixer_util import BlankLine, syms, token


class FixItertoolsImports(fixer_base.BaseFix):
    BM_compatible = True
    PATTERN = """
              import_from< 'from' 'itertools' 'import' imports=any >
              """ %(locals())

    def transform(self, node, results):
        imports = results['imports']
        if imports.type == syms.import_as_name or not imports.children:
            children = [imports]
        else:
            children = imports.children
        for child in children[::2]:
            if child.type == token.NAME:
                member = child.value
                name_node = child
            elif child.type == token.STAR:
                # Just leave the import as is.
                return
            else:
                assert child.type == syms.import_as_name
                name_node = child.children[0]
            member_name = name_node.value
            if member_name in (u'imap', u'izip', u'ifilter'):
                child.value = None
                child.remove()
            elif member_name in (u'ifilterfalse', u'izip_longest'):
                node.changed()
                name_node.value = (u'filterfalse' if member_name[1] == u'f'
                                   else u'zip_longest')

        # Make sure the import statement is still sane
        children = imports.children[:] or [imports]
        remove_comma = True
        for child in children:
            if remove_comma and child.type == token.COMMA:
                child.remove()
            else:
                remove_comma ^= True

        while children and children[-1].type == token.COMMA:
            children.pop().remove()

        # If there are no imports left, just get rid of the entire statement
        if (not (imports.children or getattr(imports, 'value', None)) or
            imports.parent is None):
            p = node.prefix
            node = BlankLine()
            node.prefix = p
            return node

filename:/usr/lib/python2.7/lib2to3/fixes/fix_repr.py
__doc__
# Copyright 2006 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Fixer that transforms `xyzzy` into repr(xyzzy)."""

filename:/usr/lib/python2.7/lib2to3/fixes/fix_imports.py
__doc__
"""Fix incompatible imports and module references."""
# Authors: Collin Winter, Nick Edds

# Local imports
from .. import fixer_base
from ..fixer_util import Name, attr_chain

MAPPING = {'StringIO':  'io',
           'cStringIO': 'io',
           'cPickle': 'pickle',
           '__builtin__' : 'builtins',
           'copy_reg': 'copyreg',
           'Queue': 'queue',
           'SocketServer': 'socketserver',
           'ConfigParser': 'configparser',
           'repr': 'reprlib',
           'FileDialog': 'tkinter.filedialog',
           'tkFileDialog': 'tkinter.filedialog',
           'SimpleDialog': 'tkinter.simpledialog',
           'tkSimpleDialog': 'tkinter.simpledialog',
           'tkColorChooser': 'tkinter.colorchooser',
           'tkCommonDialog': 'tkinter.commondialog',
           'Dialog': 'tkinter.dialog',
           'Tkdnd': 'tkinter.dnd',
           'tkFont': 'tkinter.font',
           'tkMessageBox': 'tkinter.messagebox',
           'ScrolledText': 'tkinter.scrolledtext',
           'Tkconstants': 'tkinter.constants',
           'Tix': 'tkinter.tix',
           'ttk': 'tkinter.ttk',
           'Tkinter': 'tkinter',
           'markupbase': '_markupbase',
           '_winreg': 'winreg',
           'thread': '_thread',
           'dummy_thread': '_dummy_thread',
           # anydbm and whichdb are handled by fix_imports2
           'dbhash': 'dbm.bsd',
           'dumbdbm': 'dbm.dumb',
           'dbm': 'dbm.ndbm',
           'gdbm': 'dbm.gnu',
           'xmlrpclib': 'xmlrpc.client',
           'DocXMLRPCServer': 'xmlrpc.server',
           'SimpleXMLRPCServer': 'xmlrpc.server',
           'httplib': 'http.client',
           'htmlentitydefs' : 'html.entities',
           'HTMLParser' : 'html.parser',
           'Cookie': 'http.cookies',
           'cookielib': 'http.cookiejar',
           'BaseHTTPServer': 'http.server',
           'SimpleHTTPServer': 'http.server',
           'CGIHTTPServer': 'http.server',
           #'test.test_support': 'test.support',
           'commands': 'subprocess',
           'UserString' : 'collections',
           'UserList' : 'collections',
           'urlparse' : 'urllib.parse',
           'robotparser' : 'urllib.robotparser',
}


def alternates(members):
    return "(" + "|".join(map(repr, members)) + ")"


def build_pattern(mapping=MAPPING):
    mod_list = ' | '.join(["module_name='%s'" % key for key in mapping])
    bare_names = alternates(mapping.keys())

    yield """name_import=import_name< 'import' ((%s) |
               multiple_imports=dotted_as_names< any* (%s) any* >) >
          """ % (mod_list, mod_list)
    yield """import_from< 'from' (%s) 'import' ['(']
              ( any | import_as_name< any 'as' any > |
                import_as_names< any* >)  [')'] >
          """ % mod_list
    yield """import_name< 'import' (dotted_as_name< (%s) 'as' any > |
               multiple_imports=dotted_as_names<
                 any* dotted_as_name< (%s) 'as' any > any* >) >
          """ % (mod_list, mod_list)

    # Find usages of module members in code e.g. thread.foo(bar)
    yield "power< bare_with_attr=(%s) trailer<'.' any > any* >" % bare_names


class FixImports(fixer_base.BaseFix):

    BM_compatible = True
    keep_line_order = True
    # This is overridden in fix_imports2.
    mapping = MAPPING

    # We want to run this fixer late, so fix_import doesn't try to make stdlib
    # renames into relative imports.
    run_order = 6

    def build_pattern(self):
        return "|".join(build_pattern(self.mapping))

    def compile_pattern(self):
        # We override this, so MAPPING can be pragmatically altered and the
        # changes will be reflected in PATTERN.
        self.PATTERN = self.build_pattern()
        super(FixImports, self).compile_pattern()

    # Don't match the node if it's within another match.
    def match(self, node):
        match = super(FixImports, self).match
        results = match(node)
        if results:
            # Module usage could be in the trailer of an attribute lookup, so we
            # might have nested matches when "bare_with_attr" is present.
            if "bare_with_attr" not in results and \
                    any(match(obj) for obj in attr_chain(node, "parent")):
                return False
            return results
        return False

    def start_tree(self, tree, filename):
        super(FixImports, self).start_tree(tree, filename)
        self.replace = {}

    def transform(self, node, results):
        import_mod = results.get("module_name")
        if import_mod:
            mod_name = import_mod.value
            new_name = unicode(self.mapping[mod_name])
            import_mod.replace(Name(new_name, prefix=import_mod.prefix))
            if "name_import" in results:
                # If it's not a "from x import x, y" or "import x as y" import,
                # marked its usage to be replaced.
                self.replace[mod_name] = new_name
            if "multiple_imports" in results:
                # This is a nasty hack to fix multiple imports on a line (e.g.,
                # "import StringIO, urlparse"). The problem is that I can't
                # figure out an easy way to make a pattern recognize the keys of
                # MAPPING randomly sprinkled in an import statement.
                results = self.match(node)
                if results:
                    self.transform(node, results)
        else:
            # Replace usage of the module.
            bare_name = results["bare_with_attr"][0]
            new_name = self.replace.get(bare_name.value)
            if new_name:
                bare_name.replace(Name(new_name, prefix=bare_name.prefix))

filename:/usr/lib/python2.7/lib2to3/fixes/fix_methodattrs.py
__doc__
"""Fix bound method attributes (method.im_? -> method.__?__).

filename:/usr/lib/python2.7/lib2to3/fixes/fix_imports2.py
__doc__
"""Fix incompatible imports and module references that must be fixed after
fix_imports."""
from . import fix_imports


MAPPING = {
            'whichdb': 'dbm',
            'anydbm': 'dbm',
          }


class FixImports2(fix_imports.FixImports):

    run_order = 7

    mapping = MAPPING

filename:/usr/lib/python2.7/lib2to3/fixes/fix_import.py
__doc__
"""Fixer for import statements.

filename:/usr/lib/python2.7/lib2to3/fixes/fix_future.py
__doc__
"""Remove __future__ imports

from __future__ import foo is replaced with an empty line.
"""

filename:/usr/lib/python2.7/lib2to3/fixes/fix_renames.py
__doc__
"""Fix incompatible renames

Fixes:
  * sys.maxint -> sys.maxsize
"""

filename:/usr/lib/python2.7/lib2to3/fixes/fix_basestring.py
__doc__
"""Fixer for basestring -> str."""
# Author: Christian Heimes

# Local imports
from .. import fixer_base
from ..fixer_util import Name

class FixBasestring(fixer_base.BaseFix):
    BM_compatible = True

    PATTERN = "'basestring'"

    def transform(self, node, results):
        return Name(u"str", prefix=node.prefix)

filename:/usr/lib/python2.7/lib2to3/fixes/fix_intern.py
__doc__
# Copyright 2006 Georg Brandl.
# Licensed to PSF under a Contributor Agreement.

"""Fixer for intern().

filename:/usr/lib/python2.7/lib2to3/fixes/fix_itertools.py
__doc__
""" Fixer for itertools.(imap|ifilter|izip) --> (map|filter|zip) and
    itertools.ifilterfalse --> itertools.filterfalse (bugs 2360-2363)

    imports from itertools are fixed in fix_itertools_import.py

    If itertools is imported as something else (ie: import itertools as it;
    it.izip(spam, eggs)) method calls will not get fixed.
    """

# Local imports
from .. import fixer_base
from ..fixer_util import Name

class FixItertools(fixer_base.BaseFix):
    BM_compatible = True
    it_funcs = "('imap'|'ifilter'|'izip'|'izip_longest'|'ifilterfalse')"
    PATTERN = """
              power< it='itertools'
                  trailer<
                     dot='.' func=%(it_funcs)s > trailer< '(' [any] ')' > >
              |
              power< func=%(it_funcs)s trailer< '(' [any] ')' > >
              """ %(locals())

    # Needs to be run after fix_(map|zip|filter)
    run_order = 6

    def transform(self, node, results):
        prefix = None
        func = results['func'][0]
        if ('it' in results and
            func.value not in (u'ifilterfalse', u'izip_longest')):
            dot, it = (results['dot'], results['it'])
            # Remove the 'itertools'
            prefix = it.prefix
            it.remove()
            # Replace the node which contains ('.', 'function') with the
            # function (to be consistent with the second part of the pattern)
            dot.remove()
            func.parent.replace(func)

        prefix = prefix or func.prefix
        func.replace(Name(func.value[1:], prefix=prefix))

filename:/usr/lib/python2.7/lib2to3/fixes/fix_sys_exc.py
__doc__
"""Fixer for sys.exc_{type, value, traceback}

filename:/usr/lib/python2.7/lib2to3/fixes/fix_idioms.py
__doc__
"""Adjust some old Python 2 idioms to their modern counterparts.

* Change some type comparisons to isinstance() calls:
    type(x) == T -> isinstance(x, T)
    type(x) is T -> isinstance(x, T)
    type(x) != T -> not isinstance(x, T)
    type(x) is not T -> not isinstance(x, T)

* Change "while 1:" into "while True:".

* Change both

    v = list(EXPR)
    v.sort()
    foo(v)

and the more general

    v = EXPR
    v.sort()
    foo(v)

into

    v = sorted(EXPR)
    foo(v)
"""

filename:/usr/lib/python2.7/lib2to3/fixes/fix_numliterals.py
__doc__
"""Fixer that turns 1L into 1, 0755 into 0o755.
"""

filename:/usr/lib/python2.7/lib2to3/fixes/fix_tuple_params.py
__doc__
"""Fixer for function definitions with tuple parameters.

def func(((a, b), c), d):
    ...

    ->

def func(x, d):
    ((a, b), c) = x
    ...

It will also support lambdas:

    lambda (x, y): x + y -> lambda t: t[0] + t[1]

    # The parens are a syntax error in Python 3
    lambda (x): x + y -> lambda x: x + y
"""

filename:/usr/lib/python2.7/lib2to3/fixes/fix_urllib.py
__doc__
"""Fix changes imports of urllib which are now incompatible.
   This is rather similar to fix_imports, but because of the more
   complex nature of the fixing for urllib, it has its own fixer.
"""

filename:/usr/lib/python2.7/lib2to3/fixes/fix_paren.py
__doc__
"""Fixer that addes parentheses where they are required

This converts ``[x for x in 1, 2]`` to ``[x for x in (1, 2)]``."""

# By Taek Joo Kim and Benjamin Peterson

# Local imports
from .. import fixer_base
from ..fixer_util import LParen, RParen

# XXX This doesn't support nested for loops like [x for x in 1, 2 for x in 1, 2]
class FixParen(fixer_base.BaseFix):
    BM_compatible = True

    PATTERN = """
        atom< ('[' | '(')
            (listmaker< any
                comp_for<
                    'for' NAME 'in'
                    target=testlist_safe< any (',' any)+ [',']
                     >
                    [any]
                >
            >
            |
            testlist_gexp< any
                comp_for<
                    'for' NAME 'in'
                    target=testlist_safe< any (',' any)+ [',']
                     >
                    [any]
                >
            >)
        (']' | ')') >
    """

    def transform(self, node, results):
        target = results["target"]

        lparen = LParen()
        lparen.prefix = target.prefix
        target.prefix = u"" # Make it hug the parentheses
        target.insert_child(0, lparen)
        target.append_child(RParen())

filename:/usr/lib/python2.7/lib2to3/fixes/fix_dict.py
__doc__
# Copyright 2007 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Fixer for dict methods.

filename:/usr/lib/python2.7/lib2to3/fixes/fix_getcwdu.py
__doc__
"""
Fixer that changes os.getcwdu() to os.getcwd().
"""

filename:/usr/lib/python2.7/lib2to3/fixes/fix_funcattrs.py
__doc__
"""Fix function attribute names (f.func_x -> f.__x__)."""
# Author: Collin Winter

# Local imports
from .. import fixer_base
from ..fixer_util import Name


class FixFuncattrs(fixer_base.BaseFix):
    BM_compatible = True

    PATTERN = """
    power< any+ trailer< '.' attr=('func_closure' | 'func_doc' | 'func_globals'
                                  | 'func_name' | 'func_defaults' | 'func_code'
                                  | 'func_dict') > any* >
    """

    def transform(self, node, results):
        attr = results["attr"][0]
        attr.replace(Name((u"__%s__" % attr.value[5:]),
                          prefix=attr.prefix))

filename:/usr/lib/python2.7/lib2to3/fixes/fix_unicode.py
__doc__
r"""Fixer for unicode.

* Changes unicode to str and unichr to chr.

* If "...\u..." is not unicode literal change it into "...\\u...".

* Change u"..." into "...".

"""

filename:/usr/lib/python2.7/lib2to3/fixes/fix_next.py
__doc__
"""Fixer for it.next() -> next(it), per PEP 3114."""
# Author: Collin Winter

# Things that currently aren't covered:
#   - listcomp "next" names aren't warned
#   - "with" statement targets aren't checked

# Local imports
from ..pgen2 import token
from ..pygram import python_symbols as syms
from .. import fixer_base
from ..fixer_util import Name, Call, find_binding

bind_warning = "Calls to builtin next() possibly shadowed by global binding"


class FixNext(fixer_base.BaseFix):
    BM_compatible = True
    PATTERN = """
    power< base=any+ trailer< '.' attr='next' > trailer< '(' ')' > >
    |
    power< head=any+ trailer< '.' attr='next' > not trailer< '(' ')' > >
    |
    classdef< 'class' any+ ':'
              suite< any*
                     funcdef< 'def'
                              name='next'
                              parameters< '(' NAME ')' > any+ >
                     any* > >
    |
    global=global_stmt< 'global' any* 'next' any* >
    """

    order = "pre" # Pre-order tree traversal

    def start_tree(self, tree, filename):
        super(FixNext, self).start_tree(tree, filename)

        n = find_binding(u'next', tree)
        if n:
            self.warning(n, bind_warning)
            self.shadowed_next = True
        else:
            self.shadowed_next = False

    def transform(self, node, results):
        assert results

        base = results.get("base")
        attr = results.get("attr")
        name = results.get("name")

        if base:
            if self.shadowed_next:
                attr.replace(Name(u"__next__", prefix=attr.prefix))
            else:
                base = [n.clone() for n in base]
                base[0].prefix = u""
                node.replace(Call(Name(u"next", prefix=node.prefix), base))
        elif name:
            n = Name(u"__next__", prefix=name.prefix)
            name.replace(n)
        elif attr:
            # We don't do this transformation if we're assigning to "x.next".
            # Unfortunately, it doesn't seem possible to do this in PATTERN,
            #  so it's being done here.
            if is_assign_target(node):
                head = results["head"]
                if "".join([str(n) for n in head]).strip() == u'__builtin__':
                    self.warning(node, bind_warning)
                return
            attr.replace(Name(u"__next__"))
        elif "global" in results:
            self.warning(node, bind_warning)
            self.shadowed_next = True


### The following functions help test if node is part of an assignment
###  target.

def is_assign_target(node):
    assign = find_assign(node)
    if assign is None:
        return False

    for child in assign.children:
        if child.type == token.EQUAL:
            return False
        elif is_subtree(child, node):
            return True
    return False

def find_assign(node):
    if node.type == syms.expr_stmt:
        return node
    if node.type == syms.simple_stmt or node.parent is None:
        return None
    return find_assign(node.parent)

def is_subtree(root, node):
    if root == node:
        return True
    return any(is_subtree(c, node) for c in root.children)

filename:/usr/lib/python2.7/lib2to3/fixes/fix_set_literal.py
__doc__
"""

filename:/usr/lib/python2.7/lib2to3/fixes/fix_zip.py
__doc__
"""
Fixer that changes zip(seq0, seq1, ...) into list(zip(seq0, seq1, ...)
unless there exists a 'from future_builtins import zip' statement in the
top-level namespace.

We avoid the transformation if the zip() call is directly contained in
iter(<>), list(<>), tuple(<>), sorted(<>), ...join(<>), or for V in <>:.
"""

filename:/usr/lib/python2.7/lib2to3/fixes/fix_ws_comma.py
__doc__
"""Fixer that changes 'a ,b' into 'a, b'.

This also changes '{a :b}' into '{a: b}', but does not touch other
uses of colons.  It does not touch other uses of whitespace.

"""

filename:/usr/lib/python2.7/lib2to3/fixes/fix_xreadlines.py
__doc__
"""Fix "for x in f.xreadlines()" -> "for x in f".

This fixer will also convert g(f.xreadlines) into g(f.__iter__)."""
# Author: Collin Winter

# Local imports
from .. import fixer_base
from ..fixer_util import Name


class FixXreadlines(fixer_base.BaseFix):
    BM_compatible = True
    PATTERN = """
    power< call=any+ trailer< '.' 'xreadlines' > trailer< '(' ')' > >
    |
    power< any+ trailer< '.' no_call='xreadlines' > >
    """

    def transform(self, node, results):
        no_call = results.get("no_call")

        if no_call:
            no_call.replace(Name(u"__iter__", prefix=no_call.prefix))
        else:
            node.replace([x.clone() for x in results["call"]])

filename:/usr/lib/python2.7/lib2to3/fixes/fix_input.py
__doc__
"""Fixer that changes input(...) into eval(input(...))."""

filename:/usr/lib/python2.7/lib2to3/fixes/fix_exitfunc.py
__doc__
"""
Convert use of sys.exitfunc to use the atexit module.
"""

filename:/usr/lib/python2.7/lib2to3/fixes/fix_asserts.py
__doc__
"""Fixer that replaces deprecated unittest method names."""

# Author: Ezio Melotti

from ..fixer_base import BaseFix
from ..fixer_util import Name

NAMES = dict(
    assert_="assertTrue",
    assertEquals="assertEqual",
    assertNotEquals="assertNotEqual",
    assertAlmostEquals="assertAlmostEqual",
    assertNotAlmostEquals="assertNotAlmostEqual",
    assertRegexpMatches="assertRegex",
    assertRaisesRegexp="assertRaisesRegex",
    failUnlessEqual="assertEqual",
    failIfEqual="assertNotEqual",
    failUnlessAlmostEqual="assertAlmostEqual",
    failIfAlmostEqual="assertNotAlmostEqual",
    failUnless="assertTrue",
    failUnlessRaises="assertRaises",
    failIf="assertFalse",
)


class FixAsserts(BaseFix):

    PATTERN = """
              power< any+ trailer< '.' meth=(%s)> any* >
              """ % '|'.join(map(repr, NAMES))

    def transform(self, node, results):
        name = results["meth"][0]
        name.replace(Name(NAMES[str(name)], prefix=name.prefix))

filename:/usr/lib/python2.7/lib2to3/fixes/fix_nonzero.py
__doc__
"""Fixer for __nonzero__ -> __bool__ methods."""

filename:/usr/lib/python2.7/lib2to3/fixes/fix_operator.py
__doc__
"""Fixer for operator functions.

operator.isCallable(obj)       -> hasattr(obj, '__call__')
operator.sequenceIncludes(obj) -> operator.contains(obj)
operator.isSequenceType(obj)   -> isinstance(obj, collections.Sequence)
operator.isMappingType(obj)    -> isinstance(obj, collections.Mapping)
operator.isNumberType(obj)     -> isinstance(obj, numbers.Number)
operator.repeat(obj, n)        -> operator.mul(obj, n)
operator.irepeat(obj, n)       -> operator.imul(obj, n)
"""

filename:/usr/lib/python2.7/lib2to3/fixes/fix_raw_input.py
__doc__
"""Fixer that changes raw_input(...) into input(...)."""
# Author: Andre Roberge

# Local imports
from .. import fixer_base
from ..fixer_util import Name

class FixRawInput(fixer_base.BaseFix):

    BM_compatible = True
    PATTERN = """
              power< name='raw_input' trailer< '(' [any] ')' > any* >
              """

    def transform(self, node, results):
        name = results["name"]
        name.replace(Name(u"input", prefix=name.prefix))

filename:/usr/lib/python2.7/lib2to3/pgen2/__init__.py
__doc__
# Copyright 2004-2005 Elemental Security, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""The pgen2 package."""

filename:/usr/lib/python2.7/lib2to3/fixer_util.py
__doc__
"""Utility functions, node construction macros, etc."""
# Author: Collin Winter

from itertools import islice

# Local imports
from .pgen2 import token
from .pytree import Leaf, Node
from .pygram import python_symbols as syms
from . import patcomp


###########################################################
### Common node-construction "macros"
###########################################################

def KeywordArg(keyword, value):
    return Node(syms.argument,
                [keyword, Leaf(token.EQUAL, u"="), value])

def LParen():
    return Leaf(token.LPAR, u"(")

def RParen():
    return Leaf(token.RPAR, u")")

def Assign(target, source):
    """Build an assignment statement"""
    if not isinstance(target, list):
        target = [target]
    if not isinstance(source, list):
        source.prefix = u" "
        source = [source]

    return Node(syms.atom,
                target + [Leaf(token.EQUAL, u"=", prefix=u" ")] + source)

def Name(name, prefix=None):
    """Return a NAME leaf"""
    return Leaf(token.NAME, name, prefix=prefix)

def Attr(obj, attr):
    """A node tuple for obj.attr"""
    return [obj, Node(syms.trailer, [Dot(), attr])]

def Comma():
    """A comma leaf"""
    return Leaf(token.COMMA, u",")

def Dot():
    """A period (.) leaf"""
    return Leaf(token.DOT, u".")

def ArgList(args, lparen=LParen(), rparen=RParen()):
    """A parenthesised argument list, used by Call()"""
    node = Node(syms.trailer, [lparen.clone(), rparen.clone()])
    if args:
        node.insert_child(1, Node(syms.arglist, args))
    return node

def Call(func_name, args=None, prefix=None):
    """A function call"""
    node = Node(syms.power, [func_name, ArgList(args)])
    if prefix is not None:
        node.prefix = prefix
    return node

def Newline():
    """A newline literal"""
    return Leaf(token.NEWLINE, u"\n")

def BlankLine():
    """A blank line"""
    return Leaf(token.NEWLINE, u"")

def Number(n, prefix=None):
    return Leaf(token.NUMBER, n, prefix=prefix)

def Subscript(index_node):
    """A numeric or string subscript"""
    return Node(syms.trailer, [Leaf(token.LBRACE, u"["),
                               index_node,
                               Leaf(token.RBRACE, u"]")])

def String(string, prefix=None):
    """A string leaf"""
    return Leaf(token.STRING, string, prefix=prefix)

def ListComp(xp, fp, it, test=None):
    """A list comprehension of the form [xp for fp in it if test].

    If test is None, the "if test" part is omitted.
    """
    xp.prefix = u""
    fp.prefix = u" "
    it.prefix = u" "
    for_leaf = Leaf(token.NAME, u"for")
    for_leaf.prefix = u" "
    in_leaf = Leaf(token.NAME, u"in")
    in_leaf.prefix = u" "
    inner_args = [for_leaf, fp, in_leaf, it]
    if test:
        test.prefix = u" "
        if_leaf = Leaf(token.NAME, u"if")
        if_leaf.prefix = u" "
        inner_args.append(Node(syms.comp_if, [if_leaf, test]))
    inner = Node(syms.listmaker, [xp, Node(syms.comp_for, inner_args)])
    return Node(syms.atom,
                       [Leaf(token.LBRACE, u"["),
                        inner,
                        Leaf(token.RBRACE, u"]")])

def FromImport(package_name, name_leafs):
    """ Return an import statement in the form:
        from package import name_leafs"""
    # XXX: May not handle dotted imports properly (eg, package_name='foo.bar')
    #assert package_name == '.' or '.' not in package_name, "FromImport has "\
    #       "not been tested with dotted package names -- use at your own "\
    #       "peril!"

    for leaf in name_leafs:
        # Pull the leaves out of their old tree
        leaf.remove()

    children = [Leaf(token.NAME, u"from"),
                Leaf(token.NAME, package_name, prefix=u" "),
                Leaf(token.NAME, u"import", prefix=u" "),
                Node(syms.import_as_names, name_leafs)]
    imp = Node(syms.import_from, children)
    return imp


###########################################################
### Determine whether a node represents a given literal
###########################################################

def is_tuple(node):
    """Does the node represent a tuple literal?"""
    if isinstance(node, Node) and node.children == [LParen(), RParen()]:
        return True
    return (isinstance(node, Node)
            and len(node.children) == 3
            and isinstance(node.children[0], Leaf)
            and isinstance(node.children[1], Node)
            and isinstance(node.children[2], Leaf)
            and node.children[0].value == u"("
            and node.children[2].value == u")")

def is_list(node):
    """Does the node represent a list literal?"""
    return (isinstance(node, Node)
            and len(node.children) > 1
            and isinstance(node.children[0], Leaf)
            and isinstance(node.children[-1], Leaf)
            and node.children[0].value == u"["
            and node.children[-1].value == u"]")


###########################################################
### Misc
###########################################################

def parenthesize(node):
    return Node(syms.atom, [LParen(), node, RParen()])


consuming_calls = set(["sorted", "list", "set", "any", "all", "tuple", "sum",
                       "min", "max", "enumerate"])

def attr_chain(obj, attr):
    """Follow an attribute chain.

    If you have a chain of objects where a.foo -> b, b.foo-> c, etc,
    use this to iterate over all objects in the chain. Iteration is
    terminated by getattr(x, attr) is None.

    Args:
        obj: the starting object
        attr: the name of the chaining attribute

    Yields:
        Each successive object in the chain.
    """
    next = getattr(obj, attr)
    while next:
        yield next
        next = getattr(next, attr)

p0 = """for_stmt< 'for' any 'in' node=any ':' any* >
        | comp_for< 'for' any 'in' node=any any* >
     """
p1 = """
power<
    ( 'iter' | 'list' | 'tuple' | 'sorted' | 'set' | 'sum' |
      'any' | 'all' | 'enumerate' | (any* trailer< '.' 'join' >) )
    trailer< '(' node=any ')' >
    any*
>
"""

filename:/usr/lib/python2.7/lib2to3/main.py
__doc__
"""
Main program for 2to3.
"""

filename:/usr/lib/python2.7/codecs.py
__doc__
""" codecs -- Python Codec Registry, API and helpers.


Written by Marc-Andre Lemburg (mal@lemburg.com).

(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.

"""#"

filename:/usr/lib/python2.7/fnmatch.py
__doc__
"""Filename matching with shell patterns.

fnmatch(FILENAME, PATTERN) matches according to the local convention.
fnmatchcase(FILENAME, PATTERN) always takes case in account.

The functions operate by translating the pattern into a regular
expression.  They cache the compiled regular expressions for speed.

The function translate(PATTERN) returns a regular expression
corresponding to PATTERN.  (It does not compile it.)
"""

filename:/usr/lib/python2.7/aifc.py
__doc__
"""Stuff to parse AIFF-C and AIFF files.

Unless explicitly stated otherwise, the description below is true
both for AIFF-C files and AIFF files.

An AIFF-C file has the following structure.

  +-----------------+
  | FORM            |
  +-----------------+
  | <size>          |
  +----+------------+
  |    | AIFC       |
  |    +------------+
  |    | <chunks>   |
  |    |    .       |
  |    |    .       |
  |    |    .       |
  +----+------------+

An AIFF file has the string "AIFF" instead of "AIFC".

A chunk consists of an identifier (4 bytes) followed by a size (4 bytes,
big endian order), followed by the data.  The size field does not include
the size of the 8 byte header.

The following chunk types are recognized.

  FVER
      <version number of AIFF-C defining document> (AIFF-C only).
  MARK
      <# of markers> (2 bytes)
      list of markers:
          <marker ID> (2 bytes, must be > 0)
          <position> (4 bytes)
          <marker name> ("pstring")
  COMM
      <# of channels> (2 bytes)
      <# of sound frames> (4 bytes)
      <size of the samples> (2 bytes)
      <sampling frequency> (10 bytes, IEEE 80-bit extended
          floating point)
      in AIFF-C files only:
      <compression type> (4 bytes)
      <human-readable version of compression type> ("pstring")
  SSND
      <offset> (4 bytes, not used by this program)
      <blocksize> (4 bytes, not used by this program)
      <sound data>

A pstring consists of 1 byte length, a string of characters, and 0 or 1
byte pad to make the total length even.

Usage.

Reading AIFF files:
  f = aifc.open(file, 'r')
where file is either the name of a file or an open file pointer.
The open file pointer must have methods read(), seek(), and close().
In some types of audio files, if the setpos() method is not used,
the seek() method is not necessary.

This returns an instance of a class with the following public methods:
  getnchannels()  -- returns number of audio channels (1 for
             mono, 2 for stereo)
  getsampwidth()  -- returns sample width in bytes
  getframerate()  -- returns sampling frequency
  getnframes()    -- returns number of audio frames
  getcomptype()   -- returns compression type ('NONE' for AIFF files)
  getcompname()   -- returns human-readable version of
             compression type ('not compressed' for AIFF files)
  getparams() -- returns a tuple consisting of all of the
             above in the above order
  getmarkers()    -- get the list of marks in the audio file or None
             if there are no marks
  getmark(id) -- get mark with the specified id (raises an error
             if the mark does not exist)
  readframes(n)   -- returns at most n frames of audio
  rewind()    -- rewind to the beginning of the audio stream
  setpos(pos) -- seek to the specified position
  tell()      -- return the current position
  close()     -- close the instance (make it unusable)
The position returned by tell(), the position given to setpos() and
the position of marks are all compatible and have nothing to do with
the actual position in the file.
The close() method is called automatically when the class instance
is destroyed.

Writing AIFF files:
  f = aifc.open(file, 'w')
where file is either the name of a file or an open file pointer.
The open file pointer must have methods write(), tell(), seek(), and
close().

This returns an instance of a class with the following public methods:
  aiff()      -- create an AIFF file (AIFF-C default)
  aifc()      -- create an AIFF-C file
  setnchannels(n) -- set the number of channels
  setsampwidth(n) -- set the sample width
  setframerate(n) -- set the frame rate
  setnframes(n)   -- set the number of frames
  setcomptype(type, name)
          -- set the compression type and the
             human-readable compression type
  setparams(tuple)
          -- set all parameters at once
  setmark(id, pos, name)
          -- add specified mark to the list of marks
  tell()      -- return current position in output file (useful
             in combination with setmark())
  writeframesraw(data)
          -- write audio frames without pathing up the
             file header
  writeframes(data)
          -- write audio frames and patch up the file header
  close()     -- patch up the file header and close the
             output file
You should set the parameters before the first writeframesraw or
writeframes.  The total number of frames does not need to be set,
but when it is set to the correct value, the header does not have to
be patched up.
It is best to first set all parameters, perhaps possibly the
compression type, and then write audio frames using writeframesraw.
When all frames have been written, either call writeframes('') or
close() to patch up the sizes in the header.
Marks can be added anytime.  If there are any marks, you must call
close() after all frames have been written.
The close() method is called automatically when the class instance
is destroyed.

When a file is opened with the extension '.aiff', an AIFF file is
written, otherwise an AIFF-C file is written.  This default can be
changed by calling aiff() or aifc() before the first writeframes or
writeframesraw.
"""

filename:/usr/lib/python2.7/xml/__init__.py
__doc__
"""Core XML support for Python.

This package contains four sub-packages:

dom -- The W3C Document Object Model.  This supports DOM Level 1 +
       Namespaces.

parsers -- Python wrappers for XML parsers (currently only supports Expat).

sax -- The Simple API for XML, developed by XML-Dev, led by David
       Megginson and ported to Python by Lars Marius Garshol.  This
       supports the SAX 2 API.

etree -- The ElementTree XML library.  This is a subset of the full
       ElementTree XML release.

"""

filename:/usr/lib/python2.7/xml/parsers/__init__.py
__doc__
"""Python interfaces to XML parsers.

This package contains one module:

expat -- Python wrapper for James Clark's Expat parser, with namespace
         support.

"""

filename:/usr/lib/python2.7/xml/parsers/expat.py
__doc__
"""Interface to the Expat non-validating XML parser."""
__version__ = '$Revision: 17640 $'

from pyexpat import *

filename:/usr/lib/python2.7/xml/dom/__init__.py
__doc__
"""W3C Document Object Model implementation for Python.

filename:/usr/lib/python2.7/xml/dom/domreg.py
__doc__
"""Registration facilities for DOM. This module should not be used
directly. Instead, the functions getDOMImplementation and
registerDOMImplementation should be imported from xml.dom."""

from xml.dom.minicompat import *  # isinstance, StringTypes

# This is a list of well-known implementations.  Well-known names
# should be published by posting to xml-sig@python.org, and are
# subsequently recorded in this file.

well_known_implementations = {
    'minidom':'xml.dom.minidom',
    '4DOM': 'xml.dom.DOMImplementation',
    }

# DOM implementations not officially registered should register
# themselves with their

registered = {}

def registerDOMImplementation(name, factory):
    """registerDOMImplementation(name, factory)

    Register the factory function with the name. The factory function
    should return an object which implements the DOMImplementation
    interface. The factory function can either return the same object,
    or a new one (e.g. if that implementation supports some
    customization)."""

    registered[name] = factory

def _good_enough(dom, features):
    "_good_enough(dom, features) -> Return 1 if the dom offers the features"
    for f,v in features:
        if not dom.hasFeature(f,v):
            return 0
    return 1

def getDOMImplementation(name = None, features = ()):
    """getDOMImplementation(name = None, features = ()) -> DOM implementation.

    Return a suitable DOM implementation. The name is either
    well-known, the module name of a DOM implementation, or None. If
    it is not None, imports the corresponding module and returns
    DOMImplementation object if the import succeeds.

    If name is not given, consider the available implementations to
    find one with the required feature set. If no implementation can
    be found, raise an ImportError. The features list must be a sequence
    of (feature, version) pairs which are passed to hasFeature."""

    import os
    creator = None
    mod = well_known_implementations.get(name)
    if mod:
        mod = __import__(mod, {}, {}, ['getDOMImplementation'])
        return mod.getDOMImplementation()
    elif name:
        return registered[name]()
    elif "PYTHON_DOM" in os.environ:
        return getDOMImplementation(name = os.environ["PYTHON_DOM"])

    # User did not specify a name, try implementations in arbitrary
    # order, returning the one that has the required features
    if isinstance(features, StringTypes):
        features = _parse_feature_string(features)
    for creator in registered.values():
        dom = creator()
        if _good_enough(dom, features):
            return dom

    for creator in well_known_implementations.keys():
        try:
            dom = getDOMImplementation(name = creator)
        except StandardError: # typically ImportError, or AttributeError
            continue
        if _good_enough(dom, features):
            return dom

    raise ImportError,"no suitable DOM implementation found"

def _parse_feature_string(s):
    features = []
    parts = s.split()
    i = 0
    length = len(parts)
    while i < length:
        feature = parts[i]
        if feature[0] in "0123456789":
            raise ValueError, "bad feature name: %r" % (feature,)
        i = i + 1
        version = None
        if i < length:
            v = parts[i]
            if v[0] in "0123456789":
                i = i + 1
                version = v
        features.append((feature, version))
    return tuple(features)

filename:/usr/lib/python2.7/xml/dom/NodeFilter.py
__doc__
# This is the Python mapping for interface NodeFilter from
# DOM2-Traversal-Range. It contains only constants.

class NodeFilter:
    """
    This is the DOM2 NodeFilter interface. It contains only constants.
    """
    FILTER_ACCEPT = 1
    FILTER_REJECT = 2
    FILTER_SKIP   = 3

    SHOW_ALL                    = 0xFFFFFFFFL
    SHOW_ELEMENT                = 0x00000001
    SHOW_ATTRIBUTE              = 0x00000002
    SHOW_TEXT                   = 0x00000004
    SHOW_CDATA_SECTION          = 0x00000008
    SHOW_ENTITY_REFERENCE       = 0x00000010
    SHOW_ENTITY                 = 0x00000020
    SHOW_PROCESSING_INSTRUCTION = 0x00000040
    SHOW_COMMENT                = 0x00000080
    SHOW_DOCUMENT               = 0x00000100
    SHOW_DOCUMENT_TYPE          = 0x00000200
    SHOW_DOCUMENT_FRAGMENT      = 0x00000400
    SHOW_NOTATION               = 0x00000800

    def acceptNode(self, node):
        raise NotImplementedError

filename:/usr/lib/python2.7/xml/dom/minidom.py
__doc__
"""Simple implementation of the Level 1 DOM.

filename:/usr/lib/python2.7/xml/dom/xmlbuilder.py
__doc__
"""Implementation of the DOM Level 3 'LS-Load' feature."""

import copy
import xml.dom

from xml.dom.NodeFilter import NodeFilter


__all__ = ["DOMBuilder", "DOMEntityResolver", "DOMInputSource"]


class Options:
    """Features object that has variables set for each DOMBuilder feature.

    The DOMBuilder class uses an instance of this class to pass settings to
    the ExpatBuilder class.
    """

    # Note that the DOMBuilder class in LoadSave constrains which of these
    # values can be set using the DOM Level 3 LoadSave feature.

    namespaces = 1
    namespace_declarations = True
    validation = False
    external_parameter_entities = True
    external_general_entities = True
    external_dtd_subset = True
    validate_if_schema = False
    validate = False
    datatype_normalization = False
    create_entity_ref_nodes = True
    entities = True
    whitespace_in_element_content = True
    cdata_sections = True
    comments = True
    charset_overrides_xml_encoding = True
    infoset = False
    supported_mediatypes_only = False

    errorHandler = None
    filter = None


class DOMBuilder:
    entityResolver = None
    errorHandler = None
    filter = None

    ACTION_REPLACE = 1
    ACTION_APPEND_AS_CHILDREN = 2
    ACTION_INSERT_AFTER = 3
    ACTION_INSERT_BEFORE = 4

    _legal_actions = (ACTION_REPLACE, ACTION_APPEND_AS_CHILDREN,
                      ACTION_INSERT_AFTER, ACTION_INSERT_BEFORE)

    def __init__(self):
        self._options = Options()

    def _get_entityResolver(self):
        return self.entityResolver
    def _set_entityResolver(self, entityResolver):
        self.entityResolver = entityResolver

    def _get_errorHandler(self):
        return self.errorHandler
    def _set_errorHandler(self, errorHandler):
        self.errorHandler = errorHandler

    def _get_filter(self):
        return self.filter
    def _set_filter(self, filter):
        self.filter = filter

    def setFeature(self, name, state):
        if self.supportsFeature(name):
            state = state and 1 or 0
            try:
                settings = self._settings[(_name_xform(name), state)]
            except KeyError:
                raise xml.dom.NotSupportedErr(
                    "unsupported feature: %r" % (name,))
            else:
                for name, value in settings:
                    setattr(self._options, name, value)
        else:
            raise xml.dom.NotFoundErr("unknown feature: " + repr(name))

    def supportsFeature(self, name):
        return hasattr(self._options, _name_xform(name))

    def canSetFeature(self, name, state):
        key = (_name_xform(name), state and 1 or 0)
        return key in self._settings

    # This dictionary maps from (feature,value) to a list of
    # (option,value) pairs that should be set on the Options object.
    # If a (feature,value) setting is not in this dictionary, it is
    # not supported by the DOMBuilder.
    #
    _settings = {
        ("namespace_declarations", 0): [
            ("namespace_declarations", 0)],
        ("namespace_declarations", 1): [
            ("namespace_declarations", 1)],
        ("validation", 0): [
            ("validation", 0)],
        ("external_general_entities", 0): [
            ("external_general_entities", 0)],
        ("external_general_entities", 1): [
            ("external_general_entities", 1)],
        ("external_parameter_entities", 0): [
            ("external_parameter_entities", 0)],
        ("external_parameter_entities", 1): [
            ("external_parameter_entities", 1)],
        ("validate_if_schema", 0): [
            ("validate_if_schema", 0)],
        ("create_entity_ref_nodes", 0): [
            ("create_entity_ref_nodes", 0)],
        ("create_entity_ref_nodes", 1): [
            ("create_entity_ref_nodes", 1)],
        ("entities", 0): [
            ("create_entity_ref_nodes", 0),
            ("entities", 0)],
        ("entities", 1): [
            ("entities", 1)],
        ("whitespace_in_element_content", 0): [
            ("whitespace_in_element_content", 0)],
        ("whitespace_in_element_content", 1): [
            ("whitespace_in_element_content", 1)],
        ("cdata_sections", 0): [
            ("cdata_sections", 0)],
        ("cdata_sections", 1): [
            ("cdata_sections", 1)],
        ("comments", 0): [
            ("comments", 0)],
        ("comments", 1): [
            ("comments", 1)],
        ("charset_overrides_xml_encoding", 0): [
            ("charset_overrides_xml_encoding", 0)],
        ("charset_overrides_xml_encoding", 1): [
            ("charset_overrides_xml_encoding", 1)],
        ("infoset", 0): [],
        ("infoset", 1): [
            ("namespace_declarations", 0),
            ("validate_if_schema", 0),
            ("create_entity_ref_nodes", 0),
            ("entities", 0),
            ("cdata_sections", 0),
            ("datatype_normalization", 1),
            ("whitespace_in_element_content", 1),
            ("comments", 1),
            ("charset_overrides_xml_encoding", 1)],
        ("supported_mediatypes_only", 0): [
            ("supported_mediatypes_only", 0)],
        ("namespaces", 0): [
            ("namespaces", 0)],
        ("namespaces", 1): [
            ("namespaces", 1)],
    }

    def getFeature(self, name):
        xname = _name_xform(name)
        try:
            return getattr(self._options, xname)
        except AttributeError:
            if name == "infoset":
                options = self._options
                return (options.datatype_normalization
                        and options.whitespace_in_element_content
                        and options.comments
                        and options.charset_overrides_xml_encoding
                        and not (options.namespace_declarations
                                 or options.validate_if_schema
                                 or options.create_entity_ref_nodes
                                 or options.entities
                                 or options.cdata_sections))
            raise xml.dom.NotFoundErr("feature %s not known" % repr(name))

    def parseURI(self, uri):
        if self.entityResolver:
            input = self.entityResolver.resolveEntity(None, uri)
        else:
            input = DOMEntityResolver().resolveEntity(None, uri)
        return self.parse(input)

    def parse(self, input):
        options = copy.copy(self._options)
        options.filter = self.filter
        options.errorHandler = self.errorHandler
        fp = input.byteStream
        if fp is None and options.systemId:
            import urllib2
            fp = urllib2.urlopen(input.systemId)
        return self._parse_bytestream(fp, options)

    def parseWithContext(self, input, cnode, action):
        if action not in self._legal_actions:
            raise ValueError("not a legal action")
        raise NotImplementedError("Haven't written this yet...")

    def _parse_bytestream(self, stream, options):
        import xml.dom.expatbuilder
        builder = xml.dom.expatbuilder.makeBuilder(options)
        return builder.parseFile(stream)


def _name_xform(name):
    return name.lower().replace('-', '_')


class DOMEntityResolver(object):
    __slots__ = '_opener',

    def resolveEntity(self, publicId, systemId):
        assert systemId is not None
        source = DOMInputSource()
        source.publicId = publicId
        source.systemId = systemId
        source.byteStream = self._get_opener().open(systemId)

        # determine the encoding if the transport provided it
        source.encoding = self._guess_media_encoding(source)

        # determine the base URI is we can
        import posixpath, urlparse
        parts = urlparse.urlparse(systemId)
        scheme, netloc, path, params, query, fragment = parts
        # XXX should we check the scheme here as well?
        if path and not path.endswith("/"):
            path = posixpath.dirname(path) + "/"
            parts = scheme, netloc, path, params, query, fragment
            source.baseURI = urlparse.urlunparse(parts)

        return source

    def _get_opener(self):
        try:
            return self._opener
        except AttributeError:
            self._opener = self._create_opener()
            return self._opener

    def _create_opener(self):
        import urllib2
        return urllib2.build_opener()

    def _guess_media_encoding(self, source):
        info = source.byteStream.info()
        if "Content-Type" in info:
            for param in info.getplist():
                if param.startswith("charset="):
                    return param.split("=", 1)[1].lower()


class DOMInputSource(object):
    __slots__ = ('byteStream', 'characterStream', 'stringData',
                 'encoding', 'publicId', 'systemId', 'baseURI')

    def __init__(self):
        self.byteStream = None
        self.characterStream = None
        self.stringData = None
        self.encoding = None
        self.publicId = None
        self.systemId = None
        self.baseURI = None

    def _get_byteStream(self):
        return self.byteStream
    def _set_byteStream(self, byteStream):
        self.byteStream = byteStream

    def _get_characterStream(self):
        return self.characterStream
    def _set_characterStream(self, characterStream):
        self.characterStream = characterStream

    def _get_stringData(self):
        return self.stringData
    def _set_stringData(self, data):
        self.stringData = data

    def _get_encoding(self):
        return self.encoding
    def _set_encoding(self, encoding):
        self.encoding = encoding

    def _get_publicId(self):
        return self.publicId
    def _set_publicId(self, publicId):
        self.publicId = publicId

    def _get_systemId(self):
        return self.systemId
    def _set_systemId(self, systemId):
        self.systemId = systemId

    def _get_baseURI(self):
        return self.baseURI
    def _set_baseURI(self, uri):
        self.baseURI = uri


class DOMBuilderFilter:
    """Element filter which can be used to tailor construction of
    a DOM instance.
    """

    # There's really no need for this class; concrete implementations
    # should just implement the endElement() and startElement()
    # methods as appropriate.  Using this makes it easy to only
    # implement one of them.

    FILTER_ACCEPT = 1
    FILTER_REJECT = 2
    FILTER_SKIP = 3
    FILTER_INTERRUPT = 4

    whatToShow = NodeFilter.SHOW_ALL

    def _get_whatToShow(self):
        return self.whatToShow

    def acceptNode(self, element):
        return self.FILTER_ACCEPT

    def startContainer(self, element):
        return self.FILTER_ACCEPT

del NodeFilter


class DocumentLS:
    """Mixin to create documents that conform to the load/save spec."""

    async = False

    def _get_async(self):
        return False
    def _set_async(self, async):
        if async:
            raise xml.dom.NotSupportedErr(
                "asynchronous document loading is not supported")

    def abort(self):
        # What does it mean to "clear" a document?  Does the
        # documentElement disappear?
        raise NotImplementedError(
            "haven't figured out what this means yet")

    def load(self, uri):
        raise NotImplementedError("haven't written this yet")

    def loadXML(self, source):
        raise NotImplementedError("haven't written this yet")

    def saveXML(self, snode):
        if snode is None:
            snode = self
        elif snode.ownerDocument is not self:
            raise xml.dom.WrongDocumentErr()
        return snode.toxml()


class DOMImplementationLS:
    MODE_SYNCHRONOUS = 1
    MODE_ASYNCHRONOUS = 2

    def createDOMBuilder(self, mode, schemaType):
        if schemaType is not None:
            raise xml.dom.NotSupportedErr(
                "schemaType not yet supported")
        if mode == self.MODE_SYNCHRONOUS:
            return DOMBuilder()
        if mode == self.MODE_ASYNCHRONOUS:
            raise xml.dom.NotSupportedErr(
                "asynchronous builders are not supported")
        raise ValueError("unknown value for mode")

    def createDOMWriter(self):
        raise NotImplementedError(
            "the writer interface hasn't been written yet!")

    def createDOMInputSource(self):
        return DOMInputSource()

filename:/usr/lib/python2.7/xml/dom/pulldom.py
__doc__
import xml.sax
import xml.sax.handler
import types

try:
    _StringTypes = [types.StringType, types.UnicodeType]
except AttributeError:
    _StringTypes = [types.StringType]

START_ELEMENT = "START_ELEMENT"
END_ELEMENT = "END_ELEMENT"
COMMENT = "COMMENT"
START_DOCUMENT = "START_DOCUMENT"
END_DOCUMENT = "END_DOCUMENT"
PROCESSING_INSTRUCTION = "PROCESSING_INSTRUCTION"
IGNORABLE_WHITESPACE = "IGNORABLE_WHITESPACE"
CHARACTERS = "CHARACTERS"

class PullDOM(xml.sax.ContentHandler):
    _locator = None
    document = None

    def __init__(self, documentFactory=None):
        from xml.dom import XML_NAMESPACE
        self.documentFactory = documentFactory
        self.firstEvent = [None, None]
        self.lastEvent = self.firstEvent
        self.elementStack = []
        self.push = self.elementStack.append
        try:
            self.pop = self.elementStack.pop
        except AttributeError:
            # use class' pop instead
            pass
        self._ns_contexts = [{XML_NAMESPACE:'xml'}] # contains uri -> prefix dicts
        self._current_context = self._ns_contexts[-1]
        self.pending_events = []

    def pop(self):
        result = self.elementStack[-1]
        del self.elementStack[-1]
        return result

    def setDocumentLocator(self, locator):
        self._locator = locator

    def startPrefixMapping(self, prefix, uri):
        if not hasattr(self, '_xmlns_attrs'):
            self._xmlns_attrs = []
        self._xmlns_attrs.append((prefix or 'xmlns', uri))
        self._ns_contexts.append(self._current_context.copy())
        self._current_context[uri] = prefix or None

    def endPrefixMapping(self, prefix):
        self._current_context = self._ns_contexts.pop()

    def startElementNS(self, name, tagName , attrs):
        # Retrieve xml namespace declaration attributes.
        xmlns_uri = 'http://www.w3.org/2000/xmlns/'
        xmlns_attrs = getattr(self, '_xmlns_attrs', None)
        if xmlns_attrs is not None:
            for aname, value in xmlns_attrs:
                attrs._attrs[(xmlns_uri, aname)] = value
            self._xmlns_attrs = []
        uri, localname = name
        if uri:
            # When using namespaces, the reader may or may not
            # provide us with the original name. If not, create
            # *a* valid tagName from the current context.
            if tagName is None:
                prefix = self._current_context[uri]
                if prefix:
                    tagName = prefix + ":" + localname
                else:
                    tagName = localname
            if self.document:
                node = self.document.createElementNS(uri, tagName)
            else:
                node = self.buildDocument(uri, tagName)
        else:
            # When the tagname is not prefixed, it just appears as
            # localname
            if self.document:
                node = self.document.createElement(localname)
            else:
                node = self.buildDocument(None, localname)

        for aname,value in attrs.items():
            a_uri, a_localname = aname
            if a_uri == xmlns_uri:
                if a_localname == 'xmlns':
                    qname = a_localname
                else:
                    qname = 'xmlns:' + a_localname
                attr = self.document.createAttributeNS(a_uri, qname)
                node.setAttributeNodeNS(attr)
            elif a_uri:
                prefix = self._current_context[a_uri]
                if prefix:
                    qname = prefix + ":" + a_localname
                else:
                    qname = a_localname
                attr = self.document.createAttributeNS(a_uri, qname)
                node.setAttributeNodeNS(attr)
            else:
                attr = self.document.createAttribute(a_localname)
                node.setAttributeNode(attr)
            attr.value = value

        self.lastEvent[1] = [(START_ELEMENT, node), None]
        self.lastEvent = self.lastEvent[1]
        self.push(node)

    def endElementNS(self, name, tagName):
        self.lastEvent[1] = [(END_ELEMENT, self.pop()), None]
        self.lastEvent = self.lastEvent[1]

    def startElement(self, name, attrs):
        if self.document:
            node = self.document.createElement(name)
        else:
            node = self.buildDocument(None, name)

        for aname,value in attrs.items():
            attr = self.document.createAttribute(aname)
            attr.value = value
            node.setAttributeNode(attr)

        self.lastEvent[1] = [(START_ELEMENT, node), None]
        self.lastEvent = self.lastEvent[1]
        self.push(node)

    def endElement(self, name):
        self.lastEvent[1] = [(END_ELEMENT, self.pop()), None]
        self.lastEvent = self.lastEvent[1]

    def comment(self, s):
        if self.document:
            node = self.document.createComment(s)
            self.lastEvent[1] = [(COMMENT, node), None]
            self.lastEvent = self.lastEvent[1]
        else:
            event = [(COMMENT, s), None]
            self.pending_events.append(event)

    def processingInstruction(self, target, data):
        if self.document:
            node = self.document.createProcessingInstruction(target, data)
            self.lastEvent[1] = [(PROCESSING_INSTRUCTION, node), None]
            self.lastEvent = self.lastEvent[1]
        else:
            event = [(PROCESSING_INSTRUCTION, target, data), None]
            self.pending_events.append(event)

    def ignorableWhitespace(self, chars):
        node = self.document.createTextNode(chars)
        self.lastEvent[1] = [(IGNORABLE_WHITESPACE, node), None]
        self.lastEvent = self.lastEvent[1]

    def characters(self, chars):
        node = self.document.createTextNode(chars)
        self.lastEvent[1] = [(CHARACTERS, node), None]
        self.lastEvent = self.lastEvent[1]

    def startDocument(self):
        if self.documentFactory is None:
            import xml.dom.minidom
            self.documentFactory = xml.dom.minidom.Document.implementation

    def buildDocument(self, uri, tagname):
        # Can't do that in startDocument, since we need the tagname
        # XXX: obtain DocumentType
        node = self.documentFactory.createDocument(uri, tagname, None)
        self.document = node
        self.lastEvent[1] = [(START_DOCUMENT, node), None]
        self.lastEvent = self.lastEvent[1]
        self.push(node)
        # Put everything we have seen so far into the document
        for e in self.pending_events:
            if e[0][0] == PROCESSING_INSTRUCTION:
                _,target,data = e[0]
                n = self.document.createProcessingInstruction(target, data)
                e[0] = (PROCESSING_INSTRUCTION, n)
            elif e[0][0] == COMMENT:
                n = self.document.createComment(e[0][1])
                e[0] = (COMMENT, n)
            else:
                raise AssertionError("Unknown pending event ",e[0][0])
            self.lastEvent[1] = e
            self.lastEvent = e
        self.pending_events = None
        return node.firstChild

    def endDocument(self):
        self.lastEvent[1] = [(END_DOCUMENT, self.document), None]
        self.pop()

    def clear(self):
        "clear(): Explicitly release parsing structures"
        self.document = None

class ErrorHandler:
    def warning(self, exception):
        print exception
    def error(self, exception):
        raise exception
    def fatalError(self, exception):
        raise exception

class DOMEventStream:
    def __init__(self, stream, parser, bufsize):
        self.stream = stream
        self.parser = parser
        self.bufsize = bufsize
        if not hasattr(self.parser, 'feed'):
            self.getEvent = self._slurp
        self.reset()

    def reset(self):
        self.pulldom = PullDOM()
        # This content handler relies on namespace support
        self.parser.setFeature(xml.sax.handler.feature_namespaces, 1)
        self.parser.setContentHandler(self.pulldom)

    def __getitem__(self, pos):
        rc = self.getEvent()
        if rc:
            return rc
        raise IndexError

    def next(self):
        rc = self.getEvent()
        if rc:
            return rc
        raise StopIteration

    def __iter__(self):
        return self

    def expandNode(self, node):
        event = self.getEvent()
        parents = [node]
        while event:
            token, cur_node = event
            if cur_node is node:
                return
            if token != END_ELEMENT:
                parents[-1].appendChild(cur_node)
            if token == START_ELEMENT:
                parents.append(cur_node)
            elif token == END_ELEMENT:
                del parents[-1]
            event = self.getEvent()

    def getEvent(self):
        # use IncrementalParser interface, so we get the desired
        # pull effect
        if not self.pulldom.firstEvent[1]:
            self.pulldom.lastEvent = self.pulldom.firstEvent
        while not self.pulldom.firstEvent[1]:
            buf = self.stream.read(self.bufsize)
            if not buf:
                self.parser.close()
                return None
            self.parser.feed(buf)
        rc = self.pulldom.firstEvent[1][0]
        self.pulldom.firstEvent[1] = self.pulldom.firstEvent[1][1]
        return rc

    def _slurp(self):
        """ Fallback replacement for getEvent() using the
            standard SAX2 interface, which means we slurp the
            SAX events into memory (no performance gain, but
            we are compatible to all SAX parsers).
        """
        self.parser.parse(self.stream)
        self.getEvent = self._emit
        return self._emit()

    def _emit(self):
        """ Fallback replacement for getEvent() that emits
            the events that _slurp() read previously.
        """
        rc = self.pulldom.firstEvent[1][0]
        self.pulldom.firstEvent[1] = self.pulldom.firstEvent[1][1]
        return rc

    def clear(self):
        """clear(): Explicitly release parsing objects"""
        self.pulldom.clear()
        del self.pulldom
        self.parser = None
        self.stream = None

class SAX2DOM(PullDOM):

    def startElementNS(self, name, tagName , attrs):
        PullDOM.startElementNS(self, name, tagName, attrs)
        curNode = self.elementStack[-1]
        parentNode = self.elementStack[-2]
        parentNode.appendChild(curNode)

    def startElement(self, name, attrs):
        PullDOM.startElement(self, name, attrs)
        curNode = self.elementStack[-1]
        parentNode = self.elementStack[-2]
        parentNode.appendChild(curNode)

    def processingInstruction(self, target, data):
        PullDOM.processingInstruction(self, target, data)
        node = self.lastEvent[0][1]
        parentNode = self.elementStack[-1]
        parentNode.appendChild(node)

    def ignorableWhitespace(self, chars):
        PullDOM.ignorableWhitespace(self, chars)
        node = self.lastEvent[0][1]
        parentNode = self.elementStack[-1]
        parentNode.appendChild(node)

    def characters(self, chars):
        PullDOM.characters(self, chars)
        node = self.lastEvent[0][1]
        parentNode = self.elementStack[-1]
        parentNode.appendChild(node)


default_bufsize = (2 ** 14) - 20

def parse(stream_or_string, parser=None, bufsize=None):
    if bufsize is None:
        bufsize = default_bufsize
    if type(stream_or_string) in _StringTypes:
        stream = open(stream_or_string)
    else:
        stream = stream_or_string
    if not parser:
        parser = xml.sax.make_parser()
    return DOMEventStream(stream, parser, bufsize)

def parseString(string, parser=None):
    try:
        from cStringIO import StringIO
    except ImportError:
        from StringIO import StringIO

    bufsize = len(string)
    buf = StringIO(string)
    if not parser:
        parser = xml.sax.make_parser()
    return DOMEventStream(buf, parser, bufsize)

filename:/usr/lib/python2.7/xml/dom/expatbuilder.py
__doc__
"""Facility to use the Expat parser to load a minidom instance

filename:/usr/lib/python2.7/xml/dom/minicompat.py
__doc__
"""Python version compatibility support for minidom."""

# This module should only be imported using "import *".
#
# The following names are defined:
#
#   NodeList      -- lightest possible NodeList implementation
#
#   EmptyNodeList -- lightest possible NodeList that is guaranteed to
#                    remain empty (immutable)
#
#   StringTypes   -- tuple of defined string types
#
#   defproperty   -- function used in conjunction with GetattrMagic;
#                    using these together is needed to make them work
#                    as efficiently as possible in both Python 2.2+
#                    and older versions.  For example:
#
#                        class MyClass(GetattrMagic):
#                            def _get_myattr(self):
#                                return something
#
#                        defproperty(MyClass, "myattr",
#                                    "return some value")
#
#                    For Python 2.2 and newer, this will construct a
#                    property object on the class, which avoids
#                    needing to override __getattr__().  It will only
#                    work for read-only attributes.
#
#                    For older versions of Python, inheriting from
#                    GetattrMagic will use the traditional
#                    __getattr__() hackery to achieve the same effect,
#                    but less efficiently.
#
#                    defproperty() should be used for each version of
#                    the relevant _get_<property>() function.

__all__ = ["NodeList", "EmptyNodeList", "StringTypes", "defproperty"]

import xml.dom

try:
    unicode
except NameError:
    StringTypes = type(''),
else:
    StringTypes = type(''), type(unicode(''))


class NodeList(list):
    __slots__ = ()

    def item(self, index):
        if 0 <= index < len(self):
            return self[index]

    def _get_length(self):
        return len(self)

    def _set_length(self, value):
        raise xml.dom.NoModificationAllowedErr(
            "attempt to modify read-only attribute 'length'")

    length = property(_get_length, _set_length,
                      doc="The number of nodes in the NodeList.")

    # For backward compatibility
    def __setstate__(self, state):
        if state is None:
            state = []
        self[:] = state


class EmptyNodeList(tuple):
    __slots__ = ()

    def __add__(self, other):
        NL = NodeList()
        NL.extend(other)
        return NL

    def __radd__(self, other):
        NL = NodeList()
        NL.extend(other)
        return NL

    def item(self, index):
        return None

    def _get_length(self):
        return 0

    def _set_length(self, value):
        raise xml.dom.NoModificationAllowedErr(
            "attempt to modify read-only attribute 'length'")

    length = property(_get_length, _set_length,
                      doc="The number of nodes in the NodeList.")


def defproperty(klass, name, doc):
    get = getattr(klass, ("_get_" + name)).im_func
    def set(self, value, name=name):
        raise xml.dom.NoModificationAllowedErr(
            "attempt to modify read-only attribute " + repr(name))
    assert not hasattr(klass, "_set_" + name), \
           "expected not to find _set_" + name
    prop = property(get, set, doc=doc)
    setattr(klass, name, prop)

filename:/usr/lib/python2.7/xml/sax/__init__.py
__doc__
"""Simple API for XML (SAX) implementation for Python.

filename:/usr/lib/python2.7/xml/sax/expatreader.py
__doc__
"""
SAX driver for the pyexpat C module.  This driver works with
pyexpat.__version__ == '2.22'.
"""

filename:/usr/lib/python2.7/xml/sax/_exceptions.py
__doc__
"""Different kinds of SAX Exceptions"""
import sys
if sys.platform[:4] == "java":
    from java.lang import Exception
del sys

# ===== SAXEXCEPTION =====

class SAXException(Exception):
    """Encapsulate an XML error or warning. This class can contain
    basic error or warning information from either the XML parser or
    the application: you can subclass it to provide additional
    functionality, or to add localization. Note that although you will
    receive a SAXException as the argument to the handlers in the
    ErrorHandler interface, you are not actually required to raise
    the exception; instead, you can simply read the information in
    it."""

    def __init__(self, msg, exception=None):
        """Creates an exception. The message is required, but the exception
        is optional."""
        self._msg = msg
        self._exception = exception
        Exception.__init__(self, msg)

    def getMessage(self):
        "Return a message for this exception."
        return self._msg

    def getException(self):
        "Return the embedded exception, or None if there was none."
        return self._exception

    def __str__(self):
        "Create a string representation of the exception."
        return self._msg

    def __getitem__(self, ix):
        """Avoids weird error messages if someone does exception[ix] by
        mistake, since Exception has __getitem__ defined."""
        raise AttributeError("__getitem__")


# ===== SAXPARSEEXCEPTION =====

class SAXParseException(SAXException):
    """Encapsulate an XML parse error or warning.

    This exception will include information for locating the error in
    the original XML document. Note that although the application will
    receive a SAXParseException as the argument to the handlers in the
    ErrorHandler interface, the application is not actually required
    to raise the exception; instead, it can simply read the
    information in it and take a different action.

    Since this exception is a subclass of SAXException, it inherits
    the ability to wrap another exception."""

    def __init__(self, msg, exception, locator):
        "Creates the exception. The exception parameter is allowed to be None."
        SAXException.__init__(self, msg, exception)
        self._locator = locator

        # We need to cache this stuff at construction time.
        # If this exception is raised, the objects through which we must
        # traverse to get this information may be deleted by the time
        # it gets caught.
        self._systemId = self._locator.getSystemId()
        self._colnum = self._locator.getColumnNumber()
        self._linenum = self._locator.getLineNumber()

    def getColumnNumber(self):
        """The column number of the end of the text where the exception
        occurred."""
        return self._colnum

    def getLineNumber(self):
        "The line number of the end of the text where the exception occurred."
        return self._linenum

    def getPublicId(self):
        "Get the public identifier of the entity where the exception occurred."
        return self._locator.getPublicId()

    def getSystemId(self):
        "Get the system identifier of the entity where the exception occurred."
        return self._systemId

    def __str__(self):
        "Create a string representation of the exception."
        sysid = self.getSystemId()
        if sysid is None:
            sysid = "<unknown>"
        linenum = self.getLineNumber()
        if linenum is None:
            linenum = "?"
        colnum = self.getColumnNumber()
        if colnum is None:
            colnum = "?"
        return "%s:%s:%s: %s" % (sysid, linenum, colnum, self._msg)


# ===== SAXNOTRECOGNIZEDEXCEPTION =====

class SAXNotRecognizedException(SAXException):
    """Exception class for an unrecognized identifier.

    An XMLReader will raise this exception when it is confronted with an
    unrecognized feature or property. SAX applications and extensions may
    use this class for similar purposes."""


# ===== SAXNOTSUPPORTEDEXCEPTION =====

class SAXNotSupportedException(SAXException):
    """Exception class for an unsupported operation.

    An XMLReader will raise this exception when a service it cannot
    perform is requested (specifically setting a state or value). SAX
    applications and extensions may use this class for similar
    purposes."""

# ===== SAXNOTSUPPORTEDEXCEPTION =====

class SAXReaderNotAvailable(SAXNotSupportedException):
    """Exception class for a missing driver.

    An XMLReader module (driver) should raise this exception when it
    is first imported, e.g. when a support module cannot be imported.
    It also may be raised during parsing, e.g. if executing an external
    program is not permitted."""

filename:/usr/lib/python2.7/xml/sax/saxutils.py
__doc__
"""\

filename:/usr/lib/python2.7/xml/sax/xmlreader.py
__doc__
"""An XML Reader is the SAX 2 name for an XML parser. XML Parsers
should be based on this code. """

import handler

from _exceptions import SAXNotSupportedException, SAXNotRecognizedException


# ===== XMLREADER =====

class XMLReader:
    """Interface for reading an XML document using callbacks.

    XMLReader is the interface that an XML parser's SAX2 driver must
    implement. This interface allows an application to set and query
    features and properties in the parser, to register event handlers
    for document processing, and to initiate a document parse.

    All SAX interfaces are assumed to be synchronous: the parse
    methods must not return until parsing is complete, and readers
    must wait for an event-handler callback to return before reporting
    the next event."""

    def __init__(self):
        self._cont_handler = handler.ContentHandler()
        self._dtd_handler = handler.DTDHandler()
        self._ent_handler = handler.EntityResolver()
        self._err_handler = handler.ErrorHandler()

    def parse(self, source):
        "Parse an XML document from a system identifier or an InputSource."
        raise NotImplementedError("This method must be implemented!")

    def getContentHandler(self):
        "Returns the current ContentHandler."
        return self._cont_handler

    def setContentHandler(self, handler):
        "Registers a new object to receive document content events."
        self._cont_handler = handler

    def getDTDHandler(self):
        "Returns the current DTD handler."
        return self._dtd_handler

    def setDTDHandler(self, handler):
        "Register an object to receive basic DTD-related events."
        self._dtd_handler = handler

    def getEntityResolver(self):
        "Returns the current EntityResolver."
        return self._ent_handler

    def setEntityResolver(self, resolver):
        "Register an object to resolve external entities."
        self._ent_handler = resolver

    def getErrorHandler(self):
        "Returns the current ErrorHandler."
        return self._err_handler

    def setErrorHandler(self, handler):
        "Register an object to receive error-message events."
        self._err_handler = handler

    def setLocale(self, locale):
        """Allow an application to set the locale for errors and warnings.

        SAX parsers are not required to provide localization for errors
        and warnings; if they cannot support the requested locale,
        however, they must raise a SAX exception. Applications may
        request a locale change in the middle of a parse."""
        raise SAXNotSupportedException("Locale support not implemented")

    def getFeature(self, name):
        "Looks up and returns the state of a SAX2 feature."
        raise SAXNotRecognizedException("Feature '%s' not recognized" % name)

    def setFeature(self, name, state):
        "Sets the state of a SAX2 feature."
        raise SAXNotRecognizedException("Feature '%s' not recognized" % name)

    def getProperty(self, name):
        "Looks up and returns the value of a SAX2 property."
        raise SAXNotRecognizedException("Property '%s' not recognized" % name)

    def setProperty(self, name, value):
        "Sets the value of a SAX2 property."
        raise SAXNotRecognizedException("Property '%s' not recognized" % name)

class IncrementalParser(XMLReader):
    """This interface adds three extra methods to the XMLReader
    interface that allow XML parsers to support incremental
    parsing. Support for this interface is optional, since not all
    underlying XML parsers support this functionality.

    When the parser is instantiated it is ready to begin accepting
    data from the feed method immediately. After parsing has been
    finished with a call to close the reset method must be called to
    make the parser ready to accept new data, either from feed or
    using the parse method.

    Note that these methods must _not_ be called during parsing, that
    is, after parse has been called and before it returns.

    By default, the class also implements the parse method of the XMLReader
    interface using the feed, close and reset methods of the
    IncrementalParser interface as a convenience to SAX 2.0 driver
    writers."""

    def __init__(self, bufsize=2**16):
        self._bufsize = bufsize
        XMLReader.__init__(self)

    def parse(self, source):
        import saxutils
        source = saxutils.prepare_input_source(source)

        self.prepareParser(source)
        file = source.getByteStream()
        buffer = file.read(self._bufsize)
        while buffer != "":
            self.feed(buffer)
            buffer = file.read(self._bufsize)
        self.close()

    def feed(self, data):
        """This method gives the raw XML data in the data parameter to
        the parser and makes it parse the data, emitting the
        corresponding events. It is allowed for XML constructs to be
        split across several calls to feed.

        feed may raise SAXException."""
        raise NotImplementedError("This method must be implemented!")

    def prepareParser(self, source):
        """This method is called by the parse implementation to allow
        the SAX 2.0 driver to prepare itself for parsing."""
        raise NotImplementedError("prepareParser must be overridden!")

    def close(self):
        """This method is called when the entire XML document has been
        passed to the parser through the feed method, to notify the
        parser that there are no more data. This allows the parser to
        do the final checks on the document and empty the internal
        data buffer.

        The parser will not be ready to parse another document until
        the reset method has been called.

        close may raise SAXException."""
        raise NotImplementedError("This method must be implemented!")

    def reset(self):
        """This method is called after close has been called to reset
        the parser so that it is ready to parse new documents. The
        results of calling parse or feed after close without calling
        reset are undefined."""
        raise NotImplementedError("This method must be implemented!")

# ===== LOCATOR =====

class Locator:
    """Interface for associating a SAX event with a document
    location. A locator object will return valid results only during
    calls to DocumentHandler methods; at any other time, the
    results are unpredictable."""

    def getColumnNumber(self):
        "Return the column number where the current event ends."
        return -1

    def getLineNumber(self):
        "Return the line number where the current event ends."
        return -1

    def getPublicId(self):
        "Return the public identifier for the current event."
        return None

    def getSystemId(self):
        "Return the system identifier for the current event."
        return None

# ===== INPUTSOURCE =====

class InputSource:
    """Encapsulation of the information needed by the XMLReader to
    read entities.

    This class may include information about the public identifier,
    system identifier, byte stream (possibly with character encoding
    information) and/or the character stream of an entity.

    Applications will create objects of this class for use in the
    XMLReader.parse method and for returning from
    EntityResolver.resolveEntity.

    An InputSource belongs to the application, the XMLReader is not
    allowed to modify InputSource objects passed to it from the
    application, although it may make copies and modify those."""

    def __init__(self, system_id = None):
        self.__system_id = system_id
        self.__public_id = None
        self.__encoding  = None
        self.__bytefile  = None
        self.__charfile  = None

    def setPublicId(self, public_id):
        "Sets the public identifier of this InputSource."
        self.__public_id = public_id

    def getPublicId(self):
        "Returns the public identifier of this InputSource."
        return self.__public_id

    def setSystemId(self, system_id):
        "Sets the system identifier of this InputSource."
        self.__system_id = system_id

    def getSystemId(self):
        "Returns the system identifier of this InputSource."
        return self.__system_id

    def setEncoding(self, encoding):
        """Sets the character encoding of this InputSource.

        The encoding must be a string acceptable for an XML encoding
        declaration (see section 4.3.3 of the XML recommendation).

        The encoding attribute of the InputSource is ignored if the
        InputSource also contains a character stream."""
        self.__encoding = encoding

    def getEncoding(self):
        "Get the character encoding of this InputSource."
        return self.__encoding

    def setByteStream(self, bytefile):
        """Set the byte stream (a Python file-like object which does
        not perform byte-to-character conversion) for this input
        source.

        The SAX parser will ignore this if there is also a character
        stream specified, but it will use a byte stream in preference
        to opening a URI connection itself.

        If the application knows the character encoding of the byte
        stream, it should set it with the setEncoding method."""
        self.__bytefile = bytefile

    def getByteStream(self):
        """Get the byte stream for this input source.

        The getEncoding method will return the character encoding for
        this byte stream, or None if unknown."""
        return self.__bytefile

    def setCharacterStream(self, charfile):
        """Set the character stream for this input source. (The stream
        must be a Python 2.0 Unicode-wrapped file-like that performs
        conversion to Unicode strings.)

        If there is a character stream specified, the SAX parser will
        ignore any byte stream and will not attempt to open a URI
        connection to the system identifier."""
        self.__charfile = charfile

    def getCharacterStream(self):
        "Get the character stream for this input source."
        return self.__charfile

# ===== ATTRIBUTESIMPL =====

class AttributesImpl:

    def __init__(self, attrs):
        """Non-NS-aware implementation.

        attrs should be of the form {name : value}."""
        self._attrs = attrs

    def getLength(self):
        return len(self._attrs)

    def getType(self, name):
        return "CDATA"

    def getValue(self, name):
        return self._attrs[name]

    def getValueByQName(self, name):
        return self._attrs[name]

    def getNameByQName(self, name):
        if not name in self._attrs:
            raise KeyError, name
        return name

    def getQNameByName(self, name):
        if not name in self._attrs:
            raise KeyError, name
        return name

    def getNames(self):
        return self._attrs.keys()

    def getQNames(self):
        return self._attrs.keys()

    def __len__(self):
        return len(self._attrs)

    def __getitem__(self, name):
        return self._attrs[name]

    def keys(self):
        return self._attrs.keys()

    def has_key(self, name):
        return name in self._attrs

    def __contains__(self, name):
        return name in self._attrs

    def get(self, name, alternative=None):
        return self._attrs.get(name, alternative)

    def copy(self):
        return self.__class__(self._attrs)

    def items(self):
        return self._attrs.items()

    def values(self):
        return self._attrs.values()

# ===== ATTRIBUTESNSIMPL =====

class AttributesNSImpl(AttributesImpl):

    def __init__(self, attrs, qnames):
        """NS-aware implementation.

        attrs should be of the form {(ns_uri, lname): value, ...}.
        qnames of the form {(ns_uri, lname): qname, ...}."""
        self._attrs = attrs
        self._qnames = qnames

    def getValueByQName(self, name):
        for (nsname, qname) in self._qnames.items():
            if qname == name:
                return self._attrs[nsname]

        raise KeyError, name

    def getNameByQName(self, name):
        for (nsname, qname) in self._qnames.items():
            if qname == name:
                return nsname

        raise KeyError, name

    def getQNameByName(self, name):
        return self._qnames[name]

    def getQNames(self):
        return self._qnames.values()

    def copy(self):
        return self.__class__(self._attrs, self._qnames)


def _test():
    XMLReader()
    IncrementalParser()
    Locator()

if __name__ == "__main__":
    _test()

filename:/usr/lib/python2.7/xml/sax/handler.py
__doc__
"""

filename:/usr/lib/python2.7/sysconfig.py
__doc__
"""Provide access to Python's configuration information.

"""

filename:/usr/lib/python2.7/cmd.py
__doc__
"""A generic class to build line-oriented command interpreters.

Interpreters constructed with this class obey the following conventions:

1. End of file on input is processed as the command 'EOF'.
2. A command is parsed out of each line by collecting the prefix composed
   of characters in the identchars member.
3. A command `foo' is dispatched to a method 'do_foo()'; the do_ method
   is passed a single argument consisting of the remainder of the line.
4. Typing an empty line repeats the last command.  (Actually, it calls the
   method `emptyline', which may be overridden in a subclass.)
5. There is a predefined `help' method.  Given an argument `topic', it
   calls the command `help_topic'.  With no arguments, it lists all topics
   with defined help_ functions, broken into up to three topics; documented
   commands, miscellaneous help topics, and undocumented commands.
6. The command '?' is a synonym for `help'.  The command '!' is a synonym
   for `shell', if a do_shell method exists.
7. If completion is enabled, completing commands will be done automatically,
   and completing of commands args is done by calling complete_foo() with
   arguments text, line, begidx, endidx.  text is string we are matching
   against, all returned matches must begin with it.  line is the current
   input line (lstripped), begidx and endidx are the beginning and end
   indexes of the text being matched, which could be used to provide
   different completion depending upon which position the argument is in.

The `default' method may be overridden to intercept commands for which there
is no do_ method.

The `completedefault' method may be overridden to intercept completions for
commands that have no complete_ method.

The data member `self.ruler' sets the character used to draw separator lines
in the help messages.  If empty, no ruler line is drawn.  It defaults to "=".

If the value of `self.intro' is nonempty when the cmdloop method is called,
it is printed out on interpreter startup.  This value may be overridden
via an optional argument to the cmdloop() method.

The data members `self.doc_header', `self.misc_header', and
`self.undoc_header' set the headers used for the help function's
listings of documented functions, miscellaneous topics, and undocumented
functions respectively.

These interpreters use raw_input; thus, if the readline module is loaded,
they automatically support Emacs-like command history and editing features.
"""

filename:/usr/lib/python2.7/tempfile.py
__doc__
"""Temporary files.

This module provides generic, low- and high-level interfaces for
creating temporary files and directories.  All of the interfaces
provided by this module can be used without fear of race conditions
except for 'mktemp'.  'mktemp' is subject to race conditions and
should not be used; it is provided for backward compatibility only.

This module also provides some data items to the user:

  TMP_MAX  - maximum number of names that will be tried before
             giving up.
  template - the default prefix for all temporary names.
             You may change this to control the default prefix.
  tempdir  - If this is set to a string before the first use of
             any routine from this module, it will be considered as
             another candidate location to store temporary files.
"""

filename:/usr/lib/python2.7/CGIHTTPServer.py
__doc__
"""CGI-savvy HTTP Server.

This module builds on SimpleHTTPServer by implementing GET and POST
requests to cgi-bin scripts.

If the os.fork() function is not present (e.g. on Windows),
os.popen2() is used as a fallback, with slightly altered semantics; if
that function is not present either (e.g. on Macintosh), only Python
scripts are supported, and they are executed by the current process.

In all cases, the implementation is intentionally naive -- all
requests are executed sychronously.

SECURITY WARNING: DON'T USE THIS CODE UNLESS YOU ARE INSIDE A FIREWALL
-- it may execute arbitrary Python code or external programs.

Note that status code 200 is sent prior to execution of a CGI script, so
scripts cannot send other status codes such as 302 (redirect).
"""

filename:/usr/lib/python2.7/warnings.py
__doc__
"""Python part of the warnings subsystem."""

# Note: function level imports should *not* be used
# in this module as it may cause import lock deadlock.
# See bug 683658.
import linecache
import sys
import types

__all__ = ["warn", "warn_explicit", "showwarning",
           "formatwarning", "filterwarnings", "simplefilter",
           "resetwarnings", "catch_warnings"]


def warnpy3k(message, category=None, stacklevel=1):
    """Issue a deprecation warning for Python 3.x related changes.

    Warnings are omitted unless Python is started with the -3 option.
    """
    if sys.py3kwarning:
        if category is None:
            category = DeprecationWarning
        warn(message, category, stacklevel+1)

def _show_warning(message, category, filename, lineno, file=None, line=None):
    """Hook to write a warning to a file; replace if you like."""
    if file is None:
        file = sys.stderr
        if file is None:
            # sys.stderr is None - warnings get lost
            return
    try:
        file.write(formatwarning(message, category, filename, lineno, line))
    except (IOError, UnicodeError):
        pass # the file (probably stderr) is invalid - this warning gets lost.
# Keep a working version around in case the deprecation of the old API is
# triggered.
showwarning = _show_warning

def formatwarning(message, category, filename, lineno, line=None):
    """Function to format a warning the standard way."""
    try:
        unicodetype = unicode
    except NameError:
        unicodetype = ()
    try:
        message = str(message)
    except UnicodeEncodeError:
        pass
    s =  "%s: %s: %s\n" % (lineno, category.__name__, message)
    line = linecache.getline(filename, lineno) if line is None else line
    if line:
        line = line.strip()
        if isinstance(s, unicodetype) and isinstance(line, str):
            line = unicode(line, 'latin1')
        s += "  %s\n" % line
    if isinstance(s, unicodetype) and isinstance(filename, str):
        enc = sys.getfilesystemencoding()
        if enc:
            try:
                filename = unicode(filename, enc)
            except UnicodeDecodeError:
                pass
    s = "%s:%s" % (filename, s)
    return s

def filterwarnings(action, message="", category=Warning, module="", lineno=0,
                   append=0):
    """Insert an entry into the list of warnings filters (at the front).

    'action' -- one of "error", "ignore", "always", "default", "module",
                or "once"
    'message' -- a regex that the warning message must match
    'category' -- a class that the warning must be a subclass of
    'module' -- a regex that the module name must match
    'lineno' -- an integer line number, 0 matches all warnings
    'append' -- if true, append to the list of filters
    """
    import re
    assert action in ("error", "ignore", "always", "default", "module",
                      "once"), "invalid action: %r" % (action,)
    assert isinstance(message, basestring), "message must be a string"
    assert isinstance(category, (type, types.ClassType)), \
           "category must be a class"
    assert issubclass(category, Warning), "category must be a Warning subclass"
    assert isinstance(module, basestring), "module must be a string"
    assert isinstance(lineno, int) and lineno >= 0, \
           "lineno must be an int >= 0"
    item = (action, re.compile(message, re.I), category,
            re.compile(module), lineno)
    if append:
        filters.append(item)
    else:
        filters.insert(0, item)

def simplefilter(action, category=Warning, lineno=0, append=0):
    """Insert a simple entry into the list of warnings filters (at the front).

    A simple filter matches all modules and messages.
    'action' -- one of "error", "ignore", "always", "default", "module",
                or "once"
    'category' -- a class that the warning must be a subclass of
    'lineno' -- an integer line number, 0 matches all warnings
    'append' -- if true, append to the list of filters
    """
    assert action in ("error", "ignore", "always", "default", "module",
                      "once"), "invalid action: %r" % (action,)
    assert isinstance(lineno, int) and lineno >= 0, \
           "lineno must be an int >= 0"
    item = (action, None, category, None, lineno)
    if append:
        filters.append(item)
    else:
        filters.insert(0, item)

def resetwarnings():
    """Clear the list of warning filters, so that no filters are active."""
    filters[:] = []

class _OptionError(Exception):
    """Exception used by option processing helpers."""
    pass

# Helper to process -W options passed via sys.warnoptions
def _processoptions(args):
    for arg in args:
        try:
            _setoption(arg)
        except _OptionError, msg:
            print >>sys.stderr, "Invalid -W option ignored:", msg

# Helper for _processoptions()
def _setoption(arg):
    import re
    parts = arg.split(':')
    if len(parts) > 5:
        raise _OptionError("too many fields (max 5): %r" % (arg,))
    while len(parts) < 5:
        parts.append('')
    action, message, category, module, lineno = [s.strip()
                                                 for s in parts]
    action = _getaction(action)
    message = re.escape(message)
    category = _getcategory(category)
    module = re.escape(module)
    if module:
        module = module + '$'
    if lineno:
        try:
            lineno = int(lineno)
            if lineno < 0:
                raise ValueError
        except (ValueError, OverflowError):
            raise _OptionError("invalid lineno %r" % (lineno,))
    else:
        lineno = 0
    filterwarnings(action, message, category, module, lineno)

# Helper for _setoption()
def _getaction(action):
    if not action:
        return "default"
    if action == "all": return "always" # Alias
    for a in ('default', 'always', 'ignore', 'module', 'once', 'error'):
        if a.startswith(action):
            return a
    raise _OptionError("invalid action: %r" % (action,))

# Helper for _setoption()
def _getcategory(category):
    import re
    if not category:
        return Warning
    if re.match("^[a-zA-Z0-9_]+$", category):
        try:
            cat = eval(category)
        except NameError:
            raise _OptionError("unknown warning category: %r" % (category,))
    else:
        i = category.rfind(".")
        module = category[:i]
        klass = category[i+1:]
        try:
            m = __import__(module, None, None, [klass])
        except ImportError:
            raise _OptionError("invalid module name: %r" % (module,))
        try:
            cat = getattr(m, klass)
        except AttributeError:
            raise _OptionError("unknown warning category: %r" % (category,))
    if not issubclass(cat, Warning):
        raise _OptionError("invalid warning category: %r" % (category,))
    return cat


# Code typically replaced by _warnings
def warn(message, category=None, stacklevel=1):
    """Issue a warning, or maybe ignore it or raise an exception."""
    # Check if message is already a Warning object
    if isinstance(message, Warning):
        category = message.__class__
    # Check category argument
    if category is None:
        category = UserWarning
    assert issubclass(category, Warning)
    # Get context information
    try:
        caller = sys._getframe(stacklevel)
    except ValueError:
        globals = sys.__dict__
        lineno = 1
    else:
        globals = caller.f_globals
        lineno = caller.f_lineno
    if '__name__' in globals:
        module = globals['__name__']
    else:
        module = "<string>"
    filename = globals.get('__file__')
    if filename:
        fnl = filename.lower()
        if fnl.endswith((".pyc", ".pyo")):
            filename = filename[:-1]
    else:
        if module == "__main__":
            try:
                filename = sys.argv[0]
            except AttributeError:
                # embedded interpreters don't have sys.argv, see bug #839151
                filename = '__main__'
        if not filename:
            filename = module
    registry = globals.setdefault("__warningregistry__", {})
    warn_explicit(message, category, filename, lineno, module, registry,
                  globals)

def warn_explicit(message, category, filename, lineno,
                  module=None, registry=None, module_globals=None):
    lineno = int(lineno)
    if module is None:
        module = filename or "<unknown>"
        if module[-3:].lower() == ".py":
            module = module[:-3] # XXX What about leading pathname?
    if registry is None:
        registry = {}
    if isinstance(message, Warning):
        text = str(message)
        category = message.__class__
    else:
        text = message
        message = category(message)
    key = (text, category, lineno)
    # Quick test for common case
    if registry.get(key):
        return
    # Search the filters
    for item in filters:
        action, msg, cat, mod, ln = item
        if ((msg is None or msg.match(text)) and
            issubclass(category, cat) and
            (mod is None or mod.match(module)) and
            (ln == 0 or lineno == ln)):
            break
    else:
        action = defaultaction
    # Early exit actions
    if action == "ignore":
        registry[key] = 1
        return

    # Prime the linecache for formatting, in case the
    # "file" is actually in a zipfile or something.
    linecache.getlines(filename, module_globals)

    if action == "error":
        raise message
    # Other actions
    if action == "once":
        registry[key] = 1
        oncekey = (text, category)
        if onceregistry.get(oncekey):
            return
        onceregistry[oncekey] = 1
    elif action == "always":
        pass
    elif action == "module":
        registry[key] = 1
        altkey = (text, category, 0)
        if registry.get(altkey):
            return
        registry[altkey] = 1
    elif action == "default":
        registry[key] = 1
    else:
        # Unrecognized actions are errors
        raise RuntimeError(
              "Unrecognized action (%r) in warnings.filters:\n %s" %
              (action, item))
    # Print message and context
    showwarning(message, category, filename, lineno)


class WarningMessage(object):

    """Holds the result of a single showwarning() call."""

    _WARNING_DETAILS = ("message", "category", "filename", "lineno", "file",
                        "line")

    def __init__(self, message, category, filename, lineno, file=None,
                    line=None):
        local_values = locals()
        for attr in self._WARNING_DETAILS:
            setattr(self, attr, local_values[attr])
        self._category_name = category.__name__ if category else None

    def __str__(self):
        return ("{message : %r, category : %r, filename : %r, lineno : %s, "
                    "line : %r}" % (self.message, self._category_name,
                                    self.filename, self.lineno, self.line))


class catch_warnings(object):

    """A context manager that copies and restores the warnings filter upon
    exiting the context.

    The 'record' argument specifies whether warnings should be captured by a
    custom implementation of warnings.showwarning() and be appended to a list
    returned by the context manager. Otherwise None is returned by the context
    manager. The objects appended to the list are arguments whose attributes
    mirror the arguments to showwarning().

    The 'module' argument is to specify an alternative module to the module
    named 'warnings' and imported under that name. This argument is only useful
    when testing the warnings module itself.

    """

    def __init__(self, record=False, module=None):
        """Specify whether to record warnings and if an alternative module
        should be used other than sys.modules['warnings'].

        For compatibility with Python 3.0, please consider all arguments to be
        keyword-only.

        """
        self._record = record
        self._module = sys.modules['warnings'] if module is None else module
        self._entered = False

    def __repr__(self):
        args = []
        if self._record:
            args.append("record=True")
        if self._module is not sys.modules['warnings']:
            args.append("module=%r" % self._module)
        name = type(self).__name__
        return "%s(%s)" % (name, ", ".join(args))

    def __enter__(self):
        if self._entered:
            raise RuntimeError("Cannot enter %r twice" % self)
        self._entered = True
        self._filters = self._module.filters
        self._module.filters = self._filters[:]
        self._showwarning = self._module.showwarning
        if self._record:
            log = []
            def showwarning(*args, **kwargs):
                log.append(WarningMessage(*args, **kwargs))
            self._module.showwarning = showwarning
            return log
        else:
            return None

    def __exit__(self, *exc_info):
        if not self._entered:
            raise RuntimeError("Cannot exit %r without entering first" % self)
        self._module.filters = self._filters
        self._module.showwarning = self._showwarning


# filters contains a sequence of filter 5-tuples
# The components of the 5-tuple are:
# - an action: error, ignore, always, default, module, or once
# - a compiled regex that must match the warning message
# - a class representing the warning category
# - a compiled regex that must match the module that is being warned
# - a line number for the line being warning, or 0 to mean any line
# If either if the compiled regexs are None, match anything.
_warnings_defaults = False
try:
    from _warnings import (filters, default_action, once_registry,
                            warn, warn_explicit)
    defaultaction = default_action
    onceregistry = once_registry
    _warnings_defaults = True
except ImportError:
    filters = []
    defaultaction = "default"
    onceregistry = {}


# Module initialization
_processoptions(sys.warnoptions)
if not _warnings_defaults:
    silence = [ImportWarning, PendingDeprecationWarning]
    # Don't silence DeprecationWarning if -3 or -Q was used.
    if not sys.py3kwarning and not sys.flags.division_warning:
        silence.append(DeprecationWarning)
    for cls in silence:
        simplefilter("ignore", category=cls)
    bytes_warning = sys.flags.bytes_warning
    if bytes_warning > 1:
        bytes_action = "error"
    elif bytes_warning:
        bytes_action = "default"
    else:
        bytes_action = "ignore"
    simplefilter(bytes_action, category=BytesWarning, append=1)
del _warnings_defaults

filename:/usr/lib/python2.7/robotparser.py
__doc__
""" robotparser.py

filename:/usr/lib/python2.7/dist-packages/pkg_resources/__init__.py
__doc__
"""
Package resource API
--------------------

A resource is a logical file contained within a package, or a logical
subdirectory thereof.  The package resource API expects resource names
to have their path parts separated with ``/``, *not* whatever the local
path separator is.  Do not use os.path operations to manipulate resource
names being passed into the API.

The package resource API is designed to work with normal filesystem packages,
.egg files, and unpacked .egg files.  It can also work in a limited way with
.zip files and with custom PEP 302 loaders that support the ``get_data()``
method.
"""

filename:/usr/lib/python2.7/dist-packages/pkg_resources/_vendor/six.py
__doc__
"""Utilities for writing code that runs on Python 2 and 3"""

# Copyright (c) 2010-2015 Benjamin Peterson
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from __future__ import absolute_import

import functools
import itertools
import operator
import sys
import types

__author__ = "Benjamin Peterson <benjamin@python.org>"
__version__ = "1.10.0"


# Useful for very coarse version differentiation.
PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] == 3
PY34 = sys.version_info[0:2] >= (3, 4)

if PY3:
    string_types = str,
    integer_types = int,
    class_types = type,
    text_type = str
    binary_type = bytes

    MAXSIZE = sys.maxsize
else:
    string_types = basestring,
    integer_types = (int, long)
    class_types = (type, types.ClassType)
    text_type = unicode
    binary_type = str

    if sys.platform.startswith("java"):
        # Jython always uses 32 bits.
        MAXSIZE = int((1 << 31) - 1)
    else:
        # It's possible to have sizeof(long) != sizeof(Py_ssize_t).
        class X(object):

            def __len__(self):
                return 1 << 31
        try:
            len(X())
        except OverflowError:
            # 32-bit
            MAXSIZE = int((1 << 31) - 1)
        else:
            # 64-bit
            MAXSIZE = int((1 << 63) - 1)
        del X


def _add_doc(func, doc):
    """Add documentation to a function."""
    func.__doc__ = doc


def _import_module(name):
    """Import module, returning the module after the last dot."""
    __import__(name)
    return sys.modules[name]


class _LazyDescr(object):

    def __init__(self, name):
        self.name = name

    def __get__(self, obj, tp):
        result = self._resolve()
        setattr(obj, self.name, result)  # Invokes __set__.
        try:
            # This is a bit ugly, but it avoids running this again by
            # removing this descriptor.
            delattr(obj.__class__, self.name)
        except AttributeError:
            pass
        return result


class MovedModule(_LazyDescr):

    def __init__(self, name, old, new=None):
        super(MovedModule, self).__init__(name)
        if PY3:
            if new is None:
                new = name
            self.mod = new
        else:
            self.mod = old

    def _resolve(self):
        return _import_module(self.mod)

    def __getattr__(self, attr):
        _module = self._resolve()
        value = getattr(_module, attr)
        setattr(self, attr, value)
        return value


class _LazyModule(types.ModuleType):

    def __init__(self, name):
        super(_LazyModule, self).__init__(name)
        self.__doc__ = self.__class__.__doc__

    def __dir__(self):
        attrs = ["__doc__", "__name__"]
        attrs += [attr.name for attr in self._moved_attributes]
        return attrs

    # Subclasses should override this
    _moved_attributes = []


class MovedAttribute(_LazyDescr):

    def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):
        super(MovedAttribute, self).__init__(name)
        if PY3:
            if new_mod is None:
                new_mod = name
            self.mod = new_mod
            if new_attr is None:
                if old_attr is None:
                    new_attr = name
                else:
                    new_attr = old_attr
            self.attr = new_attr
        else:
            self.mod = old_mod
            if old_attr is None:
                old_attr = name
            self.attr = old_attr

    def _resolve(self):
        module = _import_module(self.mod)
        return getattr(module, self.attr)


class _SixMetaPathImporter(object):

    """
    A meta path importer to import six.moves and its submodules.

    This class implements a PEP302 finder and loader. It should be compatible
    with Python 2.5 and all existing versions of Python3
    """

    def __init__(self, six_module_name):
        self.name = six_module_name
        self.known_modules = {}

    def _add_module(self, mod, *fullnames):
        for fullname in fullnames:
            self.known_modules[self.name + "." + fullname] = mod

    def _get_module(self, fullname):
        return self.known_modules[self.name + "." + fullname]

    def find_module(self, fullname, path=None):
        if fullname in self.known_modules:
            return self
        return None

    def __get_module(self, fullname):
        try:
            return self.known_modules[fullname]
        except KeyError:
            raise ImportError("This loader does not know module " + fullname)

    def load_module(self, fullname):
        try:
            # in case of a reload
            return sys.modules[fullname]
        except KeyError:
            pass
        mod = self.__get_module(fullname)
        if isinstance(mod, MovedModule):
            mod = mod._resolve()
        else:
            mod.__loader__ = self
        sys.modules[fullname] = mod
        return mod

    def is_package(self, fullname):
        """
        Return true, if the named module is a package.

        We need this method to get correct spec objects with
        Python 3.4 (see PEP451)
        """
        return hasattr(self.__get_module(fullname), "__path__")

    def get_code(self, fullname):
        """Return None

        Required, if is_package is implemented"""
        self.__get_module(fullname)  # eventually raises ImportError
        return None
    get_source = get_code  # same as get_code

_importer = _SixMetaPathImporter(__name__)


class _MovedItems(_LazyModule):

    """Lazy loading of moved objects"""
    __path__ = []  # mark as package


_moved_attributes = [
    MovedAttribute("cStringIO", "cStringIO", "io", "StringIO"),
    MovedAttribute("filter", "itertools", "builtins", "ifilter", "filter"),
    MovedAttribute("filterfalse", "itertools", "itertools", "ifilterfalse", "filterfalse"),
    MovedAttribute("input", "__builtin__", "builtins", "raw_input", "input"),
    MovedAttribute("intern", "__builtin__", "sys"),
    MovedAttribute("map", "itertools", "builtins", "imap", "map"),
    MovedAttribute("getcwd", "os", "os", "getcwdu", "getcwd"),
    MovedAttribute("getcwdb", "os", "os", "getcwd", "getcwdb"),
    MovedAttribute("range", "__builtin__", "builtins", "xrange", "range"),
    MovedAttribute("reload_module", "__builtin__", "importlib" if PY34 else "imp", "reload"),
    MovedAttribute("reduce", "__builtin__", "functools"),
    MovedAttribute("shlex_quote", "pipes", "shlex", "quote"),
    MovedAttribute("StringIO", "StringIO", "io"),
    MovedAttribute("UserDict", "UserDict", "collections"),
    MovedAttribute("UserList", "UserList", "collections"),
    MovedAttribute("UserString", "UserString", "collections"),
    MovedAttribute("xrange", "__builtin__", "builtins", "xrange", "range"),
    MovedAttribute("zip", "itertools", "builtins", "izip", "zip"),
    MovedAttribute("zip_longest", "itertools", "itertools", "izip_longest", "zip_longest"),
    MovedModule("builtins", "__builtin__"),
    MovedModule("configparser", "ConfigParser"),
    MovedModule("copyreg", "copy_reg"),
    MovedModule("dbm_gnu", "gdbm", "dbm.gnu"),
    MovedModule("_dummy_thread", "dummy_thread", "_dummy_thread"),
    MovedModule("http_cookiejar", "cookielib", "http.cookiejar"),
    MovedModule("http_cookies", "Cookie", "http.cookies"),
    MovedModule("html_entities", "htmlentitydefs", "html.entities"),
    MovedModule("html_parser", "HTMLParser", "html.parser"),
    MovedModule("http_client", "httplib", "http.client"),
    MovedModule("email_mime_multipart", "email.MIMEMultipart", "email.mime.multipart"),
    MovedModule("email_mime_nonmultipart", "email.MIMENonMultipart", "email.mime.nonmultipart"),
    MovedModule("email_mime_text", "email.MIMEText", "email.mime.text"),
    MovedModule("email_mime_base", "email.MIMEBase", "email.mime.base"),
    MovedModule("BaseHTTPServer", "BaseHTTPServer", "http.server"),
    MovedModule("CGIHTTPServer", "CGIHTTPServer", "http.server"),
    MovedModule("SimpleHTTPServer", "SimpleHTTPServer", "http.server"),
    MovedModule("cPickle", "cPickle", "pickle"),
    MovedModule("queue", "Queue"),
    MovedModule("reprlib", "repr"),
    MovedModule("socketserver", "SocketServer"),
    MovedModule("_thread", "thread", "_thread"),
    MovedModule("tkinter", "Tkinter"),
    MovedModule("tkinter_dialog", "Dialog", "tkinter.dialog"),
    MovedModule("tkinter_filedialog", "FileDialog", "tkinter.filedialog"),
    MovedModule("tkinter_scrolledtext", "ScrolledText", "tkinter.scrolledtext"),
    MovedModule("tkinter_simpledialog", "SimpleDialog", "tkinter.simpledialog"),
    MovedModule("tkinter_tix", "Tix", "tkinter.tix"),
    MovedModule("tkinter_ttk", "ttk", "tkinter.ttk"),
    MovedModule("tkinter_constants", "Tkconstants", "tkinter.constants"),
    MovedModule("tkinter_dnd", "Tkdnd", "tkinter.dnd"),
    MovedModule("tkinter_colorchooser", "tkColorChooser",
                "tkinter.colorchooser"),
    MovedModule("tkinter_commondialog", "tkCommonDialog",
                "tkinter.commondialog"),
    MovedModule("tkinter_tkfiledialog", "tkFileDialog", "tkinter.filedialog"),
    MovedModule("tkinter_font", "tkFont", "tkinter.font"),
    MovedModule("tkinter_messagebox", "tkMessageBox", "tkinter.messagebox"),
    MovedModule("tkinter_tksimpledialog", "tkSimpleDialog",
                "tkinter.simpledialog"),
    MovedModule("urllib_parse", __name__ + ".moves.urllib_parse", "urllib.parse"),
    MovedModule("urllib_error", __name__ + ".moves.urllib_error", "urllib.error"),
    MovedModule("urllib", __name__ + ".moves.urllib", __name__ + ".moves.urllib"),
    MovedModule("urllib_robotparser", "robotparser", "urllib.robotparser"),
    MovedModule("xmlrpc_client", "xmlrpclib", "xmlrpc.client"),
    MovedModule("xmlrpc_server", "SimpleXMLRPCServer", "xmlrpc.server"),
]
# Add windows specific modules.
if sys.platform == "win32":
    _moved_attributes += [
        MovedModule("winreg", "_winreg"),
    ]

for attr in _moved_attributes:
    setattr(_MovedItems, attr.name, attr)
    if isinstance(attr, MovedModule):
        _importer._add_module(attr, "moves." + attr.name)
del attr

_MovedItems._moved_attributes = _moved_attributes

moves = _MovedItems(__name__ + ".moves")
_importer._add_module(moves, "moves")


class Module_six_moves_urllib_parse(_LazyModule):

    """Lazy loading of moved objects in six.moves.urllib_parse"""


_urllib_parse_moved_attributes = [
    MovedAttribute("ParseResult", "urlparse", "urllib.parse"),
    MovedAttribute("SplitResult", "urlparse", "urllib.parse"),
    MovedAttribute("parse_qs", "urlparse", "urllib.parse"),
    MovedAttribute("parse_qsl", "urlparse", "urllib.parse"),
    MovedAttribute("urldefrag", "urlparse", "urllib.parse"),
    MovedAttribute("urljoin", "urlparse", "urllib.parse"),
    MovedAttribute("urlparse", "urlparse", "urllib.parse"),
    MovedAttribute("urlsplit", "urlparse", "urllib.parse"),
    MovedAttribute("urlunparse", "urlparse", "urllib.parse"),
    MovedAttribute("urlunsplit", "urlparse", "urllib.parse"),
    MovedAttribute("quote", "urllib", "urllib.parse"),
    MovedAttribute("quote_plus", "urllib", "urllib.parse"),
    MovedAttribute("unquote", "urllib", "urllib.parse"),
    MovedAttribute("unquote_plus", "urllib", "urllib.parse"),
    MovedAttribute("urlencode", "urllib", "urllib.parse"),
    MovedAttribute("splitquery", "urllib", "urllib.parse"),
    MovedAttribute("splittag", "urllib", "urllib.parse"),
    MovedAttribute("splituser", "urllib", "urllib.parse"),
    MovedAttribute("uses_fragment", "urlparse", "urllib.parse"),
    MovedAttribute("uses_netloc", "urlparse", "urllib.parse"),
    MovedAttribute("uses_params", "urlparse", "urllib.parse"),
    MovedAttribute("uses_query", "urlparse", "urllib.parse"),
    MovedAttribute("uses_relative", "urlparse", "urllib.parse"),
]
for attr in _urllib_parse_moved_attributes:
    setattr(Module_six_moves_urllib_parse, attr.name, attr)
del attr

Module_six_moves_urllib_parse._moved_attributes = _urllib_parse_moved_attributes

_importer._add_module(Module_six_moves_urllib_parse(__name__ + ".moves.urllib_parse"),
                      "moves.urllib_parse", "moves.urllib.parse")


class Module_six_moves_urllib_error(_LazyModule):

    """Lazy loading of moved objects in six.moves.urllib_error"""


_urllib_error_moved_attributes = [
    MovedAttribute("URLError", "urllib2", "urllib.error"),
    MovedAttribute("HTTPError", "urllib2", "urllib.error"),
    MovedAttribute("ContentTooShortError", "urllib", "urllib.error"),
]
for attr in _urllib_error_moved_attributes:
    setattr(Module_six_moves_urllib_error, attr.name, attr)
del attr

Module_six_moves_urllib_error._moved_attributes = _urllib_error_moved_attributes

_importer._add_module(Module_six_moves_urllib_error(__name__ + ".moves.urllib.error"),
                      "moves.urllib_error", "moves.urllib.error")


class Module_six_moves_urllib_request(_LazyModule):

    """Lazy loading of moved objects in six.moves.urllib_request"""


_urllib_request_moved_attributes = [
    MovedAttribute("urlopen", "urllib2", "urllib.request"),
    MovedAttribute("install_opener", "urllib2", "urllib.request"),
    MovedAttribute("build_opener", "urllib2", "urllib.request"),
    MovedAttribute("pathname2url", "urllib", "urllib.request"),
    MovedAttribute("url2pathname", "urllib", "urllib.request"),
    MovedAttribute("getproxies", "urllib", "urllib.request"),
    MovedAttribute("Request", "urllib2", "urllib.request"),
    MovedAttribute("OpenerDirector", "urllib2", "urllib.request"),
    MovedAttribute("HTTPDefaultErrorHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPRedirectHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPCookieProcessor", "urllib2", "urllib.request"),
    MovedAttribute("ProxyHandler", "urllib2", "urllib.request"),
    MovedAttribute("BaseHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPPasswordMgr", "urllib2", "urllib.request"),
    MovedAttribute("HTTPPasswordMgrWithDefaultRealm", "urllib2", "urllib.request"),
    MovedAttribute("AbstractBasicAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPBasicAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("ProxyBasicAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("AbstractDigestAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPDigestAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("ProxyDigestAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPSHandler", "urllib2", "urllib.request"),
    MovedAttribute("FileHandler", "urllib2", "urllib.request"),
    MovedAttribute("FTPHandler", "urllib2", "urllib.request"),
    MovedAttribute("CacheFTPHandler", "urllib2", "urllib.request"),
    MovedAttribute("UnknownHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPErrorProcessor", "urllib2", "urllib.request"),
    MovedAttribute("urlretrieve", "urllib", "urllib.request"),
    MovedAttribute("urlcleanup", "urllib", "urllib.request"),
    MovedAttribute("URLopener", "urllib", "urllib.request"),
    MovedAttribute("FancyURLopener", "urllib", "urllib.request"),
    MovedAttribute("proxy_bypass", "urllib", "urllib.request"),
]
for attr in _urllib_request_moved_attributes:
    setattr(Module_six_moves_urllib_request, attr.name, attr)
del attr

Module_six_moves_urllib_request._moved_attributes = _urllib_request_moved_attributes

_importer._add_module(Module_six_moves_urllib_request(__name__ + ".moves.urllib.request"),
                      "moves.urllib_request", "moves.urllib.request")


class Module_six_moves_urllib_response(_LazyModule):

    """Lazy loading of moved objects in six.moves.urllib_response"""


_urllib_response_moved_attributes = [
    MovedAttribute("addbase", "urllib", "urllib.response"),
    MovedAttribute("addclosehook", "urllib", "urllib.response"),
    MovedAttribute("addinfo", "urllib", "urllib.response"),
    MovedAttribute("addinfourl", "urllib", "urllib.response"),
]
for attr in _urllib_response_moved_attributes:
    setattr(Module_six_moves_urllib_response, attr.name, attr)
del attr

Module_six_moves_urllib_response._moved_attributes = _urllib_response_moved_attributes

_importer._add_module(Module_six_moves_urllib_response(__name__ + ".moves.urllib.response"),
                      "moves.urllib_response", "moves.urllib.response")


class Module_six_moves_urllib_robotparser(_LazyModule):

    """Lazy loading of moved objects in six.moves.urllib_robotparser"""


_urllib_robotparser_moved_attributes = [
    MovedAttribute("RobotFileParser", "robotparser", "urllib.robotparser"),
]
for attr in _urllib_robotparser_moved_attributes:
    setattr(Module_six_moves_urllib_robotparser, attr.name, attr)
del attr

Module_six_moves_urllib_robotparser._moved_attributes = _urllib_robotparser_moved_attributes

_importer._add_module(Module_six_moves_urllib_robotparser(__name__ + ".moves.urllib.robotparser"),
                      "moves.urllib_robotparser", "moves.urllib.robotparser")


class Module_six_moves_urllib(types.ModuleType):

    """Create a six.moves.urllib namespace that resembles the Python 3 namespace"""
    __path__ = []  # mark as package
    parse = _importer._get_module("moves.urllib_parse")
    error = _importer._get_module("moves.urllib_error")
    request = _importer._get_module("moves.urllib_request")
    response = _importer._get_module("moves.urllib_response")
    robotparser = _importer._get_module("moves.urllib_robotparser")

    def __dir__(self):
        return ['parse', 'error', 'request', 'response', 'robotparser']

_importer._add_module(Module_six_moves_urllib(__name__ + ".moves.urllib"),
                      "moves.urllib")


def add_move(move):
    """Add an item to six.moves."""
    setattr(_MovedItems, move.name, move)


def remove_move(name):
    """Remove item from six.moves."""
    try:
        delattr(_MovedItems, name)
    except AttributeError:
        try:
            del moves.__dict__[name]
        except KeyError:
            raise AttributeError("no such move, %r" % (name,))


if PY3:
    _meth_func = "__func__"
    _meth_self = "__self__"

    _func_closure = "__closure__"
    _func_code = "__code__"
    _func_defaults = "__defaults__"
    _func_globals = "__globals__"
else:
    _meth_func = "im_func"
    _meth_self = "im_self"

    _func_closure = "func_closure"
    _func_code = "func_code"
    _func_defaults = "func_defaults"
    _func_globals = "func_globals"


try:
    advance_iterator = next
except NameError:
    def advance_iterator(it):
        return it.next()
next = advance_iterator


try:
    callable = callable
except NameError:
    def callable(obj):
        return any("__call__" in klass.__dict__ for klass in type(obj).__mro__)


if PY3:
    def get_unbound_function(unbound):
        return unbound

    create_bound_method = types.MethodType

    def create_unbound_method(func, cls):
        return func

    Iterator = object
else:
    def get_unbound_function(unbound):
        return unbound.im_func

    def create_bound_method(func, obj):
        return types.MethodType(func, obj, obj.__class__)

    def create_unbound_method(func, cls):
        return types.MethodType(func, None, cls)

    class Iterator(object):

        def next(self):
            return type(self).__next__(self)

    callable = callable
_add_doc(get_unbound_function,
         """Get the function out of a possibly unbound function""")


get_method_function = operator.attrgetter(_meth_func)
get_method_self = operator.attrgetter(_meth_self)
get_function_closure = operator.attrgetter(_func_closure)
get_function_code = operator.attrgetter(_func_code)
get_function_defaults = operator.attrgetter(_func_defaults)
get_function_globals = operator.attrgetter(_func_globals)


if PY3:
    def iterkeys(d, **kw):
        return iter(d.keys(**kw))

    def itervalues(d, **kw):
        return iter(d.values(**kw))

    def iteritems(d, **kw):
        return iter(d.items(**kw))

    def iterlists(d, **kw):
        return iter(d.lists(**kw))

    viewkeys = operator.methodcaller("keys")

    viewvalues = operator.methodcaller("values")

    viewitems = operator.methodcaller("items")
else:
    def iterkeys(d, **kw):
        return d.iterkeys(**kw)

    def itervalues(d, **kw):
        return d.itervalues(**kw)

    def iteritems(d, **kw):
        return d.iteritems(**kw)

    def iterlists(d, **kw):
        return d.iterlists(**kw)

    viewkeys = operator.methodcaller("viewkeys")

    viewvalues = operator.methodcaller("viewvalues")

    viewitems = operator.methodcaller("viewitems")

_add_doc(iterkeys, "Return an iterator over the keys of a dictionary.")
_add_doc(itervalues, "Return an iterator over the values of a dictionary.")
_add_doc(iteritems,
         "Return an iterator over the (key, value) pairs of a dictionary.")
_add_doc(iterlists,
         "Return an iterator over the (key, [values]) pairs of a dictionary.")


if PY3:
    def b(s):
        return s.encode("latin-1")

    def u(s):
        return s
    unichr = chr
    import struct
    int2byte = struct.Struct(">B").pack
    del struct
    byte2int = operator.itemgetter(0)
    indexbytes = operator.getitem
    iterbytes = iter
    import io
    StringIO = io.StringIO
    BytesIO = io.BytesIO
    _assertCountEqual = "assertCountEqual"
    if sys.version_info[1] <= 1:
        _assertRaisesRegex = "assertRaisesRegexp"
        _assertRegex = "assertRegexpMatches"
    else:
        _assertRaisesRegex = "assertRaisesRegex"
        _assertRegex = "assertRegex"
else:
    def b(s):
        return s
    # Workaround for standalone backslash

    def u(s):
        return unicode(s.replace(r'\\', r'\\\\'), "unicode_escape")
    unichr = unichr
    int2byte = chr

    def byte2int(bs):
        return ord(bs[0])

    def indexbytes(buf, i):
        return ord(buf[i])
    iterbytes = functools.partial(itertools.imap, ord)
    import StringIO
    StringIO = BytesIO = StringIO.StringIO
    _assertCountEqual = "assertItemsEqual"
    _assertRaisesRegex = "assertRaisesRegexp"
    _assertRegex = "assertRegexpMatches"
_add_doc(b, """Byte literal""")
_add_doc(u, """Text literal""")


def assertCountEqual(self, *args, **kwargs):
    return getattr(self, _assertCountEqual)(*args, **kwargs)


def assertRaisesRegex(self, *args, **kwargs):
    return getattr(self, _assertRaisesRegex)(*args, **kwargs)


def assertRegex(self, *args, **kwargs):
    return getattr(self, _assertRegex)(*args, **kwargs)


if PY3:
    exec_ = getattr(moves.builtins, "exec")

    def reraise(tp, value, tb=None):
        if value is None:
            value = tp()
        if value.__traceback__ is not tb:
            raise value.with_traceback(tb)
        raise value

else:
    def exec_(_code_, _globs_=None, _locs_=None):
        """Execute code in a namespace."""
        if _globs_ is None:
            frame = sys._getframe(1)
            _globs_ = frame.f_globals
            if _locs_ is None:
                _locs_ = frame.f_locals
            del frame
        elif _locs_ is None:
            _locs_ = _globs_
        exec("""exec _code_ in _globs_, _locs_""")

    exec_("""def reraise(tp, value, tb=None):
    raise tp, value, tb
""")

filename:/usr/lib/python2.7/dist-packages/OpenSSL/rand.py
__doc__
"""
PRNG management routines, thin wrappers.

See the file RATIONALE for a short explanation of why this module was written.
"""

filename:/usr/lib/python2.7/dist-packages/pygame/compat.py
__doc__
"""Python 2.x/3.x compatibility tools"""

import sys

__all__ = ['geterror', 'long_', 'xrange_', 'ord_', 'unichr_',
           'unicode_', 'raw_input_']

def geterror ():
    return sys.exc_info()[1]

try:
    long_ = long
except NameError:
    long_ = int

try:
    xrange_ = xrange
except NameError:
    xrange_ = range

def get_BytesIO():
    try:
        from cStringIO import StringIO as BytesIO
    except ImportError:
        from io import BytesIO
    return BytesIO

def ord_(o):
    try:
        return ord(o)
    except TypeError:
        return o

try:
    unichr_ = unichr
except NameError:
    unichr_ = chr

try:
    unicode_ = unicode
except NameError:
    unicode_ = str

try:
    raw_input_ = raw_input
except NameError:
    raw_input_ = input

filename:/usr/lib/python2.7/dist-packages/pygame/surfarray.pyc
__doc__
Û
Ï[Jc           @   s0  d  Z  d d l Z d a y d d l j Z e Z d a Wn e	 k
 rP e
 Z n Xy( d d l j Z e Z e sx d a n  Wn e	 k
 rí e
 Z n Xe r∞ e r∞ e	 d É Ç n  d d l m Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d S(   så  pygame module for accessing surface pixel data using array interfaces

Functions to convert pixel data between pygame Surfaces and arrays. This
module will only be functional when pygame can use the external Numpy or
Numeric packages.

Every pixel is stored as a single integer value to represent the red,
green, and blue colors. The 8bit images use a value that looks into a
colormap. Pixels with higher depth use a bit packing process to place
three or four values into a single number.

The arrays are indexed by the X axis first, followed by the Y
axis. Arrays that treat the pixels as a single integer are referred to
as 2D arrays. This module can also separate the red, green, and blue
color values into separate indices. These types of arrays are referred
to as 3D arrays, and the last index is 0 for red, 1 for green, and 2 for
blue.

Supported array types are

  numpy
  numeric

The default will be numpy, if installed. Otherwise, Numeric will be set
as default if installed. If neither numpy nor Numeric are installed, the
module will raise an ImportError.

The array type to use can be changed at runtime using the use_arraytype()
method, which requires one of the above types as string.

Note: numpy and Numeric are not completely compatible. Certain array
manipulations, which work for one type, might behave differently or even
completely break for the other.

Additionally, in contrast to Numeric numpy does use unsigned 16-bit
integers. Images with 16-bit data will be treated as unsigned
integers. Numeric instead uses signed integers for the representation,
which is important to keep in mind, if you use the module's functions
and wonder about the values.
iˇˇˇˇNt   numpyt   numerics&   no module named numpy or Numeric found(   t
   blit_arrayc         C   sB   t  d k r t j |  É St  d k r2 t j |  É St d É Ç d S(   s¶  pygame.surfarray.array2d (Surface): return array

    Copy pixels into a 2d array.

    Copy the pixels from a Surface into a 2D array. The bit depth of the
    surface will control the size of the integer values, and will work
    for any type of pixel format.

    This function will temporarily lock the Surface as pixels are copied
    (see the Surface.lock - lock the Surface memory for pixel access
    method).
    R   R    s    surface arrays are not supportedN(   t   __arraytypet	   numericsft   array2dt   numpysft   NotImplementedError(   t   surface(    (    s4   /usr/lib/python2.7/dist-packages/pygame/surfarray.pyR   X   s
    c         C   sB   t  d k r t j |  É St  d k r2 t j |  É St d É Ç d S(   s4  pygame.surfarray.pixels2d (Surface): return array

    Reference pixels into a 2d array.
    
    Create a new 2D array that directly references the pixel values in a
    Surface. Any changes to the array will affect the pixels in the
    Surface. This is a fast operation since no data is copied.

    Pixels from a 24-bit Surface cannot be referenced, but all other
    Surface bit depths can.

    The Surface this references will remain locked for the lifetime of
    the array (see the Surface.lock - lock the Surface memory for pixel
    access method).
    R   R    s    surface arrays are not supportedN(   R   R   t   pixels2dR   R   (   R   (    (    s4   /usr/lib/python2.7/dist-packages/pygame/surfarray.pyR	   k   s
    c         C   sB   t  d k r t j |  É St  d k r2 t j |  É St d É Ç d S(   s¶  pygame.surfarray.array3d (Surface): return array

    Copy pixels into a 3d array.

    Copy the pixels from a Surface into a 3D array. The bit depth of the
    surface will control the size of the integer values, and will work
    for any type of pixel format.

    This function will temporarily lock the Surface as pixels are copied
    (see the Surface.lock - lock the Surface memory for pixel access
    method).
    R   R    s    surface arrays are not supportedN(   R   R   t   array3dR   R   (   R   (    (    s4   /usr/lib/python2.7/dist-packages/pygame/surfarray.pyR
   Å   s
    c         C   sB   t  d k r t j |  É St  d k r2 t j |  É St d É Ç d S(   sE  pygame.surfarray.pixels3d (Surface): return array

    Reference pixels into a 3d array.

    Create a new 3D array that directly references the pixel values in a
    Surface. Any changes to the array will affect the pixels in the
    Surface. This is a fast operation since no data is copied.

    This will only work on Surfaces that have 24-bit or 32-bit
    formats. Lower pixel formats cannot be referenced.

    The Surface this references will remain locked for the lifetime of
    the array (see the Surface.lock - lock the Surface memory for pixel
    access method).
    R   R    s    surface arrays are not supportedN(   R   R   t   pixels3dR   R   (   R   (    (    s4   /usr/lib/python2.7/dist-packages/pygame/surfarray.pyR   î   s
    c         C   sB   t  d k r t j |  É St  d k r2 t j |  É St d É Ç d S(   sﬁ  pygame.surfarray.array_alpha (Surface): return array

    Copy pixel alphas into a 2d array.

    Copy the pixel alpha values (degree of transparency) from a Surface
    into a 2D array. This will work for any type of Surface
    format. Surfaces without a pixel alpha will return an array with all
    opaque values.

    This function will temporarily lock the Surface as pixels are copied
    (see the Surface.lock - lock the Surface memory for pixel access
    method).
    R   R    s    surface arrays are not supportedN(   R   R   t   array_alphaR   R   (   R   (    (    s4   /usr/lib/python2.7/dist-packages/pygame/surfarray.pyR   ™   s
    c         C   sB   t  d k r t j |  É St  d k r2 t j |  É St d É Ç d S(   s˜  pygame.surfarray.pixels_alpha (Surface): return array

    Reference pixel alphas into a 2d array.

    Create a new 2D array that directly references the alpha values
    (degree of transparency) in a Surface. Any changes to the array will
    affect the pixels in the Surface. This is a fast operation since no
    data is copied.

    This can only work on 32-bit Surfaces with a per-pixel alpha value.

    The Surface this array references will remain locked for the
    lifetime of the array.
    R   R    s    surface arrays are not supportedN(   R   R   t   pixels_alphaR   R   (   R   (    (    s4   /usr/lib/python2.7/dist-packages/pygame/surfarray.pyR   æ   s
    c         C   sB   t  d k r t j |  É St  d k r2 t j |  É St d É Ç d S(   sÌ  pygame.surfarray.array_colorkey (Surface): return array

    Copy the colorkey values into a 2d array.

    Create a new array with the colorkey transparency value from each
    pixel. If the pixel matches the colorkey it will be fully
    tranparent; otherwise it will be fully opaque.

    This will work on any type of Surface format. If the image has no
    colorkey a solid opaque array will be returned.

    This function will temporarily lock the Surface as pixels are
    copied.
    R   R    s    surface arrays are not supportedN(   R   R   t   array_colorkeyR   R   (   R   (    (    s4   /usr/lib/python2.7/dist-packages/pygame/surfarray.pyR   ”   s
    c         C   sB   t  d k r t j |  É St  d k r2 t j |  É St d É Ç d S(   sÏ   pygame.surfarray.make_surface (array): return Surface

    Copy an array to a new surface.

    Create a new Surface that best resembles the data and format on the
    array. The array can be 2D or 3D with any sized integer values.
    R   R    s    surface arrays are not supportedN(   R   R   t   make_surfaceR   R   (   t   array(    (    s4   /usr/lib/python2.7/dist-packages/pygame/surfarray.pyR   Ë   s
    c         C   sH   t  d k r t j |  | É St  d k r8 t j |  | É St d É Ç d S(   s  pygame.surfarray.map_array (Surface, array3d): return array2d

    Map a 3D array into a 2D array.

    Convert a 3D array into a 2D array. This will use the given Surface
    format to control the conversion. Palette surface formats are not
    supported.
    R   R    s    surface arrays are not supportedN(   R   R   t	   map_arrayR   R   (   R   R   (    (    s4   /usr/lib/python2.7/dist-packages/pygame/surfarray.pyR   	  s
    	c         C   sp   |  j  É  }  |  d k r6 t r' |  a ql t d É Ç n6 |  d k r` t rQ |  a ql t d É Ç n t d É Ç d S(   sB  pygame.surfarray.use_arraytype (arraytype): return None

    Sets the array system to be used for surface arrays.

    Uses the requested array type for the module functions.
    Currently supported array types are:

      numeric 
      numpy

    If the requested type is not available, a ValueError will be raised.
    R   s    Numeric arrays are not availableR    s   numpy arrays are not availables   invalid array typeN(   t   lowert   __hasnumericR   t
   ValueErrort
   __hasnumpy(   t	   arraytype(    (    s4   /usr/lib/python2.7/dist-packages/pygame/surfarray.pyt   use_arraytype  s    		c           C   s   t  S(   s  pygame.surfarray.get_arraytype (): return str

    Gets the currently active array type.

    Returns the currently active array type. This will be a value of the
    get_arraytypes() tuple and indicates which type of array module is
    used for the array creation.
    (   R   (    (    (    s4   /usr/lib/python2.7/dist-packages/pygame/surfarray.pyt   get_arraytype6  s    	c          C   sR   g  }  t  r |  j d É n  t r2 |  j d É n  t |  É d k rH d St |  É S(   se  pygame.surfarray.get_arraytypes (): return tuple

    Gets the array system types currently supported.

    Checks, which array system types are available and returns them as a
    tuple of strings. The values of the tuple can be used directly in
    the use_arraytype () method.

    If no supported array system could be found, None will be returned.
    R   R    i    N(   R   t   appendR   t   lent   Nonet   tuple(   t   vals(    (    s4   /usr/lib/python2.7/dist-packages/pygame/surfarray.pyt   get_arraytypesA  s    (   t   __doc__t   pygameR   R   t   pygame._numpysurfarrayt   _numpysurfarrayR   t   TrueR   t   ImportErrort   Falset   pygame._numericsurfarrayt   _numericsurfarrayR   R   t   _arraysurfarrayR   R   R	   R
   R   R   R   R   R   R   R   R   R   (    (    (    s4   /usr/lib/python2.7/dist-packages/pygame/surfarray.pyt   <module><   s<   


								!			
filename:/usr/lib/python2.7/dist-packages/pygame/_numpysndarray.pyc
__doc__
Û
Ï[Jc           @   sU   d  Z  d d l Z d d l j Z d d l Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d S(   s`  pygame module for accessing sound sample data using numpy

Functions to convert between numpy arrays and Sound objects. This module
will only be available when pygame can use the external numpy package.

Sound data is made of thousands of samples per second, and each sample
is the amplitude of the wave at a particular moment in time. For
example, in 22-kHz format, element number 5 of the array is the
amplitude of the wave after 5/22000 seconds.

Each sample is an 8-bit or 16-bit integer, depending on the data format.
A stereo sound file has two values per sample, while a mono sound file
only has one.
iˇˇˇˇNc   	      C   sı   t  j É  } | s$ t j d É Ç n  t | d É d @d ?} | d } | r^ |  j É  j } n |  j É  } t | É | f } | d k r† | d | | f } n  i t j	 d 6t j
 d 6t j d	 6t j d
 6| d } t j | | É } | | _ | S(   Ns   Mixer not initializedi   iˇ   i   i   i    i   i   i¯ˇˇˇiˇˇˇ(   t   mixert   get_initt   pygamet   errort   abst
   get_buffert   rawt   lent   numpyt   uint8t   uint16t   int8t   int16t
   fromstringt   shape(	   t   soundR   t   infot   fmtbytest   channelst   dataR   t   typecodet   array(    (    s9   /usr/lib/python2.7/dist-packages/pygame/_numpysndarray.pyt   _array_samples(   s&    



	c         C   s   t  |  t É S(   sˆ   pygame._numpysndarray.array(Sound): return array

    Copy Sound samples into an array.

    Creates a new array for the sound data and copies the samples. The
    array will always be in the format returned from
    pygame.mixer.get_init().
    (   R   t   True(   R   (    (    s9   /usr/lib/python2.7/dist-packages/pygame/_numpysndarray.pyR   D   s    	c         C   s›   t  j j É  } | s' t  j d É Ç n  t | d É d @d ?} | d } |  j É  } | j | f } | d k rà | d | | f } n  i t j d 6t j	 d 6t j
 d	 6t j d
 6| d } t j | | É } | | _ | S(   s5  pygame._numpysndarray.samples(Sound): return array

    Reference Sound samples into an array.

    Creates a new array that directly references the samples in a Sound
    object. Modifying the array will change the Sound. The array will
    always be in the format returned from pygame.mixer.get_init().
    s   Mixer not initializedi   iˇ   i   i   i    i   i   i¯ˇˇˇiˇˇˇ(   R   R    R   R   R   R   t   lengthR   R	   R
   R   R   t
   frombufferR   (   R   R   R   R   R   R   R   R   (    (    s9   /usr/lib/python2.7/dist-packages/pygame/_numpysndarray.pyt   samplesO   s"    




	c         C   s∑   t  j j É  } | s' t  j d É Ç n  | d } |  j } | d k rj t | É d k r™ t d É Ç q™ n@ t | É d k rã t d É Ç n | d | k r™ t d É Ç n  t j |  É S(   s  pygame._numpysndarray.make_sound(array): return Sound

    Convert an array into a Sound object.
    
    Create a new playable Sound object from an array. The mixer module
    must be initialized and the array format must be similar to the mixer
    audio format.
    s   Mixer not initializedi   i   s*   Array must be 1-dimensional for mono mixers,   Array must be 2-dimensional for stereo mixers/   Array depth must match number of mixer channels(   R   R    R   R   R   R   t
   ValueErrort   Sound(   R   R   R   R   (    (    s9   /usr/lib/python2.7/dist-packages/pygame/_numpysndarray.pyt
   make_soundp   s    

	(	   t   __doc__R   t   pygame.mixerR    R   R   R   R   R   (    (    (    s9   /usr/lib/python2.7/dist-packages/pygame/_numpysndarray.pyt   <module>"   s   			!
filename:/usr/lib/python2.7/dist-packages/pygame/__init__.py
__doc__
##    pygame - Python Game Library
##    Copyright (C) 2000-2001  Pete Shinners
##
##    This library is free software; you can redistribute it and/or
##    modify it under the terms of the GNU Library General Public
##    License as published by the Free Software Foundation; either
##    version 2 of the License, or (at your option) any later version.
##
##    This library is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
##    Library General Public License for more details.
##
##    You should have received a copy of the GNU Library General Public
##    License along with this library; if not, write to the Free
##    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
##    Pete Shinners
##    pete@shinners.org
"""Pygame is a set of Python modules designed for writing games.

filename:/usr/lib/python2.7/dist-packages/pygame/midi.py
__doc__
"""pygame.midi
pygame module for interacting with midi input and output.

The midi module can send output to midi devices, and get input
from midi devices.  It can also list midi devices on the system.

Including real midi devices, and virtual ones.

It uses the portmidi library.  Is portable to which ever platforms
portmidi supports (currently windows, OSX, and linux).

This uses pyportmidi for now, but may use its own bindings at some
point in the future.  The pyportmidi bindings are included with pygame.

New in pygame 1.9.0.
"""

filename:/usr/lib/python2.7/dist-packages/pygame/pkgdata.py
__doc__
"""
pkgdata is a simple, extensible way for a package to acquire data file 
resources.

The getResource function is equivalent to the standard idioms, such as
the following minimal implementation:
    
    import sys, os

    def getResource(identifier, pkgname=__name__):
        pkgpath = os.path.dirname(sys.modules[pkgname].__file__)
        path = os.path.join(pkgpath, identifier)
        return file(os.path.normpath(path), mode='rb')

When a __loader__ is present on the module given by __name__, it will defer
getResource to its get_data implementation and return it as a file-like
object (such as StringIO).
"""

filename:/usr/lib/python2.7/dist-packages/pygame/examples/macosx/aliens_app_example/setup.py
__doc__
"""
Script for building the example.

Usage:
    python setup.py py2app
"""

filename:/usr/lib/python2.7/dist-packages/pygame/examples/macosx/macfont.py
__doc__
"""
EXPERIMENTAL CODE!

Here we load a .TTF font file, and display it in
a basic pygame window. It demonstrates several of the
Font object attributes. Nothing exciting in here, but
it makes a great example for basic window, event, and
font management.
"""

filename:/usr/lib/python2.7/dist-packages/pygame/threads/__init__.py
__doc__
"""
* Experimental *

Like the map function, but can use a pool of threads.

Really easy to use threads.  eg.  tmap(f, alist)

If you know how to use the map function, you can use threads.
"""

filename:/usr/lib/python2.7/dist-packages/pygame/threads/Py25Queue.py
__doc__
"""A multi-producer, multi-consumer queue."""

from time import time as _time

from collections import deque

__all__ = ['Empty', 'Full', 'Queue']

class Empty(Exception):
    "Exception raised by Queue.get(block=0)/get_nowait()."
    pass

class Full(Exception):
    "Exception raised by Queue.put(block=0)/put_nowait()."
    pass

class Queue:
    """Create a queue object with a given maximum size.

    If maxsize is <= 0, the queue size is infinite.
    """
    def __init__(self, maxsize=0):
        try:
            import threading
        except ImportError:
            import dummy_threading as threading
        self._init(maxsize)
        # mutex must be held whenever the queue is mutating.  All methods
        # that acquire mutex must release it before returning.  mutex
        # is shared between the three conditions, so acquiring and
        # releasing the conditions also acquires and releases mutex.
        self.mutex = threading.Lock()
        # Notify not_empty whenever an item is added to the queue; a
        # thread waiting to get is notified then.
        self.not_empty = threading.Condition(self.mutex)
        # Notify not_full whenever an item is removed from the queue;
        # a thread waiting to put is notified then.
        self.not_full = threading.Condition(self.mutex)
        # Notify all_tasks_done whenever the number of unfinished tasks
        # drops to zero; thread waiting to join() is notified to resume
        self.all_tasks_done = threading.Condition(self.mutex)
        self.unfinished_tasks = 0

    def task_done(self):
        """Indicate that a formerly enqueued task is complete.

        Used by Queue consumer threads.  For each get() used to fetch a task,
        a subsequent call to task_done() tells the queue that the processing
        on the task is complete.

        If a join() is currently blocking, it will resume when all items
        have been processed (meaning that a task_done() call was received
        for every item that had been put() into the queue).

        Raises a ValueError if called more times than there were items
        placed in the queue.
        """
        self.all_tasks_done.acquire()
        try:
            unfinished = self.unfinished_tasks - 1
            if unfinished <= 0:
                if unfinished < 0:
                    raise ValueError('task_done() called too many times')
                self.all_tasks_done.notifyAll()
            self.unfinished_tasks = unfinished
        finally:
            self.all_tasks_done.release()

    def join(self):
        """Blocks until all items in the Queue have been gotten and processed.

        The count of unfinished tasks goes up whenever an item is added to the
        queue. The count goes down whenever a consumer thread calls task_done()
        to indicate the item was retrieved and all work on it is complete.

        When the count of unfinished tasks drops to zero, join() unblocks.
        """
        self.all_tasks_done.acquire()
        try:
            while self.unfinished_tasks:
                self.all_tasks_done.wait()
        finally:
            self.all_tasks_done.release()

    def qsize(self):
        """Return the approximate size of the queue (not reliable!)."""
        self.mutex.acquire()
        n = self._qsize()
        self.mutex.release()
        return n

    def empty(self):
        """Return True if the queue is empty, False otherwise (not reliable!)."""
        self.mutex.acquire()
        n = self._empty()
        self.mutex.release()
        return n

    def full(self):
        """Return True if the queue is full, False otherwise (not reliable!)."""
        self.mutex.acquire()
        n = self._full()
        self.mutex.release()
        return n

    def put(self, item, block=True, timeout=None):
        """Put an item into the queue.

        If optional args 'block' is true and 'timeout' is None (the default),
        block if necessary until a free slot is available. If 'timeout' is
        a positive number, it blocks at most 'timeout' seconds and raises
        the Full exception if no free slot was available within that time.
        Otherwise ('block' is false), put an item on the queue if a free slot
        is immediately available, else raise the Full exception ('timeout'
        is ignored in that case).
        """
        self.not_full.acquire()
        try:
            if not block:
                if self._full():
                    raise Full
            elif timeout is None:
                while self._full():
                    self.not_full.wait()
            else:
                if timeout < 0:
                    raise ValueError("'timeout' must be a positive number")
                endtime = _time() + timeout
                while self._full():
                    remaining = endtime - _time()
                    if remaining <= 0.0:
                        raise Full
                    self.not_full.wait(remaining)
            self._put(item)
            self.unfinished_tasks += 1
            self.not_empty.notify()
        finally:
            self.not_full.release()

    def put_nowait(self, item):
        """Put an item into the queue without blocking.

        Only enqueue the item if a free slot is immediately available.
        Otherwise raise the Full exception.
        """
        return self.put(item, False)

    def get(self, block=True, timeout=None):
        """Remove and return an item from the queue.

        If optional args 'block' is true and 'timeout' is None (the default),
        block if necessary until an item is available. If 'timeout' is
        a positive number, it blocks at most 'timeout' seconds and raises
        the Empty exception if no item was available within that time.
        Otherwise ('block' is false), return an item if one is immediately
        available, else raise the Empty exception ('timeout' is ignored
        in that case).
        """
        self.not_empty.acquire()
        try:
            if not block:
                if self._empty():
                    raise Empty
            elif timeout is None:
                while self._empty():
                    self.not_empty.wait()
            else:
                if timeout < 0:
                    raise ValueError("'timeout' must be a positive number")
                endtime = _time() + timeout
                while self._empty():
                    remaining = endtime - _time()
                    if remaining <= 0.0:
                        raise Empty
                    self.not_empty.wait(remaining)
            item = self._get()
            self.not_full.notify()
            return item
        finally:
            self.not_empty.release()

    def get_nowait(self):
        """Remove and return an item from the queue without blocking.

        Only get an item if one is immediately available. Otherwise
        raise the Empty exception.
        """
        return self.get(False)

    # Override these methods to implement other queue organizations
    # (e.g. stack or priority queue).
    # These will only be called with appropriate locks held

    # Initialize the queue representation
    def _init(self, maxsize):
        self.maxsize = maxsize
        self.queue = deque()

    def _qsize(self):
        return len(self.queue)

    # Check whether the queue is empty
    def _empty(self):
        return not self.queue

    # Check whether the queue is full
    def _full(self):
        return self.maxsize > 0 and len(self.queue) == self.maxsize

    # Put a new item in the queue
    def _put(self, item):
        self.queue.append(item)

    # Get an item from the queue
    def _get(self):
        return self.queue.popleft()

filename:/usr/lib/python2.7/dist-packages/pygame/threads/__init__.pyc
__doc__
Û
Ï[Jc           @   s~  d  Z  d Z d Z d Z d d l Z d d l Z d d l m Z e j d d k rv d d	 l	 m
 Z d d
 l m Z ni e j d d k rø e j d d k  rø d d l m Z d d
 l m Z n  d d l m Z d d
 l m Z d d l Z e j Z e É  Z e É  Z d a d a d Z d d Ñ Z d Ñ  Z d d d Ñ Z d e f d Ñ  É  YZ d d d Ñ  É  YZ d d e e d Ñ Z d S(   s∫   
* Experimental *

Like the map function, but can use a pool of threads.

Really easy to use threads.  eg.  tmap(f, alist)

If you know how to use the map function, you can use threads.
s   Rene Dudfields   0.3.0s   Python licenseiˇˇˇˇN(   t   geterrori    i   (   t   JoinableQueue(   t   Emptyi   i   i   (   t   Queuei@   c         C   s(   |  r |  a  n	 t É  a  t t  É a d S(   sª    Does a little test to see if threading is worth it.
          Sets up a global worker queue if it's worth it.

        Calling init() is not required, but is generally better to do.
    N(   t   _use_workerst   benchmark_workerst   WorkerQueuet   _wq(   t   number_of_workers(    (    s;   /usr/lib/python2.7/dist-packages/pygame/threads/__init__.pyt   init4   s    		c           C   s   t  j É  d a  t a d S(   s    cleans up everything.
    N(   R   t   stopt   Nonet   FalseR   (    (    (    s;   /usr/lib/python2.7/dist-packages/pygame/threads/__init__.pyt   quitG   s    
c            s{  d d l  â  d d l â  d d l } |  s< á  f d Ü  } n |  } | sÑ g  } x9 t d É D]" } | j à  j d d d É É q[ Wn | } | j É  d } d } d } xŒ t d t É D]Ω }	 t |	 É }
 | j É  } x8 t d	 É D]* } d
 t j	 É  GHt
 | | d |
 É} q· W| j É  } |
 j É  | | } d |	 | f GH| | k  r_| } |	 } | } n  |	 | d k r∂ Pq∂ q∂ W| S(   sX   does a little test to see if workers are at all faster.
        Returns the number of workers which works best.
        Takes a little bit of time to run, so you should only really call
          it once.
        You can pass in benchmark data, and functions if you want.
        a_bench_func - f(data)
        the_data - data to work on.
    iˇˇˇˇNc            s   à  j  j |  d É S(   Ni   i@  (   i   i@  (   t	   transformt   scale(   t   x(   t   pygame(    s;   /usr/lib/python2.7/dist-packages/pygame/threads/__init__.pyt   doiti   s    i
   iõ   i    i    i ·ıi   s   active count:%st   worker_queues#   total time num_workers:%s: time:%s:i   (   iõ   iõ   (   R   t   pygame.transformt   timet   ranget   appendt   Surfacet   MAX_WORKERS_TO_TESTR   t	   threadingt   activeCountt   tmapR
   (   t   a_bench_funct   the_dataR   R   t   thedataR   t   bestt   best_numbert	   last_bestt   num_workerst   wqt   t1t   xxt   resultst   t2t
   total_time(    (   R   s;   /usr/lib/python2.7/dist-packages/pygame/threads/__init__.pyR   P   s>    #

	R   c           B   sA   e  Z d  d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   i   c         C   s&   t  É  |  _ g  |  _ |  j | É d  S(   N(   R   t   queuet   poolt   _setup_workers(   t   selfR#   (    (    s;   /usr/lib/python2.7/dist-packages/pygame/threads/__init__.pyt   __init__ö   s    	c         C   sk   g  |  _  x0 t | É D]" } |  j  j t d |  j É É q Wx( |  j  D] } | j t É | j É  qF Wd S(   sd    Sets up the worker threads
              NOTE: undefined behaviour if you call this again.
        t   targetN(   R+   R   R   t   Threadt
   threadloopt	   setDaemont   Truet   start(   R-   R#   t   _t   a_thread(    (    s;   /usr/lib/python2.7/dist-packages/pygame/threads/__init__.pyR,   ü   s    	 c         O   s   |  j  j | | | f É d S(   s7    puts a function on a queue for running later.
        N(   R*   t   put(   R-   t   ft   argst   kwArgs(    (    s;   /usr/lib/python2.7/dist-packages/pygame/threads/__init__.pyt   do≠   s    c         C   s2   |  j  j t É x |  j D] } | j É  q Wd S(   sK    Stops the WorkerQueue, waits for all of the threads to finish up.
        N(   R*   R7   t   STOPR+   t   join(   R-   t   thread(    (    s;   /usr/lib/python2.7/dist-packages/pygame/threads/__init__.pyR
   ≥   s    c         C   s{   xt t  rv |  j j É  } | t k rE |  j j t É |  j j É  Pq z | d | d | d é  Wd |  j j É  Xq Wd S(   s4    Loops until all of the tasks are finished.
        i    i   i   N(   R3   R*   t   getR<   R7   t	   task_done(   R-   R9   (    (    s;   /usr/lib/python2.7/dist-packages/pygame/threads/__init__.pyR1   ª   s    	c         C   s   |  j  j É  d S(   s-    waits until all tasks are complete.
        N(   R*   R=   (   R-   (    (    s;   /usr/lib/python2.7/dist-packages/pygame/threads/__init__.pyt   waitÕ   s    (   t   __name__t
   __module__R.   R,   R;   R
   R1   RA   (    (    (    s;   /usr/lib/python2.7/dist-packages/pygame/threads/__init__.pyR   ò   s   				t
   FuncResultc           B   s&   e  Z d  Z d d d Ñ Z d Ñ  Z RS(   sy    Used for wrapping up a function call so that the results are stored
         inside the instances result attribute.
    c         C   s(   | |  _  d |  _ | |  _ | |  _ d S(   sˆ    f - is the function we that we call 
            callback(result) - this is called when the function(f) returns
            errback(exception) - this is called when the function(f) raises
                                   an exception.
        N(   R8   R   t	   exceptiont   callbackt   errback(   R-   R8   RF   RG   (    (    s;   /usr/lib/python2.7/dist-packages/pygame/threads/__init__.pyR.   ÷   s    			c         O   su   y5 |  j  | | é  |  _ |  j r4 |  j |  j É n  Wn9 t k
 rp t É  |  _ |  j rq |  j |  j É qq n Xd  S(   N(   R8   t   resultRF   t	   ExceptionR    RE   RG   (   R-   R9   t   kwargs(    (    s;   /usr/lib/python2.7/dist-packages/pygame/threads/__init__.pyt   __call__·   s    		N(   RB   RC   t   __doc__R   R.   RK   (    (    (    s;   /usr/lib/python2.7/dist-packages/pygame/threads/__init__.pyRD   “   s   i   c         C   sw  | r | } n4 t  r t  } n% | d k r7 t |  | É St | É } t | j É d k re t |  | É Sg  } x5 | D]- } | j t |  É É | j | d | É qr W| ri| j É  | j	 j
 É  r— t d É Ç n  | r(t  r(| j É  | j	 j
 É  r(| j	 j É  }	 |	 t k	 r%t d É Ç q%q(n  | rYt d Ñ  | É }
 |
 rY|
 d j Ç qYn  t d Ñ  | É S| | g Sd S(   s'   like map, but uses a thread pool to execute.
        num_workers - the number of worker threads that will be used.  If pool
                        is passed in, then the num_workers arg is ignored.
        worker_queue - you can optionally pass in an existing WorkerQueue.
        wait - True means that the results are returned when everything is finished.
               False means that we return the [worker_queue, results] right away instead. 
               results, is returned as a list of FuncResult instances.
        stop_on_error - 
    i    iˇˇˇˇs   buggy threadmapc         S   s   |  j  S(   N(   RE   (   R   (    (    s;   /usr/lib/python2.7/dist-packages/pygame/threads/__init__.pyt   <lambda>0  s    c         S   s   |  j  S(   N(   RH   (   R   (    (    s;   /usr/lib/python2.7/dist-packages/pygame/threads/__init__.pyRM   4  s    N(   R   t   mapR   t   lenR+   R   RD   R;   RA   R*   t   qsizeRI   R
   R?   R<   t   filterRE   (   R8   t   seq_argsR#   R   RA   t   stop_on_errorR$   R'   t   sat   umt
   error_ones(    (    s;   /usr/lib/python2.7/dist-packages/pygame/threads/__init__.pyR   Ó   s:    		

(    (   RL   t
   __author__t   __version__t   __license__t	   tracebackt   syst   pygame.compatR    t   version_infot   multiprocessingR   R   R*   R   t	   Py25QueueR   R0   t   objectR<   t   FINISHR   R   R   R   R	   R   R   R   RD   R3   R   (    (    (    s;   /usr/lib/python2.7/dist-packages/pygame/threads/__init__.pyt   <module>	   s4   &					H:
filename:/usr/lib/python2.7/dist-packages/pygame/tests/midi_test.py
__doc__
if __name__ == '__main__':
    import sys
    import os
    pkg_dir = os.path.split(os.path.abspath(__file__))[0]
    parent_dir, pkg_name = os.path.split(pkg_dir)
    is_pygame_pkg = (pkg_name == 'tests' and
                     os.path.split(parent_dir)[1] == 'pygame')
    if not is_pygame_pkg:
        sys.path.insert(0, parent_dir)
else:
    is_pygame_pkg = __name__.startswith('pygame.tests.')

if is_pygame_pkg:
    from pygame.tests import test_utils
    from pygame.tests.test_utils import test_not_implemented, unittest
else:
    from test import test_utils
    from test.test_utils import test_not_implemented, unittest
import pygame
import pygame.midi
import pygame.compat
from pygame.locals import *


import os
import sys
import time





class MidiTest( unittest.TestCase ):            

    def todo_test_poll(self):

        # __doc__ (as of 2009-05-19) for pygame.midi.Input.poll:

          # returns true if there's data, or false if not.
          # Input.poll(): return Bool
          # 
          # raises a MidiException on error.

        self.fail() 

    def todo_test_read(self):

        # __doc__ (as of 2009-05-19) for pygame.midi.Input.read:

          # reads num_events midi events from the buffer.
          # Input.read(num_events): return midi_event_list
          # 
          # Reads from the Input buffer and gives back midi events.
          # [[[status,data1,data2,data3],timestamp],
          #  [[status,data1,data2,data3],timestamp],...]

        self.fail() 

    def test_MidiException(self):

        # __doc__ (as of 2009-05-19) for pygame.midi.MidiException.message:

        def raiseit():
            raise pygame.midi.MidiException(0)

        self.assertRaises(pygame.midi.MidiException, raiseit)
        try:
            raise pygame.midi.MidiException(0) 
        except pygame.midi.MidiException:
            e = pygame.compat.geterror()
            self.assertEqual(e.parameter, 0)


    def test_note_off(self):
        """|tags: interactive|
        """

        # __doc__ (as of 2009-05-19) for pygame.midi.Output.note_off:

          # turns a midi note off.  Note must be on.
          # Output.note_off(note, velocity=None, channel = 0)
          # 
          # Turn a note off in the output stream.  The note must already
          # be on for this to work correctly.

        i = pygame.midi.get_default_output_id()
        if i != -1:
            o = pygame.midi.Output(i)
            o.note_on(5, 30, 0)
            o.note_off(5, 30, 0)



    def test_note_on(self):
        """|tags: interactive|
        """

        # __doc__ (as of 2009-05-19) for pygame.midi.Output.note_on:

          # turns a midi note on.  Note must be off.
          # Output.note_on(note, velocity=None, channel = 0)
          # 
          # Turn a note on in the output stream.  The note must already
          # be off for this to work correctly.


        i = pygame.midi.get_default_output_id()
        if i != -1:
            o = pygame.midi.Output(i)
            o.note_on(5, 30, 0)


    def todo_test_set_instrument(self):

        # __doc__ (as of 2009-05-19) for pygame.midi.Output.set_instrument:

          # Select an instrument, with a value between 0 and 127.
          # Output.set_instrument(instrument_id, channel = 0)

        self.fail() 

    def todo_test_write(self):

        # __doc__ (as of 2009-05-19) for pygame.midi.Output.write:

          # writes a list of midi data to the Output.
          # Output.write(data)
          # 
          # writes series of MIDI information in the form of a list:
          #      write([[[status <,data1><,data2><,data3>],timestamp],
          #             [[status <,data1><,data2><,data3>],timestamp],...])
          # <data> fields are optional
          # example: choose program change 1 at time 20000 and
          # send note 65 with velocity 100 500 ms later.
          #      write([[[0xc0,0,0],20000],[[0x90,60,100],20500]])
          # notes:
          #   1. timestamps will be ignored if latency = 0.
          #   2. To get a note to play immediately, send MIDI info with
          #      timestamp read from function Time.
          #   3. understanding optional data fields:
          #        write([[[0xc0,0,0],20000]]) is equivalent to
          #        write([[[0xc0],20000]])
          # 
          # Can send up to 1024 elements in your data list, otherwise an 
          #  IndexError exception is raised.

        self.fail() 

    def test_write_short(self):
        """|tags: interactive|
        """
        # __doc__ (as of 2009-05-19) for pygame.midi.Output.write_short:

          # write_short(status <, data1><, data2>)
          # Output.write_short(status)
          # Output.write_short(status, data1 = 0, data2 = 0)
          # 
          # output MIDI information of 3 bytes or less.
          # data fields are optional
          # status byte could be:
          #      0xc0 = program change
          #      0x90 = note on
          #      etc.
          #      data bytes are optional and assumed 0 if omitted
          # example: note 65 on with velocity 100
          #      write_short(0x90,65,100)

        i = pygame.midi.get_default_output_id()
        if i != -1:
            o = pygame.midi.Output(i)
            # put a note on, then off.
            o.write_short(0x90,65,100)
            o.write_short(0x80,65,100)




    def test_Input(self):
        """|tags: interactive|
        """

        i = pygame.midi.get_default_input_id()
        if i != -1:
            o = pygame.midi.Input(i)
            del o

        # try feeding it an input id.
        i = pygame.midi.get_default_output_id()

        # can handle some invalid input too.
        self.assertRaises(pygame.midi.MidiException, pygame.midi.Input, i)
        self.assertRaises(pygame.midi.MidiException, pygame.midi.Input, 9009)
        self.assertRaises(pygame.midi.MidiException, pygame.midi.Input, -1)
        self.assertRaises(TypeError, pygame.midi.Input,"1234")
        self.assertRaises(OverflowError, pygame.midi.Input, pow(2,99))


    def test_Output(self):
        """|tags: interactive|
        """
        i = pygame.midi.get_default_output_id()
        if i != -1:
            o = pygame.midi.Output(i)
            del o

        # try feeding it an input id.
        i = pygame.midi.get_default_input_id()

        # can handle some invalid input too.
        self.assertRaises(pygame.midi.MidiException, pygame.midi.Output, i)
        self.assertRaises(pygame.midi.MidiException, pygame.midi.Output, 9009)
        self.assertRaises(pygame.midi.MidiException, pygame.midi.Output, -1)
        self.assertRaises(TypeError, pygame.midi.Output,"1234")
        self.assertRaises(OverflowError, pygame.midi.Output, pow(2,99))


    def todo_test_write_sys_ex(self):

        # __doc__ (as of 2009-05-19) for pygame.midi.Output.write_sys_ex:

          # writes a timestamped system-exclusive midi message.
          # Output.write_sys_ex(when, msg)
          # 
          # write_sys_ex(<timestamp>,<msg>)
          # 
          # msg - can be a *list* or a *string*
          # example:
          #   (assuming o is an onput MIDI stream)
          #     o.write_sys_ex(0,'\xF0\x7D\x10\x11\x12\x13\xF7')
          #   is equivalent to
          #     o.write_sys_ex(pygame.midi.Time,
          #                    [0xF0,0x7D,0x10,0x11,0x12,0x13,0xF7])

        self.fail() 


    def tearDown(self):
        pygame.midi.quit()

    def setUp(self):
        pygame.midi.init()

    def test_get_count(self):

        # __doc__ (as of 2009-05-19) for pygame.midi.get_count:

          # gets the number of devices.
          # pygame.midi.get_count(): return num_devices
          # 
          # 
          # Device ids range from 0 to get_count() -1

        c = pygame.midi.get_count()
        self.assertEqual(type(c), type(1))
        self.failUnless(c >= 0)



    def test_get_default_input_id(self):

        # __doc__ (as of 2009-05-19) for pygame.midi.get_default_input_device_id:

          # gets the device number of the default input device.
          # pygame.midi.get_default_input_device_id(): return default_id
          # 
          # 
          # Return the default device ID or -1 if there are no devices.
          # The result can be passed to the Input()/Ouput() class.
          # 
          # On the PC, the user can specify a default device by
          # setting an environment variable. For example, to use device #1.
          # 
          #     set PM_RECOMMENDED_INPUT_DEVICE=1
          # 
          # The user should first determine the available device ID by using
          # the supplied application "testin" or "testout".
          # 
          # In general, the registry is a better place for this kind of info,
          # and with USB devices that can come and go, using integers is not
          # very reliable for device identification. Under Windows, if
          # PM_RECOMMENDED_OUTPUT_DEVICE (or PM_RECOMMENDED_INPUT_DEVICE) is
          # *NOT* found in the environment, then the default device is obtained
          # by looking for a string in the registry under:
          #     HKEY_LOCAL_MACHINE/SOFTWARE/PortMidi/Recommended_Input_Device
          # and HKEY_LOCAL_MACHINE/SOFTWARE/PortMidi/Recommended_Output_Device
          # for a string. The number of the first device with a substring that
          # matches the string exactly is returned. For example, if the string
          # in the registry is "USB", and device 1 is named
          # "In USB MidiSport 1x1", then that will be the default
          # input because it contains the string "USB".
          # 
          # In addition to the name, get_device_info() returns "interf", which
          # is the interface name. (The "interface" is the underlying software
          #     system or API used by PortMidi to access devices. Examples are
          #     MMSystem, DirectX (not implemented), ALSA, OSS (not implemented), etc.)
          #     At present, the only Win32 interface is "MMSystem", the only Linux
          #     interface is "ALSA", and the only Max OS X interface is "CoreMIDI".
          # To specify both the interface and the device name in the registry,
          # separate the two with a comma and a space, e.g.:
          #     MMSystem, In USB MidiSport 1x1
          # In this case, the string before the comma must be a substring of
          # the "interf" string, and the string after the space must be a
          # substring of the "name" name string in order to match the device.
          # 
          # Note: in the current release, the default is simply the first device
          #     (the input or output device with the lowest PmDeviceID).

        c = pygame.midi.get_default_input_id()
        # if there is a not None return make sure it is an int.
        self.assertEqual(type(c), type(1))
        self.failUnless(c >= 0 or c == -1)



    def test_get_default_output_id(self):

        # __doc__ (as of 2009-05-19) for pygame.midi.get_default_output_device_id:

          # get the device number of the default output device.
          # pygame.midi.get_default_output_device_id(): return default_id
          # 
          # 
          # Return the default device ID or -1 if there are no devices.
          # The result can be passed to the Input()/Ouput() class.
          # 
          # On the PC, the user can specify a default device by
          # setting an environment variable. For example, to use device #1.
          # 
          #     set PM_RECOMMENDED_OUTPUT_DEVICE=1
          # 
          # The user should first determine the available device ID by using
          # the supplied application "testin" or "testout".
          # 
          # In general, the registry is a better place for this kind of info,
          # and with USB devices that can come and go, using integers is not
          # very reliable for device identification. Under Windows, if
          # PM_RECOMMENDED_OUTPUT_DEVICE (or PM_RECOMMENDED_INPUT_DEVICE) is
          # *NOT* found in the environment, then the default device is obtained
          # by looking for a string in the registry under:
          #     HKEY_LOCAL_MACHINE/SOFTWARE/PortMidi/Recommended_Input_Device
          # and HKEY_LOCAL_MACHINE/SOFTWARE/PortMidi/Recommended_Output_Device
          # for a string. The number of the first device with a substring that
          # matches the string exactly is returned. For example, if the string
          # in the registry is "USB", and device 1 is named
          # "In USB MidiSport 1x1", then that will be the default
          # input because it contains the string "USB".
          # 
          # In addition to the name, get_device_info() returns "interf", which
          # is the interface name. (The "interface" is the underlying software
          #     system or API used by PortMidi to access devices. Examples are
          #     MMSystem, DirectX (not implemented), ALSA, OSS (not implemented), etc.)
          #     At present, the only Win32 interface is "MMSystem", the only Linux
          #     interface is "ALSA", and the only Max OS X interface is "CoreMIDI".
          # To specify both the interface and the device name in the registry,
          # separate the two with a comma and a space, e.g.:
          #     MMSystem, In USB MidiSport 1x1
          # In this case, the string before the comma must be a substring of
          # the "interf" string, and the string after the space must be a
          # substring of the "name" name string in order to match the device.
          # 
          # Note: in the current release, the default is simply the first device
          #     (the input or output device with the lowest PmDeviceID).

        c = pygame.midi.get_default_output_id()
        self.assertEqual(type(c), type(1))
        self.failUnless(c >= 0 or c == -1)




    def test_get_device_info(self):

        # __doc__ (as of 2009-05-19) for pygame.midi.get_device_info:

          # returns (interf, name, input, output, opened)
          # pygame.midi.get_device_info(an_id): return (interf, name, input,
          # output, opened)
          #
          #
          # If the id is out of range, the function returns None.

        an_id = pygame.midi.get_default_output_id()
        if an_id != -1:
            interf, name, input, output, opened = pygame.midi.get_device_info(an_id)
            #print interf
            #print name
            #print input, output, opened

            self.assertEqual(output, 1)
            self.assertEqual(input, 0)
            self.assertEqual(opened, 0)


        an_in_id = pygame.midi.get_default_input_id()
        if an_in_id != -1:
            r = pygame.midi.get_device_info(an_in_id)
            # if r is None, it means that the id is out of range.
            try:
                interf, name, input, output, opened = r
            except TypeError:
                raise Exception(repr(r))

            self.assertEqual(output, 0)
            self.assertEqual(input, 1)
            self.assertEqual(opened, 0)






    def test_init(self):

        # __doc__ (as of 2009-05-19) for pygame.midi.init:

          # initialize the midi module
          # pygame.midi.init(): return None
          # 
          # Call the initialisation function before using the midi module.
          # 
          # It is safe to call this more than once.
        pygame.midi.quit()
        self.assertRaises(RuntimeError, pygame.midi.get_count)
        # initialising many times should be fine.
        pygame.midi.init()
        pygame.midi.init()
        pygame.midi.init()
        pygame.midi.init()



    def todo_test_midis2events(self):

        # __doc__ (as of 2009-05-19) for pygame.midi.midis2events:

          # converts midi events to pygame events
          # pygame.midi.midis2events(midis, device_id): return [Event, ...]
          # 
          # Takes a sequence of midi events and returns list of pygame events.

        self.fail() 

    def test_quit(self):

        # __doc__ (as of 2009-05-19) for pygame.midi.quit:

          # uninitialize the midi module
          # pygame.midi.quit(): return None
          # 
          # 
          # Called automatically atexit if you don't call it.
          # 
          # It is safe to call this function more than once.


          # It is safe to call this more than once.
        pygame.midi.quit()
        pygame.midi.init()
        pygame.midi.quit()
        pygame.midi.quit()
        pygame.midi.init()
        pygame.midi.init()
        pygame.midi.quit()

    def test_time(self):

        # __doc__ (as of 2009-05-19) for pygame.midi.time:

          # returns the current time in ms of the PortMidi timer
          # pygame.midi.time(): return time

        t = pygame.midi.time()
        self.assertEqual(type(t), type(1))
        # should be close to 2-3... since the timer is just init'd.
        self.failUnless(t >= 0 and t < 100)


 
if __name__ == '__main__':
    unittest.main()

filename:/usr/lib/python2.7/dist-packages/pygame/tests/surflock_test.py
__doc__
if __name__ == '__main__':
    import sys
    import os
    pkg_dir = os.path.split(os.path.abspath(__file__))[0]
    parent_dir, pkg_name = os.path.split(pkg_dir)
    is_pygame_pkg = (pkg_name == 'tests' and
                     os.path.split(parent_dir)[1] == 'pygame')
    if not is_pygame_pkg:
        sys.path.insert(0, parent_dir)
else:
    is_pygame_pkg = __name__.startswith('pygame.tests.')

if is_pygame_pkg:
    from pygame.tests.test_utils import test_not_implemented, unittest
else:
    from test.test_utils import test_not_implemented, unittest
import pygame

import sys

class SurfaceLockTest (unittest.TestCase):

    def test_lock (self):
        sf = pygame.Surface ((5, 5))

        sf.lock ()
        self.assertEquals (sf.get_locked (), True)
        self.assertEquals (sf.get_locks (), (sf,))

        sf.lock ()
        self.assertEquals (sf.get_locked (), True)
        self.assertEquals (sf.get_locks (), (sf, sf))

        sf.unlock ()
        self.assertEquals (sf.get_locked (), True)
        self.assertEquals (sf.get_locks (), (sf,))

        sf.unlock ()
        self.assertEquals (sf.get_locked (), False)
        self.assertEquals (sf.get_locks (), ())

    def test_subsurface_lock (self):
        sf = pygame.Surface ((5, 5))
        subsf = sf.subsurface ((1, 1, 2, 2))
        sf2 = pygame.Surface ((5, 5))

        # Simple blits, nothing should happen here.
        sf2.blit (subsf, (0, 0))
        sf2.blit (sf, (0, 0))

        # Test blitting on self:
        self.assertRaises (pygame.error, sf.blit, subsf, (0, 0))
        #self.assertRaises (pygame.error, subsf.blit, sf, (0, 0))
        # ^ Fails although it should not in my opinion. If I cannot
        # blit the subsurface to the surface, it should not be allowed
        # the other way around as well.

        # Test additional locks.
        sf.lock ()
        sf2.blit (subsf, (0, 0))
        self.assertRaises (pygame.error, sf2.blit, sf, (0, 0))

        subsf.lock ()
        self.assertRaises (pygame.error, sf2.blit, subsf, (0, 0))
        self.assertRaises (pygame.error, sf2.blit, sf, (0, 0))

        # sf and subsf are now explicitly locked. Unlock sf, so we can
        # (assume) to blit it.
        # It will fail though as the subsurface still has a lock around,
        # which is okay and correct behaviour.
        sf.unlock ()
        self.assertRaises (pygame.error, sf2.blit, subsf, (0, 0))
        self.assertRaises (pygame.error, sf2.blit, sf, (0, 0))

        # Run a second unlock on the surface. This should ideally have
        # no effect as the subsurface is the locking reason!
        sf.unlock ()
        self.assertRaises (pygame.error, sf2.blit, sf, (0, 0))
        self.assertRaises (pygame.error, sf2.blit, subsf, (0, 0))
        subsf.unlock ()
        
        sf.lock ()
        self.assertEquals (sf.get_locked (), True)
        self.assertEquals (sf.get_locks (), (sf,))
        self.assertEquals (subsf.get_locked (), False)
        self.assertEquals (subsf.get_locks (), ())

        subsf.lock ()
        self.assertEquals (sf.get_locked (), True)
        self.assertEquals (sf.get_locks (), (sf, subsf))
        self.assertEquals (subsf.get_locked (), True)
        self.assertEquals (subsf.get_locks (), (subsf,))

        sf.unlock ()
        self.assertEquals (sf.get_locked (), True)
        self.assertEquals (sf.get_locks (), (subsf,))
        self.assertEquals (subsf.get_locked (), True)
        self.assertEquals (subsf.get_locks (), (subsf,))

        subsf.unlock ()
        self.assertEquals (sf.get_locked (), False)
        self.assertEquals (sf.get_locks (), ())
        self.assertEquals (subsf.get_locked (), False)
        self.assertEquals (subsf.get_locks (), ())

        subsf.lock ()
        self.assertEquals (sf.get_locked (), True)
        self.assertEquals (sf.get_locks (), (subsf,))
        self.assertEquals (subsf.get_locked (), True)
        self.assertEquals (subsf.get_locks (), (subsf,))

        subsf.lock ()
        self.assertEquals (sf.get_locked (), True)
        self.assertEquals (sf.get_locks (), (subsf, subsf))
        self.assertEquals (subsf.get_locked (), True)
        self.assertEquals (subsf.get_locks (), (subsf, subsf))

    def test_pxarray_ref (self):
        sf = pygame.Surface ((5, 5))
        ar = pygame.PixelArray (sf)
        ar2 = pygame.PixelArray (sf)

        self.assertEquals (sf.get_locked (), True)
        self.assertEquals (sf.get_locks (), (ar, ar2))

        del ar
        self.assertEquals (sf.get_locked (), True)
        self.assertEquals (sf.get_locks (), (ar2,))

        ar = ar2[:]
        self.assertEquals (sf.get_locked (), True)
        self.assertEquals (sf.get_locks (), (ar2,))

        del ar
        self.assertEquals (sf.get_locked (), True)
        self.assertEquals (len (sf.get_locks ()), 1)

    def test_buffer (self):
        sf = pygame.Surface ((5, 5))
        buf = sf.get_buffer ()

        self.assertEquals (sf.get_locked (), True)
        self.assertEquals (sf.get_locks (), (buf,))

        sf.unlock ()
        self.assertEquals (sf.get_locked (), True)
        self.assertEquals (sf.get_locks (), (buf,))

        del buf
        self.assertEquals (sf.get_locked (), False)
        self.assertEquals (sf.get_locks (), ())


if __name__ == '__main__':
    unittest.main()

filename:/usr/lib/python2.7/dist-packages/pygame/tests/sndarray_test.py
__doc__
if __name__ == '__main__':
    import sys
    import os
    pkg_dir = os.path.split(os.path.abspath(__file__))[0]
    parent_dir, pkg_name = os.path.split(pkg_dir)
    is_pygame_pkg = (pkg_name == 'tests' and
                     os.path.split(parent_dir)[1] == 'pygame')
    if not is_pygame_pkg:
        sys.path.insert(0, parent_dir)
else:
    is_pygame_pkg = __name__.startswith('pygame.tests.')

if is_pygame_pkg:
    from pygame.tests.test_utils import test_not_implemented, unittest
else:
    from test.test_utils import test_not_implemented, unittest
import pygame

arraytype = ""
try:
    import pygame.sndarray
except ImportError:
    pass
else:
    arraytype = pygame.sndarray.get_arraytype()
    if arraytype == 'numpy':
        from numpy import \
             int8, int16, uint8, uint16, array, alltrue
    elif arraytype == 'numeric':
        from Numeric import \
             Int8 as int8, Int16 as int16, UInt8 as uint8, UInt16 as uint16, \
             array, alltrue
    else:
        print ("Unknown array type %s; tests skipped" %
               (pygame.sndarray.get_arraytype(),))
        arraytype = ""


class SndarrayTest (unittest.TestCase):
    if arraytype:
        array_dtypes = {8: uint8, -8: int8, 16: uint16, -16: int16}

    def _assert_compatible(self, arr, size):
        dtype = self.array_dtypes[size]
        if arraytype == 'numpy':
            self.failUnlessEqual(arr.dtype, dtype)
        else:
            self.failUnlessEqual(arr.typecode(), dtype)

    def test_import(self):
        'does it import'
        if not arraytype:
            self.fail("no array package installed")
        import pygame.sndarray

    def test_array(self):
        if not arraytype:
            self.fail("no array package installed")

        def check_array(size, channels, test_data):
            try:
                pygame.mixer.init(22050, size, channels)
            except pygame.error:
                # Not all sizes are supported on all systems.
                return
            try:
                __, sz, __ = pygame.mixer.get_init()
                if sz == size:
                    srcarr = array(test_data, self.array_dtypes[size])
                    snd = pygame.sndarray.make_sound(srcarr)
                    arr = pygame.sndarray.array(snd)
                    self._assert_compatible(arr, size)
                    self.failUnless(alltrue(arr == srcarr),
                                    "size: %i\n%s\n%s" %
                                    (size, arr, test_data))
            finally:
                pygame.mixer.quit()

        check_array(8, 1, [0, 0x0f, 0xf0, 0xff])
        check_array(8, 2,
                    [[0, 0x80], [0x2D, 0x41], [0x64, 0xA1], [0xff, 0x40]])
        check_array(16, 1, [0, 0x00ff, 0xff00, 0xffff])
        check_array(16, 2, [[0, 0xffff], [0xffff, 0],
                            [0x00ff, 0xff00], [0x0f0f, 0xf0f0]])
        check_array(-8, 1, [0, -0x80, 0x7f, 0x64])
        check_array(-8, 2,
                    [[0, -0x80], [-0x64, 0x64], [0x25, -0x50], [0xff, 0]])
        check_array(-16, 1, [0, 0x7fff, -0x7fff, -1])
        check_array(-16, 2, [[0, -0x7fff], [-0x7fff, 0],
                             [0x7fff, 0], [0, 0x7fff]])

    def test_get_arraytype(self):
        if not arraytype:
            self.fail("no array package installed")

        self.failUnless((pygame.sndarray.get_arraytype() in
                         ['numpy', 'numeric']),
                        ("unknown array type %s" %
                         pygame.sndarray.get_arraytype()))

    def test_get_arraytypes(self):
        if not arraytype:
            self.fail("no array package installed")

        arraytypes = pygame.sndarray.get_arraytypes()
        try:
            import numpy
        except ImportError:
            self.failIf('numpy' in arraytypes)
        else:
            self.failUnless('numpy' in arraytypes)

        try:
            import Numeric
        except ImportError:
            self.failIf('numeric' in arraytypes)
        else:
            self.failUnless('numeric' in arraytypes)

        for atype in arraytypes:
            self.failUnless(atype in ['numpy', 'numeric'],
                            "unknown array type %s" % atype)

    def test_make_sound(self):
        if not arraytype:
            self.fail("no array package installed")

        def check_sound(size, channels, test_data):
            try:
                pygame.mixer.init(22050, size, channels)
            except pygame.error:
                # Not all sizes are supported on all systems.
                return
            try:
                __, sz, __ = pygame.mixer.get_init()
                if sz == size:
                    srcarr = array(test_data, self.array_dtypes[size])
                    snd = pygame.sndarray.make_sound(srcarr)
                    arr = pygame.sndarray.samples(snd)
                    self.failUnless(alltrue(arr == srcarr),
                                    "size: %i\n%s\n%s" %
                                    (size, arr, test_data))
            finally:
                pygame.mixer.quit()

        check_sound(8, 1, [0, 0x0f, 0xf0, 0xff])
        check_sound(8, 2,
                    [[0, 0x80], [0x2D, 0x41], [0x64, 0xA1], [0xff, 0x40]])
        check_sound(16, 1, [0, 0x00ff, 0xff00, 0xffff])
        check_sound(16, 2, [[0, 0xffff], [0xffff, 0],
                            [0x00ff, 0xff00], [0x0f0f, 0xf0f0]])
        check_sound(-8, 1, [0, -0x80, 0x7f, 0x64])
        check_sound(-8, 2,
                    [[0, -0x80], [-0x64, 0x64], [0x25, -0x50], [0xff, 0]])
        check_sound(-16, 1, [0, 0x7fff, -0x7fff, -1])
        check_sound(-16, 2, [[0, -0x7fff], [-0x7fff, 0],
                             [0x7fff, 0], [0, 0x7fff]])

    def test_samples(self):
        if not arraytype:
            self.fail("no array package installed")

        def check_sample(size, channels, test_data):
            try:
                pygame.mixer.init(22050, size, channels)
            except pygame.error:
                # Not all sizes are supported on all systems.
                return
            try:
                __, sz, __ = pygame.mixer.get_init()
                if sz == size:
                    zeroed = '\0' * ((abs(size) // 8) *
                                     len(test_data) *
                                     channels)
                    snd = pygame.mixer.Sound(buffer(zeroed))
                    samples = pygame.sndarray.samples(snd)
                    self._assert_compatible(samples, size)
                    print ('X %s' % (samples.shape,))
                    print ('Y %s' % (test_data,))
                    samples[...] = test_data
                    arr = pygame.sndarray.array(snd)
                    self.failUnless(alltrue(samples == arr),
                                    "size: %i\n%s\n%s" %
                                    (size, arr, test_data))
            finally:
                pygame.mixer.quit()

        check_sample(8, 1, [0, 0x0f, 0xf0, 0xff])
        check_sample(8, 2,
                    [[0, 0x80], [0x2D, 0x41], [0x64, 0xA1], [0xff, 0x40]])
        check_sample(16, 1, [0, 0x00ff, 0xff00, 0xffff])
        check_sample(16, 2, [[0, 0xffff], [0xffff, 0],
                            [0x00ff, 0xff00], [0x0f0f, 0xf0f0]])
        check_sample(-8, 1, [0, -0x80, 0x7f, 0x64])
        check_sample(-8, 2,
                    [[0, -0x80], [-0x64, 0x64], [0x25, -0x50], [0xff, 0]])
        check_sample(-16, 1, [0, 0x7fff, -0x7fff, -1])
        check_sample(-16, 2, [[0, -0x7fff], [-0x7fff, 0],
                             [0x7fff, 0], [0, 0x7fff]])

    def test_use_arraytype(self):
        if not arraytype:
            self.fail("no array package installed")

        def do_use_arraytype(atype):
            pygame.sndarray.use_arraytype(atype)

        try:
            import numpy
        except ImportError:
            self.failUnlessRaises(ValueError, do_use_arraytype, 'numpy')
            self.failIfEqual(pygame.sndarray.get_arraytype(), 'numpy')
        else:
            pygame.sndarray.use_arraytype('numpy')
            self.failUnlessEqual(pygame.sndarray.get_arraytype(), 'numpy')

        try:
            import Numeric
        except ImportError:
            self.failUnlessRaises(ValueError, do_use_arraytype, 'numeric')
            self.failIfEqual(pygame.sndarray.get_arraytype(), 'numeric')
        else:
            pygame.sndarray.use_arraytype('numeric')
            self.failUnlessEqual(pygame.sndarray.get_arraytype(), 'numeric')

        self.failUnlessRaises(ValueError, do_use_arraytype, 'not an option')


if __name__ == '__main__':
    unittest.main()

filename:/usr/lib/python2.7/dist-packages/pygame/tests/image__save_gl_surface_test.py
__doc__
if __name__ == '__main__':
    import sys
    import os
    pkg_dir = os.path.split(os.path.abspath(__file__))[0]
    parent_dir, pkg_name = os.path.split(pkg_dir)
    is_pygame_pkg = (pkg_name == 'tests' and
                     os.path.split(parent_dir)[1] == 'pygame')
    if not is_pygame_pkg:
        sys.path.insert(0, parent_dir)
else:
    is_pygame_pkg = __name__.startswith('pygame.tests.')

if is_pygame_pkg:
    from pygame.tests import test_utils
    from pygame.tests.test_utils import unittest
else:
    from test import test_utils
    from test.test_utils import unittest
import pygame, os
from pygame.locals import *

class GL_ImageSave(unittest.TestCase):
    def test_image_save_works_with_opengl_surfaces(self):
        "|tags:display,slow|"

        pygame.display.init()
        
        
        screen = pygame.display.set_mode((640,480), OPENGL|DOUBLEBUF)

        pygame.display.flip()
        
        tmp_dir = test_utils.get_tmp_dir()
        # Try the imageext module.
        tmp_file = os.path.join(tmp_dir, "opengl_save_surface_test.png")
        
        pygame.image.save(screen, tmp_file)
        
        self.assert_(os.path.exists(tmp_file))
        
        os.remove(tmp_file)

        # Only test the image module.
        tmp_file = os.path.join(tmp_dir, "opengl_save_surface_test.bmp")
        
        pygame.image.save(screen, tmp_file)
        
        self.assert_(os.path.exists(tmp_file))
        
        os.remove(tmp_file)
        
        # stops tonnes of tmp dirs building up in trunk dir
        os.rmdir(tmp_dir)
        
        
        pygame.display.quit()
if __name__ == '__main__': 
    unittest.main()

filename:/usr/lib/python2.7/dist-packages/pygame/tests/__init__.py
__doc__
"""Pygame unit test suite package

filename:/usr/lib/python2.7/dist-packages/pygame/tests/__main__.py
__doc__
"""Load and run the Pygame test suite

python -c "import pygame.tests.go" [<test options>]

or

python test/go.py [<test options>]

Command line option --help displays a command line usage message.

run_tests.py in the main distribution directory is an alternative to test.go

"""

filename:/usr/lib/python2.7/dist-packages/lxml/sax.py
__doc__
"""
SAX-based adapter to copy trees from/to the Python standard library.

Use the `ElementTreeContentHandler` class to build an ElementTree from
SAX events.

Use the `ElementTreeProducer` class or the `saxify()` function to fire
the SAX events of an ElementTree against a SAX ContentHandler.

See http://codespeak.net/lxml/sax.html
"""

filename:/usr/lib/python2.7/dist-packages/lxml/isoschematron/__init__.py
__doc__
"""The ``lxml.isoschematron`` package implements ISO Schematron support on top
of the pure-xslt 'skeleton' implementation.
"""

filename:/usr/lib/python2.7/dist-packages/lxml/cssselect.py
__doc__
"""CSS Selectors based on XPath.

This module supports selecting XML/HTML tags based on CSS selectors.
See the `CSSSelector` class for details.

This is a thin wrapper around cssselect 0.7 or later.
"""

filename:/usr/lib/python2.7/dist-packages/lxml/html/html5parser.py
__doc__
"""
An interface to html5lib that mimics the lxml.html interface.
"""

filename:/usr/lib/python2.7/dist-packages/lxml/html/soupparser.py
__doc__
"""External interface to the BeautifulSoup HTML parser.
"""

filename:/usr/lib/python2.7/dist-packages/lxml/html/clean.py
__doc__
"""A cleanup tool for HTML.

Removes unwanted tags and content.  See the `Cleaner` class for
details.
"""

filename:/usr/lib/python2.7/dist-packages/lxml/html/usedoctest.py
__doc__
"""Doctest module for HTML comparison.

Usage::

   >>> import lxml.html.usedoctest
   >>> # now do your HTML doctests ...

See `lxml.doctestcompare`.
"""

filename:/usr/lib/python2.7/dist-packages/lxml/html/_html5builder.py
__doc__
"""
Legacy module - don't use in new code!

html5lib now has its own proper implementation.

This module implements a tree builder for html5lib that generates lxml
html element trees.  This module uses camelCase as it follows the
html5lib style guide.
"""

filename:/usr/lib/python2.7/dist-packages/lxml/doctestcompare.py
__doc__
"""
lxml-based doctest output comparison.

Note: normally, you should just import the `lxml.usedoctest` and
`lxml.html.usedoctest` modules from within a doctest, instead of this
one::

    >>> import lxml.usedoctest # for XML output

    >>> import lxml.html.usedoctest # for HTML output

To use this module directly, you must call ``lxmldoctest.install()``,
which will cause doctest to use this in all subsequent calls.

This changes the way output is checked and comparisons are made for
XML or HTML-like content.

XML or HTML content is noticed because the example starts with ``<``
(it's HTML if it starts with ``<html``).  You can also use the
``PARSE_HTML`` and ``PARSE_XML`` flags to force parsing.

Some rough wildcard-like things are allowed.  Whitespace is generally
ignored (except in attributes).  In text (attributes and text in the
body) you can use ``...`` as a wildcard.  In an example it also
matches any trailing tags in the element, though it does not match
leading tags.  You may create a tag ``<any>`` or include an ``any``
attribute in the tag.  An ``any`` tag matches any tag, while the
attribute matches any and all attributes.

When a match fails, the reformatted example and gotten text is
displayed (indented), and a rough diff-like output is given.  Anything
marked with ``+`` is in the output but wasn't supposed to be, and
similarly ``-`` means its in the example but wasn't in the output.

You can disable parsing on one line with ``# doctest:+NOPARSE_MARKUP``
"""

filename:/usr/lib/python2.7/dist-packages/lxml/usedoctest.py
__doc__
"""Doctest module for XML comparison.

Usage::

   >>> import lxml.usedoctest
   >>> # now do your XML doctests ...

See `lxml.doctestcompare`
"""

filename:/usr/lib/python2.7/dist-packages/service_identity/pyopenssl.py
__doc__
"""
`pyOpenSSL <https://github.com/pyca/pyopenssl>`_-specific code.
"""

filename:/usr/lib/python2.7/dist-packages/service_identity/__init__.py
__doc__
"""
Verify service identities.
"""

filename:/usr/lib/python2.7/dist-packages/service_identity/_compat.py
__doc__
"""
Avoid depending on any particular Python 3 compatibility approach.
"""

filename:/usr/lib/python2.7/dist-packages/service_identity/_common.py
__doc__
"""
Common verification code.
"""

filename:/usr/lib/python2.7/dist-packages/service_identity/exceptions.py
__doc__
"""
All exceptions and warnings thrown by ``service_identity``.

Separated into an own package for nicer tracebacks, you should still import
them from __init__.py.
"""

filename:/usr/lib/python2.7/dist-packages/xdg/Mime.py
__doc__
"""
This module is based on a rox module (LGPL):

http://cvs.sourceforge.net/viewcvs.py/rox/ROX-Lib2/python/rox/mime.py?rev=1.21&view=log

This module provides access to the shared MIME database.

types is a dictionary of all known MIME types, indexed by the type name, e.g.
types['application/x-python']

Applications can install information about MIME types by storing an
XML file as <MIME>/packages/<application>.xml and running the
update-mime-database command, which is provided by the freedesktop.org
shared mime database package.

See http://www.freedesktop.org/standards/shared-mime-info-spec/ for
information about the format of these files.

(based on version 0.13)
"""

filename:/usr/lib/python2.7/dist-packages/xdg/IniFile.py
__doc__
"""
Base Class for DesktopEntry, IconTheme and IconData
"""

filename:/usr/lib/python2.7/dist-packages/xdg/IconTheme.py
__doc__
"""
Complete implementation of the XDG Icon Spec Version 0.8
http://standards.freedesktop.org/icon-theme-spec/
"""

filename:/usr/lib/python2.7/dist-packages/xdg/MenuEditor.py
__doc__
""" CLass to edit XDG Menus """

from xdg.Menu import *
from xdg.BaseDirectory import *
from xdg.Exceptions import *
from xdg.DesktopEntry import *
from xdg.Config import *

import xml.dom.minidom
import os
import re

# XML-Cleanups: Move / Exclude
# FIXME: proper reverte/delete
# FIXME: pass AppDirs/DirectoryDirs around in the edit/move functions
# FIXME: catch Exceptions
# FIXME: copy functions
# FIXME: More Layout stuff
# FIXME: unod/redo function / remove menu...
# FIXME: Advanced MenuEditing Stuff: LegacyDir/MergeFile
#        Complex Rules/Deleted/OnlyAllocated/AppDirs/DirectoryDirs

class MenuEditor:
    def __init__(self, menu=None, filename=None, root=False):
        self.menu = None
        self.filename = None
        self.doc = None
        self.parse(menu, filename, root)

        # fix for creating two menus with the same name on the fly
        self.filenames = []

    def parse(self, menu=None, filename=None, root=False):
        if root == True:
            setRootMode(True)

        if isinstance(menu, Menu):
            self.menu = menu
        elif menu:
            self.menu = parse(menu)
        else:
            self.menu = parse()

        if root == True:
            self.filename = self.menu.Filename
        elif filename:
            self.filename = filename
        else:
            self.filename = os.path.join(xdg_config_dirs[0], "menus", os.path.split(self.menu.Filename)[1])

        try:
            self.doc = xml.dom.minidom.parse(self.filename)
        except IOError:
            self.doc = xml.dom.minidom.parseString('<!DOCTYPE Menu PUBLIC "-//freedesktop//DTD Menu 1.0//EN" "http://standards.freedesktop.org/menu-spec/menu-1.0.dtd"><Menu><Name>Applications</Name><MergeFile type="parent">'+self.menu.Filename+'</MergeFile></Menu>')
        except xml.parsers.expat.ExpatError:
            raise ParsingError('Not a valid .menu file', self.filename)

        self.__remove_whilespace_nodes(self.doc)

    def save(self):
        self.__saveEntries(self.menu)
        self.__saveMenu()

    def createMenuEntry(self, parent, name, command=None, genericname=None, comment=None, icon=None, terminal=None, after=None, before=None):
        menuentry = MenuEntry(self.__getFileName(name, ".desktop"))
        menuentry = self.editMenuEntry(menuentry, name, genericname, comment, command, icon, terminal)

        self.__addEntry(parent, menuentry, after, before)

        sort(self.menu)

        return menuentry

    def createMenu(self, parent, name, genericname=None, comment=None, icon=None, after=None, before=None):
        menu = Menu()

        menu.Parent = parent
        menu.Depth = parent.Depth + 1
        menu.Layout = parent.DefaultLayout
        menu.DefaultLayout = parent.DefaultLayout

        menu = self.editMenu(menu, name, genericname, comment, icon)

        self.__addEntry(parent, menu, after, before)

        sort(self.menu)

        return menu

    def createSeparator(self, parent, after=None, before=None):
        separator = Separator(parent)

        self.__addEntry(parent, separator, after, before)

        sort(self.menu)

        return separator

    def moveMenuEntry(self, menuentry, oldparent, newparent, after=None, before=None):
        self.__deleteEntry(oldparent, menuentry, after, before)
        self.__addEntry(newparent, menuentry, after, before)

        sort(self.menu)

        return menuentry

    def moveMenu(self, menu, oldparent, newparent, after=None, before=None):
        self.__deleteEntry(oldparent, menu, after, before)
        self.__addEntry(newparent, menu, after, before)

        root_menu = self.__getXmlMenu(self.menu.Name)
        if oldparent.getPath(True) != newparent.getPath(True):
            self.__addXmlMove(root_menu, os.path.join(oldparent.getPath(True), menu.Name), os.path.join(newparent.getPath(True), menu.Name))

        sort(self.menu)

        return menu

    def moveSeparator(self, separator, parent, after=None, before=None):
        self.__deleteEntry(parent, separator, after, before)
        self.__addEntry(parent, separator, after, before)

        sort(self.menu)

        return separator

    def copyMenuEntry(self, menuentry, oldparent, newparent, after=None, before=None):
        self.__addEntry(newparent, menuentry, after, before)

        sort(self.menu)

        return menuentry

    def editMenuEntry(self, menuentry, name=None, genericname=None, comment=None, command=None, icon=None, terminal=None, nodisplay=None, hidden=None):
        deskentry = menuentry.DesktopEntry

        if name:
            if not deskentry.hasKey("Name"):
                deskentry.set("Name", name)
            deskentry.set("Name", name, locale = True)
        if comment:
            if not deskentry.hasKey("Comment"):
                deskentry.set("Comment", comment)
            deskentry.set("Comment", comment, locale = True)
        if genericname:
            if not deskentry.hasKey("GnericNe"):
                deskentry.set("GenericName", genericname)
            deskentry.set("GenericName", genericname, locale = True)
        if command:
            deskentry.set("Exec", command)
        if icon:
            deskentry.set("Icon", icon)

        if terminal == True:
            deskentry.set("Terminal", "true")
        elif terminal == False:
            deskentry.set("Terminal", "false")

        if nodisplay == True:
            deskentry.set("NoDisplay", "true")
        elif nodisplay == False:
            deskentry.set("NoDisplay", "false")

        if hidden == True:
            deskentry.set("Hidden", "true")
        elif hidden == False:
            deskentry.set("Hidden", "false")

        menuentry.updateAttributes()

        if len(menuentry.Parents) > 0:
            sort(self.menu)

        return menuentry

    def editMenu(self, menu, name=None, genericname=None, comment=None, icon=None, nodisplay=None, hidden=None):
        # Hack for legacy dirs
        if isinstance(menu.Directory, MenuEntry) and menu.Directory.Filename == ".directory":
            xml_menu = self.__getXmlMenu(menu.getPath(True, True))
            self.__addXmlTextElement(xml_menu, 'Directory', menu.Name + ".directory")
            menu.Directory.setAttributes(menu.Name + ".directory")
        # Hack for New Entries
        elif not isinstance(menu.Directory, MenuEntry):
            if not name:
                name = menu.Name
            filename = self.__getFileName(name, ".directory").replace("/", "")
            if not menu.Name:
                menu.Name = filename.replace(".directory", "")
            xml_menu = self.__getXmlMenu(menu.getPath(True, True))
            self.__addXmlTextElement(xml_menu, 'Directory', filename)
            menu.Directory = MenuEntry(filename)

        deskentry = menu.Directory.DesktopEntry

        if name:
            if not deskentry.hasKey("Name"):
                deskentry.set("Name", name)
            deskentry.set("Name", name, locale = True)
        if genericname:
            if not deskentry.hasKey("GenericName"):
                deskentry.set("GenericName", genericname)
            deskentry.set("GenericName", genericname, locale = True)
        if comment:
            if not deskentry.hasKey("Comment"):
                deskentry.set("Comment", comment)
            deskentry.set("Comment", comment, locale = True)
        if icon:
            deskentry.set("Icon", icon)

        if nodisplay == True:
            deskentry.set("NoDisplay", "true")
        elif nodisplay == False:
            deskentry.set("NoDisplay", "false")

        if hidden == True:
            deskentry.set("Hidden", "true")
        elif hidden == False:
            deskentry.set("Hidden", "false")

        menu.Directory.updateAttributes()

        if isinstance(menu.Parent, Menu):
            sort(self.menu)

        return menu

    def hideMenuEntry(self, menuentry):
        self.editMenuEntry(menuentry, nodisplay = True)

    def unhideMenuEntry(self, menuentry):
        self.editMenuEntry(menuentry, nodisplay = False, hidden = False)

    def hideMenu(self, menu):
        self.editMenu(menu, nodisplay = True)

    def unhideMenu(self, menu):
        self.editMenu(menu, nodisplay = False, hidden = False)
        xml_menu = self.__getXmlMenu(menu.getPath(True,True), False)
        for node in self.__getXmlNodesByName(["Deleted", "NotDeleted"], xml_menu):
            node.parentNode.removeChild(node)

    def deleteMenuEntry(self, menuentry):
        if self.getAction(menuentry) == "delete":
            self.__deleteFile(menuentry.DesktopEntry.filename)
            for parent in menuentry.Parents:
                self.__deleteEntry(parent, menuentry)
            sort(self.menu)
        return menuentry

    def revertMenuEntry(self, menuentry):
        if self.getAction(menuentry) == "revert":
            self.__deleteFile(menuentry.DesktopEntry.filename)
            menuentry.Original.Parents = []
            for parent in menuentry.Parents:
                index = parent.Entries.index(menuentry)
                parent.Entries[index] = menuentry.Original
                index = parent.MenuEntries.index(menuentry)
                parent.MenuEntries[index] = menuentry.Original
                menuentry.Original.Parents.append(parent)
            sort(self.menu)
        return menuentry

    def deleteMenu(self, menu):
        if self.getAction(menu) == "delete":
            self.__deleteFile(menu.Directory.DesktopEntry.filename)
            self.__deleteEntry(menu.Parent, menu)
            xml_menu = self.__getXmlMenu(menu.getPath(True, True))
            xml_menu.parentNode.removeChild(xml_menu)
            sort(self.menu)
        return menu

    def revertMenu(self, menu):
        if self.getAction(menu) == "revert":
            self.__deleteFile(menu.Directory.DesktopEntry.filename)
            menu.Directory = menu.Directory.Original
            sort(self.menu)
        return menu

    def deleteSeparator(self, separator):
        self.__deleteEntry(separator.Parent, separator, after=True)

        sort(self.menu)

        return separator

    """ Private Stuff """
    def getAction(self, entry):
        if isinstance(entry, Menu):
            if not isinstance(entry.Directory, MenuEntry):
                return "none"
            elif entry.Directory.getType() == "Both":
                return "revert"
            elif entry.Directory.getType() == "User" \
            and (len(entry.Submenus) + len(entry.MenuEntries)) == 0:
                return "delete"

        elif isinstance(entry, MenuEntry):
            if entry.getType() == "Both":
                return "revert"
            elif entry.getType() == "User":
                return "delete"
            else:
                return "none"

        return "none"

    def __saveEntries(self, menu):
        if not menu:
            menu = self.menu
        if isinstance(menu.Directory, MenuEntry):
            menu.Directory.save()
        for entry in menu.getEntries(hidden=True):
            if isinstance(entry, MenuEntry):
                entry.save()
            elif isinstance(entry, Menu):
                self.__saveEntries(entry)

    def __saveMenu(self):
        if not os.path.isdir(os.path.dirname(self.filename)):
            os.makedirs(os.path.dirname(self.filename))
        fd = open(self.filename, 'w')
        fd.write(re.sub("\n[\s]*([^\n<]*)\n[\s]*</", "\\1</", self.doc.toprettyxml().replace('<?xml version="1.0" ?>\n', '')))
        fd.close()

    def __getFileName(self, name, extension):
        postfix = 0
        while 1:
            if postfix == 0:
                filename = name + extension
            else:
                filename = name + "-" + str(postfix) + extension
            if extension == ".desktop":
                dir = "applications"
            elif extension == ".directory":
                dir = "desktop-directories"
            if not filename in self.filenames and not \
                os.path.isfile(os.path.join(xdg_data_dirs[0], dir, filename)):
                self.filenames.append(filename)
                break
            else:
                postfix += 1

        return filename

    def __getXmlMenu(self, path, create=True, element=None):
        if not element:
            element = self.doc

        if "/" in path:
            (name, path) = path.split("/", 1)
        else:
            name = path
            path = ""

        found = None
        for node in self.__getXmlNodesByName("Menu", element):
            for child in self.__getXmlNodesByName("Name", node):
                if child.childNodes[0].nodeValue == name:
                    if path:
                        found = self.__getXmlMenu(path, create, node)
                    else:
                        found = node
                    break
            if found:
                break
        if not found and create == True:
            node = self.__addXmlMenuElement(element, name)
            if path:
                found = self.__getXmlMenu(path, create, node)
            else:
                found = node

        return found

    def __addXmlMenuElement(self, element, name):
        node = self.doc.createElement('Menu')
        self.__addXmlTextElement(node, 'Name', name)
        return element.appendChild(node)

    def __addXmlTextElement(self, element, name, text):
        node = self.doc.createElement(name)
        text = self.doc.createTextNode(text)
        node.appendChild(text)
        return element.appendChild(node)

    def __addXmlFilename(self, element, filename, type = "Include"):
        # remove old filenames
        for node in self.__getXmlNodesByName(["Include", "Exclude"], element):
            if node.childNodes[0].nodeName == "Filename" and node.childNodes[0].childNodes[0].nodeValue == filename:
                element.removeChild(node)

        # add new filename
        node = self.doc.createElement(type)
        node.appendChild(self.__addXmlTextElement(node, 'Filename', filename))
        return element.appendChild(node)

    def __addXmlMove(self, element, old, new):
        node = self.doc.createElement("Move")
        node.appendChild(self.__addXmlTextElement(node, 'Old', old))
        node.appendChild(self.__addXmlTextElement(node, 'New', new))
        return element.appendChild(node)

    def __addXmlLayout(self, element, layout):
        # remove old layout
        for node in self.__getXmlNodesByName("Layout", element):
            element.removeChild(node)

        # add new layout
        node = self.doc.createElement("Layout")
        for order in layout.order:
            if order[0] == "Separator":
                child = self.doc.createElement("Separator")
                node.appendChild(child)
            elif order[0] == "Filename":
                child = self.__addXmlTextElement(node, "Filename", order[1])
            elif order[0] == "Menuname":
                child = self.__addXmlTextElement(node, "Menuname", order[1])
            elif order[0] == "Merge":
                child = self.doc.createElement("Merge")
                child.setAttribute("type", order[1])
                node.appendChild(child)
        return element.appendChild(node)

    def __getXmlNodesByName(self, name, element):
        for child in element.childNodes:
            if child.nodeType == xml.dom.Node.ELEMENT_NODE and child.nodeName in name:
                yield child

    def __addLayout(self, parent):
        layout = Layout()
        layout.order = []
        layout.show_empty = parent.Layout.show_empty
        layout.inline = parent.Layout.inline
        layout.inline_header = parent.Layout.inline_header
        layout.inline_alias = parent.Layout.inline_alias
        layout.inline_limit = parent.Layout.inline_limit

        layout.order.append(["Merge", "menus"])
        for entry in parent.Entries:
            if isinstance(entry, Menu):
                layout.parseMenuname(entry.Name)
            elif isinstance(entry, MenuEntry):
                layout.parseFilename(entry.DesktopFileID)
            elif isinstance(entry, Separator):
                layout.parseSeparator()
        layout.order.append(["Merge", "files"])

        parent.Layout = layout

        return layout

    def __addEntry(self, parent, entry, after=None, before=None):
        if after or before:
            if after:
                index = parent.Entries.index(after) + 1
            elif before:
                index = parent.Entries.index(before)
            parent.Entries.insert(index, entry)
        else:
            parent.Entries.append(entry)

        xml_parent = self.__getXmlMenu(parent.getPath(True, True))

        if isinstance(entry, MenuEntry):
            parent.MenuEntries.append(entry)
            entry.Parents.append(parent)
            self.__addXmlFilename(xml_parent, entry.DesktopFileID, "Include")
        elif isinstance(entry, Menu):
            parent.addSubmenu(entry)

        if after or before:
            self.__addLayout(parent)
            self.__addXmlLayout(xml_parent, parent.Layout)

    def __deleteEntry(self, parent, entry, after=None, before=None):
        parent.Entries.remove(entry)

        xml_parent = self.__getXmlMenu(parent.getPath(True, True))

        if isinstance(entry, MenuEntry):
            entry.Parents.remove(parent)
            parent.MenuEntries.remove(entry)
            self.__addXmlFilename(xml_parent, entry.DesktopFileID, "Exclude")
        elif isinstance(entry, Menu):
            parent.Submenus.remove(entry)

        if after or before:
            self.__addLayout(parent)
            self.__addXmlLayout(xml_parent, parent.Layout)

    def __deleteFile(self, filename):
        try:
            os.remove(filename)
        except OSError:
            pass
        try:
            self.filenames.remove(filename)
        except ValueError:
            pass

    def __remove_whilespace_nodes(self, node):
        remove_list = []
        for child in node.childNodes:
            if child.nodeType == xml.dom.minidom.Node.TEXT_NODE:
                child.data = child.data.strip()
                if not child.data.strip():
                    remove_list.append(child)
            elif child.hasChildNodes():
                self.__remove_whilespace_nodes(child)
        for node in remove_list:
            node.parentNode.removeChild(node)

filename:/usr/lib/python2.7/dist-packages/xdg/IniFile.pyc
__doc__
Û
‚ËRc           @   s≤   d  Z  d d l Z d d l Z d d l Z d d l Z d d l m Z m Z m Z m	 Z	 m
 Z
 m Z m Z d d l Z d d l m Z d d l Z d Ñ  Z d d d Ñ  É  YZ d S(	   s5   
Base Class for DesktopEntry, IconTheme and IconData
iˇˇˇˇN(   t   ParsingErrort   DuplicateGroupErrort   NoGroupErrort
   NoKeyErrort   DuplicateKeyErrort   ValidationErrort   debug(   t   uc         C   s1   y |  j  d d É t SWn t k
 r, t SXd S(   s>   Return True if a string consists entirely of ASCII characters.t   asciit   strictN(   t   encodet   Truet   UnicodeErrort   False(   t   s(    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyt   is_ascii   s
    t   IniFilec           B   sL  e  Z d  Z d  Z d  Z d Z e Z d d Ñ Z	 d Ñ  Z
 d d Ñ Z d e d e d Ñ Z d Ñ  Z d Ñ  Z d d Ñ Z d	 d
 Ñ Z d Ñ  Z d Ñ  Z d e d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d e d Ñ Z d e d Ñ Z d Ñ  Z d Ñ  Z d e d Ñ Z  d Ñ  Z! d Ñ  Z" d d Ñ Z# d Ñ  Z$ RS(   t    c         C   s&   t  É  |  _ | r" |  j | É n  d  S(   N(   t   dictt   contentt   parse(   t   selft   filename(    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyt   __init__   s    c         C   s   t  |  j | j É S(   N(   t   cmpR   (   R   t   other(    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyt   __cmp__#   s    c         C   sp  |  j  } t j j | É s- t d | É Ç n  y" t j | d d d d d É} Wn& t k
 rw } t rp | Ç qx d Sn XxU| D]M} | j	 É  } | sù q q | d d	 k r≥ q q | d d
 k r| j
 d
 É j d É } t r|  j | É rt | | É Ç qÃi  | | <q y | j d d É \ } }	 Wn$ t k
 rQt d | | É Ç n X| j	 É  } yE t ré|  j | | É rét | | | É Ç n |	 j	 É  | | | <Wq t t f k
 rÀt d | É Ç q Xq W| j É  | |  _ t |  _ | r6xA | D] }
 |
 | k r˘|
 |  _ Pq˘q˘Wt d | d | É Ç n  |  j  j d i  É } | j d | j d d É É |  _ d S(   sy   Parse an INI file.
        
        headers -- list of headers the parser will try to select as a default header
        s   File not foundt   rt   encodings   utf-8t   errorst   replaceNi    t   #t   [t   ]t   =i   s   Invalid line: s#   Parsing error on key, group missings   [%s]-Header missings   Desktop Entrys   X-GNOME-Gettext-Domains   X-Ubuntu-Gettext-Domain(   R   t   ost   patht   isfileR    t   iot   opent   IOErrorR   t   stript   lstript   rstript   hasGroupR   t   splitt
   ValueErrort   hasKeyR   t
   IndexErrort   UnboundLocalErrort   closeR   R   t   taintedt   defaultGroupt   gett   Nonet   gettext_domain(   R   R   t   headersR   t   fdt   et   linet   currentGroupt   keyt   valuet   header(    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyR   &   sV    	"	
				t   stringc         C   s\  | s |  j  } n  | |  j k r∞ | |  j | k r∞ | rú |  j | | É } | j d É se |  j ry |  j | | } q≠ t j |  j |  j | | É } q|  j | | } n^ t r| |  j k r⁄ t | |  j	 É Ç q| |  j | k rt
 | | |  j	 É Ç qn d } | t k r2|  j | É } g  } n	 | g } x| D]} | d k rf|  j | É } nÃ | d k rüy t | É } Wq2t k
 rõd } q2Xnì | d k rÿy t | É } Wq2t k
 r‘d } q2XnZ | d k rˆt j | É } n< | d	 k r2| j d
 É \ }	 }
 t |	 É t |
 É f } n  | t k rN| j | É qB| } qBW| S(   NR!   R   t   booleant   integeri    t   numericg        t   regext   pointt   ,(   R4   R   t   _IniFile__addLocalet   endswithR7   t   gettextt   dgettextR   R   R   R   R   t   getListt   _IniFile__getBooleant   intR.   t   floatt   ret   compileR-   t   append(   R   R=   t   groupt   localet   typet   listR>   t   valuest   resultt   xt   y(    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyR5   p   sR    "#		
c         C   sü   t  j d | É r' t  j d | É } nW t  j d | É rN t  j d | É } n0 t  j d | É ru t  j d | É } n	 | g } | d d k rõ | j É  n  | S(   Ns	   (?<!\\)\;s   (?<!\\);s	   (?<!\\)\|s   (?<!\\),iˇˇˇˇR   (   RO   t   searchR-   t   pop(   R   R@   RU   (    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyRK   ´   s    	c         C   sT   | d k s$ | d k s$ | d k r( t  S| d k sL | d k sL | d k rP t St S(   Ni   t   trueR   i    t   falseR   (   R   R   (   R   RA   (    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyt   __getBoolean∏   s
    $$c         C   sT   | s |  j  } n  x; t j j D]- } d | | f } | |  j | k r | Sq W| S(   s3   add locale to key according the current lc_messagess   %s[%s](   R4   t   xdgt   Localet   langsR   (   R   R=   RR   t   langt   langkey(    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyt   __addLocale¿   s    t   Allc         C   s\  g  |  _  g  |  _ t j j |  j É d |  _ |  j É  xÇ |  j D]w } |  j	 | É xa |  j | D]R } |  j
 | |  j | | | É |  j | | d k rc |  j  j d | É qc qc WqB Wd } | d k s€ | d k r x" |  j  D] } | d | 7} qÂ Wn  | d k s| d k r=x" |  j D] } | d | 7} q"Wn  | rXt | |  j É Ç n  d S(	   sú   Validate the contents, raising ``ValidationError`` if there
        is anything amiss.
        
        report can be 'All' / 'Warnings' / 'Errors'
        i   R   s   Value of Key '%s' is emptyRe   t   Warningss   
- t   ErrorsN(   t   warningsR   R#   R$   t   splitextR   t   fileExtensiont   checkExtrasR   t
   checkGroupt   checkKeyRQ   R   (   R   t   reportRR   R=   t   msgR;   (    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyt   validateŒ   s&    		
c         C   s   d  S(   N(    (   R   RR   (    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyRl   ˆ   s    c         C   s   d  S(   N(    (   R   R=   R>   RR   (    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyRm   ˙   s    c         C   sN  | t  k r |  j | É } n	 | g } x | D]} | d k rR |  j | É } n  | d k rd q. nñ | d k rÇ |  j | É } nx | d k r† |  j | É } nZ | d k ræ |  j | É } n< | d k r‹ |  j | É } n | d k r˙ |  j | É } n  | d k r#|  j j	 d	 | | f É q. | d
 k r. |  j
 j	 d | É q. q. Wd  S(   NR@   t   localestringRA   RC   RB   RD   RE   i   s   '%s' is not a valid %si   s   Value of key '%s' is deprecated(   R   RK   t   checkStringt   checkBooleant   checkNumbert   checkIntegert
   checkRegext
   checkPointR   RQ   Rh   (   R   R=   R>   RT   RU   RV   t   code(    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyt
   checkValue˛   s,    	c         C   s   d  S(   N(    (   R   (    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyRk     s    c         C   s<   | d k s | d k r d S| d k p1 | d k s8 d Sd  S(   Nt   1t   0i   R\   R]   i   (    (   R   R>   (    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyRs     s    c         C   s   y t  | É Wn d SXd  S(   Ni   (   RN   (   R   R>   (    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyRt   #  s    c         C   s   y t  | É Wn d SXd  S(   Ni   (   RM   (   R   R>   (    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyRu   *  s    c         C   s   t  j d | É s d Sd  S(   Ns   ^[0-9]+,[0-9]+$i   (   RO   t   match(   R   R>   (    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyRw   1  s    c         C   s   t  | É r d Sd S(   Ni    i   (   R   (   R   R>   (    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyRr   5  s    c         C   s    y t  j | É Wn d SXd  S(   Ni   (   RO   RP   (   R   R>   (    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyRv   8  s    c   
   
   C   s.  | r# |  j  r# t d d É Ç n  | r5 | |  _  n	 |  j  } t j j | É rã t j j t j j | É É rã t j t j j | É É n  t j | d d d Éè6} | r¬ | j	 t
 d É É n  |  j r?| j	 t
 d É |  j É xA |  j |  j j É  D]) \ } } | j	 t
 d É | | f É q¸ W| j	 t
 d	 É É n  xì |  j j É  D]Ç \ } } | |  j k rO| j	 t
 d É | É x7 | j É  D]) \ } } | j	 t
 d É | | f É qéW| j	 t
 d	 É É qOqOWWd  QX| r!t j | É j } | t j Bt j Bt j B}	 t j | |	 É n  t |  _ d  S(
   Ns   File not foundR   t   wR   s   utf-8s   #!/usr/bin/env xdg-open
s   [%s]
s   %s=%s
s   
(   R   R    R#   R$   t   dirnamet   isdirt   makedirsR&   R'   t   writeR   R4   R   t   itemst   statt   st_modet   S_IXUSRt   S_IXGRPt   S_IXOTHt   chmodR   R3   (
   R   R   t   trustedt   fpR=   R>   t   nameRR   t   oldmodet   mode(    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyRÅ   ?  s4    	1	#!! c         C   sØ   | s |  j  } n  | t k rU t t j j É d k rU | d t j j d d } n  y | |  j | | <Wn# t k
 rè t | |  j	 É Ç n X| |  j
 | | É k |  _ d  S(   Ni    R    R!   (   R4   R   t   lenR_   R`   Ra   R   t   KeyErrorR   R   R5   R3   (   R   R=   R>   RR   RS   (    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyt   seth  s    $c         C   sG   |  j  | É r- t rC t | |  j É Ç qC n i  |  j | <t |  _ d  S(   N(   R,   R   R   R   R   R   R3   (   R   RR   (    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyt   addGroupw  s
    c         C   sJ   | |  j  k } | r+ |  j  | =t |  _ n t rF t | |  j É Ç n  | S(   N(   R   R   R3   R   R   R   (   R   RR   t   existed(    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyt   removeGroup  s    
c         C   s˛   | s |  j  } n  yè | r} x_ t |  j | É D]G } t j d | t j j d | É r/ | | k r/ |  j | | =q/ q/ Wn  |  j | j | É } t	 |  _
 | SWnV t k
 r˘ } t rÚ | | k r⁄ t | |  j É Ç qˆ t | | |  j É Ç q˙ d Sn Xd  S(   Nt   ^t   $R   (   R4   RU   R   RO   R|   R_   R`   RD   R[   R   R3   Rè   R   R   R   R   (   R   R=   RR   t   localesRã   R>   R:   (    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyt	   removeKeyâ  s     0	c         C   s   |  j  j É  S(   N(   R   t   keys(   R   (    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyt   groups†  s    c         C   s   | |  j  k S(   N(   R   (   R   RR   (    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyR,   £  s    c         C   s#   | s |  j  } n  | |  j | k S(   N(   R4   R   (   R   R=   RR   (    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyR/   ¶  s    c         C   s   |  j  S(   N(   R   (   R   (    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyt   getFileName≠  s    N(%   t   __name__t
   __module__R4   Rj   R   R6   R7   R   R3   R   R   R   R5   RK   RL   RG   Rp   Rl   Rm   Ry   Rk   Rs   Rt   Ru   Rw   Rr   Rv   RÅ   Rê   Rë   Rì   R   Ró   Rô   R,   R/   Rö   (    (    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyR      s@   	J;		(									)		
		(    (   t   __doc__RO   R#   RÉ   R&   t   xdg.ExceptionsR    R   R   R   R   R   R   t
   xdg.LocaleR_   t   xdg.utilR   RI   R   R   (    (    (    s/   /usr/lib/python2.7/dist-packages/xdg/IniFile.pyt   <module>   s   04	
filename:/usr/lib/python2.7/dist-packages/xdg/Config.py
__doc__
"""

filename:/usr/lib/python2.7/dist-packages/xdg/DesktopEntry.py
__doc__
"""
Complete implementation of the XDG Desktop Entry Specification Version 1.0
http://standards.freedesktop.org/desktop-entry-spec/

Not supported:
- Encoding: Legacy Mixed
- Does not check exec parameters
- Does not check URL's
- Does not completly validate deprecated/kde items
- Does not completly check categories
"""

filename:/usr/lib/python2.7/dist-packages/xdg/Locale.py
__doc__
"""
Helper Module for Locale settings

This module is based on a ROX module (LGPL):

http://cvs.sourceforge.net/viewcvs.py/rox/ROX-Lib2/python/rox/i18n.py?rev=1.3&view=log
"""

filename:/usr/lib/python2.7/dist-packages/xdg/RecentFiles.py
__doc__
"""
Implementation of the XDG Recent File Storage Specification Version 0.2
http://standards.freedesktop.org/recent-file-spec
"""

filename:/usr/lib/python2.7/dist-packages/xdg/Menu.py
__doc__
"""
Implementation of the XDG Menu Specification Version 1.0.draft-1
http://standards.freedesktop.org/menu-spec/

Example code:

from xdg.Menu import parse, Menu, MenuEntry

def print_menu(menu, tab=0):
  for submenu in menu.Entries:
    if isinstance(submenu, Menu):
      print ("\t" * tab) + unicode(submenu)
      print_menu(submenu, tab+1)
    elif isinstance(submenu, MenuEntry):
      print ("\t" * tab) + unicode(submenu.DesktopEntry)

print_menu(parse())
"""

filename:/usr/lib/python2.7/dist-packages/xdg/BaseDirectory.py
__doc__
"""
This module is based on a rox module (LGPL):

http://cvs.sourceforge.net/viewcvs.py/rox/ROX-Lib2/python/rox/basedir.py?rev=1.9&view=log

The freedesktop.org Base Directory specification provides a way for
applications to locate shared data and configuration:

    http://standards.freedesktop.org/basedir-spec/

(based on version 0.6)

This module can be used to load and save from and to these directories.

Typical usage:

    from rox import basedir
    
    for dir in basedir.load_config_paths('mydomain.org', 'MyProg', 'Options'):
        print "Load settings from", dir

    dir = basedir.save_config_path('mydomain.org', 'MyProg')
    print >>file(os.path.join(dir, 'Options'), 'w'), "foo=2"

Note: see the rox.Options module for a higher-level API for managing options.
"""

filename:/usr/lib/python2.7/dist-packages/xdg/Exceptions.py
__doc__
"""
Exception Classes for the xdg package
"""

filename:/usr/lib/python2.7/dist-packages/twisted/protocols/gps/__init__.py
__doc__
"""Global Positioning System protocols."""

filename:/usr/lib/python2.7/dist-packages/twisted/protocols/gps/nmea.pyc
__doc__
Û
qóÁVc           @   s®   d  Z  d d l Z d d l m Z d d l m Z d \ Z Z Z Z	 d \ Z
 Z d \ Z Z Z d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e j f d Ñ  É  YZ d S(   s∫  
NMEA 0183 implementation

Maintainer: Bob Ippolito

The following NMEA 0183 sentences are currently understood::
    GPGGA (fix)
    GPGLL (position)
    GPRMC (position and time)
    GPGSA (active satellites)
 
The following NMEA 0183 sentences require implementation::
    None really, the others aren't generally useful or implemented in most devices anyhow

Other desired features::
    - A NMEA 0183 producer to emulate GPS devices (?)
iˇˇˇˇN(   t   reduce(   t   basici    i   i   i   t   At   Mt   InvalidSentencec           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s>   /usr/lib/python2.7/dist-packages/twisted/protocols/gps/nmea.pyR       s   t   InvalidChecksumc           B   s   e  Z RS(    (   R   R   (    (    (    s>   /usr/lib/python2.7/dist-packages/twisted/protocols/gps/nmea.pyR   #   s   t   NMEAReceiverc           B   sæ   e  Z d  Z d Z i d d 6d d 6d d 6d d	 6d
 d 6d d 6d d 6d d 6d d 6d d 6d d 6Z d Z d Z d Z d Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d  Ñ  Z RS(!   sj   
    This parses most common NMEA-0183 messages, presumably from a serial GPS
    device at 4800 bps.
    s   
t   fixt   GPGGAt   positiont   GPGLLt   activesatellitest   GPGSAt   positiontimet   GPRMCt   viewsatellitest   GPGSVt   courset   GPVTGt   almanact   GPALMt   ranget   GPGRSt   noiset   GPGSTt   beacont   GPMSSt   timet   GPZDAi   i    c         C   sï  | j  d É s2 |  j r d  St d | f É Ç n  | d j É  j d É \ } } | j d É } | d | d } } |  j j | d  É } | r± |  j r± t d | f É Ç n  |  j	 st
 | d É } t t j t t | É É } | | k rt d	 | | f É Ç qn  t |  d
 | d  É } t |  d | d  É }	 | oG| oG|	 sNd  Sy |	 | å  }
 Wn* t k
 rät d | | | f É Ç n X| |
 å  S(   Nt   $s   %r does not begin with $i   t   *t   ,i    s   sentencetype %ri   s   Given 0x%02X != 0x%02Xs	   handle_%ss	   decode_%ss"   %r is not a valid %s (%s) sentence(   t
   startswitht   ignore_invalid_sentenceR   t   stript   splitt   dispatcht   gett   Nonet   ignore_unknown_sentencetypest   ignore_checksum_mismatcht   intR    t   operatort   xort   mapt   ordR   t   getattrt	   Exception(   t   selft   linet
   strmessaget   checksumt   messaget   sentencetypeR&   t   calculated_checksumt   handlert   decodert   decoded(    (    s>   /usr/lib/python2.7/dist-packages/twisted/protocols/gps/nmea.pyt   lineReceivedB   s4    			c         C   sX   |  j  | | | | É \ } } |  j | É } | d k rB d } n d } | | | | f S(   NR   i   i    (   t   _decode_latlont   _decode_utc(   R2   t   latitudet   nst	   longitudet   ewt   utct   status(    (    s>   /usr/lib/python2.7/dist-packages/twisted/protocols/gps/nmea.pyt   decode_positionb   s    	c         C   s4  |  j  | É } |  j | | | | É \ } } | d k rH t | É } n d  } | d k ri t | É } n d  } d t |	 d d !É t |	 d d !É t |	 d d !É f }	 |  j r‰ |	 d d k r‰ |	 d d |	 d	 |	 d f }	 n  |
 d k rˇ t |
 É }
 n  | d
 k r|
 }
 n d  }
 | | | | | |	 |
 f S(   Nt    i–  i   i   i   i    i  id   i   t   W(   R>   R=   t   floatR(   R+   t   convert_dates_before_y2k(   R2   RC   RD   R?   R@   RA   RB   t   speedR   t   utcdatet   magvart   magdir(    (    s>   /usr/lib/python2.7/dist-packages/twisted/protocols/gps/nmea.pyt   decode_positiontimep   s.    :"
c         C   sD   t  t | d  | d d !| d f É \ } } } | d | d | S(   Ni   i   g      ¨@g      N@(   R.   RH   (   R2   RC   t   utc_hht   utc_mmt   utc_ss(    (    s>   /usr/lib/python2.7/dist-packages/twisted/protocols/gps/nmea.pyR>   î   s    0c         C   sz   t  | d  É t  | d É d } | d k r8 | } n  t  | d  É t  | d É d } | d k rp | } n  | | f S(   Ni   g      N@t   Si   RG   (   RH   (   R2   R?   R@   RA   RB   (    (    s>   /usr/lib/python2.7/dist-packages/twisted/protocols/gps/nmea.pyR=   ò   s    "
"
c         G   sí   | d  t  t | d É } \ } } } g  } x7 | D]/ }	 |	 rV | j t |	 É É q4 | j d  É q4 W| t | É f }
 t | É |
 | | | f S(   Ni   (   R.   RH   t   appendR+   R(   t   tuple(   R2   t   mode1t   mode2t   argst
   satellitest   pdopt   hdopt   vdopt   satlistt   nt   mode(    (    s>   /usr/lib/python2.7/dist-packages/twisted/protocols/gps/nmea.pyt   decode_activesatellites°   s    '	c      	   C   s–   |  j  | | | | É \ } } |  j | É } t | É } t | É } t | É } t |	 É |
 f }	 | d k rÑ t | É | f } n d  } | d k r´ t | É | f } n d  } | | | | | | |	 | | f	 S(   NRF   (   R=   R>   R+   RH   R(   (   R2   RC   R?   R@   RA   RB   t   posfixRX   RZ   t   altitudet   altitude_unitst   geoid_separationt   geoid_separation_unitst   dgps_aget   dgps_station_idt   geoidt   dgps(    (    s>   /usr/lib/python2.7/dist-packages/twisted/protocols/gps/nmea.pyt
   decode_fix∑   s*    (   R   R   t   __doc__t	   delimiterR&   R#   R*   R)   RI   R<   RE   RN   R>   R=   R_   Ri   (    (    (    s>   /usr/lib/python2.7/dist-packages/twisted/protocols/gps/nmea.pyR   &   s2   
	 		$				(   i    i   i   i   (   R   R   (   i   i   i   (   Rj   R,   t	   functoolsR    t   twisted.protocolsR   t   POSFIX_INVALIDt
   POSFIX_SPSt   POSFIX_DGPSt
   POSFIX_PPSt	   MODE_AUTOt   MODE_FORCEDt
   MODE_NOFIXt   MODE_2Dt   MODE_3DR1   R   R   t   LineReceiverR   (    (    (    s>   /usr/lib/python2.7/dist-packages/twisted/protocols/gps/nmea.pyt   <module>   s   
filename:/usr/lib/python2.7/dist-packages/twisted/protocols/gps/rockwell.py
__doc__
# Copyright (c) Twisted Matrix Laboratories.
# See LICENSE for details.
 

"""

filename:/usr/lib/python2.7/dist-packages/twisted/protocols/mice/__init__.py
__doc__
"""Mice Protocols."""

filename:/usr/lib/python2.7/dist-packages/twisted/protocols/mice/mouseman.pyc
__doc__
Û
qóÁVc           @   s3   d  Z  d d l m Z d e j f d Ñ  É  YZ d S(   sT   Logictech MouseMan serial protocol.

http://www.softnco.demon.co.uk/SerialMouse.txt
iˇˇˇˇ(   t   protocolt   MouseManc           B   s—   e  Z d  Z d Z d Z d Z d Z d Z d Z	 d Z
 d Z d Z d Z d Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Z d Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sl   

    Parser for Logitech MouseMan serial mouse protocol (compatible
    with Microsoft Serial Mouse).

    t   initialc         C   s   d  S(   N(    (   t   self(    (    sC   /usr/lib/python2.7/dist-packages/twisted/protocols/mice/mouseman.pyt	   down_left#   s    c         C   s   d  S(   N(    (   R   (    (    sC   /usr/lib/python2.7/dist-packages/twisted/protocols/mice/mouseman.pyt   up_left&   s    c         C   s   d  S(   N(    (   R   (    (    sC   /usr/lib/python2.7/dist-packages/twisted/protocols/mice/mouseman.pyt   down_middle)   s    c         C   s   d  S(   N(    (   R   (    (    sC   /usr/lib/python2.7/dist-packages/twisted/protocols/mice/mouseman.pyt	   up_middle,   s    c         C   s   d  S(   N(    (   R   (    (    sC   /usr/lib/python2.7/dist-packages/twisted/protocols/mice/mouseman.pyt
   down_right/   s    c         C   s   d  S(   N(    (   R   (    (    sC   /usr/lib/python2.7/dist-packages/twisted/protocols/mice/mouseman.pyt   up_right2   s    c         C   s   d  S(   N(    (   R   t   xt   y(    (    sC   /usr/lib/python2.7/dist-packages/twisted/protocols/mice/mouseman.pyt   move5   s    c         C   s9   | d @r1 | |  _  | d @|  _ | d	 @|  _ d Sd Sd  S(
   Ni   i   i   i   t   horizR   i@   i    i   (   t   word1t
   leftbuttont   rightbutton(   R   t   byte(    (    sC   /usr/lib/python2.7/dist-packages/twisted/protocols/mice/mouseman.pyt   state_initial;   s    
	c         C   sZ   | d @r |  j  | É S|  j d @d >| d @B} | d k rI d | } n  | |  _ d Sd  S(	   Ni   i   i   i?   iÄ   i ˇˇˇt   verti@   (   R   R   R   (   R   R   R
   (    (    sC   /usr/lib/python2.7/dist-packages/twisted/protocols/mice/mouseman.pyt   state_horizD   s    
	c         C   sd   | d	 @r |  j  | É S|  j d @d >| d @B} | d k rI d | } n  | |  _ |  j É  d Sd  S(
   Ni   i   i   i   i?   iÄ   i ˇˇˇt   maybemiddlei@   (   R   R   R   t   snapshot(   R   R   R
   (    (    sC   /usr/lib/python2.7/dist-packages/twisted/protocols/mice/mouseman.pyt
   state_vertN   s    
	
c         C   s@   | d @r! |  j  É  |  j | É S| d @|  _ |  j  É  d Sd  S(   Ni   i   i   R   i@   i    (   R   R   t   middlebutton(   R   R   (    (    sC   /usr/lib/python2.7/dist-packages/twisted/protocols/mice/mouseman.pyt   state_maybemiddleZ   s    


c         C   s%  |  j  r) |  j r) |  j É  d |  _ n  |  j  rR |  j rR |  j É  d |  _ n  |  j r{ |  j r{ |  j É  d |  _ n  |  j r§ |  j r§ |  j É  d |  _ n  |  j rÕ |  j	 rÕ |  j
 É  d |  _	 n  |  j rˆ |  j	 rˆ |  j É  d |  _	 n  |  j s|  j r!|  j |  j |  j É n  d  S(   Ni   i    (   R   t   leftoldR   R   R   t	   middleoldR   R   R   t   rightoldR   R	   R   R   R   (   R   (    (    sC   /usr/lib/python2.7/dist-packages/twisted/protocols/mice/mouseman.pyR   c   s(    





c         C   s@   x9 | D]1 } t  | É } t |  d |  j É | É |  _ q Wd  S(   Nt   state_(   t   ordt   getattrt   state(   R   t   datat   cR   (    (    sC   /usr/lib/python2.7/dist-packages/twisted/protocols/mice/mouseman.pyt   dataReceived|   s    N(   t   __name__t
   __module__t   __doc__R    t   NoneR   R   R   R   R   R   R   R   t   horizoldt   vertoldR   R   R   R   R   R	   R   R   R   R   R   R   R#   (    (    (    sC   /usr/lib/python2.7/dist-packages/twisted/protocols/mice/mouseman.pyR      s6   										
				N(   R&   t   twisted.internetR    t   ProtocolR   (    (    (    sC   /usr/lib/python2.7/dist-packages/twisted/protocols/mice/mouseman.pyt   <module>   s   
filename:/usr/lib/python2.7/dist-packages/twisted/protocols/mice/mouseman.py
__doc__
# Copyright (c) Twisted Matrix Laboratories.
# See LICENSE for details.

#
"""Logictech MouseMan serial protocol.

filename:/usr/lib/python2.7/dist-packages/twisted/python/test/__init__.py
__doc__
"""
Unit tests for L{twisted.python}.
"""

filename:/usr/lib/python2.7/dist-packages/twisted/trial/test/sample.py
__doc__
"""This module is used by test_loader to test the Trial test loading
functionality. Do NOT change the number of tests in this module.  Do NOT change
the names the tests in this module.
"""

filename:/usr/lib/python2.7/dist-packages/twisted/conch/insults/__init__.py
__doc__
"""
Insults: a replacement for Curses/S-Lang.

Very basic at the moment."""

from twisted.python import deprecate, versions

deprecate.deprecatedModuleAttribute(
    versions.Version("Twisted", 10, 1, 0),
    "Please use twisted.conch.insults.helper instead.",
    __name__, "colors")

deprecate.deprecatedModuleAttribute(
    versions.Version("Twisted", 10, 1, 0),
    "Please use twisted.conch.insults.insults instead.",
    __name__, "client")

filename:/usr/lib/python2.7/dist-packages/twisted/conch/insults/insults.py
__doc__
# -*- test-case-name: twisted.conch.test.test_insults -*-
# Copyright (c) Twisted Matrix Laboratories.
# See LICENSE for details.

"""

filename:/usr/lib/python2.7/dist-packages/twisted/conch/insults/client.py
__doc__
"""
You don't really want to use this module. Try insults.py instead.
"""

filename:/usr/lib/python2.7/dist-packages/twisted/conch/insults/colors.py
__doc__
"""
You don't really want to use this module. Try helper.py instead.
"""

filename:/usr/lib/python2.7/dist-packages/twisted/test/test_shortcut.py
__doc__
"""Test win32 shortcut script
"""

filename:/usr/lib/python2.7/dist-packages/twisted/test/process_tester.py
__doc__
"""Test program for processes."""

import sys, os

# Twisted is unimportable from this file, so just do the PY3 check manually
if sys.version_info < (3, 0):
    _PY3 = False
else:
    _PY3 = True

test_file_match = "process_test.log.*"
test_file = "process_test.log.%d" % os.getpid()

def main():
    f = open(test_file, 'wb')

    if _PY3:
        stdin = sys.stdin.buffer
        stderr = sys.stderr.buffer
        stdout = sys.stdout.buffer
    else:
        stdin = sys.stdin
        stdout = sys.stdout
        stderr = sys.stderr

    # stage 1
    b = stdin.read(4)
    f.write(b"one: " + b + b"\n")

    # stage 2
    stdout.write(b)
    stdout.flush()
    os.close(sys.stdout.fileno())

    # and a one, and a two, and a...
    b = stdin.read(4)
    f.write(b"two: " + b + b"\n")

    # stage 3
    stderr.write(b)
    stderr.flush()
    os.close(stderr.fileno())

    # stage 4
    b = stdin.read(4)
    f.write(b"three: " + b + b"\n")

    # exit with status code 23
    sys.exit(23)


if __name__ == '__main__':
    main()

filename:/usr/lib/python2.7/dist-packages/twisted/test/stdio_test_producer.py
__doc__
# -*- test-case-name: twisted.test.test_stdio.StandardInputOutputTests.test_producer -*-
# Copyright (c) Twisted Matrix Laboratories.
# See LICENSE for details.

"""

filename:/usr/lib/python2.7/dist-packages/twisted/test/process_reader.py
__doc__
"""Script used by test_process.TestTwoProcesses"""

# run until stdin is closed, then quit

import sys

while 1:
    d = sys.stdin.read()
    if len(d) == 0:
        sys.exit(0)
        


filename:/usr/lib/python2.7/dist-packages/twisted/test/reflect_helper_IE.py
__doc__

# Helper for a test_reflect test

__import__('idonotexist')

filename:/usr/lib/python2.7/dist-packages/twisted/test/raiser.pyx
__doc__
# Copyright (c) Twisted Matrix Laboratories.
# See LICENSE for details.

"""

filename:/usr/lib/python2.7/dist-packages/twisted/test/process_twisted.py
__doc__
"""A process that reads from stdin and out using Twisted."""

from __future__ import division, absolute_import

### Twisted Preamble
# This makes sure that users don't have to set up their environment
# specially in order to run these programs from bin/.
import sys, os
pos = os.path.abspath(sys.argv[0]).find(os.sep+'Twisted')
if pos != -1:
    sys.path.insert(0, os.path.abspath(sys.argv[0])[:pos+8])
sys.path.insert(0, os.curdir)
### end of preamble


from twisted.python import log
from zope.interface import implementer
from twisted.internet import interfaces

log.startLogging(sys.stderr)

from twisted.internet import protocol, reactor, stdio


@implementer(interfaces.IHalfCloseableProtocol)
class Echo(protocol.Protocol):

    def connectionMade(self):
        print("connection made")

    def dataReceived(self, data):
        self.transport.write(data)

    def readConnectionLost(self):
        print("readConnectionLost")
        self.transport.loseConnection()
    def writeConnectionLost(self):
        print("writeConnectionLost")

    def connectionLost(self, reason):
        print("connectionLost", reason)
        reactor.stop()

stdio.StandardIO(Echo())
reactor.run()

filename:/usr/lib/python2.7/dist-packages/twisted/test/ssl_helpers.pyc
__doc__
Û
qóÁVc           @`  s≥   d  Z  d d l m Z m Z d d l m Z d d l m Z d d l m	 Z	 d d l
 m Z e e	 e j d É É j d É j É Z d	 e j f d
 Ñ  É  YZ d d d Ñ  É  YZ d S(   sì   
Helper classes for twisted.test.test_ssl.

They are in a separate module so they will not prevent test_ssl importing if
pyOpenSSL is unavailable.
i    (   t   divisiont   absolute_import(   t   nativeString(   t   ssl(   t   FilePath(   t   SSLs   utf-8s
   server.pemt   ClientTLSContextc           B`  s   e  Z d  Z d Ñ  Z RS(   i   c         C`  s   t  j t  j É S(   N(   R   t   Contextt   TLSv1_METHOD(   t   self(    (    s<   /usr/lib/python2.7/dist-packages/twisted/test/ssl_helpers.pyt
   getContext   s    (   t   __name__t
   __module__t   isClientR
   (    (    (    s<   /usr/lib/python2.7/dist-packages/twisted/test/ssl_helpers.pyR      s   t   ServerTLSContextc           B`  s#   e  Z d  Z e d Ñ Z d Ñ  Z RS(   i    c         C`  s   | |  _  d  S(   N(   t   filename(   R	   R   (    (    s<   /usr/lib/python2.7/dist-packages/twisted/test/ssl_helpers.pyt   __init__   s    c         C`  s6   t  j t  j É } | j |  j É | j |  j É | S(   N(   R   R   R   t   use_certificate_fileR   t   use_privatekey_file(   R	   t   ctx(    (    s<   /usr/lib/python2.7/dist-packages/twisted/test/ssl_helpers.pyR
   !   s    (   R   R   R   t   certPathR   R
   (    (    (    s<   /usr/lib/python2.7/dist-packages/twisted/test/ssl_helpers.pyR      s   N(    (   t   __doc__t
   __future__R    R   t   twisted.python.compatR   t   twisted.internetR   t   twisted.python.filepathR   t   OpenSSLR   t   __file__t   encodet   siblingt   pathR   t   ClientContextFactoryR   R   (    (    (    s<   /usr/lib/python2.7/dist-packages/twisted/test/ssl_helpers.pyt   <module>	   s   
filename:/usr/lib/python2.7/dist-packages/twisted/test/test_text.py
__doc__
# Copyright (c) Twisted Matrix Laboratories.
# See LICENSE for details.

"""

filename:/usr/lib/python2.7/dist-packages/twisted/test/process_cmdline.py
__doc__
"""
Write to stdout the command line args it received, one per line.
"""

filename:/usr/lib/python2.7/dist-packages/twisted/test/process_echoer.py
__doc__
"""Write back all data it receives."""

import sys

data = sys.stdin.read(1)
while data:
    sys.stdout.write(data)
    sys.stdout.flush()
    data = sys.stdin.read(1)
sys.stderr.write("byebye")
sys.stderr.flush()

filename:/usr/lib/python2.7/dist-packages/twisted/test/reflect_helper_ZDE.pyc
__doc__
Û
qóÁVc           @   s   d  d d S(   i   i    N(    (    (    (    sC   /usr/lib/python2.7/dist-packages/twisted/test/reflect_helper_ZDE.pyt   <module>   s    
filename:/usr/lib/python2.7/dist-packages/twisted/test/process_fds.pyc
__doc__
Û
qóÁVc           @  sÂ  d  Z  d d l m Z d d l Z d d l Z d Z e rO e j d d É Z n  e rh e d d e Én  e j	 d d	 É Z
 e rñ e d
 e
 d e Én  e
 d k r≤ e j d É n  e rÀ e d d e Én  e j d d É e j	 d d	 É Z e re d d e Én  e d k r"e j d É n  e r;e d d e Én  e j d	 É e j	 d d	 É Z e rve d e d e Én  e d k ríe j d É n  e r´e d d e Én  e j d d É e r‘e d d e Én  e j d É d S(   sa   Write to a handful of file descriptors, to test the childFDs= argument of
reactor.spawnProcess()
iˇˇˇˇ(   t   print_functionNi    i   t   ws   this is stderrt   filei   s   read(0):t   abcdi   s   os.write(1, righto)t   rightoi   s   read(3):t   efghs   os.close(4)i   s   read(5):t    s   os.write(1, closed)t   closeds   sys.exit(0)(   t   __doc__t
   __future__R    t   ost   syst   debugt   fdopent   stderrt   printt   readR   t   exitt   writeR   t   closet   eof(    (    (    s<   /usr/lib/python2.7/dist-packages/twisted/test/process_fds.pyt   <module>   sD            
filename:/usr/lib/python2.7/dist-packages/twisted/test/test_iosim.pyc
__doc__
Û
qóÁVc           @`  sV   d  Z  d d l m Z m Z d d l m Z d d l m Z d e f d Ñ  É  YZ d S(   s"   
Tests for L{twisted.test.iosim}.
i    (   t   absolute_importt   division(   t   FakeTransport(   t   TestCaset   FakeTransportTestsc           B`  s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   s%   
    Tests for L{FakeTransport}.
    c         C`  sd   t  t É  t É } t  t É  t É } |  j | j t É |  j | j t É |  j | j | j É d S(   se   
        Each L{FakeTransport} receives a serial number that uniquely identifies
        it.
        N(   R   t   objectt   Truet   Falset   assertIsInstancet   serialt   intt   assertNotEqual(   t   selft   at   b(    (    s;   /usr/lib/python2.7/dist-packages/twisted/test/test_iosim.pyt   test_connectionSerial   s
    c         C`  sU   t  t É  t É } | j d É | j d d d g É |  j d j | j É d É d S(   sl   
        L{FakeTransport.writeSequence} will write a sequence of L{bytes} to the
        transport.
        R   R   t   ct   dt    t   abcdN(   R   R   R   t   writet   writeSequencet   assertEqualt   joint   stream(   R   R   (    (    s;   /usr/lib/python2.7/dist-packages/twisted/test/test_iosim.pyt   test_writeSequence   s    (   t   __name__t
   __module__t   __doc__R   R   (    (    (    s;   /usr/lib/python2.7/dist-packages/twisted/test/test_iosim.pyR      s   	N(	   R   t
   __future__R    R   t   twisted.test.iosimR   t   twisted.trial.unittestR   R   (    (    (    s;   /usr/lib/python2.7/dist-packages/twisted/test/test_iosim.pyt   <module>   s   
filename:/usr/lib/python2.7/dist-packages/twisted/test/test_ident.py
__doc__
# Copyright (c) Twisted Matrix Laboratories.
# See LICENSE for details.


"""

filename:/usr/lib/python2.7/dist-packages/twisted/test/process_tty.py
__doc__
"""Test to make sure we can open /dev/tty"""

f = open("/dev/tty", "rb+", buffering=0)
a = f.readline()
f.write(a)
f.close()

filename:/usr/lib/python2.7/dist-packages/twisted/test/test_persisted.py
__doc__

# Copyright (c) Twisted Matrix Laboratories.
# See LICENSE for details.

from __future__ import division, absolute_import

# System Imports
import sys

from twisted.trial import unittest

try:
    import cPickle as pickle
except ImportError:
    import pickle

import io

try:
    from cStringIO import StringIO as _oldStyleCStringIO
except ImportError:
    skipStringIO = "No cStringIO available."
else:
    skipStringIO = None

try:
    import copyreg
except:
    import copy_reg as copyreg

# Twisted Imports
from twisted.persisted import styles, aot, crefutil
from twisted.python.compat import _PY3


class VersionTests(unittest.TestCase):
    def test_nullVersionUpgrade(self):
        global NullVersioned
        class NullVersioned(object):
            def __init__(self):
                self.ok = 0
        pkcl = pickle.dumps(NullVersioned())
        class NullVersioned(styles.Versioned, object):
            persistenceVersion = 1
            def upgradeToVersion1(self):
                self.ok = 1
        mnv = pickle.loads(pkcl)
        styles.doUpgrade()
        assert mnv.ok, "initial upgrade not run!"

    def test_versionUpgrade(self):
        global MyVersioned
        class MyVersioned(styles.Versioned):
            persistenceVersion = 2
            persistenceForgets = ['garbagedata']
            v3 = 0
            v4 = 0

            def __init__(self):
                self.somedata = 'xxx'
                self.garbagedata = lambda q: 'cant persist'

            def upgradeToVersion3(self):
                self.v3 += 1

            def upgradeToVersion4(self):
                self.v4 += 1
        mv = MyVersioned()
        assert not (mv.v3 or mv.v4), "hasn't been upgraded yet"
        pickl = pickle.dumps(mv)
        MyVersioned.persistenceVersion = 4
        obj = pickle.loads(pickl)
        styles.doUpgrade()
        assert obj.v3, "didn't do version 3 upgrade"
        assert obj.v4, "didn't do version 4 upgrade"
        pickl = pickle.dumps(obj)
        obj = pickle.loads(pickl)
        styles.doUpgrade()
        assert obj.v3 == 1, "upgraded unnecessarily"
        assert obj.v4 == 1, "upgraded unnecessarily"
    
    def test_nonIdentityHash(self):
        global ClassWithCustomHash
        class ClassWithCustomHash(styles.Versioned):
            def __init__(self, unique, hash):
                self.unique = unique
                self.hash = hash
            def __hash__(self):
                return self.hash
        
        v1 = ClassWithCustomHash('v1', 0)
        v2 = ClassWithCustomHash('v2', 0)

        pkl = pickle.dumps((v1, v2))
        del v1, v2
        ClassWithCustomHash.persistenceVersion = 1
        ClassWithCustomHash.upgradeToVersion1 = lambda self: setattr(self, 'upgraded', True)
        v1, v2 = pickle.loads(pkl)
        styles.doUpgrade()
        self.assertEqual(v1.unique, 'v1')
        self.assertEqual(v2.unique, 'v2')
        self.assertTrue(v1.upgraded)
        self.assertTrue(v2.upgraded)
    
    def test_upgradeDeserializesObjectsRequiringUpgrade(self):
        global ToyClassA, ToyClassB
        class ToyClassA(styles.Versioned):
            pass
        class ToyClassB(styles.Versioned):
            pass
        x = ToyClassA()
        y = ToyClassB()
        pklA, pklB = pickle.dumps(x), pickle.dumps(y)
        del x, y
        ToyClassA.persistenceVersion = 1
        def upgradeToVersion1(self):
            self.y = pickle.loads(pklB)
            styles.doUpgrade()
        ToyClassA.upgradeToVersion1 = upgradeToVersion1
        ToyClassB.persistenceVersion = 1
        ToyClassB.upgradeToVersion1 = lambda self: setattr(self, 'upgraded', True)

        x = pickle.loads(pklA)
        styles.doUpgrade()
        self.assertTrue(x.y.upgraded)



class VersionedSubClass(styles.Versioned):
    pass



class SecondVersionedSubClass(styles.Versioned):
    pass



class VersionedSubSubClass(VersionedSubClass):
    pass



class VersionedDiamondSubClass(VersionedSubSubClass, SecondVersionedSubClass):
    pass



class AybabtuTests(unittest.TestCase):
    """
    L{styles._aybabtu} gets all of classes in the inheritance hierarchy of its
    argument that are strictly between L{Versioned} and the class itself.
    """

    def test_aybabtuStrictEmpty(self):
        """
        L{styles._aybabtu} of L{Versioned} itself is an empty list.
        """
        self.assertEqual(styles._aybabtu(styles.Versioned), [])


    def test_aybabtuStrictSubclass(self):
        """
        There are no classes I{between} L{VersionedSubClass} and L{Versioned},
        so L{styles._aybabtu} returns an empty list.
        """
        self.assertEqual(styles._aybabtu(VersionedSubClass), [])


    def test_aybabtuSubsubclass(self):
        """
        With a sub-sub-class of L{Versioned}, L{styles._aybabtu} returns a list
        containing the intervening subclass.
        """
        self.assertEqual(styles._aybabtu(VersionedSubSubClass),
                         [VersionedSubClass])


    def test_aybabtuStrict(self):
        """
        For a diamond-shaped inheritance graph, L{styles._aybabtu} returns a
        list containing I{both} intermediate subclasses.
        """
        self.assertEqual(
            styles._aybabtu(VersionedDiamondSubClass),
            [VersionedSubSubClass, VersionedSubClass, SecondVersionedSubClass])



class MyEphemeral(styles.Ephemeral):

    def __init__(self, x):
        self.x = x


class EphemeralTests(unittest.TestCase):

    def test_ephemeral(self):
        o = MyEphemeral(3)
        self.assertEqual(o.__class__, MyEphemeral)
        self.assertEqual(o.x, 3)
        
        pickl = pickle.dumps(o)
        o = pickle.loads(pickl)
        
        self.assertEqual(o.__class__, styles.Ephemeral)
        self.assert_(not hasattr(o, 'x'))


class Pickleable:

    def __init__(self, x):
        self.x = x
    
    def getX(self):
        return self.x



class NotPickleable(object):
    """
    A class that is not pickleable.
    """

    def __reduce__(self):
        """
        Raise an exception instead of pickling.
        """
        raise TypeError("Not serializable.")



class CopyRegistered(object):
    """
    A class that is pickleable only because it is registered with the
    C{copyreg} module.
    """

    def __init__(self):
        """
        Ensure that this object is normally not pickleable.
        """
        self.notPickleable = NotPickleable()



class CopyRegisteredLoaded(object):
    """
    L{CopyRegistered} after unserialization.
    """



def reduceCopyRegistered(cr):
    """
    Externally implement C{__reduce__} for L{CopyRegistered}.

    @param cr: The L{CopyRegistered} instance.

    @return: a 2-tuple of callable and argument list, in this case
        L{CopyRegisteredLoaded} and no arguments.
    """
    return CopyRegisteredLoaded, ()



copyreg.pickle(CopyRegistered, reduceCopyRegistered)

class A:
    """
    dummy class
    """
    def amethod(self):
        pass

class B:
    """
    dummy class
    """
    def bmethod(self):
        pass

def funktion():
    pass

class PicklingTests(unittest.TestCase):
    """Test pickling of extra object types."""
    
    def test_module(self):
        pickl = pickle.dumps(styles)
        o = pickle.loads(pickl)
        self.assertEqual(o, styles)


    def test_classMethod(self):
        """
        After importing L{twisted.persisted.styles}, it is possible to pickle
        classmethod objects.
        """
        pickl = pickle.dumps(Pickleable.getX)
        o = pickle.loads(pickl)
        self.assertEqual(o, Pickleable.getX)

    if sys.version_info > (3, 4):
        test_classMethod.skip = (
            "As of Python 3.4 it is no longer possible to globally change "
            "the behavior of function pickling."
        )


    def test_instanceMethod(self):
        obj = Pickleable(4)
        pickl = pickle.dumps(obj.getX)
        o = pickle.loads(pickl)
        self.assertEqual(o(), 4)
        self.assertEqual(type(o), type(obj.getX))
    
    def test_stringIO(self):
        f = _oldStyleCStringIO()
        f.write("abc")
        pickl = pickle.dumps(f)
        o = pickle.loads(pickl)
        self.assertEqual(type(o), type(f))
        self.assertEqual(f.getvalue(), "abc")

    if skipStringIO:
        test_stringIO.skip = skipStringIO



class StringIOTransitionTests(unittest.TestCase):
    """
    When pickling a cStringIO in Python 2, it should unpickle as a BytesIO or a
    StringIO in Python 3, depending on the type of its contents.
    """

    if not _PY3:
        skip = "In Python 2 we can still unpickle cStringIO as such."


    def test_unpickleBytesIO(self):
        """
        A cStringIO pickled with bytes in it will yield an L{io.BytesIO} on
        python 3.
        """
        pickledStringIWithText = (
            b"ctwisted.persisted.styles\nunpickleStringI\np0\n"
            b"(S'test'\np1\nI0\ntp2\nRp3\n."
        )
        loaded = pickle.loads(pickledStringIWithText)
        self.assertIsInstance(loaded, io.StringIO)
        self.assertEqual(loaded.getvalue(), u"test")



class EvilSourceror:
    def __init__(self, x):
        self.a = self
        self.a.b = self
        self.a.b.c = x

class NonDictState:
    def __getstate__(self):
        return self.state
    def __setstate__(self, state):
        self.state = state

class AOTTests(unittest.TestCase):
    def test_simpleTypes(self):
        obj = (1, 2.0, 3j, True, slice(1, 2, 3), 'hello', u'world',
               sys.maxsize + 1, None, Ellipsis)
        rtObj = aot.unjellyFromSource(aot.jellyToSource(obj))
        self.assertEqual(obj, rtObj)


    def test_methodSelfIdentity(self):
        a = A()
        b = B()
        a.bmethod = b.bmethod
        b.a = a
        im_ = aot.unjellyFromSource(aot.jellyToSource(b)).a.bmethod
        self.assertEqual(aot._selfOfMethod(im_).__class__,
                         aot._classOfMethod(im_))


    def test_methodNotSelfIdentity(self):
        """
        If a class change after an instance has been created,
        L{aot.unjellyFromSource} shoud raise a C{TypeError} when trying to
        unjelly the instance.
        """
        a = A()
        b = B()
        a.bmethod = b.bmethod
        b.a = a
        savedbmethod = B.bmethod
        del B.bmethod
        try:
            self.assertRaises(TypeError, aot.unjellyFromSource,
                              aot.jellyToSource(b))
        finally:
            B.bmethod = savedbmethod


    def test_unsupportedType(self):
        """
        L{aot.jellyToSource} should raise a C{TypeError} when trying to jelly
        an unknown type without a C{__dict__} property or C{__getstate__}
        method.
        """
        class UnknownType(object):
            @property
            def __dict__(self):
                raise AttributeError()
        self.assertRaises(TypeError, aot.jellyToSource, UnknownType())


    def test_basicIdentity(self):
        # Anyone wanting to make this datastructure more complex, and thus this
        # test more comprehensive, is welcome to do so.
        aj = aot.AOTJellier().jellyToAO
        d = {'hello': 'world', "method": aj}
        l = [1, 2, 3,
             "he\tllo\n\n\"x world!",
             u"goodbye \n\t\u1010 world!",
             1, 1.0, 100 ** 100, unittest, aot.AOTJellier, d,
             funktion
             ]
        t = tuple(l)
        l.append(l)
        l.append(t)
        l.append(t)
        uj = aot.unjellyFromSource(aot.jellyToSource([l, l]))
        assert uj[0] is uj[1]
        assert uj[1][0:5] == l[0:5]


    def test_nonDictState(self):
        a = NonDictState()
        a.state = "meringue!"
        assert aot.unjellyFromSource(aot.jellyToSource(a)).state == a.state


    def test_copyReg(self):
        """
        L{aot.jellyToSource} and L{aot.unjellyFromSource} honor functions
        registered in the pickle copy registry.
        """
        uj = aot.unjellyFromSource(aot.jellyToSource(CopyRegistered()))
        self.assertIsInstance(uj, CopyRegisteredLoaded)


    def test_funkyReferences(self):
        o = EvilSourceror(EvilSourceror([]))
        j1 = aot.jellyToAOT(o)
        oj = aot.unjellyFromAOT(j1)

        assert oj.a is oj
        assert oj.a.b is oj.b
        assert oj.c is not oj.c.c


    def test_circularTuple(self):
        """
        L{aot.jellyToAOT} can persist circular references through tuples.
        """
        l = []
        t = (l, 4321)
        l.append(t)
        j1 = aot.jellyToAOT(l)
        oj = aot.unjellyFromAOT(j1)
        self.assertIsInstance(oj[0], tuple)
        self.assertIs(oj[0][0], oj)
        self.assertEqual(oj[0][1], 4321)



class CrefUtilTests(unittest.TestCase):
    """
    Tests for L{crefutil}.
    """

    def test_dictUnknownKey(self):
        """
        L{crefutil._DictKeyAndValue} only support keys C{0} and C{1}.
        """
        d = crefutil._DictKeyAndValue({})
        self.assertRaises(RuntimeError, d.__setitem__, 2, 3)


    def test_deferSetMultipleTimes(self):
        """
        L{crefutil._Defer} can be assigned a key only one time.
        """
        d = crefutil._Defer()
        d[0] = 1
        self.assertRaises(RuntimeError, d.__setitem__, 0, 1)


    def test_containerWhereAllElementsAreKnown(self):
        """
        A L{crefutil._Container} where all of its elements are known at
        construction time is nonsensical and will result in errors in any call
        to addDependant.
        """
        container = crefutil._Container([1, 2, 3], list)
        self.assertRaises(AssertionError,
                          container.addDependant, {}, "ignore-me")


    def test_dontPutCircularReferencesInDictionaryKeys(self):
        """
        If a dictionary key contains a circular reference (which is probably a
        bad practice anyway) it will be resolved by a
        L{crefutil._DictKeyAndValue}, not by placing a L{crefutil.NotKnown}
        into a dictionary key.
        """
        self.assertRaises(AssertionError,
                          dict().__setitem__, crefutil.NotKnown(), "value")


    def test_dontCallInstanceMethodsThatArentReady(self):
        """
        L{crefutil._InstanceMethod} raises L{AssertionError} to indicate it
        should not be called.  This should not be possible with any of its API
        clients, but is provided for helping to debug.
        """
        self.assertRaises(AssertionError,
                          crefutil._InstanceMethod(
                              "no_name", crefutil.NotKnown(), type))



testCases = [VersionTests, EphemeralTests, PicklingTests]


filename:/usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyc
__doc__
Û
qóÁVc           @`  s€  d  Z  d d l m Z m Z d d l Z d d l Z d d l Z d d l m Z d d l	 m
 Z
 d d l m Z m Z m Z m Z m Z m Z d d l m Z m Z m Z m Z e
 rø e Z n  d e j f d	 Ñ  É  YZ d
 d d Ñ  É  YZ d e j f d Ñ  É  YZ d e j f d Ñ  É  YZ d Z d e j f d Ñ  É  YZ  d e j f d Ñ  É  YZ! e j" e d É d k rìx/ e e e! f D] Z$ d e$ _% q}Wn d d l& Z& e j' e d É d k r◊x e! f D] Z$ d e$ _% q¡Wn  d S(   sC   
Test methods in twisted.internet.threads and reactor thread APIs.
i    (   t   divisiont   absolute_importN(   t   unittest(   t   _PY3(   t   reactort   defert
   interfacest   threadst   protocolt   error(   t   failuret
   threadablet   logt
   threadpoolt   ReactorThreadsTestsc           B`  sh   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z RS(   s.   
    Tests for the reactor threading API.
    c         C`  sJ   t  j d É |  j t  j j d É t  j d É |  j t  j j d É d S(   s:   
        Try to change maximum number of threads.
        i"   i   N(   R   t   suggestThreadPoolSizet   assertEqualR   t   max(   t   self(    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   test_suggestThreadPoolSize   s    c         C`  s   t  j t j d É S(   sƒ   
        The reactor's threadpool is only available when the reactor is running,
        so to have a sane behavior during the tests we make a dummy
        L{threads.deferToThread} call.
        i    (   R   t   deferToThreadt   timet   sleep(   R   (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   _waitForThread&   s    c         `  s"   á  f d Ü  } à  j  É  j | É S(   sÄ   
        Test callInThread functionality: set a C{threading.Event}, and check
        that it's not in the main thread.
        c         `  sq   t  j É  â g  â  á  á f d Ü  } t j | É à j d É à j É  sZ à j d É n à j à  t g É d  S(   Nc           `  s!   à  j  t j É  É à j É  d  S(   N(   t   appendR   t   isInIOThreadt   set(    (   t   resultt   waiter(    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   threadedFunc7   s    ix   s   Timed out waiting for event.(	   t	   threadingt   EventR   t   callInThreadt   waitt   isSett   failR   t   False(   t   ignR   (   R   (   R   R   s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   cb4   s    (   R   t   addCallback(   R   R&   (    (   R   s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   test_callInThread/   s    c         C`  s   d Ñ  } |  j  É  j | É S(   sk   
        Test callFromThread functionality: from the main thread, and from
        another thread.
        c         `  s`   t  j É  } t  j É  â  á  f d Ü  } t j | É t j | j d  É t  j | à  g d t ÉS(   Nc           `  s   t  j à  j d  É d  S(   N(   R   t   callFromThreadt   callbackt   None(    (   t   firedByOtherThread(    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyR   M   s    t   fireOnOneErrback(	   R   t   DeferredR   R    R)   R*   R+   t   DeferredListt   True(   R%   t   firedByReactorThreadR   (    (   R,   s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyR&   I   s    (   R   R'   (   R   R&   (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   test_callFromThreadD   s    	c         `  s"   á  f d Ü  } à  j  É  j | É S(   sT   
        Try to make an overflow on the reactor waker using callFromThread.
        c         `  sÄ   d  à _ t j É  â  á á  f d Ü  } t j | É à  j d É à  j É  s] à j d É n  à j d  k	 r| t	 j à j É Sd  S(   Nc          `  sS   xB t  d É D]4 }  y t j d Ñ  É Wq t j É  à  _ Pq Xq Wà j É  d  S(   Ni†Ü c           S`  s   d  S(   N(   R+   (    (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   <lambda>e   s    (   t   xrangeR   R)   R
   t   FailureR   (   t   i(   R   R   (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   threadedFunction`   s    	ix   s   Timed out waiting for event(
   R+   R
   R   R   R   R    R!   R"   R#   R   (   R%   R7   (   R   (   R   s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyR&   ]   s    	
(   R   R'   (   R   R&   (    (   R   s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   test_wakerOverflowY   s    c         `  sg   t  j É  â g  â g  â  á  á á á á f d Ü  } á  á á á f d Ü  } à j É  j | É j | É S(   sK   
        Utility method to test L{threads.blockingCallFromThread}.
        c         `  s>   á  á á á f d Ü  } t  j | É t j à j à j É  É S(   Nc          `  sT   y t  j t à É }  Wn  t k
 r8 } à  j | É n Xà j |  É à j É  d  S(   N(   R   t   blockingCallFromThreadR   t	   ExceptionR   R   (   t   rt   e(   t   errorst   reactorFunct   resultsR   (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyR   z   s    (   R   R    R   R   R!   t
   getTimeout(   R%   R   (   R=   R>   R?   R   R   (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   cb1y   s    	c         `  s&   à j  É  s à j d É n  à à  f S(   Ns   Timed out waiting for event(   R"   R#   (   R%   (   R=   R?   R   R   (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   cb2Ü   s    (   R   R   R   R'   t   addBoth(   R   R>   RA   RB   (    (   R=   R>   R?   R   R   s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   _testBlockingCallFromThreadr   s    c         `  s.   d Ñ  } á  f d Ü  } à  j  | É j | É S(   s¿   
        Test blockingCallFromThread facility: create a thread, call a function
        in the reactor using L{threads.blockingCallFromThread}, and verify the
        result returned.
        c           S`  s   t  j d É S(   Nt   foo(   R   t   succeed(    (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyR>   ì   s    c         `  s   à  j  |  d d d É d  S(   Ni    RE   (   R   (   t   res(   R   (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyR&   ï   s    (   RD   R'   (   R   R>   R&   (    (   R   s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   test_blockingCallFromThreadç   s    	c         `  s.   d Ñ  } á  f d Ü  } à  j  | É j | É S(   sx   
        Test blockingCallFromThread as above, but be sure the resulting
        Deferred is not already fired.
        c          S`  s&   t  j É  }  t j d |  j d É |  S(   Ngöôôôôôπ?t   egg(   R   R.   R   t	   callLaterR*   (   t   d(    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyR>   ü   s    c         `  s   à  j  |  d d d É d  S(   Ni    RI   (   R   (   RG   (   R   (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyR&   £   s    (   RD   R'   (   R   R>   R&   (    (   R   s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt    test_asyncBlockingCallFromThreadö   s    	c         `  s.   d Ñ  } á  f d Ü  } à  j  | É j | É S(   s?   
        Test error report for blockingCallFromThread.
        c           S`  s   t  j t d É É S(   Nt   bar(   R   R#   t   RuntimeError(    (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyR>   ¨   s    c         `  sA   à  j  t |  d d t É É à  j |  d d j d d É d  S(   Ni   i    RM   (   t   assert_t
   isinstanceRN   R   t   args(   RG   (   R   (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyR&   Æ   s    (   RD   R'   (   R   R>   R&   (    (   R   s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt    test_errorBlockingCallFromThread®   s    	c         `  s.   d Ñ  } á  f d Ü  } à  j  | É j | É S(   sâ   
        Test error report for blockingCallFromThread as above, but be sure the
        resulting Deferred is not already fired.
        c          S`  s,   t  j É  }  t j d |  j t d É É |  S(   Ngöôôôôôπ?t   spam(   R   R.   R   RJ   t   errbackRN   (   RK   (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyR>   π   s    c         `  sA   à  j  t |  d d t É É à  j |  d d j d d É d  S(   Ni   i    RS   (   RO   RP   RN   R   RQ   (   RG   (   R   (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyR&   Ω   s    (   RD   R'   (   R   R>   R&   (    (   R   s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt%   test_asyncErrorBlockingCallFromThread¥   s    	(   t   __name__t
   __module__t   __doc__R   R   R(   R2   R8   RD   RH   RL   RR   RU   (    (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyR      s   	
									t   Counterc           B`  s   e  Z d  Z d  Z d Ñ  Z RS(   i    c         C`  s?   |  j  d } | |  j  d k r2 d |  _ t Ç n  | |  _  d S(   s   A non thread-safe method.i   N(   t   indext   problemt
   ValueError(   R   t   next(    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   add»   s
    		(   RV   RW   RZ   R[   R^   (    (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyRY   ƒ   s   t   DeferredResultTestsc           B`  sD   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s(   
    Test twisted.internet.threads.
    c         C`  s   t  j d É d  S(   Ni   (   R   R   (   R   (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   setUp‹   s    c         C`  s   t  j d É d  S(   Ni    (   R   R   (   R   (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   tearDown‡   s    c         `  s   g  â  d â t  j É  â á  á á á f d Ü  } t j g  t à É D] } à  j | f i  f ^ qC t j | f i  f g É à S(   sW   
        L{threads.callMultipleInThread} calls multiple functions in a thread.
        i
   c           `  s-   à j  à  t t à É É É à j d  É d  S(   N(   R   t   listt   rangeR*   R+   (    (   t   Lt   NRK   R   (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   finishedÏ   s    (   R   R.   R   t   callMultipleInThreadR4   R   R   R)   (   R   Rf   R6   (    (   Rd   Re   RK   R   s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   test_callMultiple‰   s    +c         C`  s5   t  j d d Ñ d d d É} | j |  j d É | S(   sí   
        L{threads.deferToThread} executes the function passed, and correctly
        handles the positional and keyword arguments given.
        i   c         S`  s   |  | S(   N(    (   t   xt   y(    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyR3   ˚   s    i   Rj   i   i   (   R   R   R'   R   (   R   RK   (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   test_deferredResultˆ   s    c         `  sD   d t  f d Ñ  É  Yâ  á  f d Ü  } t j | É } |  j | à  É S(   s≤   
        Check that L{threads.deferToThread} return a failure object
        with an appropriate exception instance when the called
        function raises an exception.
        t   NewErrorc           B`  s   e  Z RS(    (   RV   RW   (    (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyRl     s   c           `  s   à  É  Ç d  S(   N(    (    (   Rl   (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt
   raiseError  s    (   R:   R   R   t   assertFailure(   R   Rm   RK   (    (   Rl   s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   test_deferredFailure   s    c         C`  s2   t  j d Ñ  É } | j d Ñ  É |  j | t É S(   sï   
        Check that a successfull L{threads.deferToThread} followed by a one
        that raises an exception correctly result as a failure.
        c           S`  s   d  S(   N(   R+   (    (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyR3     s    c         S`  s   t  j d Ñ  É S(   Nc           S`  s   d d S(   Ni   i    (    (    (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyR3     s    (   R   R   (   R%   (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyR3     s    (   R   R   R'   Rn   t   ZeroDivisionError(   R   RK   (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt    test_deferredFailureAfterSuccess  s    (	   RV   RW   RX   R`   Ra   Rh   Rk   Ro   Rq   (    (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyR_   ◊   s   				
	t   DeferToThreadPoolTestsc           B`  s2   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s=   
    Test L{twisted.internet.threads.deferToThreadPool}.
    c         C`  s&   t  j d d É |  _ |  j j É  d  S(   Ni    i   (   R   t
   ThreadPoolt   tpt   start(   R   (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyR`   (  s    c         C`  s   |  j  j É  d  S(   N(   Rt   t   stop(   R   (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyRa   -  s    c         C`  s>   t  j t |  j d d Ñ d d d É} | j |  j d É | S(   sñ   
        L{threads.deferToThreadPool} executes the function passed, and
        correctly handles the positional and keyword arguments given.
        i   c         S`  s   |  | S(   N(    (   Ri   Rj   (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyR3   7  s    i   Rj   i   i   (   R   t   deferToThreadPoolR   Rt   R'   R   (   R   RK   (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyRk   1  s    c         `  sM   d t  f d Ñ  É  Yâ  á  f d Ü  } t j t |  j | É } |  j | à  É S(   s∂   
        Check that L{threads.deferToThreadPool} return a failure object with an
        appropriate exception instance when the called function raises an
        exception.
        Rl   c           B`  s   e  Z RS(    (   RV   RW   (    (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyRl   B  s   c           `  s   à  É  Ç d  S(   N(    (    (   Rl   (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyRm   D  s    (   R:   R   Rw   R   Rt   Rn   (   R   Rm   RK   (    (   Rl   s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyRo   <  s    (   RV   RW   RX   R`   Ra   Rk   Ro   (    (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyRr   #  s
   			s_  
import time
import %(reactor)s
%(reactor)s.install()

from twisted.internet import reactor

def threadedCall():
    print('threaded call')

reactor.callInThread(threadedCall)

# Spin very briefly to try to give the thread a chance to run, if it
# is going to.  Is there a better way to achieve this behavior?
for i in range(100):
    time.sleep(0.0)
t   ThreadStartupProcessProtocolc           B`  s,   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C`  s   | |  _  g  |  _ g  |  _ d  S(   N(   Rf   t   outt   err(   R   Rf   (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   __init___  s    		c         C`  s   |  j  j | É d  S(   N(   Ry   R   (   R   Ry   (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   outReceivedd  s    c         C`  s   |  j  j | É d  S(   N(   Rz   R   (   R   Rz   (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   errReceivedg  s    c         C`  s#   |  j  j |  j |  j | f É d  S(   N(   Rf   R*   Ry   Rz   (   R   t   reason(    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   processEndedj  s    (   RV   RW   R{   R|   R}   R   (    (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyRx   ^  s   			t   StartupBehaviorTestsc           B`  s   e  Z d  Z d Ñ  Z RS(   s  
    Test cases for the behavior of the reactor threadpool near startup
    boundary conditions.

    In particular, this asserts that no threaded calls are attempted
    until the reactor starts up, that calls attempted before it starts
    are in fact executed once it has started, and that in both cases,
    the reactor properly cleans itself up (which is tested for
    somewhat implicitly, by requiring a child process be able to exit,
    something it cannot do unless the threadpool has been properly
    torn down).
    c         `  sÕ   à j  É  } t | d É } | j t i t j d 6É | j É  á f d Ü  } á  f d Ü  } t j j	 É  } t j
 j t j É | d <t j É  j | | É } t | É â  t j à  t j d | f | É | S(   Nt   wR   c         `  ss   |  \ } } } | j  t j É r; à  j d | | f É n  | rX t j d | f É n  à  j | d | f É d  S(   Ns.   Process did not exit cleanly (out: %s err: %s)s'   Unexpected output on standard error: %ss(   Expected no output, instead received:
%s(   t   checkR	   t   ProcessTerminatedR#   R   t   msgt   assertFalse(   R   Ry   Rz   R~   (   R   (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   programFinishedÑ  s    c         `  s!   |  j  t j É à  j d É |  S(   Nt   KILL(   t   trapR	   t   TimeoutErrort   signalProcess(   Rz   (   t   proto(    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   programTimeoutè  s    t
   PYTHONPATHt   python(   t   mktempt   opent   writet   _callBeforeStartupProgramR   RW   t   closet   ost   environt   copyt   pathsept   joint   syst   pathR   R.   t   addCallbacksRx   t   spawnProcesst
   executable(   R   t   prognamet   progfileRÜ   Rå   t   envRK   (    (   Rã   R   s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   testCallBeforeStartupUnexecuted~  s    
(   RV   RW   RX   R°   (    (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyRÄ   o  s   s(   No thread support, nothing to test here.s7   No process support, cannot run subprocess thread tests.(    ((   RX   t
   __future__R    R   Rô   Rî   R   t   twisted.trialR   t   twisted.python.compatR   t   twisted.internetR   R   R   R   R   R	   t   twisted.pythonR
   R   R   R   Rc   R4   t   TestCaseR   RY   R_   Rr   Rí   t   ProcessProtocolRx   RÄ   t   IReactorThreadsR+   t   clst   skipR   t   IReactorProcess(    (    (    s=   /usr/lib/python2.7/dist-packages/twisted/test/test_threads.pyt   <module>   s0   $."	≠L8.
filename:/usr/lib/python2.7/dist-packages/twisted/test/test_loopback.py
__doc__
# Copyright (c) Twisted Matrix Laboratories.
# See LICENSE for details.

"""

filename:/usr/lib/python2.7/dist-packages/twisted/news/test/__init__.py
__doc__
"""News Tests"""

filename:/usr/lib/python2.7/dist-packages/twisted/news/test/test_nntp.py
__doc__
# Copyright (c) Twisted Matrix Laboratories.
# See LICENSE for details.

from twisted.trial import unittest
from twisted.news import database
from twisted.news import nntp
from twisted.protocols import loopback
from twisted.test import proto_helpers

ALL_GROUPS = ('alt.test.nntp', 0, 1, 'y'),
GROUP = ('0', '1', '0', 'alt.test.nntp', 'group', 'selected')
SUBSCRIPTIONS = ['alt.test.nntp', 'news.testgroup']

POST_STRING = """Path: not-for-mail
From: <exarkun@somehost.domain.com>
Subject: a test
Newsgroups: alt.test.nntp
Organization: 
Summary: 
Keywords: 
User-Agent: tin/1.4.5-20010409 ("One More Nightmare") (UNIX) (Linux/2.4.17 (i686))

this is a test
.
..
...
lala
moo
-- 
"One World, one Web, one Program." - Microsoft(R) promotional ad
"Ein Volk, ein Reich, ein Fuhrer." - Adolf Hitler
--
 10:56pm up 4 days, 4:42, 1 user, load average: 0.08, 0.08, 0.12
"""

filename:/usr/lib/python2.7/dist-packages/six.py
__doc__
"""Utilities for writing code that runs on Python 2 and 3"""

# Copyright (c) 2010-2015 Benjamin Peterson
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from __future__ import absolute_import

import functools
import itertools
import operator
import sys
import types

__author__ = "Benjamin Peterson <benjamin@python.org>"
__version__ = "1.10.0"


# Useful for very coarse version differentiation.
PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] == 3
PY34 = sys.version_info[0:2] >= (3, 4)

if PY3:
    string_types = str,
    integer_types = int,
    class_types = type,
    text_type = str
    binary_type = bytes

    MAXSIZE = sys.maxsize
else:
    string_types = basestring,
    integer_types = (int, long)
    class_types = (type, types.ClassType)
    text_type = unicode
    binary_type = str

    if sys.platform.startswith("java"):
        # Jython always uses 32 bits.
        MAXSIZE = int((1 << 31) - 1)
    else:
        # It's possible to have sizeof(long) != sizeof(Py_ssize_t).
        class X(object):

            def __len__(self):
                return 1 << 31
        try:
            len(X())
        except OverflowError:
            # 32-bit
            MAXSIZE = int((1 << 31) - 1)
        else:
            # 64-bit
            MAXSIZE = int((1 << 63) - 1)
        del X


def _add_doc(func, doc):
    """Add documentation to a function."""
    func.__doc__ = doc


def _import_module(name):
    """Import module, returning the module after the last dot."""
    __import__(name)
    return sys.modules[name]


class _LazyDescr(object):

    def __init__(self, name):
        self.name = name

    def __get__(self, obj, tp):
        result = self._resolve()
        setattr(obj, self.name, result)  # Invokes __set__.
        try:
            # This is a bit ugly, but it avoids running this again by
            # removing this descriptor.
            delattr(obj.__class__, self.name)
        except AttributeError:
            pass
        return result


class MovedModule(_LazyDescr):

    def __init__(self, name, old, new=None):
        super(MovedModule, self).__init__(name)
        if PY3:
            if new is None:
                new = name
            self.mod = new
        else:
            self.mod = old

    def _resolve(self):
        return _import_module(self.mod)

    def __getattr__(self, attr):
        _module = self._resolve()
        value = getattr(_module, attr)
        setattr(self, attr, value)
        return value


class _LazyModule(types.ModuleType):

    def __init__(self, name):
        super(_LazyModule, self).__init__(name)
        self.__doc__ = self.__class__.__doc__

    def __dir__(self):
        attrs = ["__doc__", "__name__"]
        attrs += [attr.name for attr in self._moved_attributes]
        return attrs

    # Subclasses should override this
    _moved_attributes = []


class MovedAttribute(_LazyDescr):

    def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):
        super(MovedAttribute, self).__init__(name)
        if PY3:
            if new_mod is None:
                new_mod = name
            self.mod = new_mod
            if new_attr is None:
                if old_attr is None:
                    new_attr = name
                else:
                    new_attr = old_attr
            self.attr = new_attr
        else:
            self.mod = old_mod
            if old_attr is None:
                old_attr = name
            self.attr = old_attr

    def _resolve(self):
        module = _import_module(self.mod)
        return getattr(module, self.attr)


class _SixMetaPathImporter(object):

    """
    A meta path importer to import six.moves and its submodules.

    This class implements a PEP302 finder and loader. It should be compatible
    with Python 2.5 and all existing versions of Python3
    """

    def __init__(self, six_module_name):
        self.name = six_module_name
        self.known_modules = {}

    def _add_module(self, mod, *fullnames):
        for fullname in fullnames:
            self.known_modules[self.name + "." + fullname] = mod

    def _get_module(self, fullname):
        return self.known_modules[self.name + "." + fullname]

    def find_module(self, fullname, path=None):
        if fullname in self.known_modules:
            return self
        return None

    def __get_module(self, fullname):
        try:
            return self.known_modules[fullname]
        except KeyError:
            raise ImportError("This loader does not know module " + fullname)

    def load_module(self, fullname):
        try:
            # in case of a reload
            return sys.modules[fullname]
        except KeyError:
            pass
        mod = self.__get_module(fullname)
        if isinstance(mod, MovedModule):
            mod = mod._resolve()
        else:
            mod.__loader__ = self
        sys.modules[fullname] = mod
        return mod

    def is_package(self, fullname):
        """
        Return true, if the named module is a package.

        We need this method to get correct spec objects with
        Python 3.4 (see PEP451)
        """
        return hasattr(self.__get_module(fullname), "__path__")

    def get_code(self, fullname):
        """Return None

        Required, if is_package is implemented"""
        self.__get_module(fullname)  # eventually raises ImportError
        return None
    get_source = get_code  # same as get_code

_importer = _SixMetaPathImporter(__name__)


class _MovedItems(_LazyModule):

    """Lazy loading of moved objects"""
    __path__ = []  # mark as package


_moved_attributes = [
    MovedAttribute("cStringIO", "cStringIO", "io", "StringIO"),
    MovedAttribute("filter", "itertools", "builtins", "ifilter", "filter"),
    MovedAttribute("filterfalse", "itertools", "itertools", "ifilterfalse", "filterfalse"),
    MovedAttribute("input", "__builtin__", "builtins", "raw_input", "input"),
    MovedAttribute("intern", "__builtin__", "sys"),
    MovedAttribute("map", "itertools", "builtins", "imap", "map"),
    MovedAttribute("getcwd", "os", "os", "getcwdu", "getcwd"),
    MovedAttribute("getcwdb", "os", "os", "getcwd", "getcwdb"),
    MovedAttribute("range", "__builtin__", "builtins", "xrange", "range"),
    MovedAttribute("reload_module", "__builtin__", "importlib" if PY34 else "imp", "reload"),
    MovedAttribute("reduce", "__builtin__", "functools"),
    MovedAttribute("shlex_quote", "pipes", "shlex", "quote"),
    MovedAttribute("StringIO", "StringIO", "io"),
    MovedAttribute("UserDict", "UserDict", "collections"),
    MovedAttribute("UserList", "UserList", "collections"),
    MovedAttribute("UserString", "UserString", "collections"),
    MovedAttribute("xrange", "__builtin__", "builtins", "xrange", "range"),
    MovedAttribute("zip", "itertools", "builtins", "izip", "zip"),
    MovedAttribute("zip_longest", "itertools", "itertools", "izip_longest", "zip_longest"),
    MovedModule("builtins", "__builtin__"),
    MovedModule("configparser", "ConfigParser"),
    MovedModule("copyreg", "copy_reg"),
    MovedModule("dbm_gnu", "gdbm", "dbm.gnu"),
    MovedModule("_dummy_thread", "dummy_thread", "_dummy_thread"),
    MovedModule("http_cookiejar", "cookielib", "http.cookiejar"),
    MovedModule("http_cookies", "Cookie", "http.cookies"),
    MovedModule("html_entities", "htmlentitydefs", "html.entities"),
    MovedModule("html_parser", "HTMLParser", "html.parser"),
    MovedModule("http_client", "httplib", "http.client"),
    MovedModule("email_mime_multipart", "email.MIMEMultipart", "email.mime.multipart"),
    MovedModule("email_mime_nonmultipart", "email.MIMENonMultipart", "email.mime.nonmultipart"),
    MovedModule("email_mime_text", "email.MIMEText", "email.mime.text"),
    MovedModule("email_mime_base", "email.MIMEBase", "email.mime.base"),
    MovedModule("BaseHTTPServer", "BaseHTTPServer", "http.server"),
    MovedModule("CGIHTTPServer", "CGIHTTPServer", "http.server"),
    MovedModule("SimpleHTTPServer", "SimpleHTTPServer", "http.server"),
    MovedModule("cPickle", "cPickle", "pickle"),
    MovedModule("queue", "Queue"),
    MovedModule("reprlib", "repr"),
    MovedModule("socketserver", "SocketServer"),
    MovedModule("_thread", "thread", "_thread"),
    MovedModule("tkinter", "Tkinter"),
    MovedModule("tkinter_dialog", "Dialog", "tkinter.dialog"),
    MovedModule("tkinter_filedialog", "FileDialog", "tkinter.filedialog"),
    MovedModule("tkinter_scrolledtext", "ScrolledText", "tkinter.scrolledtext"),
    MovedModule("tkinter_simpledialog", "SimpleDialog", "tkinter.simpledialog"),
    MovedModule("tkinter_tix", "Tix", "tkinter.tix"),
    MovedModule("tkinter_ttk", "ttk", "tkinter.ttk"),
    MovedModule("tkinter_constants", "Tkconstants", "tkinter.constants"),
    MovedModule("tkinter_dnd", "Tkdnd", "tkinter.dnd"),
    MovedModule("tkinter_colorchooser", "tkColorChooser",
                "tkinter.colorchooser"),
    MovedModule("tkinter_commondialog", "tkCommonDialog",
                "tkinter.commondialog"),
    MovedModule("tkinter_tkfiledialog", "tkFileDialog", "tkinter.filedialog"),
    MovedModule("tkinter_font", "tkFont", "tkinter.font"),
    MovedModule("tkinter_messagebox", "tkMessageBox", "tkinter.messagebox"),
    MovedModule("tkinter_tksimpledialog", "tkSimpleDialog",
                "tkinter.simpledialog"),
    MovedModule("urllib_parse", __name__ + ".moves.urllib_parse", "urllib.parse"),
    MovedModule("urllib_error", __name__ + ".moves.urllib_error", "urllib.error"),
    MovedModule("urllib", __name__ + ".moves.urllib", __name__ + ".moves.urllib"),
    MovedModule("urllib_robotparser", "robotparser", "urllib.robotparser"),
    MovedModule("xmlrpc_client", "xmlrpclib", "xmlrpc.client"),
    MovedModule("xmlrpc_server", "SimpleXMLRPCServer", "xmlrpc.server"),
]
# Add windows specific modules.
if sys.platform == "win32":
    _moved_attributes += [
        MovedModule("winreg", "_winreg"),
    ]

for attr in _moved_attributes:
    setattr(_MovedItems, attr.name, attr)
    if isinstance(attr, MovedModule):
        _importer._add_module(attr, "moves." + attr.name)
del attr

_MovedItems._moved_attributes = _moved_attributes

moves = _MovedItems(__name__ + ".moves")
_importer._add_module(moves, "moves")


class Module_six_moves_urllib_parse(_LazyModule):

    """Lazy loading of moved objects in six.moves.urllib_parse"""


_urllib_parse_moved_attributes = [
    MovedAttribute("ParseResult", "urlparse", "urllib.parse"),
    MovedAttribute("SplitResult", "urlparse", "urllib.parse"),
    MovedAttribute("parse_qs", "urlparse", "urllib.parse"),
    MovedAttribute("parse_qsl", "urlparse", "urllib.parse"),
    MovedAttribute("urldefrag", "urlparse", "urllib.parse"),
    MovedAttribute("urljoin", "urlparse", "urllib.parse"),
    MovedAttribute("urlparse", "urlparse", "urllib.parse"),
    MovedAttribute("urlsplit", "urlparse", "urllib.parse"),
    MovedAttribute("urlunparse", "urlparse", "urllib.parse"),
    MovedAttribute("urlunsplit", "urlparse", "urllib.parse"),
    MovedAttribute("quote", "urllib", "urllib.parse"),
    MovedAttribute("quote_plus", "urllib", "urllib.parse"),
    MovedAttribute("unquote", "urllib", "urllib.parse"),
    MovedAttribute("unquote_plus", "urllib", "urllib.parse"),
    MovedAttribute("urlencode", "urllib", "urllib.parse"),
    MovedAttribute("splitquery", "urllib", "urllib.parse"),
    MovedAttribute("splittag", "urllib", "urllib.parse"),
    MovedAttribute("splituser", "urllib", "urllib.parse"),
    MovedAttribute("uses_fragment", "urlparse", "urllib.parse"),
    MovedAttribute("uses_netloc", "urlparse", "urllib.parse"),
    MovedAttribute("uses_params", "urlparse", "urllib.parse"),
    MovedAttribute("uses_query", "urlparse", "urllib.parse"),
    MovedAttribute("uses_relative", "urlparse", "urllib.parse"),
]
for attr in _urllib_parse_moved_attributes:
    setattr(Module_six_moves_urllib_parse, attr.name, attr)
del attr

Module_six_moves_urllib_parse._moved_attributes = _urllib_parse_moved_attributes

_importer._add_module(Module_six_moves_urllib_parse(__name__ + ".moves.urllib_parse"),
                      "moves.urllib_parse", "moves.urllib.parse")


class Module_six_moves_urllib_error(_LazyModule):

    """Lazy loading of moved objects in six.moves.urllib_error"""


_urllib_error_moved_attributes = [
    MovedAttribute("URLError", "urllib2", "urllib.error"),
    MovedAttribute("HTTPError", "urllib2", "urllib.error"),
    MovedAttribute("ContentTooShortError", "urllib", "urllib.error"),
]
for attr in _urllib_error_moved_attributes:
    setattr(Module_six_moves_urllib_error, attr.name, attr)
del attr

Module_six_moves_urllib_error._moved_attributes = _urllib_error_moved_attributes

_importer._add_module(Module_six_moves_urllib_error(__name__ + ".moves.urllib.error"),
                      "moves.urllib_error", "moves.urllib.error")


class Module_six_moves_urllib_request(_LazyModule):

    """Lazy loading of moved objects in six.moves.urllib_request"""


_urllib_request_moved_attributes = [
    MovedAttribute("urlopen", "urllib2", "urllib.request"),
    MovedAttribute("install_opener", "urllib2", "urllib.request"),
    MovedAttribute("build_opener", "urllib2", "urllib.request"),
    MovedAttribute("pathname2url", "urllib", "urllib.request"),
    MovedAttribute("url2pathname", "urllib", "urllib.request"),
    MovedAttribute("getproxies", "urllib", "urllib.request"),
    MovedAttribute("Request", "urllib2", "urllib.request"),
    MovedAttribute("OpenerDirector", "urllib2", "urllib.request"),
    MovedAttribute("HTTPDefaultErrorHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPRedirectHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPCookieProcessor", "urllib2", "urllib.request"),
    MovedAttribute("ProxyHandler", "urllib2", "urllib.request"),
    MovedAttribute("BaseHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPPasswordMgr", "urllib2", "urllib.request"),
    MovedAttribute("HTTPPasswordMgrWithDefaultRealm", "urllib2", "urllib.request"),
    MovedAttribute("AbstractBasicAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPBasicAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("ProxyBasicAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("AbstractDigestAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPDigestAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("ProxyDigestAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPSHandler", "urllib2", "urllib.request"),
    MovedAttribute("FileHandler", "urllib2", "urllib.request"),
    MovedAttribute("FTPHandler", "urllib2", "urllib.request"),
    MovedAttribute("CacheFTPHandler", "urllib2", "urllib.request"),
    MovedAttribute("UnknownHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPErrorProcessor", "urllib2", "urllib.request"),
    MovedAttribute("urlretrieve", "urllib", "urllib.request"),
    MovedAttribute("urlcleanup", "urllib", "urllib.request"),
    MovedAttribute("URLopener", "urllib", "urllib.request"),
    MovedAttribute("FancyURLopener", "urllib", "urllib.request"),
    MovedAttribute("proxy_bypass", "urllib", "urllib.request"),
]
for attr in _urllib_request_moved_attributes:
    setattr(Module_six_moves_urllib_request, attr.name, attr)
del attr

Module_six_moves_urllib_request._moved_attributes = _urllib_request_moved_attributes

_importer._add_module(Module_six_moves_urllib_request(__name__ + ".moves.urllib.request"),
                      "moves.urllib_request", "moves.urllib.request")


class Module_six_moves_urllib_response(_LazyModule):

    """Lazy loading of moved objects in six.moves.urllib_response"""


_urllib_response_moved_attributes = [
    MovedAttribute("addbase", "urllib", "urllib.response"),
    MovedAttribute("addclosehook", "urllib", "urllib.response"),
    MovedAttribute("addinfo", "urllib", "urllib.response"),
    MovedAttribute("addinfourl", "urllib", "urllib.response"),
]
for attr in _urllib_response_moved_attributes:
    setattr(Module_six_moves_urllib_response, attr.name, attr)
del attr

Module_six_moves_urllib_response._moved_attributes = _urllib_response_moved_attributes

_importer._add_module(Module_six_moves_urllib_response(__name__ + ".moves.urllib.response"),
                      "moves.urllib_response", "moves.urllib.response")


class Module_six_moves_urllib_robotparser(_LazyModule):

    """Lazy loading of moved objects in six.moves.urllib_robotparser"""


_urllib_robotparser_moved_attributes = [
    MovedAttribute("RobotFileParser", "robotparser", "urllib.robotparser"),
]
for attr in _urllib_robotparser_moved_attributes:
    setattr(Module_six_moves_urllib_robotparser, attr.name, attr)
del attr

Module_six_moves_urllib_robotparser._moved_attributes = _urllib_robotparser_moved_attributes

_importer._add_module(Module_six_moves_urllib_robotparser(__name__ + ".moves.urllib.robotparser"),
                      "moves.urllib_robotparser", "moves.urllib.robotparser")


class Module_six_moves_urllib(types.ModuleType):

    """Create a six.moves.urllib namespace that resembles the Python 3 namespace"""
    __path__ = []  # mark as package
    parse = _importer._get_module("moves.urllib_parse")
    error = _importer._get_module("moves.urllib_error")
    request = _importer._get_module("moves.urllib_request")
    response = _importer._get_module("moves.urllib_response")
    robotparser = _importer._get_module("moves.urllib_robotparser")

    def __dir__(self):
        return ['parse', 'error', 'request', 'response', 'robotparser']

_importer._add_module(Module_six_moves_urllib(__name__ + ".moves.urllib"),
                      "moves.urllib")


def add_move(move):
    """Add an item to six.moves."""
    setattr(_MovedItems, move.name, move)


def remove_move(name):
    """Remove item from six.moves."""
    try:
        delattr(_MovedItems, name)
    except AttributeError:
        try:
            del moves.__dict__[name]
        except KeyError:
            raise AttributeError("no such move, %r" % (name,))


if PY3:
    _meth_func = "__func__"
    _meth_self = "__self__"

    _func_closure = "__closure__"
    _func_code = "__code__"
    _func_defaults = "__defaults__"
    _func_globals = "__globals__"
else:
    _meth_func = "im_func"
    _meth_self = "im_self"

    _func_closure = "func_closure"
    _func_code = "func_code"
    _func_defaults = "func_defaults"
    _func_globals = "func_globals"


try:
    advance_iterator = next
except NameError:
    def advance_iterator(it):
        return it.next()
next = advance_iterator


try:
    callable = callable
except NameError:
    def callable(obj):
        return any("__call__" in klass.__dict__ for klass in type(obj).__mro__)


if PY3:
    def get_unbound_function(unbound):
        return unbound

    create_bound_method = types.MethodType

    def create_unbound_method(func, cls):
        return func

    Iterator = object
else:
    def get_unbound_function(unbound):
        return unbound.im_func

    def create_bound_method(func, obj):
        return types.MethodType(func, obj, obj.__class__)

    def create_unbound_method(func, cls):
        return types.MethodType(func, None, cls)

    class Iterator(object):

        def next(self):
            return type(self).__next__(self)

    callable = callable
_add_doc(get_unbound_function,
         """Get the function out of a possibly unbound function""")


get_method_function = operator.attrgetter(_meth_func)
get_method_self = operator.attrgetter(_meth_self)
get_function_closure = operator.attrgetter(_func_closure)
get_function_code = operator.attrgetter(_func_code)
get_function_defaults = operator.attrgetter(_func_defaults)
get_function_globals = operator.attrgetter(_func_globals)


if PY3:
    def iterkeys(d, **kw):
        return iter(d.keys(**kw))

    def itervalues(d, **kw):
        return iter(d.values(**kw))

    def iteritems(d, **kw):
        return iter(d.items(**kw))

    def iterlists(d, **kw):
        return iter(d.lists(**kw))

    viewkeys = operator.methodcaller("keys")

    viewvalues = operator.methodcaller("values")

    viewitems = operator.methodcaller("items")
else:
    def iterkeys(d, **kw):
        return d.iterkeys(**kw)

    def itervalues(d, **kw):
        return d.itervalues(**kw)

    def iteritems(d, **kw):
        return d.iteritems(**kw)

    def iterlists(d, **kw):
        return d.iterlists(**kw)

    viewkeys = operator.methodcaller("viewkeys")

    viewvalues = operator.methodcaller("viewvalues")

    viewitems = operator.methodcaller("viewitems")

_add_doc(iterkeys, "Return an iterator over the keys of a dictionary.")
_add_doc(itervalues, "Return an iterator over the values of a dictionary.")
_add_doc(iteritems,
         "Return an iterator over the (key, value) pairs of a dictionary.")
_add_doc(iterlists,
         "Return an iterator over the (key, [values]) pairs of a dictionary.")


if PY3:
    def b(s):
        return s.encode("latin-1")

    def u(s):
        return s
    unichr = chr
    import struct
    int2byte = struct.Struct(">B").pack
    del struct
    byte2int = operator.itemgetter(0)
    indexbytes = operator.getitem
    iterbytes = iter
    import io
    StringIO = io.StringIO
    BytesIO = io.BytesIO
    _assertCountEqual = "assertCountEqual"
    if sys.version_info[1] <= 1:
        _assertRaisesRegex = "assertRaisesRegexp"
        _assertRegex = "assertRegexpMatches"
    else:
        _assertRaisesRegex = "assertRaisesRegex"
        _assertRegex = "assertRegex"
else:
    def b(s):
        return s
    # Workaround for standalone backslash

    def u(s):
        return unicode(s.replace(r'\\', r'\\\\'), "unicode_escape")
    unichr = unichr
    int2byte = chr

    def byte2int(bs):
        return ord(bs[0])

    def indexbytes(buf, i):
        return ord(buf[i])
    iterbytes = functools.partial(itertools.imap, ord)
    import StringIO
    StringIO = BytesIO = StringIO.StringIO
    _assertCountEqual = "assertItemsEqual"
    _assertRaisesRegex = "assertRaisesRegexp"
    _assertRegex = "assertRegexpMatches"
_add_doc(b, """Byte literal""")
_add_doc(u, """Text literal""")


def assertCountEqual(self, *args, **kwargs):
    return getattr(self, _assertCountEqual)(*args, **kwargs)


def assertRaisesRegex(self, *args, **kwargs):
    return getattr(self, _assertRaisesRegex)(*args, **kwargs)


def assertRegex(self, *args, **kwargs):
    return getattr(self, _assertRegex)(*args, **kwargs)


if PY3:
    exec_ = getattr(moves.builtins, "exec")

    def reraise(tp, value, tb=None):
        if value is None:
            value = tp()
        if value.__traceback__ is not tb:
            raise value.with_traceback(tb)
        raise value

else:
    def exec_(_code_, _globs_=None, _locs_=None):
        """Execute code in a namespace."""
        if _globs_ is None:
            frame = sys._getframe(1)
            _globs_ = frame.f_globals
            if _locs_ is None:
                _locs_ = frame.f_locals
            del frame
        elif _locs_ is None:
            _locs_ = _globs_
        exec("""exec _code_ in _globs_, _locs_""")

    exec_("""def reraise(tp, value, tb=None):
    raise tp, value, tb
""")

filename:/usr/lib/python2.7/dist-packages/bs4/__init__.py
__doc__
"""Beautiful Soup
Elixir and Tonic
"The Screen-Scraper's Friend"
http://www.crummy.com/software/BeautifulSoup/

Beautiful Soup uses a pluggable XML or HTML parser to parse a
(possibly invalid) document into a tree representation. Beautiful Soup
provides provides methods and Pythonic idioms that make it easy to
navigate, search, and modify the parse tree.

Beautiful Soup works with Python 2.6 and up. It works better if lxml
and/or html5lib is installed.

For more than you ever wanted to know about Beautiful Soup, see the
documentation:
http://www.crummy.com/software/BeautifulSoup/bs4/doc/
"""

filename:/usr/lib/python2.7/dist-packages/bs4/testing.py
__doc__
"""Helper classes for tests."""

__license__ = "MIT"

import pickle
import copy
import functools
import unittest
from unittest import TestCase
from bs4 import BeautifulSoup
from bs4.element import (
    CharsetMetaAttributeValue,
    Comment,
    ContentMetaAttributeValue,
    Doctype,
    SoupStrainer,
)

from bs4.builder import HTMLParserTreeBuilder
default_builder = HTMLParserTreeBuilder


class SoupTest(unittest.TestCase):

    @property
    def default_builder(self):
        return default_builder()

    def soup(self, markup, **kwargs):
        """Build a Beautiful Soup object from markup."""
        builder = kwargs.pop('builder', self.default_builder)
        return BeautifulSoup(markup, builder=builder, **kwargs)

    def document_for(self, markup):
        """Turn an HTML fragment into a document.

        The details depend on the builder.
        """
        return self.default_builder.test_fragment_to_document(markup)

    def assertSoupEquals(self, to_parse, compare_parsed_to=None):
        builder = self.default_builder
        obj = BeautifulSoup(to_parse, builder=builder)
        if compare_parsed_to is None:
            compare_parsed_to = to_parse

        self.assertEqual(obj.decode(), self.document_for(compare_parsed_to))

    def assertConnectedness(self, element):
        """Ensure that next_element and previous_element are properly
        set for all descendants of the given element.
        """
        earlier = None
        for e in element.descendants:
            if earlier:
                self.assertEqual(e, earlier.next_element)
                self.assertEqual(earlier, e.previous_element)
            earlier = e

class HTMLTreeBuilderSmokeTest(object):

    """A basic test of a treebuilder's competence.

    Any HTML treebuilder, present or future, should be able to pass
    these tests. With invalid markup, there's room for interpretation,
    and different parsers can handle it differently. But with the
    markup in these tests, there's not much room for interpretation.
    """

    def test_pickle_and_unpickle_identity(self):
        # Pickling a tree, then unpickling it, yields a tree identical
        # to the original.
        tree = self.soup("<a><b>foo</a>")
        dumped = pickle.dumps(tree, 2)
        loaded = pickle.loads(dumped)
        self.assertEqual(loaded.__class__, BeautifulSoup)
        self.assertEqual(loaded.decode(), tree.decode())

    def assertDoctypeHandled(self, doctype_fragment):
        """Assert that a given doctype string is handled correctly."""
        doctype_str, soup = self._document_with_doctype(doctype_fragment)

        # Make sure a Doctype object was created.
        doctype = soup.contents[0]
        self.assertEqual(doctype.__class__, Doctype)
        self.assertEqual(doctype, doctype_fragment)
        self.assertEqual(str(soup)[:len(doctype_str)], doctype_str)

        # Make sure that the doctype was correctly associated with the
        # parse tree and that the rest of the document parsed.
        self.assertEqual(soup.p.contents[0], 'foo')

    def _document_with_doctype(self, doctype_fragment):
        """Generate and parse a document with the given doctype."""
        doctype = '<!DOCTYPE %s>' % doctype_fragment
        markup = doctype + '\n<p>foo</p>'
        soup = self.soup(markup)
        return doctype, soup

    def test_normal_doctypes(self):
        """Make sure normal, everyday HTML doctypes are handled correctly."""
        self.assertDoctypeHandled("html")
        self.assertDoctypeHandled(
            'html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"')

    def test_empty_doctype(self):
        soup = self.soup("<!DOCTYPE>")
        doctype = soup.contents[0]
        self.assertEqual("", doctype.strip())

    def test_public_doctype_with_url(self):
        doctype = 'html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"'
        self.assertDoctypeHandled(doctype)

    def test_system_doctype(self):
        self.assertDoctypeHandled('foo SYSTEM "http://www.example.com/"')

    def test_namespaced_system_doctype(self):
        # We can handle a namespaced doctype with a system ID.
        self.assertDoctypeHandled('xsl:stylesheet SYSTEM "htmlent.dtd"')

    def test_namespaced_public_doctype(self):
        # Test a namespaced doctype with a public id.
        self.assertDoctypeHandled('xsl:stylesheet PUBLIC "htmlent.dtd"')

    def test_real_xhtml_document(self):
        """A real XHTML document should come out more or less the same as it went in."""
        markup = b"""<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN">
<html xmlns="http://www.w3.org/1999/xhtml">
<head><title>Hello.</title></head>
<body>Goodbye.</body>
</html>"""
        soup = self.soup(markup)
        self.assertEqual(
            soup.encode("utf-8").replace(b"\n", b""),
            markup.replace(b"\n", b""))

    def test_processing_instruction(self):
        markup = b"""<?PITarget PIContent?>"""
        soup = self.soup(markup)
        self.assertEqual(markup, soup.encode("utf8"))

    def test_deepcopy(self):
        """Make sure you can copy the tree builder.

        This is important because the builder is part of a
        BeautifulSoup object, and we want to be able to copy that.
        """
        copy.deepcopy(self.default_builder)

    def test_p_tag_is_never_empty_element(self):
        """A <p> tag is never designated as an empty-element tag.

        Even if the markup shows it as an empty-element tag, it
        shouldn't be presented that way.
        """
        soup = self.soup("<p/>")
        self.assertFalse(soup.p.is_empty_element)
        self.assertEqual(str(soup.p), "<p></p>")

    def test_unclosed_tags_get_closed(self):
        """A tag that's not closed by the end of the document should be closed.

        This applies to all tags except empty-element tags.
        """
        self.assertSoupEquals("<p>", "<p></p>")
        self.assertSoupEquals("<b>", "<b></b>")

        self.assertSoupEquals("<br>", "<br/>")

    def test_br_is_always_empty_element_tag(self):
        """A <br> tag is designated as an empty-element tag.

        Some parsers treat <br></br> as one <br/> tag, some parsers as
        two tags, but it should always be an empty-element tag.
        """
        soup = self.soup("<br></br>")
        self.assertTrue(soup.br.is_empty_element)
        self.assertEqual(str(soup.br), "<br/>")

    def test_nested_formatting_elements(self):
        self.assertSoupEquals("<em><em></em></em>")

    def test_double_head(self):
        html = '''<!DOCTYPE html>
<html>
<head>
<title>Ordinary HEAD element test</title>
</head>
<script type="text/javascript">
alert("Help!");
</script>
<body>
Hello, world!
</body>
</html>
'''
        soup = self.soup(html)
        self.assertEqual("text/javascript", soup.find('script')['type'])

    def test_comment(self):
        # Comments are represented as Comment objects.
        markup = "<p>foo<!--foobar-->baz</p>"
        self.assertSoupEquals(markup)

        soup = self.soup(markup)
        comment = soup.find(text="foobar")
        self.assertEqual(comment.__class__, Comment)

        # The comment is properly integrated into the tree.
        foo = soup.find(text="foo")
        self.assertEqual(comment, foo.next_element)
        baz = soup.find(text="baz")
        self.assertEqual(comment, baz.previous_element)

    def test_preserved_whitespace_in_pre_and_textarea(self):
        """Whitespace must be preserved in <pre> and <textarea> tags."""
        self.assertSoupEquals("<pre>   </pre>")
        self.assertSoupEquals("<textarea> woo  </textarea>")

    def test_nested_inline_elements(self):
        """Inline elements can be nested indefinitely."""
        b_tag = "<b>Inside a B tag</b>"
        self.assertSoupEquals(b_tag)

        nested_b_tag = "<p>A <i>nested <b>tag</b></i></p>"
        self.assertSoupEquals(nested_b_tag)

        double_nested_b_tag = "<p>A <a>doubly <i>nested <b>tag</b></i></a></p>"
        self.assertSoupEquals(nested_b_tag)

    def test_nested_block_level_elements(self):
        """Block elements can be nested."""
        soup = self.soup('<blockquote><p><b>Foo</b></p></blockquote>')
        blockquote = soup.blockquote
        self.assertEqual(blockquote.p.b.string, 'Foo')
        self.assertEqual(blockquote.b.string, 'Foo')

    def test_correctly_nested_tables(self):
        """One table can go inside another one."""
        markup = ('<table id="1">'
                  '<tr>'
                  "<td>Here's another table:"
                  '<table id="2">'
                  '<tr><td>foo</td></tr>'
                  '</table></td>')

        self.assertSoupEquals(
            markup,
            '<table id="1"><tr><td>Here\'s another table:'
            '<table id="2"><tr><td>foo</td></tr></table>'
            '</td></tr></table>')

        self.assertSoupEquals(
            "<table><thead><tr><td>Foo</td></tr></thead>"
            "<tbody><tr><td>Bar</td></tr></tbody>"
            "<tfoot><tr><td>Baz</td></tr></tfoot></table>")

    def test_deeply_nested_multivalued_attribute(self):
        # html5lib can set the attributes of the same tag many times
        # as it rearranges the tree. This has caused problems with
        # multivalued attributes.
        markup = '<table><div><div class="css"></div></div></table>'
        soup = self.soup(markup)
        self.assertEqual(["css"], soup.div.div['class'])

    def test_multivalued_attribute_on_html(self):
        # html5lib uses a different API to set the attributes ot the
        # <html> tag. This has caused problems with multivalued
        # attributes.
        markup = '<html class="a b"></html>'
        soup = self.soup(markup)
        self.assertEqual(["a", "b"], soup.html['class'])

    def test_angle_brackets_in_attribute_values_are_escaped(self):
        self.assertSoupEquals('<a b="<a>"></a>', '<a b="&lt;a&gt;"></a>')

    def test_entities_in_attributes_converted_to_unicode(self):
        expect = u'<p id="pi\N{LATIN SMALL LETTER N WITH TILDE}ata"></p>'
        self.assertSoupEquals('<p id="pi&#241;ata"></p>', expect)
        self.assertSoupEquals('<p id="pi&#xf1;ata"></p>', expect)
        self.assertSoupEquals('<p id="pi&#Xf1;ata"></p>', expect)
        self.assertSoupEquals('<p id="pi&ntilde;ata"></p>', expect)

    def test_entities_in_text_converted_to_unicode(self):
        expect = u'<p>pi\N{LATIN SMALL LETTER N WITH TILDE}ata</p>'
        self.assertSoupEquals("<p>pi&#241;ata</p>", expect)
        self.assertSoupEquals("<p>pi&#xf1;ata</p>", expect)
        self.assertSoupEquals("<p>pi&#Xf1;ata</p>", expect)
        self.assertSoupEquals("<p>pi&ntilde;ata</p>", expect)

    def test_quot_entity_converted_to_quotation_mark(self):
        self.assertSoupEquals("<p>I said &quot;good day!&quot;</p>",
                              '<p>I said "good day!"</p>')

    def test_out_of_range_entity(self):
        expect = u"\N{REPLACEMENT CHARACTER}"
        self.assertSoupEquals("&#10000000000000;", expect)
        self.assertSoupEquals("&#x10000000000000;", expect)
        self.assertSoupEquals("&#1000000000;", expect)

    def test_multipart_strings(self):
        "Mostly to prevent a recurrence of a bug in the html5lib treebuilder."
        soup = self.soup("<html><h2>\nfoo</h2><p></p></html>")
        self.assertEqual("p", soup.h2.string.next_element.name)
        self.assertEqual("p", soup.p.name)
        self.assertConnectedness(soup)

    def test_head_tag_between_head_and_body(self):
        "Prevent recurrence of a bug in the html5lib treebuilder."
        content = """<html><head></head>
  <link></link>
  <body>foo</body>
</html>
"""

filename:/usr/lib/python2.7/dist-packages/bs4/builder/_htmlparser.py
__doc__
"""Use the HTMLParser library to parse HTML files that aren't too bad."""

__all__ = [
    'HTMLParserTreeBuilder',
    ]

from HTMLParser import HTMLParser

try:
    from HTMLParser import HTMLParseError
except ImportError, e:
    # HTMLParseError is removed in Python 3.5. Since it can never be
    # thrown in 3.5, we can just define our own class as a placeholder.
    class HTMLParseError(Exception):
        pass

import sys
import warnings

# Starting in Python 3.2, the HTMLParser constructor takes a 'strict'
# argument, which we'd like to set to False. Unfortunately,
# http://bugs.python.org/issue13273 makes strict=True a better bet
# before Python 3.2.3.
#
# At the end of this file, we monkeypatch HTMLParser so that
# strict=True works well on Python 3.2.2.
major, minor, release = sys.version_info[:3]
CONSTRUCTOR_TAKES_STRICT = major == 3 and minor == 2 and release >= 3
CONSTRUCTOR_STRICT_IS_DEPRECATED = major == 3 and minor == 3
CONSTRUCTOR_TAKES_CONVERT_CHARREFS = major == 3 and minor >= 4


from bs4.element import (
    CData,
    Comment,
    Declaration,
    Doctype,
    ProcessingInstruction,
    )
from bs4.dammit import EntitySubstitution, UnicodeDammit

from bs4.builder import (
    HTML,
    HTMLTreeBuilder,
    STRICT,
    )


HTMLPARSER = 'html.parser'

class BeautifulSoupHTMLParser(HTMLParser):
    def handle_starttag(self, name, attrs):
        # XXX namespace
        attr_dict = {}
        for key, value in attrs:
            # Change None attribute values to the empty string
            # for consistency with the other tree builders.
            if value is None:
                value = ''
            attr_dict[key] = value
            attrvalue = '""'
        self.soup.handle_starttag(name, None, None, attr_dict)

    def handle_endtag(self, name):
        self.soup.handle_endtag(name)

    def handle_data(self, data):
        self.soup.handle_data(data)

    def handle_charref(self, name):
        # XXX workaround for a bug in HTMLParser. Remove this once
        # it's fixed in all supported versions.
        # http://bugs.python.org/issue13633
        if name.startswith('x'):
            real_name = int(name.lstrip('x'), 16)
        elif name.startswith('X'):
            real_name = int(name.lstrip('X'), 16)
        else:
            real_name = int(name)

        try:
            data = unichr(real_name)
        except (ValueError, OverflowError), e:
            data = u"\N{REPLACEMENT CHARACTER}"

        self.handle_data(data)

    def handle_entityref(self, name):
        character = EntitySubstitution.HTML_ENTITY_TO_CHARACTER.get(name)
        if character is not None:
            data = character
        else:
            data = "&%s;" % name
        self.handle_data(data)

    def handle_comment(self, data):
        self.soup.endData()
        self.soup.handle_data(data)
        self.soup.endData(Comment)

    def handle_decl(self, data):
        self.soup.endData()
        if data.startswith("DOCTYPE "):
            data = data[len("DOCTYPE "):]
        elif data == 'DOCTYPE':
            # i.e. "<!DOCTYPE>"
            data = ''
        self.soup.handle_data(data)
        self.soup.endData(Doctype)

    def unknown_decl(self, data):
        if data.upper().startswith('CDATA['):
            cls = CData
            data = data[len('CDATA['):]
        else:
            cls = Declaration
        self.soup.endData()
        self.soup.handle_data(data)
        self.soup.endData(cls)

    def handle_pi(self, data):
        self.soup.endData()
        self.soup.handle_data(data)
        self.soup.endData(ProcessingInstruction)


class HTMLParserTreeBuilder(HTMLTreeBuilder):

    is_xml = False
    picklable = True
    NAME = HTMLPARSER
    features = [NAME, HTML, STRICT]

    def __init__(self, *args, **kwargs):
        if CONSTRUCTOR_TAKES_STRICT and not CONSTRUCTOR_STRICT_IS_DEPRECATED:
            kwargs['strict'] = False
        if CONSTRUCTOR_TAKES_CONVERT_CHARREFS:
            kwargs['convert_charrefs'] = False
        self.parser_args = (args, kwargs)

    def prepare_markup(self, markup, user_specified_encoding=None,
                       document_declared_encoding=None, exclude_encodings=None):
        """
        :return: A 4-tuple (markup, original encoding, encoding
        declared within markup, whether any characters had to be
        replaced with REPLACEMENT CHARACTER).
        """
        if isinstance(markup, unicode):
            yield (markup, None, None, False)
            return

        try_encodings = [user_specified_encoding, document_declared_encoding]
        dammit = UnicodeDammit(markup, try_encodings, is_html=True,
                               exclude_encodings=exclude_encodings)
        yield (dammit.markup, dammit.original_encoding,
               dammit.declared_html_encoding,
               dammit.contains_replacement_characters)

    def feed(self, markup):
        args, kwargs = self.parser_args
        parser = BeautifulSoupHTMLParser(*args, **kwargs)
        parser.soup = self.soup
        try:
            parser.feed(markup)
        except HTMLParseError, e:
            warnings.warn(RuntimeWarning(
                "Python's built-in HTMLParser cannot parse the given document. This is not a bug in Beautiful Soup. The best solution is to install an external parser (lxml or html5lib), and use Beautiful Soup with that parser. See http://www.crummy.com/software/BeautifulSoup/bs4/doc/#installing-a-parser for help."))
            raise e

# Patch 3.2 versions of HTMLParser earlier than 3.2.3 to use some
# 3.2.3 code. This ensures they don't treat markup like <p></p> as a
# string.
#
# XXX This code can be removed once most Python 3 users are on 3.2.3.
if major == 3 and minor == 2 and not CONSTRUCTOR_TAKES_STRICT:
    import re
    attrfind_tolerant = re.compile(
        r'\s*((?<=[\'"\s])[^\s/>][^\s/=>]*)(\s*=+\s*'
        r'(\'[^\']*\'|"[^"]*"|(?![\'"])[^>\s]*))?')
    HTMLParserTreeBuilder.attrfind_tolerant = attrfind_tolerant

    locatestarttagend = re.compile(r"""
  <[a-zA-Z][-.a-zA-Z0-9:_]*          # tag name
  (?:\s+                             # whitespace before attribute name
    (?:[a-zA-Z_][-.:a-zA-Z0-9_]*     # attribute name
      (?:\s*=\s*                     # value indicator
        (?:'[^']*'                   # LITA-enclosed value
          |\"[^\"]*\"                # LIT-enclosed value
          |[^'\">\s]+                # bare value
         )
       )?
     )
   )*
  \s*                                # trailing whitespace
""", re.VERBOSE)

filename:/usr/lib/python2.7/dist-packages/bs4/diagnose.py
__doc__
"""Diagnostic functions, mainly for use when doing tech support."""

__license__ = "MIT"

import cProfile
from StringIO import StringIO
from HTMLParser import HTMLParser
import bs4
from bs4 import BeautifulSoup, __version__
from bs4.builder import builder_registry

import os
import pstats
import random
import tempfile
import time
import traceback
import sys
import cProfile

def diagnose(data):
    """Diagnostic suite for isolating common problems."""
    print "Diagnostic running on Beautiful Soup %s" % __version__
    print "Python version %s" % sys.version

    basic_parsers = ["html.parser", "html5lib", "lxml"]
    for name in basic_parsers:
        for builder in builder_registry.builders:
            if name in builder.features:
                break
        else:
            basic_parsers.remove(name)
            print (
                "I noticed that %s is not installed. Installing it may help." %
                name)

    if 'lxml' in basic_parsers:
        basic_parsers.append(["lxml", "xml"])
        try:
            from lxml import etree
            print "Found lxml version %s" % ".".join(map(str,etree.LXML_VERSION))
        except ImportError, e:
            print (
                "lxml is not installed or couldn't be imported.")


    if 'html5lib' in basic_parsers:
        try:
            import html5lib
            print "Found html5lib version %s" % html5lib.__version__
        except ImportError, e:
            print (
                "html5lib is not installed or couldn't be imported.")

    if hasattr(data, 'read'):
        data = data.read()
    elif os.path.exists(data):
        print '"%s" looks like a filename. Reading data from the file.' % data
        data = open(data).read()
    elif data.startswith("http:") or data.startswith("https:"):
        print '"%s" looks like a URL. Beautiful Soup is not an HTTP client.' % data
        print "You need to use some other library to get the document behind the URL, and feed that document to Beautiful Soup."
        return
    print

    for parser in basic_parsers:
        print "Trying to parse your markup with %s" % parser
        success = False
        try:
            soup = BeautifulSoup(data, parser)
            success = True
        except Exception, e:
            print "%s could not parse the markup." % parser
            traceback.print_exc()
        if success:
            print "Here's what %s did with the markup:" % parser
            print soup.prettify()

        print "-" * 80

def lxml_trace(data, html=True, **kwargs):
    """Print out the lxml events that occur during parsing.

    This lets you see how lxml parses a document when no Beautiful
    Soup code is running.
    """
    from lxml import etree
    for event, element in etree.iterparse(StringIO(data), html=html, **kwargs):
        print("%s, %4s, %s" % (event, element.tag, element.text))

class AnnouncingParser(HTMLParser):
    """Announces HTMLParser parse events, without doing anything else."""

    def _p(self, s):
        print(s)

    def handle_starttag(self, name, attrs):
        self._p("%s START" % name)

    def handle_endtag(self, name):
        self._p("%s END" % name)

    def handle_data(self, data):
        self._p("%s DATA" % data)

    def handle_charref(self, name):
        self._p("%s CHARREF" % name)

    def handle_entityref(self, name):
        self._p("%s ENTITYREF" % name)

    def handle_comment(self, data):
        self._p("%s COMMENT" % data)

    def handle_decl(self, data):
        self._p("%s DECL" % data)

    def unknown_decl(self, data):
        self._p("%s UNKNOWN-DECL" % data)

    def handle_pi(self, data):
        self._p("%s PI" % data)

def htmlparser_trace(data):
    """Print out the HTMLParser events that occur during parsing.

    This lets you see how HTMLParser parses a document when no
    Beautiful Soup code is running.
    """
    parser = AnnouncingParser()
    parser.feed(data)

_vowels = "aeiou"
_consonants = "bcdfghjklmnpqrstvwxyz"

def rword(length=5):
    "Generate a random word-like string."
    s = ''
    for i in range(length):
        if i % 2 == 0:
            t = _consonants
        else:
            t = _vowels
        s += random.choice(t)
    return s

def rsentence(length=4):
    "Generate a random sentence-like string."
    return " ".join(rword(random.randint(4,9)) for i in range(length))
        
def rdoc(num_elements=1000):
    """Randomly generate an invalid HTML document."""
    tag_names = ['p', 'div', 'span', 'i', 'b', 'script', 'table']
    elements = []
    for i in range(num_elements):
        choice = random.randint(0,3)
        if choice == 0:
            # New tag.
            tag_name = random.choice(tag_names)
            elements.append("<%s>" % tag_name)
        elif choice == 1:
            elements.append(rsentence(random.randint(1,4)))
        elif choice == 2:
            # Close a tag.
            tag_name = random.choice(tag_names)
            elements.append("</%s>" % tag_name)
    return "<html>" + "\n".join(elements) + "</html>"

def benchmark_parsers(num_elements=100000):
    """Very basic head-to-head performance benchmark."""
    print "Comparative parser benchmark on Beautiful Soup %s" % __version__
    data = rdoc(num_elements)
    print "Generated a large invalid HTML document (%d bytes)." % len(data)
    
    for parser in ["lxml", ["lxml", "html"], "html5lib", "html.parser"]:
        success = False
        try:
            a = time.time()
            soup = BeautifulSoup(data, parser)
            b = time.time()
            success = True
        except Exception, e:
            print "%s could not parse the markup." % parser
            traceback.print_exc()
        if success:
            print "BS4+%s parsed the markup in %.2fs." % (parser, b-a)

    from lxml import etree
    a = time.time()
    etree.HTML(data)
    b = time.time()
    print "Raw lxml parsed the markup in %.2fs." % (b-a)

    import html5lib
    parser = html5lib.HTMLParser()
    a = time.time()
    parser.parse(data)
    b = time.time()
    print "Raw html5lib parsed the markup in %.2fs." % (b-a)

def profile(num_elements=100000, parser="lxml"):

    filehandle = tempfile.NamedTemporaryFile()
    filename = filehandle.name

    data = rdoc(num_elements)
    vars = dict(bs4=bs4, data=data, parser=parser)
    cProfile.runctx('bs4.BeautifulSoup(data, parser)' , vars, vars, filename)

    stats = pstats.Stats(filename)
    # stats.strip_dirs()
    stats.sort_stats("cumulative")
    stats.print_stats('_html5lib|bs4', 50)

if __name__ == '__main__':
    diagnose(sys.stdin.read())

filename:/usr/lib/python2.7/dist-packages/bs4/tests/__init__.py
__doc__
"The beautifulsoup tests."

filename:/usr/lib/python2.7/dist-packages/bs4/tests/test_docs.py
__doc__
"Test harness for doctests."

# pylint: disable-msg=E0611,W0142

__metaclass__ = type
__all__ = [
    'additional_tests',
    ]

import atexit
import doctest
import os
#from pkg_resources import (
#    resource_filename, resource_exists, resource_listdir, cleanup_resources)
import unittest

DOCTEST_FLAGS = (
    doctest.ELLIPSIS |
    doctest.NORMALIZE_WHITESPACE |
    doctest.REPORT_NDIFF)


# def additional_tests():
#     "Run the doc tests (README.txt and docs/*, if any exist)"
#     doctest_files = [
#         os.path.abspath(resource_filename('bs4', 'README.txt'))]
#     if resource_exists('bs4', 'docs'):
#         for name in resource_listdir('bs4', 'docs'):
#             if name.endswith('.txt'):
#                 doctest_files.append(
#                     os.path.abspath(
#                         resource_filename('bs4', 'docs/%s' % name)))
#     kwargs = dict(module_relative=False, optionflags=DOCTEST_FLAGS)
#     atexit.register(cleanup_resources)
#     return unittest.TestSuite((
#         doctest.DocFileSuite(*doctest_files, **kwargs)))

filename:/usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyc
__doc__
Û
]–	Vc           @   s‰  d  Z  d d l m Z d d l Z d d l Z d d l Z d d l Z d d l m Z d d l	 m
 Z
 m Z d d l m Z m Z m Z m Z m Z m Z m Z m Z d d l m Z m Z e
 j d É e k	 Z e
 j d	 É e k	 Z d
 e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ  d e f d Ñ  É  YZ! d e f d Ñ  É  YZ" d e f d Ñ  É  YZ# d e f d Ñ  É  YZ$ d e$ f d Ñ  É  YZ% d e$ f d Ñ  É  YZ& d  e f d! Ñ  É  YZ' d" e' f d# Ñ  É  YZ( d$ e' f d% Ñ  É  YZ) d& e f d' Ñ  É  YZ* d( e f d) Ñ  É  YZ+ d* e f d+ Ñ  É  YZ, d, e f d- Ñ  É  YZ- d. e f d/ Ñ  É  YZ. d0 e f d1 Ñ  É  YZ/ d2 e f d3 Ñ  É  YZ0 d4 e f d5 Ñ  É  YZ1 d6 e f d7 Ñ  É  YZ2 d S(8   s8  Tests for Beautiful Soup's tree traversal methods.

The tree traversal methods are the main advantage of using Beautiful
Soup over just using a parser.

Different parsers will build different Beautiful Soup trees given the
same markup, but all Beautiful Soup trees can be traversed with the
methods tested here.
iˇˇˇˇ(   t	   set_traceN(   t   BeautifulSoup(   t   builder_registryt   HTMLParserTreeBuilder(   t   PY3Kt   CDatat   Commentt   Declarationt   Doctypet   NavigableStringt   SoupStrainert   Tag(   t   SoupTestt   skipIft   xmlt   lxmlt   TreeTestc           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c         C   s*   |  j  g  | D] } | j ^ q | É d S(   s›   Make sure that the given tags have the correct text.

        This is used in tests that define a bunch of tags, each
        containing a single string, and then select certain strings by
        some mechanism.
        N(   t   assertEqualt   string(   t   selft   tagst   should_matcht   tag(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   assertSelects*   s    c         C   s+   |  j  g  | D] } | d ^ q | É d S(   s‹   Make sure that the given tags have the correct IDs.

        This is used in tests that define a bunch of tags, each
        containing a single string, and then select certain strings by
        some mechanism.
        t   idN(   R   (   R   R   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   assertSelectsIDs3   s    (   t   __name__t
   __module__R   R   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyR   (   s   		t   TestFindc           B   s;   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sà   Basic tests of the find() method.

    find() just calls find_all() with limit=1, so it's not tested all
    that thouroughly here.
    c         C   s/   |  j  d É } |  j | j d É j d É d  S(   Ns    <a>1</a><b>2</b><a>3</a><b>4</b>t   bt   2(   t   soupR   t   findR   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_tagD   s    c         C   s/   |  j  d É } |  j | j d d É d É d  S(   Nu   <h1>R√§ksm√∂rg√•s</h1>R   u   R√§ksm√∂rg√•s(   R   R   R    (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_unicode_text_findH   s    c         C   s<   |  j  d É } t | É |  j d | j d d É j É d  S(   Nu&   <h1 id="R√§ksm√∂rg√•s">here it is</h1>s
   here it isR   u   R√§ksm√∂rg√•s(   R   t   strR   R    t   text(   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_unicode_attribute_findL   s    
c         C   s/   |  j  d É } |  j d t | j É  É É d S(   s)   Test an optimization that finds all tags.s   <a>foo</a><b>bar</b>i   N(   R   R   t   lent   find_all(   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_everythingR   s    c         C   s2   |  j  d É } |  j d t | j d É É É d S(   s;   Test an optimization that finds all tags with a given name.s   <a>foo</a><b>bar</b><a>baz</a>i   t   aN(   R   R   R&   R'   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_everything_with_nameW   s    (   R   R   t   __doc__R!   R"   R%   R(   R*   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyR   =   s   				t   TestFindAllc           B   s;   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s%   Basic tests of the find_all() method.c         C   sÃ   |  j  d É } |  j | j d d É d g É |  j | j d d É d g É |  j | j d d d g É d d g É |  j | j d t j d É É d d d	 g É |  j | j d t É d d d	 g É d
 S(   s'   You can search the tree for text nodes.s   <html>Foo<b>bar</b>ª</html>R   t   baru   barR$   t   Foou   Foos   .*u   ¬ªN(   R   R   R'   t   ret   compilet   True(   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_all_text_nodes_   s    "c         C   sπ   |  j  d É } |  j | j d d d Éd d d g É |  j | j d d d Éd g É |  j | j d d d	 Éd d d d
 d g É |  j | j d d d Éd d d d
 d g É d S(   s7   You can limit the number of items returned by find_all.s(   <a>1</a><a>2</a><a>3</a><a>4</a><a>5</a>R)   t   limiti   t   1R   t   3i   i
   t   4t   5i    N(   R   R   R'   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_all_limito   s    ("(c         C   sQ   |  j  d É } |  j | d d d Éd g É |  j | j d d É d g É d  S(	   Ns!   <a>1</a><b>2<a id='foo'>3</a></b>R)   R3   i   R4   R   t   fooR5   (   R   R   R   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt%   test_calling_a_tag_is_calling_findall{   s    c         C   s?   |  j  d É } g  } | j | É |  j g  | j | É É d  S(   Ns   <a></a>(   R   t   appendR   R'   (   R   R   t   l(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pytT   test_find_all_with_self_referential_data_structure_does_not_cause_infinite_recursionÄ   s    c         C   sÖ   |  j  d É } | j d É } |  j t | d É É | j t É } |  j t | d É É | j d d É } |  j t | d É É d S(   s%   All find_all calls return a ResultSets   <a></a>R)   t   sourceR$   R9   N(   R   R'   t
   assertTruet   hasattrR1   (   R   R   t   result(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_all_resultsetä   s    (   R   R   R+   R2   R8   R:   R=   RB   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyR,   \   s   				
t   TestFindAllBasicNamespacesc           B   s   e  Z d  Ñ  Z RS(   c         C   sU   |  j  d É } |  j d | j d É j É |  j d | j d i d d 6É j É d  S(   Ns0   <mathml:msqrt>4</mathml:msqrt><a svg:fill="red">R6   s   mathml:msqrtR)   t   attrst   reds   svg:fill(   R   R   R    R   t   name(   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_by_namespaced_nameô   s    (   R   R   RG   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyRC   ó   s   t   TestFindAllByNamec           B   sh   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z RS(   s&   Test ways of finding tags by tag name.c         C   s)   t  t |  É j É  |  j d É |  _ d  S(   Nsç   <a>First tag.</a>
                                  <b>Second tag.</b>
                                  <c>Third <a>Nested tag.</a> tag.</c>(   t   superR   t   setUpR   t   tree(   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyRJ   ¢   s    c         C   s&   |  j  |  j j d É d d g É d  S(   NR)   s
   First tag.s   Nested tag.(   R   RK   R'   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_all_by_tag_name®   s    c         C   sÇ   |  j  |  j j d d d Éd g É |  j  |  j j d d t Éd d g É |  j  |  j j d d t j d É Éd d g É d  S(   NR)   R$   s
   First tag.s   Nested tag.R   (   R   RK   R'   R1   R/   R0   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_all_by_name_and_text≠   s    "c         C   s&   |  j  |  j j j d É d g É d  S(   NR)   s   Nested tag.(   R   RK   t   cR'   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt!   test_find_all_on_non_root_elementπ   s    c         C   s#   |  j  |  j d É d d g É d  S(   NR)   s
   First tag.s   Nested tag.(   R   RK   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt%   test_calling_element_invokes_find_allΩ   s    c         C   s,   |  j  |  j j t d É É d d g É d  S(   NR)   s
   First tag.s   Nested tag.(   R   RK   R'   R
   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_all_by_tag_strainer¿   s    c         C   s/   |  j  |  j j d d g É d d d g É d  S(   NR)   R   s
   First tag.s   Second tag.s   Nested tag.(   R   RK   R'   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_all_by_tag_names≈   s    c         C   s7   |  j  |  j j i t d 6t d 6É d d d g É d  S(   NR)   R   s
   First tag.s   Second tag.s   Nested tag.(   R   RK   R'   R1   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_all_by_tag_dict    s    c         C   s2   |  j  |  j j t j d É É d d d g É d  S(   Ns   ^[ab]$s
   First tag.s   Second tag.s   Nested tag.(   R   RK   R'   R/   R0   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_all_by_tag_reœ   s    c         C   s;   d Ñ  } |  j  d É } |  j | j | É d d g É d  S(   Nc         S   s   |  j  |  j d É k S(   NR   (   RF   t   get(   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   id_matches_name◊   s    sÉ   <a id="a">Match 1.</a>
                            <a id="1">Does not match.</a>
                            <b id="b">Match 2.</a>s   Match 1.s   Match 2.(   R   R   R'   (   R   RV   RK   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt'   test_find_all_with_tags_matching_method‘   s
    		(   R   R   R+   RJ   RL   RM   RO   RP   RQ   RR   RS   RT   RW   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyRH   ü   s   									t   TestFindAllByAttributec           B   sò   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s5   |  j  d É } |  j | j d d É d d g É d  S(   Ns≈   
                         <a id="first">Matching a.</a>
                         <a id="second">
                          Non-matching <b id="first">Matching b.</b>a.
                         </a>R   t   firsts   Matching a.s   Matching b.(   R   R   R'   (   R   RK   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_all_by_attribute_name‰   s    	c         C   s¶   d j  d É } d j  d É } |  j | É } |  j | j g | j d | É É |  j | j g | j d | j d É É É |  j | j g | j d | d g É É d  S(   Nu   ◊ù◊ï◊ú◊©t   utf8u   <a title="◊ù◊ï◊ú◊©"></a>t   titles   something else(   t   encodeR   R   R)   R'   t   decode(   R   t   peacet   dataR   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt%   test_find_all_by_utf8_attribute_valueÔ   s    "+c         C   s~   |  j  d É } |  j | j d d É d g É |  j | j d i d d 6É d g É |  j | j d i d d 6É d	 g É d  S(
   Ns0  
                         <a name="name1" class="class1">Name match.</a>
                         <a name="name2" class="class2">Class match.</a>
                         <a name="name3" class="class3">Non-match.</a>
                         <name1>A tag called 'name1'.</name1>
                         RF   t   name1s   A tag called 'name1'.RD   s   Name match.t   class2t   classs   Class match.(   R   R   R'   (   R   RK   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_all_by_attribute_dict˜   s    	

c         C   s¯   |  j  d É } |  j | j d d d Éd g É |  j | j d d d Éd g É |  j | j d d d	 Éd g É |  j | j d d É d g É |  j | j d
 d É d d g É |  j | j d d É d g É |  j | j d d	 É d g É d  S(   NsÓ   
                         <a class="1">Class 1.</a>
                         <a class="2">Class 2.</a>
                         <b class="1">Class 1.</b>
                         <c class="3 4">Class 3 and 4.</c>
                         R)   t   class_R4   s   Class 1.RN   R5   s   Class 3 and 4.R6   RD   (   R   R   R'   (   R   RK   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_all_by_class  s    	""""c         C   s£   |  j  d É } | j d d t j d É É} |  j | d g É | j d d t j d É É} |  j | d g É | j d d t j d É É} |  j | g  É d  S(   Ns#   <gar class='foo bar'>Found it</gar>t   garRf   t   os   Found itR)   s   o b(   R   R'   R/   R0   R   (   R   RK   t   f(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt0   test_find_by_class_when_multiple_classes_present   s    c         C   sà   |  j  d É } |  j | j d t j d É É d g É d Ñ  } |  j | j d | É g  É d Ñ  } |  j | j d | É d g É d  S(   Ns   <a class='bar'>Found it</a>R)   t   bas   Found itc         S   s   t  |  É d k S(   Ni   (   R&   (   t   value(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   big_attribute_value3  s    c         S   s   t  |  É d k S(   Ni   (   R&   (   Rm   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   small_attribute_value8  s    (   R   R   R'   R/   R0   (   R   R   Rn   Ro   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt:   test_find_all_with_non_dictionary_for_attrs_finds_by_class.  s    (		c         C   s∆   |  j  d É } | j d É \ } } |  j | | g | j d d É É |  j | g | j d d É É |  j | g | j d d d ÉÉ |  j | g | j d d É É |  j g  | j d d É É d  S(   Ns*   <a class="foo bar"></a><a class="foo"></a>R)   R9   R-   Rf   s   foo bars   bar foo(   R   R'   R   (   R   R   R)   t   a2(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt:   test_find_all_with_string_for_attrs_finds_multiple_classes>  s    ""c         C   sE   |  j  d É } t d i d d 6É } |  j | j | É d g É d  S(   Nsi   
                         <a id="first">Match.</a>
                         <a id="second">Non-match.</a>RD   RY   R   s   Match.(   R   R
   R   R'   (   R   RK   t   strainer(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt'   test_find_all_by_attribute_soupstrainerJ  s    	c         C   s5   |  j  d É } |  j | j d d d  Éd g É d  S(   NsÅ   <a id="1">ID present.</a>
                            <a>No ID present.</a>
                            <a id="">ID is empty.</a>R)   R   s   No ID present.(   R   R   R'   t   None(   R   RK   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt#   test_find_all_with_missing_atributeR  s    	c         C   s5   |  j  d É } |  j | j d t É d d g É d  S(   NsÅ   <a id="1">ID present.</a>
                            <a>No ID present.</a>
                            <a id="">ID is empty.</a>R   s   ID present.s   ID is empty.(   R   R   R'   R1   (   R   RK   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt$   test_find_all_with_defined_attributeZ  s    	c         C   sW   |  j  d É } d d g } |  j | j d d É | É |  j | j d d É | É d  S(   Ns[   <a id=1>Unquoted attribute.</a>
                            <a id="1">Quoted attribute.</a>s   Unquoted attribute.s   Quoted attribute.R   i   R4   (   R   R   R'   (   R   RK   t   expected(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt$   test_find_all_with_numeric_attributec  s
    	c         C   s>   |  j  d É } |  j | j d d d d g É d d g É d  S(   Nsë   <a id="1">1</a>
                            <a id="2">2</a>
                            <a id="3">3</a>
                            <a>No ID.</a>R   R4   R5   R6   (   R   R   R'   (   R   RK   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt(   test_find_all_with_list_attribute_valuesl  s    	c         C   s>   |  j  d É } |  j | j d t j d É É d d g É d  S(   Nsﬁ   <a id="a">One a.</a>
                            <a id="aa">Two as.</a>
                            <a id="ab">Mixed as and bs.</a>
                            <a id="b">One b.</a>
                            <a>No ID.</a>R   s   ^a+$s   One a.s   Two as.(   R   R   R'   R/   R0   (   R   RK   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt5   test_find_all_with_regular_expression_attribute_valuev  s    	c         C   s|   |  j  d É } | j } |  j | g | j d d d ÉÉ |  j g  | j d d d ÉÉ |  j g  | j d d d ÉÉ d  S(   Ns   <b>foo</b><b>bar</b><a>foo</a>R)   R$   R9   R-   (   R   R)   R   R'   (   R   R   R)   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt'   test_find_by_name_and_containing_stringÉ  s
    	"c         C   s;   |  j  d É } |  j | j d É | j d d d ÉÉ d  S(   Ns"   <a>foo</a><a><b><c>foo</c></b></a>R)   R$   R9   (   R   R   R'   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt=   test_find_by_name_and_containing_string_when_string_is_buriedã  s    c         C   sc   |  j  d É } | j } |  j | g | j d d d d É É |  j g  | j d d d d É É d  S(   Ns"   <b id="1">foo</b><a id="2">foo</a>R   i   R$   R9   i   R-   (   R   R)   R   R'   (   R   R   R)   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt,   test_find_by_attribute_and_containing_stringè  s    	%(   R   R   RZ   Ra   Re   Rg   Rk   Rp   Rr   Rt   Rv   Rw   Ry   Rz   R{   R|   R}   R~   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyRX   ‚   s    														
			t	   TestIndexc           B   s   e  Z d  Z d Ñ  Z RS(   s   Test Tag.indexc         C   sk   |  j  d É } | j } x6 t | j É D]% \ } } |  j | | j | É É q( W|  j t | j d É d  S(   Nsh  <div>
                            <a>Identical</a>
                            <b>Not identical</b>
                            <a>Identical</a>

                            <c><d>Identical with child</d></c>
                            <b>Also not identical</b>
                            <c><d>Identical with child</d></c>
                            </div>i   (   R   t   divt	   enumeratet   contentsR   t   indext   assertRaisest
   ValueError(   R   RK   RÄ   t   it   element(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt
   test_indexõ  s    		(   R   R   R+   Rà   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyR   ô  s   t   TestParentOperationsc           B   s_   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z RS(
   s;   Test navigation and searching through an element's parents.c         C   s8   t  t |  É j É  |  j d É |  _ |  j j |  _ d  S(   Ns1  <ul id="empty"></ul>
                                 <ul id="top">
                                  <ul id="middle">
                                   <ul id="bottom">
                                    <b>Start here</b>
                                   </ul>
                                  </ul>(   RI   Râ   RJ   R   RK   R   t   start(   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyRJ   Æ  s    c         C   s[   |  j  |  j j d d É |  j  |  j j j d d É |  j  |  j j j j d d É d  S(   NR   t   bottomt   middlet   top(   R   Rä   t   parent(   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_parent∫  s    c         C   s*   |  j  j d } |  j | j |  j  É d  S(   Ni    (   RK   RÇ   R   Ré   (   R   t   top_tag(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt%   test_parent_of_top_tag_is_soup_objectø  s    c         C   s   |  j  d  |  j j É d  S(   N(   R   Ru   RK   Ré   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_soup_object_has_no_parent√  s    c         C   sN   |  j  |  j j d É d d d g É |  j  |  j j d d d Éd g É d  S(   Nt   ulRã   Rå   Rç   R   (   R   Rä   t   find_parents(   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_parents∆  s    c         C   sJ   |  j  |  j j d É d d É |  j  |  j j d d d Éd d É d  S(   NRì   R   Rã   Rç   (   R   Rä   t   find_parent(   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_parentÃ  s     c         C   s/   |  j  j d d É } |  j | j j d É d  S(   NR$   s
   Start hereR   (   RK   R    R   Ré   RF   (   R   R$   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_parent_of_text_element–  s    c         C   s6   |  j  j d d É } |  j | j d É d d É d  S(   NR$   s
   Start hereRì   R   Rã   (   RK   R    R   Rñ   (   R   R$   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_text_element_find_parent‘  s    c         C   s[   g  |  j  j D]+ } | d  k	 r d | j k r | d ^ q } |  j | d d d g É d  S(   NR   Rã   Rå   Rç   (   Rä   t   parentsRu   RD   R   (   R   Ré   Rö   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_parent_generatorÿ  s    +(   R   R   R+   RJ   Rè   Rë   Rí   Rï   Ró   Rò   Rô   Rõ   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyRâ   ´  s   								t   ProximityTestc           B   s   e  Z d  Ñ  Z RS(   c         C   s)   t  t |  É j É  |  j d É |  _ d  S(   Nsg   <html id="start"><head></head><body><b id="1">One</b><b id="2">Two</b><b id="3">Three</b></body></html>(   RI   R   RJ   R   RK   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyRJ   ‡  s    (   R   R   RJ   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyRú   ﬁ  s   t   TestNextOperationsc           B   sP   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 RS(   c         C   s&   t  t |  É j É  |  j j |  _ d  S(   N(   RI   Rù   RJ   RK   R   Rä   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyRJ   Ë  s    c         C   s7   |  j  |  j j d É |  j  |  j j j d d É d  S(   Nt   OneR   R   (   R   Rä   t   next_element(   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt	   test_nextÏ  s    c         C   s,   |  j  j d d É } |  j | j d  É d  S(   NR$   t   Three(   RK   R    R   Rü   Ru   (   R   t   last(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_next_of_last_item_is_none  s    c         C   s   |  j  |  j j d  É d  S(   N(   R   RK   Rü   Ru   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_next_of_root_is_noneÙ  s    c         C   s[   |  j  |  j j d É d d g É |  j j d d É |  j  |  j j d d É d g É d  S(   NR   t   TwoR°   R   i   (   R   Rä   t   find_all_next(   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_all_next¯  s    "c         C   sC   |  j  |  j j d É d d É |  j  |  j j d d É d É d  S(   NR   R   R   R$   R°   (   R   Rä   t	   find_next(   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_next˝  s     c         C   sT   |  j  j d d É } |  j | j d É j d É |  j | j d É d d g É d  S(   NR$   Rû   R   R•   R°   (   RK   R    R   R®   R   R   R¶   (   R   R$   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_next_for_text_element  s    c         C   se   |  j  j d d É } g  | j D] } | ^ q } | \ } } |  j | d d É |  j | d É d  S(   NR$   R•   R   R5   R°   (   RK   R    t   next_elementsR   (   R   Rä   t   nodet
   successorsR   RÇ   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_next_generator  s
    (
   R   R   RJ   R†   R£   R§   Rß   R©   R™   RÆ   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyRù   Ê  s   							t   TestPreviousOperationsc           B   sP   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 RS(   c         C   s/   t  t |  É j É  |  j j d d É |  _ d  S(   NR$   R°   (   RI   RØ   RJ   RK   R    t   end(   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyRJ     s    c         C   s7   |  j  |  j j d d É |  j  |  j j j d É d  S(   NR   R5   R•   (   R   R∞   t   previous_element(   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_previous  s    c         C   s)   |  j  j d É } |  j | j d  É d  S(   Nt   html(   RK   R    R   R±   Ru   (   R   RY   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt#   test_previous_of_first_item_is_none  s    c         C   s   d  S(   N(    (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_previous_of_root_is_none  s    c         C   sK   |  j  |  j j d É d d d g É |  j  |  j j d d É d g É d  S(   NR   R°   R•   Rû   R   i   (   R   R∞   t   find_all_previous(   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_all_previous"  s    c         C   sC   |  j  |  j j d É d d É |  j  |  j j d d É d É d  S(   NR   R   R5   R$   Rû   (   R   R∞   t   find_previous(   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_previous*  s     c         C   sW   |  j  j d d É } |  j | j d É j d É |  j | j d É d d d g É d  S(   NR$   R°   R   R•   Rû   (   RK   R    R   R∏   R   R   R∂   (   R   R$   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt#   test_find_previous_for_text_element.  s    c         C   sî   |  j  j d d É } g  | j D] } | ^ q } | \ } } } } |  j | d d É |  j | j d É |  j | j d É |  j | j d É d  S(   NR$   Rû   R   R4   t   bodyt   headR≥   (   RK   R    t   previous_elementsR   RF   (   R   Rä   R¨   t   predecessorsR   Rª   Rº   R≥   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_previous_generator4  s    (
   R   R   RJ   R≤   R¥   Rµ   R∑   Rπ   R∫   Rø   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyRØ     s   							t   SiblingTestc           B   s   e  Z d  Ñ  Z RS(   c         C   sJ   t  t |  É j É  d } t j d É j d | É } |  j | É |  _ d  S(   Nsâ  <html>
                    <span id="1">
                     <span id="1.1"></span>
                    </span>
                    <span id="2">
                     <span id="2.1"></span>
                    </span>
                    <span id="3">
                     <span id="3.1"></span>
                    </span>
                    <span id="4"></span>
                    </html>s   
\s*t    (   RI   R¿   RJ   R/   R0   t   subR   RK   (   R   t   markup(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyRJ   C  s    (   R   R   RJ   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyR¿   A  s   t   TestNextSiblingc           B   sG   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s/   t  t |  É j É  |  j j d d É |  _ d  S(   NR   R4   (   RI   Rƒ   RJ   RK   R    Rä   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyRJ   Y  s    c         C   s   |  j  |  j j d  É d  S(   N(   R   RK   t   next_siblingRu   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt!   test_next_sibling_of_root_is_none]  s    c         C   sU   |  j  |  j j d d É |  j  |  j j j d d É |  j  |  j j d d É d  S(   NR   R   R5   s   1.1(   R   Rä   R≈   Rü   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_next_sibling`  s    c         C   sm   |  j  |  j j j d  É |  j j d d É } |  j  | j d  É |  j j d d É } |  j  | j d  É d  S(   NR   s   1.1R6   (   R   RK   R≥   R≈   Ru   R    (   R   t   nested_spant	   last_span(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_next_sibling_may_not_existg  s
    c         C   s$   |  j  |  j j d É d d É d  S(   Nt   spanR   R   (   R   Rä   t   find_next_sibling(   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_next_siblingp  s    c         C   sK   |  j  |  j j d É d d d g É |  j  |  j j d d É d g É d  S(   NRÀ   R   R5   R6   R   (   R   Rä   t   find_next_siblings(   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_next_siblingss  s    c         C   s•   |  j  d É } | j d d É } |  j | j j d É |  j | j j d É |  j | j d É d g É |  j | j d d É d É |  j | j d d É d  É d  S(   Ns   Foo<b>bar</b>bazR$   R.   R   t   bazR-   t   nonesuch(	   R   R    R   R≈   RF   R   RŒ   RÃ   Ru   (   R   R   Rä   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt"   test_next_sibling_for_text_elementy  s    (	   R   R   RJ   R∆   R«   R    RÕ   Rœ   R“   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyRƒ   W  s   							t   TestPreviousSiblingc           B   sG   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s/   t  t |  É j É  |  j j d d É |  _ d  S(   NR   R6   (   RI   R”   RJ   RK   R    R∞   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyRJ   Ü  s    c         C   s   |  j  |  j j d  É d  S(   N(   R   RK   t   previous_siblingRu   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt%   test_previous_sibling_of_root_is_noneä  s    c         C   sU   |  j  |  j j d d É |  j  |  j j j d d É |  j  |  j j d d É d  S(   NR   R5   R   s   3.1(   R   R∞   R‘   R±   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_previous_siblingç  s    c         C   sm   |  j  |  j j j d  É |  j j d d É } |  j  | j d  É |  j j d d É } |  j  | j d  É d  S(   NR   s   1.1R4   (   R   RK   R≥   R‘   Ru   R    (   R   R»   t
   first_span(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt#   test_previous_sibling_may_not_existî  s
    c         C   s$   |  j  |  j j d É d d É d  S(   NRÀ   R   R5   (   R   R∞   t   find_previous_sibling(   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_find_previous_siblingù  s    c         C   sK   |  j  |  j j d É d d d g É |  j  |  j j d d É d g É d  S(   NRÀ   R5   R   R4   R   (   R   R∞   t   find_previous_siblings(   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_previous_siblings†  s    c         C   s•   |  j  d É } | j d d É } |  j | j j d É |  j | j j d É |  j | j d É d g É |  j | j d d É d É |  j | j d d É d  É d  S(   Ns   Foo<b>bar</b>bazR$   R–   R   R.   R-   R—   (	   R   R    R   R‘   RF   R   R€   RŸ   Ru   (   R   R   Rä   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt&   test_previous_sibling_for_text_element¶  s    (	   R   R   RJ   R’   R÷   Rÿ   R⁄   R‹   R›   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyR”   Ñ  s   							t   TestTagCreationc           B   s2   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s$   Test the ability to create new tags.c         C   sÄ   |  j  d É } | j d d d É} |  j t | t É É |  j d | j É |  j t d d É | j É |  j d  | j
 É d  S(   NR¡   R9   R-   R–   (   R   t   new_tagR?   t
   isinstanceR   R   RF   t   dictRD   Ru   Ré   (   R   R   Rﬂ   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_new_tag≥  s    c         C   sø   t  rb t d d É } | j d É } | j d É } |  j d | j É  É |  j d | j É  É n  t d d É } | j d É } | j d É } |  j d | j É  É |  j d | j É  É d  S(	   NR¡   s   lxml-xmlt   brt   ps   <br/>s   <p/>s   html.parsers   <p></p>(   t   XML_BUILDER_PRESENTR   Rﬂ   R   R]   (   R   t   xml_soupt   xml_brt   xml_pt	   html_soupt   html_brt   html_p(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt1   test_tag_inherits_self_closing_rules_from_builderª  s    c         C   sH   |  j  d É } | j d É } |  j d | É |  j t | t É É d  S(   NR¡   R9   (   R   t
   new_stringR   R?   R‡   R	   (   R   R   t   s(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt'   test_new_string_creates_navigablestringœ  s    c         C   sK   |  j  d É } | j d t É } |  j d | É |  j t | t É É d  S(   NR¡   R9   (   R   RÌ   R   R   R?   R‡   (   R   R   RÓ   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt3   test_new_string_can_create_navigablestring_subclass’  s    (   R   R   R+   R‚   RÏ   RÔ   R   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyRﬁ   ±  s
   			t   TestTreeModificationc           B   sU  e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z  d Ñ  Z! d  Ñ  Z" d! Ñ  Z# d" Ñ  Z$ d# Ñ  Z% d$ Ñ  Z& RS(%   c         C   sî   |  j  d É } d | j d <|  j | j É  |  j d É É | j d =|  j | j É  |  j d É É d | j d <|  j | j É  |  j d É É d  S(	   Ns   <a id="1"></a>i   R   s   <a id="2"></a>s   <a></a>R9   t   id2s   <a id2="foo"></a>(   R   R)   R   R^   t   document_for(   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_attribute_modification›  s    
c         C   sò   t  j d É É  } |  j d d | É} t | | d É } t | | d É } d | d <| j j d | É | j j d	 | É |  j | j j É  d
 É d  S(   NR≥   s   <body></body>t   builderR)   t   ols   http://foo.com/t   hrefi    i   s4   <body><a href="http://foo.com/"></a><ol></ol></body>(   R   t   lookupR   R   Rª   t   insertR   R]   (   R   Rı   R   R)   Rˆ   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_new_tag_creationÊ  s    
c         C   sÇ   d } |  j  | É } | j d d É } | j } | j d d É j | j É |  j | j | É |  j | j É  |  j d É É d  S(   NsT   <p id="1">Don't leave me <b>here</b>.</p>
                <p id="2">Don't leave!</p>R   R   sD   <p id="1">Don't leave me .</p>
<p id="2">Don't leave!<b>here</b></p>(   R   R    R   R;   R   Ré   R^   RÛ   (   R   t   docR   t   second_parat   bold(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt!   test_append_to_contents_moves_tagÚ  s    	c         C   sD   d } |  j  | É } | j } | j | j É } |  j | | É d  S(   Ns   <a></a><b><c></c></b>(   R   R)   t   replace_withRN   R   (   R   R$   R   R)   t   new_a(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt1   test_replace_with_returns_thing_that_was_replaced  s
    	c         C   s>   d } |  j  | É } | j } | j É  } |  j | | É d  S(   Ns   <a><b></b><c></c></a>(   R   R)   t   unwrapR   (   R   R$   R   R)   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt+   test_unwrap_returns_thing_that_was_replaced  s
    	c         C   se   |  j  d É } | j } | j É  |  j d  | j É |  j t | j É |  j t | j	 | j
 É d  S(   Ns   <a><b>Foo</b></a><c>Bar</c>(   R   R)   t   extractR   Ru   Ré   RÑ   RÖ   R  Rˇ   RN   (   R   R   R)   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pytI   test_replace_with_and_unwrap_give_useful_exception_when_tag_has_no_parent  s    	
c         C   sQ   d } |  j  | É } | j } | j j | É |  j | j É  |  j | É É d  S(   Ns-   <a><b></b><c>Foo<d></d></c></a><a><e></e></a>(   R   RN   Rˇ   R   R^   RÛ   (   R   R$   R   RN   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_replace_tag_with_itself  s
    	c         C   s5   d } |  j  | É } |  j t | j j | j É d  S(   Ns   <a><b></b></a>(   R   RÑ   RÖ   R   Rˇ   R)   (   R   R$   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt1   test_replace_tag_with_its_parent_raises_exception!  s    c         C   s8   d } |  j  | É } |  j t | j j d | j É d  S(   Ns   <a><b></b></a>i    (   R   RÑ   RÖ   R)   R˘   (   R   R$   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt,   test_insert_tag_into_itself_raises_exception&  s    c         C   sx   |  j  d É } | j } | j d } | j d d É | j \ } } | j d É | j d É |  j d | j j É d  S(   Ns   <p><a>one</a><b>three</b></p>i    i   t   twoR¡   t   three(   R   R)   RÇ   R˘   t   replaceWithR   R   R   (   R   R   R)   R   t   leftt   right(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt3   test_replace_with_maintains_next_element_throughout+  s    	c         C   sñ   |  j  d É } | j d d É j d É | j d d É } | j } |  j | j | É |  j | j | É |  j | j j | É |  j | j d  É d  S(   Ns   <b>Argh!</b>R$   s   Argh!s   Hooray!(	   R   R    Rˇ   R   R   R±   Ré   Rü   Ru   (   R   R   t   new_textR   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_replace_final_node:  s    	c         C   s“   |  j  d É } | j j d d É |  j | j É  |  j d É É | j d d É } |  j | j d É |  j | j j | É |  j | j	 d É |  j | j	 j
 | É |  j | j
 d  É |  j | j | j É d  S(   Ns   <a><b>Argh!</b><c></c></a>i   s   Hooray!s!   <a><b>Argh!Hooray!</b><c></c></a>R$   s   Argh!(   R   R   R˘   R   R^   RÛ   R    R±   Rü   R‘   R≈   Ru   RN   (   R   R   R  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_consecutive_text_nodesD  s    
c         C   sr   |  j  d É } | j j d d É | j j d d É |  j d d g | j j É |  j | j j d j d É d  S(   Ns   <a></a>i    R-   R9   (   R   R)   R˘   R   RÇ   Rü   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_insert_stringY  s
    c         C   sW  |  j  } |  j d d | É} t | | d É } | j d d É | j j d | É |  j | j É  |  j d É É | j } |  j | j	 | É |  j | j
 | É | j d d	 É } |  j | j | É |  j | j | É | j } |  j | j	 | É |  j | j
 | É | j d d É } |  j | j | É |  j | j | É |  j | j | É d  S(
   Ns%   <a><b>Find</b><c>lady!</c><d></d></a>Rı   t   magictagi    t   thei   s=   <a><b>Find</b><magictag>the</magictag><c>lady!</c><d></d></a>R$   t   Find(   t   default_builderR   R   R˘   R)   R   R^   RÛ   R   R≈   R‘   R    Rü   R±   RN   Ré   (   R   Rı   R   t	   magic_tagt   b_tagR    t   c_tagR  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_insert_tagb  s,    	
		c         C   sB   d } |  j  | É } | j j | j É |  j | | j É  É d  S(   Ns   <a><b></b></a>(   R   R)   R;   R   R   R^   (   R   R`   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt*   test_append_child_thats_already_at_the_endÄ  s    c         C   sE   d } |  j  | É } | j j d | j É |  j d | j É  É d  S(   Ns   <a><b></b><c></c><d></d></a>i    s   <a><d></d><b></b><c></c></a>(   R   R)   R˘   t   dR   R^   (   R   R`   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt$   test_move_tag_to_beginning_of_parentÜ  s    c         C   s?   |  j  d É } | j j d d É |  j t | j É d É d  S(   Ns   <br/>i   t   Contentss   <br>Contents</br>(   R   R„   R˘   R   R#   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt&   test_insert_works_on_empty_element_tagå  s    c         C   sÑ   |  j  d É } | j j d É | j j d É |  j | j É  |  j d É É | j j | j É |  j | j É  |  j d É É d  S(   Ns   <a>foo</a><b>bar</b>t   BAZt   QUUXs   QUUX<a>foo</a>BAZ<b>bar</b>s   QUUX<b>bar</b><a>foo</a>BAZ(   R   R   t   insert_beforeR)   R   R^   RÛ   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_insert_beforeï  s    c         C   sÑ   |  j  d É } | j j d É | j j d É |  j | j É  |  j d É É | j j | j É |  j | j É  |  j d É É d  S(   Ns   <a>foo</a><b>bar</b>R   R!  s   <a>foo</a>QUUX<b>bar</b>BAZs   QUUX<b>bar</b><a>foo</a>BAZ(   R   R   t   insert_afterR)   R   R^   RÛ   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_insert_after†  s    c         C   ss   |  j  d É } | j d É } | j d É } |  j t | j | É |  j t | j | É |  j t | j | É d  S(   NR¡   R)   (   R   Rﬂ   RÌ   RÑ   RÖ   R$  t   NotImplementedError(   R   R   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt:   test_insert_after_raises_exception_if_after_has_no_meaning™  s    c         C   ss   |  j  d É } | j d É } | j d É } |  j t | j | É |  j t | j | É |  j t | j | É d  S(   NR¡   R)   (   R   Rﬂ   RÌ   RÑ   RÖ   R"  R&  (   R   R   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pytF   test_insert_before_raises_notimplementederror_if_before_has_no_meaning≤  s    c         C   s£   |  j  d É } | j d É \ } } | j | É |  j | j É  |  j d É É |  j | j d  É |  j | j | j É |  j | j	 d É |  j | j
 d É d  S(   Ns;   <p>There's <b>no</b> business like <b>show</b> business</p>R   s0   <p>There's  business like <b>no</b> business</p>t   nos	    business(   R   R'   Rˇ   R   R^   RÛ   Ré   Ru   R‰   Rü   R≈   (   R   R   R)  t   show(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_replace_with∫  s    		
c         C   sB   d } |  j  | É } | j j | j É |  j d | j É  É d  S(   Ns   <a><b></b><c></c></a>s   <a><c></c></a>(   R   R   Rˇ   RN   R   R^   (   R   R`   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_replace_first_child…  s    c         C   sB   d } |  j  | É } | j j | j É |  j d | j É  É d  S(   Ns   <a><b></b><c></c></a>s   <a><b></b></a>(   R   RN   Rˇ   R   R   R^   (   R   R`   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_replace_last_childœ  s    c         C   sx  |  j  d É } | j } | j } | j | É |  j | j É  |  j d É É |  j | j d  É |  j | j	 d d É j
 d  É |  j | j d  É |  j | j d  É |  j | j d  É |  j | j | j É |  j | j d É |  j | j
 j
 | j É |  j | j d  É | j	 d d É } | j } |  j | j
 | É |  j | j | É |  j | j | É |  j | j | É d  S(   NsQ   <a>We<b>reserve<c>the</c><d>right</d></b></a><e>to<f>refuse</f><g>service</g></e>s-   <a>We<f>refuse</f></a><e>to<g>service</g></e>R$   R  t   Wet   to(   R   R   Rj   Rˇ   R   R^   RÛ   Ré   Ru   R    Rü   R±   R≈   R‘   R)   t   et   g(   R   R   t
   remove_tagt   move_tagt   to_textt   g_tag(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_nested_tag_replace_with’  s.    			
	c         C   sI   |  j  d É } | j j É  |  j | j d  É |  j | j j d É d  S(   NsI   
            <p>Unneeded <em>formatting</em> is unneeded</p>
            s   Unneeded formatting is unneeded(   R   t   emR  R   Ru   R‰   R$   (   R   RK   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_unwrap˘  s
    	c         C   sc   |  j  d É } | j j | j d É É } |  j | j É  d É |  j | j É  |  j d É É d  S(   Ns   I wish I was bold.R   s   <b>I wish I was bold.</b>(   R   R   t   wrapRﬂ   R   R^   RÛ   (   R   R   Rm   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt	   test_wrap  s
    c         C   sH   |  j  d É } | j j j | j É |  j | j É  |  j d É É d  S(   Ns   <b></b>I wish I was bold.s   <b>I wish I was bold.</b>(   R   R   R≈   R9  R   R^   RÛ   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt%   test_wrap_extracts_tag_from_elsewhere  s    c         C   sd   |  j  d É } | j j j | j É |  j d t | j j É É |  j | j É  |  j d É É d  S(   Ns+   <b>I like being bold.</b>I wish I was bold.i   s+   <b>I like being bold.I wish I was bold.</b>(	   R   R   R≈   R9  R   R&   RÇ   R^   RÛ   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt&   test_wrap_puts_new_contents_at_the_end  s    c         C   s;  |  j  d É } |  j t | j j É d É | j d d É j É  } |  j | j É  d É |  j | j É  d É |  j t | j j É d É |  j | j d  É |  j | j
 d  É |  j | j j d  É | j d d	 É } | j d d
 É } |  j | j | É |  j | j | É |  j | j
 | É |  j | j | É d  S(   NsR   <html><body>Some content. <div id="nav">Nav crap</div> More content.</body></html>i   R   t   navs6   <html><body>Some content.  More content.</body></html>s   <div id="nav">Nav crap</div>i   R$   s   Some content. s    More content.(   R   R   R&   Rª   RÇ   R    R  R^   Ré   Ru   R±   Rü   R≈   R‘   (   R   R   t	   extractedt	   content_1t	   content_2(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_extract  s"    	c         C   s©   |  j  d É } | j j } | j j } | j d É } | j d É } | j j | É | j j | É | j É  | j É  |  j | | j j É |  j | | j j É d  S(   Ns   <a>foo</a><b>bar</b>R9   R-   (   R   R)   R   R   RÌ   R;   R  R   (   R   R   t   foo_1t   bar_1t   foo_2t   bar_2(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt4   test_extract_distinguishes_between_identical_strings/  s    

c         C   sU   |  j  d É } g  | j d É D] } | j j É  ^ q |  j d t | j É É d  S(   Nsv   
<html>
<head>
<script>foo</script>
</head>
<body>
 <script>bar</script>
 <a></a>
</body>
<script>baz</script>
</html>t   scripts   <body>

<a></a>
</body>(   R   R'   RG  R  R   t   unicodeRª   (   R   R   RÜ   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt"   test_extract_multiples_of_same_tag@  s    
	)c         C   s?   |  j  d É } | j d É j É  |  j d  | j d É É d  S(   Ns   <html>
<body>hi</body>
</html>Rª   (   R   R    R  R   Ru   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pytB   test_extract_works_when_element_is_surrounded_by_identical_stringsP  s    	c         C   sç   |  j  d É } | j } | j j É  |  j t | j j É d É |  j t | d É É | j	 } | j d t
 É |  j d t | j É É d S(   s   Tag.clear()s4   <p><a>String <em>Italicized</em></a> and another</p>i    RÇ   t	   decomposeN(   R   R)   R‰   t   clearR   R&   RÇ   R?   R@   R7  R1   (   R   R   R)   R7  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt
   test_clearY  s    		c         C   s]   |  j  d É } d | j _ |  j | j j d g É d | j _ |  j | j j d g É d S(   s   Tag.string = 'string's   <a></a> <b><c></c></b>R9   R-   N(   R   R)   R   R   RÇ   R   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_string_setg  s
    c         C   s>   |  j  d É } | j j | j _ |  j | j j É  d É d  S(   Ns   <a><b>foo</b><c>bar</c>s   <a><b>bar</b><c>bar</c></a>(   R   RN   R   R   R   R)   R]   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt/   test_string_set_does_not_affect_original_stringo  s    c         C   sG   |  j  d É } t d É } | | j _ |  j t | j j t É É d  S(   Ns   <a></a>R9   (   R   R   R)   R   R?   R‡   (   R   R   t   cdata(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt)   test_set_string_preserves_class_of_stringt  s    ('   R   R   RÙ   R˙   R˛   R  R  R  R  R  R  R  R  R  R  R  R  R  R  R#  R%  R'  R(  R+  R,  R-  R6  R8  R:  R;  R<  RA  RF  RI  RJ  RM  RN  RO  RQ  (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyRÒ   €  sJ   												
										
						$												t   TestElementObjectsc           B   sÉ   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s)   Test various features of element objects.c         C   sw   |  j  d É } |  j t | j É d É |  j t | É d É |  j t | j É d É |  j t | j j É d É d S(   s3   The length of an element is its number of children.s   <top>1<b>2</b>3</top>i   i   N(   R   R   R&   RÇ   Rç   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_len}  s
    c         C   sj   |  j  d É } |  j | j | j d É É |  j | j j | j d É j d É É |  j | j d É d S(   s2   Accessing a Python member .foo invokes find('foo')s   <b><i></i></b>R   RÜ   N(   R   R   R   R    RÜ   R)   Ru   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_member_access_invokes_findã  s    (c         C   sg   |  j  d É } t j d t É è } | j } Wd  QX|  j | j | É |  j d t | d j É É d  S(   Ns   <b><i></i></b>t   records,   .bTag is deprecated, use .find("b") instead.i    (	   R   t   warningst   catch_warningsR1   t   bTagR   R   R#   t   message(   R   R   t   wR   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_deprecated_member_accessí  s    c         C   sE   |  j  d É } |  j | j j d É É |  j | j j d É É d S(   sŸ   has_attr() checks for the presence of an attribute.

        Please note note: has_attr() is different from
        __in__. has_attr() checks the tag's attributes and __in__
        checks the tag's chidlren.
        s   <foo attr='bar'>t   attrt   attr2N(   R   R?   R9   t   has_attrt   assertFalse(   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_has_attrõ  s    c         C   s   d } |  j  | d É d  S(   Ns%   <b a="1" z="5" m="3" f="2" y="4"></b>s%   <b a="1" f="2" m="3" y="4" z="5"></b>(   t   assertSoupEquals(   R   R√   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt.   test_attributes_come_out_in_alphabetical_orderß  s    c         C   s)   |  j  d É } |  j | j j d É d  S(   Ns
   <b>foo</b>R9   (   R   R   R   R   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_string´  s    c         C   s)   |  j  d É } |  j | j j d  É d  S(   Ns   <b></b>(   R   R   R   R   Ru   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_empty_tag_has_no_string±  s    c         C   sÜ   |  j  d É } |  j | j j d  É |  j  d É } |  j | j j d  É |  j  d É } | j j d d É |  j | j j d  É d  S(   Ns   <a>foo<b></b><b></b></b>s   <a>foo<b></b>bar</b>s
   <a>foo</b>i   R-   (   R   R   R   R   Ru   R)   R˘   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt-   test_tag_with_multiple_children_has_no_string∂  s    c         C   s<   |  j  d É } |  j | j j d É |  j | j d É d  S(   Ns   <a><b>foo</b></a>R9   (   R   R   R)   R   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt)   test_tag_with_recursive_string_has_stringƒ  s    c         C   sH   |  j  d É } |  j | j j É |  j  d É } |  j | j j É d S(   s7   Only a tag containing a single text node has a .string.s   <b>f<i>e</i>o</b>s   <b></b>N(   R   R_  R   R   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_lack_of_stringÀ  s    c         C   sÜ   |  j  d É } |  j | j j d É |  j | j j d t É d É |  j | j j d É d É |  j | j j d d t Éd É d S(	   sB   Tag.text and Tag.get_text(sep=u"") -> all child text, concatenateds   <a>a<b>r</b>   <r> t </r></a>s   ar  t t   stript   artt   ,s	   a,r, , t s   a,r,tN(   R   R   R)   R$   t   get_textR1   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_all_text”  s
    c         C   sg   |  j  d É } |  j | j É  d É |  j | j d t t f É d É |  j | j d d  É d É d  S(   Ns   foo<!--IGNORE-->bart   foobart   typest   fooIGNOREbar(   R   R   Rk  R	   R   Ru   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_get_text_ignores_comments€  s    c         C   s2   |  j  d É } |  j d d g t | j É É d  S(   Ns   foo<!--IGNORE-->barR9   R-   (   R   R   t   listt   strings(   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt!   test_all_strings_ignores_comments‰  s    (   R   R   R+   RS  RT  R[  R`  Rb  Rc  Rd  Re  Rf  Rg  Rl  Rp  Rs  (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyRR  z  s   														t   TestCDAtaListAttributesc           B   sM   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 RS(   s0   Testing cdata-list attributes like 'class'.
    c         C   s-   |  j  d É } |  j d g | j d É d  S(   Ns   <a class='foo'>R9   Rd   (   R   R   R)   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_single_value_becomes_listÏ  s    c         C   s0   |  j  d É } |  j d d g | j d É d  S(   Ns   <a class='foo bar'>R9   R-   Rd   (   R   R   R)   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt!   test_multiple_values_becomes_list  s    c         C   s3   |  j  d É } |  j d d d g | j d É d  S(   Ns   <a class='foo	bar
baz'>R9   R-   R–   Rd   (   R   R   R)   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt2   test_multiple_values_separated_by_weird_whitespaceÙ  s    c         C   s,   |  j  d É } |  j d | j j É  É d  S(   Ns   <a class='foo	bar'>s   <a class="foo bar"></a>(   R   R   R)   R]   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt,   test_attributes_joined_into_string_on_output¯  s    c         C   s0   |  j  d É } |  j d d g | j d É d  S(   Ns(   <form accept-charset="ISO-8859-1 UTF-8">s
   ISO-8859-1s   UTF-8s   accept-charset(   R   R   t   form(   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_accept_charset¸  s    c         C   s0   d } |  j  | É } |  j d | j d É d  S(   Ns)   <a accept-charset="ISO-8859-1 UTF-8"></a>s   ISO-8859-1 UTF-8s   accept-charset(   R   R   R)   (   R   R`   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt-   test_cdata_attribute_applying_only_to_one_tag   s    c            sH   |  j  d É j â  |  j d  à  j É á  f d Ü  } |  j t | É d  S(   NRÓ   c              s   d à  _  d  S(   NR9   (   RF   (    (   R   (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   t  s    (   R   R   R   Ru   RF   RÑ   t   AttributeError(   R   R|  (    (   R   s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt'   test_string_has_immutable_name_property  s    (
   R   R   R+   Ru  Rv  Rw  Rx  Rz  R{  R~  (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyRt  Ë  s   						t   TestPersistencec           B   sV   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 RS(	   s*   Testing features like pickle and deepcopy.c         C   s5   t  t |  É j É  d |  _ |  j |  j É |  _ d  S(   Nsy  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
"http://www.w3.org/TR/REC-html40/transitional.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Beautiful Soup: We called him Tortoise because he taught us.</title>
<link rev="made" href="mailto:leonardr@segfault.org">
<meta name="Description" content="Beautiful Soup: an HTML parser optimized for screen-scraping.">
<meta name="generator" content="Markov Approximation 1.4 (module: leonardr)">
<meta name="author" content="Leonard Richardson">
</head>
<body>
<a href="foo">foo</a>
<a href="foo"><b>bar</b></a>
</body>
</html>(   RI   R  RJ   t   pageR   RK   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyRJ     s    	c         C   sZ   t  j |  j d É } t  j | É } |  j | j t É |  j | j É  |  j j É  É d  S(   Ni   (   t   picklet   dumpsRK   t   loadsR   t	   __class__R   R^   (   R   t   dumpedt   loaded(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt!   test_pickle_and_unpickle_identity&  s    c         C   s5   t  j |  j É } |  j | j É  |  j j É  É d  S(   N(   t   copyt   deepcopyRK   R   R^   (   R   t   copied(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_deepcopy_identity.  s    c         C   sY   d } |  j  | É } t j | t j É } t j | É } |  j | j É  | j É  É d  S(   Nu
   <b>‚òÉ</b>(   R   RÅ  RÇ  t   HIGHEST_PROTOCOLRÉ  R   R^   (   R   R≥   R   RÖ  RÜ  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_unicode_pickle3  s
    c         C   s©   d } |  j  | É } | j d d É } t j | É } |  j | | É |  j d  | j É |  j d  | j É |  j d  | j É |  j d  | j É |  j d  | j	 É d  S(   Nu   <b>Foo<a></a></b><b>Bar</b>R   R.   (
   R   R    Rà  R   Ru   Ré   Rü   t   assertNotEqualR≈   R±   (   R   R≥   R   t   s1t   s2(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt1   test_copy_navigablestring_is_not_attached_to_tree;  s    c         C   sW   d } |  j  | É } | j } t j | É } |  j | | É |  j t | t É É d  S(   Nu   <b><!--Foo--></b>(   R   R   Rà  R   R?   R‡   R   (   R   R≥   R   Rè  Rê  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt0   test_copy_navigablestring_subclass_has_same_typeG  s    	c         C   s8   d } |  j  | É } t j | É } |  j | | É d  S(   Nu)   <div><b>Foo<a></a></b><b>Bar</b></div>end(   R   Rà  R   (   R   R≥   R   t	   soup_copy(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_copy_entire_soupO  s    c         C   s‘   d } |  j  | É } | j } t j | É } |  j t | É t | É É |  j | | É |  j | | k É |  j d  | j É |  j d  | j É |  j d  | j	 d d É j
 É |  j d  | j	 d d É j
 É d  S(   Nu)   <div><b>Foo<a></a></b><b>Bar</b></div>endR   t   Bar(   R   RÄ   Rà  R   RH  R_  Ru   Ré   R±   R    Rü   Ré  (   R   R≥   R   RÄ   t   div_copy(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_copy_tag_copies_contentsU  s    	(   R   R   R+   RJ   Rá  Rã  Rç  Rë  Rí  Rî  Ró  (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyR    s   							t   TestSubstitutionsc           B   sè   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   sD   d } |  j  | É } | j d d É } |  j | |  j d É É d  S(   Nu#   <b>&lt;&lt;Sacr√© bleu!&gt;&gt;</b>t	   formattert   minimal(   R   R^   R   RÛ   (   R   R√   R   t   decoded(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt!   test_default_formatter_is_minimalk  s    c         C   sD   d } |  j  | É } | j d d É } |  j | |  j d É É d  S(   Nu#   <b>&lt;&lt;Sacr√© bleu!&gt;&gt;</b>Rô  R≥   s)   <b>&lt;&lt;Sacr&eacute; bleu!&gt;&gt;</b>(   R   R^   R   RÛ   (   R   R√   R   Rõ  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_formatter_htmlu  s    c         C   sD   d } |  j  | É } | j d d É } |  j | |  j d É É d  S(   Nu#   <b>&lt;&lt;Sacr√© bleu!&gt;&gt;</b>Rô  Rö  (   R   R^   R   RÛ   (   R   R√   R   Rõ  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_formatter_minimal}  s    c         C   sD   d } |  j  | É } | j d d  É } |  j | |  j d É É d  S(   Nu#   <b>&lt;&lt;Sacr√© bleu!&gt;&gt;</b>Rô  u   <b><<Sacr√© bleu!>></b>(   R   R^   Ru   R   RÛ   (   R   R√   R   Rõ  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_formatter_nullá  s
    	c         C   sG   d } |  j  | É } | j d d Ñ  É } |  j | |  j d É É d  S(   Nu   <b>&lt;foo&gt;</b><b>bar</b>Rô  c         S   s
   |  j  É  S(   N(   t   upper(   t   x(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   <lambda>ì  s    u   <b><FOO></b><b>BAR</b>(   R   R^   R   RÛ   (   R   R√   R   Rõ  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_formatter_customê  s    c         C   sΩ   d } |  j  | É } | j } d } |  j | | j É  É |  j | | j d d É É d } |  j | | j d d É É |  j | | j d d  É É d } |  j | | j d d Ñ  É É d  S(	   Nu%   <a href="http://a.com?a=b&c=√©">e</a>u)   <a href="http://a.com?a=b&amp;c=√©">e</a>Rô  Rö  u/   <a href="http://a.com?a=b&amp;c=&eacute;">e</a>R≥   u%   <a href="HTTP://A.COM?A=B&C=√â">E</a>c         S   s
   |  j  É  S(   N(   R†  (   R°  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyR¢  ©  s    (   R   R)   R   R^   Ru   (   R   R√   R   R)   t   expect_minimalt   expect_htmlt   expect_upper(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt)   test_formatter_is_run_on_attribute_valuesö  s    	c         C   s2   d } t  | d É j É  } |  j d | k É d  S(   NsO   
  <script type="text/javascript">
   console.log("< < hey > > ");
  </script>
s   html.parsers   < < hey > >(   R   R]   R?   (   R   R˚   t   encoded(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt2   test_formatter_skips_script_tag_for_html_documents´  s    c         C   s2   d } t  | d É j É  } |  j d | k É d  S(   NsF   
  <style type="text/css">
   console.log("< < hey > > ");
  </style>
s   html.parsers   < < hey > >(   R   R]   R?   (   R   R˚   R®  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt1   test_formatter_skips_style_tag_for_html_documents¥  s    c         C   s,   |  j  d É } |  j d | j j É  É d  S(   Ns*   <div>  foo  <pre>  	bar
  
  </pre>  baz  u/   <div>
 foo
 <pre>  	bar
  
  </pre>
 baz
</div>(   R   R   RÄ   t   prettify(   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt,   test_prettify_leaves_preformatted_text_aloneΩ  s    c         C   s;   t  d d É } | j d d Ñ  É } |  j d | k É d  S(   Ns   <html><body>foo</body></html>s   html.parserRô  c         S   s
   |  j  É  S(   N(   R†  (   R°  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyR¢  «  s    t   FOO(   R   R´  R?   (   R   R   t   pretty(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_prettify_accepts_formatter≈  s    c         C   s/   |  j  d É } |  j t t | j É  É É d  S(   Ns   <a></a>(   R   R   RH  t   typeR´  (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt(   test_prettify_outputs_unicode_by_default   s    c         C   s2   |  j  d É } |  j t t | j d É É É d  S(   Ns   <a></a>s   utf-8(   R   R   t   bytesR∞  R´  (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_prettify_can_encode_dataŒ  s    c         C   sD   d } |  j  | É } | j j d É } |  j | | j d É É d  S(   Nu   <b>Sacr√© bleu!</b>s   utf-8(   R   R   R]   R   (   R   R√   R   R®  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt,   test_html_entity_substitution_off_by_default“  s    c         C   s¡   d } |  j  | É } |  j | j d d É | j d É } |  j d | k É | j d É } |  j d | k É | j d É } |  j d	 | k É | j d
 É j d
 É } |  j d | k É d  S(   NsE   <meta content="text/html; charset=x-sjis" http-equiv="Content-type"/>t   contents   text/html; charset=x-sjiss   utf-8s   charset=utf-8t   euc_jps   charset=euc_jps	   shift-jiss   charset=shift-jiss   utf-16s   charset=utf-16(   R   R   t   metaR]   R?   R^   (   R   t   meta_tagR   t   utf_8R∂  t	   shift_jist   utf_16_u(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_encoding_substitutionÿ  s    c         C   sE   d } t  d É } |  j | d | É} |  j | j d j d É d  S(   Ns`   <head><meta content="text/html; charset=x-sjis" http-equiv="Content-type"/></head><pre>foo</pre>t   pret
   parse_onlyi    (   R
   R   R   RÇ   RF   (   R   R√   Rs   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt;   test_encoding_substitution_doesnt_happen_if_tag_is_strained  s    (   R   R   Rú  Rù  Rû  Rü  R£  Rß  R©  R™  R¨  RØ  R±  R≥  R¥  Rº  Rø  (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyRò  i  s   	
		
			
											t   TestEncodingc           B   sV   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 RS(	   s0   Test the ability to encode objects into strings.c         C   sA   d } |  j  | É } |  j | j j j d É d j d É É d  S(   Nu
   <b>‚òÉ</b>s   utf-8u   ‚òÉ(   R   R   R   R   R]   (   R   R≥   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt"   test_unicode_string_can_be_encoded˛  s    c         C   s>   d } |  j  | É } |  j | j j d É | j d É É d  S(   Nu
   <b>‚òÉ</b>s   utf-8(   R   R   R   R]   (   R   R≥   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt1   test_tag_containing_unicode_string_can_be_encoded  s    c         C   s5   d } |  j  | É } |  j | j j d É d É d  S(   Nu
   <b>‚òÉ</b>t   asciis   <b>&#9731;</b>(   R   R   R   R]   (   R   R≥   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt<   test_encoding_substitutes_unrecognized_characters_by_default
  s    c         C   s5   d } |  j  | É } |  j t | j d d d Éd  S(   Nu
   <b>‚òÉ</b>R√  t   errorst   strict(   R   RÑ   t   UnicodeEncodeErrorR]   (   R   R≥   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt    test_encoding_can_be_made_strict  s    c         C   s2   d } |  j  | É } |  j d | j j É  É d  S(   Nu
   <b>‚òÉ</b>u   ‚òÉ(   R   R   R   t   decode_contents(   R   R≥   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_decode_contents  s    c         C   sA   d } |  j  | É } |  j d j d É | j j d d É É d  S(   Nu
   <b>‚òÉ</b>u   ‚òÉR[   t   encoding(   R   R   R]   R   t   encode_contents(   R   R≥   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_encode_contents  s
    c         C   s;   d } |  j  | É } |  j d j d É | j j É  É d  S(   Nu
   <b>‚òÉ</b>u   ‚òÉR[   (   R   R   R]   R   t   renderContents(   R   R≥   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_deprecated_renderContents!  s    c         C   sN   d } |  j  | É } t r4 |  j | t | É É n |  j d t | É É d  S(   Nu
   <b>‚òÉ</b>s   <b>\u2603</b>(   R   R   R   t   repr(   R   R≥   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt	   test_repr'  s
    (   R   R   R+   R¡  R¬  Rƒ  R»  R   RÕ  Rœ  R—  (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyR¿  ˚  s   							t   TestNavigableStringSubclassesc           B   s,   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   sx   |  j  d É } t d É } | j d | É |  j t | É d É |  j | j d d É d É |  j | j d d É d  S(   NR¡   R9   i   s   <![CDATA[foo]]>R$   i    (   R   R   R˘   R   R#   R    RÇ   (   R   R   RP  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt
   test_cdata1  s    c            sv   d à  _  á  f d Ü  } à  j d É } t d É } | j d | É à  j d | j d | É É à  j d à  j  É d S(	   sk   Text inside a CData object is passed into the formatter.

        But the return value is ignored.
        i    c             s   à  j  d 7_  d S(   Ni   s   BITTER FAILURE(   t   count(   t   args(   R   (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt	   incrementB  s    R¡   s   <><><>i   s   <![CDATA[<><><>]]>Rô  N(   R‘  R   R   R˘   R   R]   (   R   R÷  R   RP  (    (   R   s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_cdata_is_never_formatted;  s    	c         C   sE   t  d É } |  j d É } | j d | É |  j | j É  d É d  S(   NR9   R¡   i   s   <!DOCTYPE foo>
(   R   R   R˘   R   R]   (   R   t   doctypeR   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_doctype_ends_in_newlineM  s    c         C   s&   t  d É } |  j d | j É  É d  S(   NR9   s   <?foo?>(   R   R   t   output_ready(   R   R  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_declarationU  s    (   R   R   R”  R◊  RŸ  R€  (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyR“  /  s   	
		t   TestSoupSelectorc           B   s˙  e  Z d  Z d Ñ  Z d Ñ  Z e Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z  d Ñ  Z! d Ñ  Z" d  Ñ  Z# d! Ñ  Z$ d" Ñ  Z% d# Ñ  Z& d$ Ñ  Z' d% Ñ  Z( d& Ñ  Z) d' Ñ  Z* d( Ñ  Z+ d) Ñ  Z, d* Ñ  Z- d+ Ñ  Z. d, Ñ  Z/ d- Ñ  Z0 d. Ñ  Z1 d/ Ñ  Z2 d0 Ñ  Z3 d1 Ñ  Z4 d2 Ñ  Z5 d3 Ñ  Z6 d4 Ñ  Z7 d5 Ñ  Z8 d6 Ñ  Z9 RS(7   s˛  
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>The title</title>
<link rel="stylesheet" href="blah.css" type="text/css" id="l1">
</head>
<body>
<custom-dashed-tag class="dashed" id="dash1">Hello there.</custom-dashed-tag>
<div id="main" class="fancy">
<div id="inner">
<h1 id="header1">An H1</h1>
<p>Some text</p>
<p class="onep" id="p1">Some more text</p>
<h2 id="header2">An H2</h2>
<p class="class1 class2 class3" id="pmulti">Another</p>
<a href="http://bob.example.org/" rel="friend met" id="bob">Bob</a>
<h2 id="header3">Another H2</h2>
<a id="me" href="http://simonwillison.net/" rel="me">me</a>
<span class="s1">
<a href="#" id="s1a1">span1a1</a>
<a href="#" id="s1a2">span1a2 <span id="s1a2s1">test</span></a>
<span class="span2">
<a href="#" id="s2a1">span2a1</a>
</span>
<span class="span3"></span>
<custom-dashed-tag class="dashed" id="dash2"/>
<div data-tag="dashedvalue" id="data1"/>
</span>
</div>
<x id="xid">
<z id="zida"/>
<z id="zidab"/>
<z id="zidac"/>
</x>
<y id="yid">
<z id="zidb"/>
</y>
<p lang="en" id="lang-en">English</p>
<p lang="en-gb" id="lang-en-gb">English UK</p>
<p lang="en-us" id="lang-en-us">English US</p>
<p lang="fr" id="lang-fr">French</p>
</div>

<div id="footer">
</div>
c         C   s   t  |  j d É |  _ d  S(   Ns   html.parser(   R   t   HTMLR   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyRJ   å  s    c         C   ss   g  |  j  j | É D] } | d ^ q } | j É  | j É  |  j | | d | d j | É d j | É f É d  S(   NR   s$   Selector %s, expected [%s], got [%s]s   , (   R   t   selectt   sortR   t   join(   R   t   selectort   expected_idst   elt   el_ids(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyR   è  s    )

c         G   s+   x$ | D] \ } } |  j  | | É q Wd  S(   N(   t   assertSelect(   R   t   testsR·  R‚  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   assertSelectMultipleõ  s    c         C   s]   |  j  j d É } |  j t | É d É |  j | d j d É |  j | d j d g É d  S(   NR\   i   i    u	   The title(   R   Rﬁ  R   R&   RF   RÇ   (   R   t   els(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_one_tag_oneü  s    c         C   sv   |  j  j d É } |  j t | É d É x! | D] } |  j | j d É q/ W|  j  j d É } |  j d | d É d  S(   NRÄ   i   t   mainR   (   R   Rﬁ  R   R&   RF   t
   select_one(   R   RË  RÄ   R„  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_one_tag_many•  s    c         C   s&   |  j  j d É } |  j d  | É d  S(   Nt   nonexistenttag(   R   RÎ  R   Ru   (   R   t   match(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt(   test_select_one_returns_none_if_no_matchÆ  s    c         C   s,   |  j  j d É } |  j d d d g É d  S(   Ns   div divt   innert   data1(   R   Rﬁ  R   (   R   RË  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_tag_in_tag_one≥  s    c         C   s1   x* d D]" } |  j  | d d d d g É q Wd  S(	   Ns   html divs   html body divs   body divRÒ  RÍ  R  t   footer(   s   html divs   html body divs   body div(   R   (   R   R·  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_tag_in_tag_many∑  s    c         C   s&   |  j  t |  j j d É É d É d  S(   Nt   deli    (   R   R&   R   Rﬁ  (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_tag_no_matchª  s    c         C   s   |  j  t |  j j d É d  S(   Ns   tag%t(   RÑ   RÖ   R   Rﬁ  (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_invalid_tagæ  s    c         C   s   |  j  d d d g É d  S(   Ns   custom-dashed-tagt   dash1t   dash2(   R   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_select_dashed_tag_ids¡  s    c         C   sE   |  j  j d É } |  j | d j d É |  j | d d d É d  S(   Ns   custom-dashed-tag[id="dash2"]i    s   custom-dashed-tagR   R˘  (   R   Rﬁ  R   RF   (   R   t   dashed(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_select_dashed_by_idƒ  s    c         C   s'   |  j  |  j j d É d j d É d  S(   Ns   body > custom-dashed-tagi    u   Hello there.(   R   R   Rﬁ  R$   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_dashed_tag_text…  s    c         C   s,   |  j  |  j j d É |  j j d É É d  S(   Ns   custom-dashed-tag(   R   R   Rﬁ  R'   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt#   test_select_dashed_matches_find_allÃ  s    c         C   s)   |  j  d d g f d d d g f É d  S(   Nt   h1t   header1t   h2t   header2t   header3(   RÁ  (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_header_tagsœ  s    c         C   so   xh d	 D]` } |  j  j | É } |  j t | É d É |  j | d j d É |  j | d d d g É q Wd  S(
   Ns   .oneps   p.oneps   html p.onepi   i    R‰   Rd   t   onep(   s   .oneps   p.oneps   html p.onep(   R   Rﬁ  R   R&   RF   (   R   R·  RË  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_class_one’  s
    c         C   s,   |  j  j d É } |  j t | É d É d  S(   Ns   div.onepi    (   R   Rﬁ  R   R&   (   R   RË  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_class_mismatched_tag‹  s    c         C   s(   x! d D] } |  j  | d g É q Wd  S(   Ns	   div#inners   #inners   div div#innerR  (   s	   div#inners   #inners   div div#inner(   R   (   R   R·  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_one_id‡  s    c         C   s,   |  j  j d É } |  j t | É d É d  S(   Ns   #doesnotexisti    (   R   Rﬁ  R   R&   (   R   RË  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_bad_id‰  s    c         C   sÖ   |  j  j d É } |  j t | É d É x! | D] } |  j | j d É q/ W|  j | d d d g É |  j | d j d É É d  S(   Ns   div#inner pi   R‰   i   Rd   R  i    (   R   Rﬁ  R   R&   RF   R_  R^  (   R   RË  R„  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_items_in_idË  s    c         C   s7   x0 d D]( } |  j  t |  j j | É É d É q Wd  S(   Ns   div#main dels   div#main div.oopss   div div#maini    (   s   div#main dels   div#main div.oopss   div div#main(   R   R&   R   Rﬁ  (   R   R·  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_a_bunch_of_emptys  s    c         C   s(   x! d
 D] } |  j  | d	 g É q Wd  S(   Ns   .class1s   p.class1s   .class2s   p.class2s   .class3s   p.class3s   html p.class2s   div#inner .class2t   pmulti(   s   .class1s   p.class1s   .class2s   p.class2s   .class3s   p.class3s   html p.class2s   div#inner .class2(   R   (   R   R·  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_multi_class_supportÙ  s    
c         C   s(   x! d D] } |  j  | d g É q Wd  S(   Ns   .class1.class3s   .class3.class2s   .class1.class2.class3R  (   s   .class1.class3s   .class3.class2s   .class1.class2.class3(   R   (   R   R·  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_multi_class_selection˘  s    
c         C   s-   |  j  d d d g É |  j  d d g É d  S(   Ns   .s1 > at   s1a1t   s1a2s   .s1 > a spant   s1a2s1(   R   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_child_selector˛  s    c         C   s   |  j  d d g É d  S(   Ns   .s1 > a#s1a2 spanR  (   R   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_child_selector_id  s    c         C   s™   |  j  d d g f d d g f d d g f d d g f d d g f d d g f d	 d g f d
 g  f d d g f d d g f d d g f d g  f d g  f d g  f É d  S(   Ns   p[class="onep"]t   p1s
   p[id="p1"]s   [class="onep"]s	   [id="p1"]s   link[rel="stylesheet"]t   l1s   link[type="text/css"]s   link[href="blah.css"]s   link[href="no-blah.css"]s   [rel="stylesheet"]s   [type="text/css"]s   [href="blah.css"]s   [href="no-blah.css"]s   p[href="no-blah.css"](   RÁ  (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_attribute_equals  s    			c         C   sÜ   |  j  d d g f d d g f d d g f d d g f d d g f d d g f d d	 g f d
 d	 g f d d	 g f d d	 g f É
 d  S(   Ns   p[class~="class1"]R  s   p[class~="class2"]s   p[class~="class3"]s   [class~="class1"]s   [class~="class2"]s   [class~="class3"]s   a[rel~="friend"]t   bobs   a[rel~="met"]s   [rel~="friend"]s   [rel~="met"](   RÁ  (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_attribute_tilde  s    c         C   s≠   |  j  d d g f d d g f d g  f d g  f d g  f d d g f d d	 d
 g f d d	 d
 g f d d d g f d d
 d g f d d g f d d
 g f d d g f É d  S(   Ns   [rel^="style"]R  s   link[rel^="style"]s   notlink[rel^="notstyle"]s   [rel^="notstyle"]s   link[rel^="notstyle"]s   link[href^="bla"]s   a[href^="http://"]R  t   mes   [href^="http://"]s	   [id^="p"]R  R  s	   [id^="m"]RÍ  s   div[id^="m"]s
   a[id^="m"]s   div[data-tag^="dashed"]RÒ  (   RÁ  (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_attribute_startswith%  s    			c         C   sh   |  j  d d g f d d g f d d g f d d d d d d	 d
 d d g f d d g f d g  f É d  S(   Ns   [href$=".css"]R  s   link[href$=".css"]s   link[id$="1"]s	   [id$="1"]RÒ  R  R   R  t   s2a1R  R¯  s   div[id$="1"]s   [id$="noending"](   RÁ  (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_attribute_endswith6  s    !c         C   s4  |  j  d d g f d d g f d g  f d g  f d g  f d d g f d d	 d
 g f d d d g f d d g f d d
 g f d d g f d d g f d d g f d d d d d d d d d d g	 f d d g f d g  f d d	 d
 d g f d d	 d
 g f d  d g f d! d d" g f d# d" g f d$ d g f É d  S(%   Ns   [rel*="style"]R  s   link[rel*="style"]s   notlink[rel*="notstyle"]s   [rel*="notstyle"]s   link[rel*="notstyle"]s   link[href*="bla"]s   [href*="http://"]R  R  s	   [id*="p"]R  R  s   div[id*="m"]RÍ  s
   a[id*="m"]s   [href*=".css"]s   link[href*=".css"]s   link[id*="1"]s	   [id*="1"]RÒ  R   R  R  R  R  R¯  s   div[id*="1"]s   [id*="noending"]s   [href*="."]s   a[href*="."]s   link[href*="."]s   div[id*="n"]R  s   div[id*="nn"]s   div[data-tag*="edval"](   RÁ  (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_attribute_contains@  s.    			$	c         C   sG   |  j  d d d d g f d d d d g f d d g f d g  f É d  S(	   Ns   p[lang|="en"]s   lang-ens
   lang-en-gbs
   lang-en-uss   [lang|="en"]s   p[lang|="fr"]s   lang-frs   p[lang|="gb"](   RÁ  (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_attribute_exact_or_hypen]  s
    c      
   C   s}   |  j  d d d d g f d d g f d d d g f d d d	 d
 d g f d d d g f d g  f d g  f d d g f É d  S(   Ns   [rel]R  R  R  s	   link[rel]s   a[rel]s   [lang]s   lang-ens
   lang-en-gbs
   lang-en-uss   lang-frs   p[class]R  R  s   [blah]s   p[blah]s   div[data-tag]RÒ  (   RÁ  (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_attribute_existse  s    		c         C   s6   |  j  t |  j j d É |  j  t |  j j d É d  S(   Ns   a:no-such-pseudoclasss   a:nth-of-type(a)(   RÑ   R&  R   Rﬁ  (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_unsupported_pseudoclassq  s    c         C   s√   |  j  j d É } |  j t | É d É |  j | d j d É |  j  j d É } |  j t | É d É |  j | d j d É |  j  j d É } |  j t | É d É |  j t |  j  j d É d  S(	   Ns   div#inner p:nth-of-type(1)i   i    u	   Some texts   div#inner p:nth-of-type(3)u   Anothers   div#inner p:nth-of-type(4)s   div p:nth-of-type(0)(   R   Rﬁ  R   R&   R   RÑ   RÖ   (   R   RË  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_nth_of_typey  s    c         C   sC   |  j  j d É } |  j t | É d É |  j | d j d É d  S(   Ns   div#inner > p:nth-of-type(1)i   i    u	   Some text(   R   Rﬁ  R   R&   R   (   R   RË  (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt"   test_nth_of_type_direct_descendantå  s    c         C   s   |  j  d d g É d  S(   Ns   #inner > p:nth-of-type(2)R  (   R   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt"   test_id_child_selector_nth_of_typeë  s    c         C   sA   |  j  j d d d É} | j d É } |  j | d d g É d  S(   NRÄ   R   RÍ  R  RÒ  (   R   R    Rﬁ  R   (   R   R  t   selected(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_select_on_elementî  s    c         C   s'   |  j  d d g É |  j  d g  É d  S(   Ns   .fancy #innerR  s   .normal #inner(   R   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_overspecified_child_idù  s    c         C   sY   |  j  d d g É |  j  d d g É |  j  d d g É |  j g  |  j j d É É d  S(   Ns   #p1 + h2R  s   #p1 + h2 + pR  s   #p1 + #header2 + .class1s   #p1 + p(   R   R   R   Rﬁ  (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_adjacent_sibling_selector°  s    c         C   so   |  j  d d d g É |  j  d d g É |  j  d d g É |  j  d d g É |  j g  |  j j d É É d  S(	   Ns   #p1 ~ h2R  R  s   #p1 ~ #header2s   #p1 ~ h2 + aR  s   #p1 ~ h2 + [rel="me"]s   #inner ~ h2(   R   R   R   Rﬁ  (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_general_sibling_selectorß  s
    c         C   s   |  j  t |  j j d É d  S(   Ns   h1 >(   RÑ   RÖ   R   Rﬁ  (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_dangling_combinatorÆ  s    c         C   s   |  j  d d d d g É d  S(   Ns   p[lang] ~ ps
   lang-en-gbs
   lang-en-uss   lang-fr(   R   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt2   test_sibling_combinator_wont_select_same_tag_twice±  s    c         C   s   |  j  d d d g É d  S(   Ns   x, yt   xidt   yid(   R   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_multiple_selectµ  s    c         C   s   |  j  d d d g É d  S(   Ns   x,yR+  R,  (   R   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt"   test_multiple_select_with_no_space∏  s    c         C   s   |  j  d d d g É d  S(   Ns   x,    yR+  R,  (   R   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt$   test_multiple_select_with_more_spaceª  s    c         C   s   |  j  d d g É d  S(   Ns   x, xR+  (   R   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_multiple_select_duplicatedæ  s    c         C   s   |  j  d d d g É d  S(   Ns   x, y ~ p[lang=fr]R+  s   lang-fr(   R   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_multiple_select_sibling¡  s    c         C   s   |  j  d d d g É d  S(   Ns   x, y > zR+  t   zidb(   R   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt.   test_multiple_select_tag_and_direct_descendantƒ  s    c         C   s&   |  j  d d d d d d d g É d  S(   Ns   div > x, y, zR+  R,  t   zidaR2  t   zidabt   zidac(   R   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt/   test_multiple_select_direct_descendant_and_tags«  s    c         C   s&   |  j  d d d d d d d g É d  S(   Ns   div x,y,  zR+  R,  R4  R2  R5  R6  (   R   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt(   test_multiple_select_indirect_descendant   s    c         C   s6   |  j  t |  j j d É |  j  t |  j j d É d  S(   Ns   ,x, ys   x,,y(   RÑ   RÖ   R   Rﬁ  (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_invalid_multiple_selectÕ  s    c         C   s   |  j  d d d g É d  S(   Ns   p[lang=en], p[lang=en-gb]s   lang-ens
   lang-en-gb(   R   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_multiple_select_attrs—  s    c         C   s   |  j  d d d d g É d  S(   Ns*   x, y > z[id=zida], z[id=zidab], z[id=zidb]R+  R2  R5  (   R   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_multiple_select_ids‘  s    c         C   s   |  j  d d d g É d  S(   Ns   body > div > x, y > zR+  R2  (   R   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   test_multiple_select_nested◊  s    (:   R   R   R›  RJ   R   RÂ  RÁ  RÈ  RÏ  RÔ  RÚ  RÙ  Rˆ  R˜  R˙  R¸  R˝  R˛  R  R  R  R  R	  R
  R  R  R  R  R  R  R  R  R  R  R  R  R   R!  R"  R#  R%  R&  R'  R(  R)  R*  R-  R.  R/  R0  R1  R3  R7  R8  R9  R:  R;  R<  (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyR‹  Y  sp   1		
																												
																									(3   R+   t   pdbR    Rà  RÅ  R/   RV  t   bs4R   t   bs4.builderR   R   t   bs4.elementR   R   R   R   R   R	   R
   R   t   bs4.testingR   R   R¯   Ru   RÂ   t   LXML_PRESENTR   R   R,   RC   RH   RX   R   Râ   Rú   Rù   RØ   R¿   Rƒ   R”   Rﬁ   RÒ   RR  Rt  R  Rò  R¿  R“  R‹  (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_tree.pyt   <module>
   sF   :
;C∑3(3--*ˇ †n'Zí4*
filename:/usr/lib/python2.7/dist-packages/bs4/tests/test_html5lib.pyc
__doc__
Û
z“	Vc           @   s°   d  Z  d d l Z y d d l m Z e Z Wn e k
 rG Z e Z n Xd d l	 m
 Z
 d d l m Z m Z m Z e e d É d e e f d Ñ  É  YÉ Z d S(	   sD   Tests to ensure that the html5lib tree builder generates good trees.iˇˇˇˇN(   t   HTML5TreeBuilder(   t   SoupStrainer(   t   HTML5TreeBuilderSmokeTestt   SoupTestt   skipIfs?   html5lib seems not to be present, not testing its tree builder.t   HTML5LibBuilderSmokeTestc           B   s\   e  Z d  Z e d Ñ  É Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z RS(	   s"   See ``HTML5TreeBuilderSmokeTest``.c         C   s   t  É  S(   N(   R    (   t   self(    (    s;   /usr/lib/python2.7/dist-packages/bs4/tests/test_html5lib.pyt   default_builder   s    c         C   sÖ   t  d É } d } t j d t É è } |  j | d | É} Wd  QX|  j | j É  |  j | É É |  j d t	 | d j
 É k É d  S(   Nt   bs   <p>A <b>bold</b> statement.</p>t   recordt
   parse_onlys4   the html5lib tree builder doesn't support parse_onlyi    (   R   t   warningst   catch_warningst   Truet   soupt   assertEqualt   decodet   document_fort
   assertTruet   strt   message(   R   t   strainert   markupt   wR   (    (    s;   /usr/lib/python2.7/dist-packages/bs4/tests/test_html5lib.pyt   test_soupstrainer   s    c         C   s'   d } |  j  | d É |  j  d É d S(   s8   html5lib inserts <tbody> tags where other parsers don't.s[   <table id="1"><tr><td>Here's another table:<table id="2"><tr><td>foo</td></tr></table></td>sÜ   <table id="1"><tbody><tr><td>Here's another table:<table id="2"><tbody><tr><td>foo</td></tr></tbody></table></td></tr></tbody></table>s{   <table><thead><tr><td>Foo</td></tr></thead><tbody><tr><td>Bar</td></tr></tbody><tfoot><tr><td>Baz</td></tr></tfoot></table>N(   t   assertSoupEquals(   R   R   (    (    s;   /usr/lib/python2.7/dist-packages/bs4/tests/test_html5lib.pyt   test_correctly_nested_tables(   s    c         C   s2   d } |  j  | É } |  j d | j j É  É d  S(   Nsy   <?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html>
  <head>
  </head>
  <body>
   <p>foo</p>
  </body>
</html>s
   <p>foo</p>(   R   R   t   pt   encode(   R   R   R   (    (    s;   /usr/lib/python2.7/dist-packages/bs4/tests/test_html5lib.pyt(   test_xml_declaration_followed_by_doctype<   s    	c         C   sQ   d } |  j  | É } |  j d | j j É  É |  j d t | j d É É É d  S(   Ns%   <p><em>foo</p>
<p>bar<a></a></em></p>uD   <body><p><em>foo</em></p><em>
</em><p><em>bar<a></a></em></p></body>i   R   (   R   R   t   bodyR   t   lent   find_all(   R   R   R   (    (    s;   /usr/lib/python2.7/dist-packages/bs4/tests/test_html5lib.pyt   test_reparented_markupJ   s    c         C   sQ   d } |  j  | É } |  j d | j j É  É |  j d t | j d É É É d  S(   Ns&   <p><em>foo</p>
<p>bar<a></a></em></p>
uE   <body><p><em>foo</em></p><em>
</em><p><em>bar<a></a></em></p>
</body>i   R   (   R   R   R   R   R   R    (   R   R   R   (    (    s;   /usr/lib/python2.7/dist-packages/bs4/tests/test_html5lib.pyt+   test_reparented_markup_ends_with_whitespaceQ   s    c         C   s4   d } |  j  | É } t | É j d É s0 t Ç d S(   s(   Processing instructions become comments.s   <?PITarget PIContent?>s   <!--?PITarget PIContent?-->N(   R   R   t
   startswitht   AssertionError(   R   R   R   (    (    s;   /usr/lib/python2.7/dist-packages/bs4/tests/test_html5lib.pyt   test_processing_instructionW   s    c         C   sP   d } |  j  | É } | j d É \ } } |  j | | É | | k	 sL t Ç d  S(   Ns   <a class="my_class"><p></a>t   a(   R   R    R   R$   (   R   R   R   t   a1t   a2(    (    s;   /usr/lib/python2.7/dist-packages/bs4/tests/test_html5lib.pyt   test_cloned_multivalue_node]   s
    (   t   __name__t
   __module__t   __doc__t   propertyR   R   R   R   R!   R"   R%   R)   (    (    (    s;   /usr/lib/python2.7/dist-packages/bs4/tests/test_html5lib.pyR      s   						(   R,   R   t   bs4.builderR    R   t   HTML5LIB_PRESENTt   ImportErrort   et   Falset   bs4.elementR   t   bs4.testingR   R   R   R   (    (    (    s;   /usr/lib/python2.7/dist-packages/bs4/tests/test_html5lib.pyt   <module>   s   

	
filename:/usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyc
__doc__
Û
+gôUc           @   s  d  Z  d d l m Z d d l Z d d l Z d d l Z d d l Z d d l m Z m	 Z	 d d l
 m Z m Z m Z m Z d d l Z d d l m Z m Z m Z d d l m Z m Z d d l Z y  d d l m Z m Z e Z Wn e k
 rZ e Z n Xe j d k  Z  e j d d k o2e j d k  Z! d e f d Ñ  É  YZ" d e f d Ñ  É  YZ# d e f d Ñ  É  YZ# d e f d Ñ  É  YZ$ d e j% f d Ñ  É  YZ& d e f d Ñ  É  YZ' d e j% f d Ñ  É  YZ( d e f d Ñ  É  YZ) d e j% f d Ñ  É  YZ* d S(    s#   Tests of Beautiful Soup as a whole.iˇˇˇˇ(   t	   set_traceN(   t   BeautifulSoupt   BeautifulStoneSoup(   t   CharsetMetaAttributeValuet   ContentMetaAttributeValuet   SoupStrainert   NamespacedAttribute(   t   EntitySubstitutiont   UnicodeDammitt   EncodingDetector(   t   SoupTestt   skipIf(   t   LXMLTreeBuildert   LXMLTreeBuilderForXMLi   i   i    i   t   TestConstructorc           B   s#   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s/   d } |  j  | É } |  j d | j j É d  S(   Nu   <h1>√©√©</h1>u   √©√©(   t   soupt   assertEqualt   h1t   string(   t   selft   dataR   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   test_short_unicode_input+   s    c         C   s/   d } |  j  | É } |  j d | j j É d  S(   Nu   <h1>foo bar</h1>u   foo bar(   R   R   R   R   (   R   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   test_embedded_null0   s    c         C   s>   d j  d É } |  j | d d g É} |  j d | j É d  S(   Nu   R√§ksm√∂rg√•ss   utf-8t   exclude_encodingss   windows-1252(   t   encodeR   R   t   original_encoding(   R   t	   utf8_dataR   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   test_exclude_encodings5   s    (   t   __name__t
   __module__R   R   R   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyR   )   s   		t   TestWarningsc           B   sJ   e  Z e d  Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 RS(   c         C   s'   | j  t j d  É } |  j | É d  S(   NiP   (   t
   startswithR   t   NO_PARSER_SPECIFIED_WARNINGt
   assertTrue(   R   t   st   is_theret   v(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   _no_parser_specified=   s    c         C   sN   t  j d t É è } |  j d É } Wd  QXt | d j É } |  j | É d  S(   Nt   records   <a><b></b></a>i    (   t   warningst   catch_warningst   TrueR   t   strt   messaget   _assert_no_parser_specified(   R   t   wR   t   msg(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt#   test_warning_if_no_parser_specifiedA   s    c         C   sQ   t  j d t É è } |  j d d É } Wd  QXt | d j É } |  j | É d  S(   NR&   s   <a><b></b></a>t   htmli    (   R'   R(   R)   R   R*   R+   R,   (   R   R-   R   R.   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt*   test_warning_if_parser_specified_too_vagueG   s    c         C   sA   t  j d t É è } |  j d d É } Wd  QX|  j g  | É d  S(   NR&   s   <a><b></b></a>s   html.parser(   R'   R(   R)   R   t   assertEquals(   R   R-   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt,   test_no_warning_if_explicit_parser_specifiedM   s    c      	   C   sâ   t  j d t É è" } |  j d d t d É É} Wd  QXt | d j É } |  j d | k É |  j d | k É |  j d | j	 É  É d  S(   NR&   s   <a><b></b></a>t   parseOnlyTheset   bi    t
   parse_onlys   <b></b>(
   R'   R(   R)   R   R   R*   R+   R!   R   R   (   R   R-   R   R.   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt)   test_parseOnlyThese_renamed_to_parse_onlyR   s    !c         C   sÜ   t  j d t É è" } d } |  j | d d É} Wd  QXt | d j É } |  j d | k É |  j d | k É |  j d | j É d  S(   NR&   s   √©t   fromEncodingt   utf8i    t   from_encoding(	   R'   R(   R)   R   R*   R+   R!   R   R   (   R   R-   R9   R   R.   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt*   test_fromEncoding_renamed_to_from_encodingZ   s    c         C   s    |  j  t |  j d d t Éd  S(   Ns   <a>t   no_such_argument(   t   assertRaisest	   TypeErrorR   R)   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt"   test_unrecognized_keyword_argumentc   s    (
   R   R   R)   R%   R/   R1   R3   R7   R;   R?   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyR   ;   s   						c           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c         C   sª   t  j É  } | j } zT t j d t É è } |  j | É } Wd  QXt | d j É } |  j	 d | k É Wd  | j
 É  Xt j d t É è } |  j | É } Wd  QX|  j d t | É É d  S(   NR&   i    s   looks like a filename(   t   tempfilet   NamedTemporaryFilet   nameR'   R(   R)   R   R*   R+   R!   t   closeR   t   len(   R   t
   filehandlet   filenameR-   R   R.   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   test_disk_file_warningi   s    	c         C   sî   t  j d t É è } |  j d É } Wd  QXt | d j É } |  j d | k É t  j d t É è } |  j d É } Wd  QX|  j d t | É É d  S(   NR&   s   http://www.crummy.com/i    s   looks like a URLs   http://www.crummy.com/ is great(	   R'   R(   R)   R   R*   R+   R!   R   RD   (   R   R-   R   R.   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   test_url_warningy   s    (   R   R   RG   RH   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyR   g   s   	t   TestSelectiveParsingc           B   s   e  Z d  Ñ  Z RS(   c         C   sA   d } t  d É } |  j | d | É} |  j | j É  d É d  S(   Ns&   No<b>Yes</b><a>No<b>Yes <c>Yes</c></b>R5   R6   s   <b>Yes</b><b>Yes <c>Yes</c></b>(   R   R   R   R   (   R   t   markupt   strainerR   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   test_parse_with_soupstrainerÖ   s    (   R   R   RL   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyRI   É   s   t   TestEntitySubstitutionc           B   sÉ   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s1   Standalone tests of the EntitySubstitution class.c         C   s   t  |  _ d  S(   N(   R   t   sub(   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   setUpé   s    c         C   s&   d } |  j  |  j j | É d É d  S(   Nu   foo‚àÄ‚òÉ√µbaru   foo&forall;‚òÉ&otilde;bar(   R   RN   t   substitute_html(   R   R"   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   test_simple_html_substitutionë   s    c         C   s5   d } t  | É } |  j |  j j | j É d É d  S(   Ns   ëífooìîs   &lsquo;&rsquo;foo&ldquo;&rdquo;(   R   R   RN   RP   RJ   (   R   t   quotest   dammit(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   test_smart_quote_substitutionò   s    c         C   s)   d } |  j  |  j j | t É | É d  S(   Ns   Welcome to "my bar"(   R   RN   t   substitute_xmlt   False(   R   R"   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pytI   test_xml_converstion_includes_no_quotes_if_make_quoted_attribute_is_false†   s    c         C   sB   |  j  |  j j d t É d É |  j  |  j j d t É d É d  S(   Nt   Welcomes	   "Welcome"s	   Bob's Bars   "Bob's Bar"(   R   RN   RU   R)   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt6   test_xml_attribute_quoting_normally_uses_double_quotes§   s    c         C   s)   d } |  j  |  j j | t É d É d  S(   Ns   Welcome to "my bar"s   'Welcome to "my bar"'(   R   RN   RU   R)   (   R   R"   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pytO   test_xml_attribute_quoting_uses_single_quotes_when_value_contains_double_quotes™   s    c         C   s)   d } |  j  |  j j | t É d É d  S(   Ns   Welcome to "Bob's Bar"s"   "Welcome to &quot;Bob's Bar&quot;"(   R   RN   RU   R)   (   R   R"   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pytb   test_xml_attribute_quoting_escapes_single_quotes_when_value_contains_both_single_and_double_quotesØ   s    c         C   s&   d } |  j  |  j j | É | É d  S(   Ns   Welcome to "Bob's Bar"(   R   RN   RU   (   R   t   quoted(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt<   test_xml_quotes_arent_escaped_when_value_is_not_being_quotedµ   s    c         C   s    |  j  |  j j d É d É d  S(   Ns   foo<bar>s   foo&lt;bar&gt;(   R   RN   RU   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt'   test_xml_quoting_handles_angle_bracketsπ   s    c         C   s    |  j  |  j j d É d É d  S(   Ns   AT&Ts   AT&amp;T(   R   RN   RU   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt#   test_xml_quoting_handles_ampersandsæ   s    c         C   s    |  j  |  j j d É d É d  S(   Ns   &Aacute;T&Ts   &amp;Aacute;T&amp;T(   R   RN   RU   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pytE   test_xml_quoting_including_ampersands_when_they_are_part_of_an_entity¡   s    c         C   s    |  j  |  j j d É d É d  S(   Ns   &Aacute;T&Ts   &Aacute;T&amp;T(   R   RN   t"   substitute_xml_containing_entities(   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pytD   test_xml_quoting_ignoring_ampersands_when_they_are_part_of_an_entity∆   s    c         C   s&   d } |  j  |  j j | É | É d S(   s:   There's no need to do this except inside attribute values.s   Bob's "bar"N(   R   RN   RP   (   R   t   text(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt    test_quotes_not_html_substitutedÀ   s    (   R   R   t   __doc__RO   RQ   RT   RW   RY   RZ   R[   R]   R^   R_   R`   Rb   Rd   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyRM   å   s   												t   TestEncodingConversionc           B   sS   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e e p? e	 d É d Ñ  É Z
 RS(   c         C   sH   t  t |  É j É  d |  _ |  j j d É |  _ |  j |  j d É d  S(   NuU   <html><head><meta charset="utf-8"/></head><body><foo>Sacr√© bleu!</foo></body></html>s   utf-8sU   <html><head><meta charset="utf-8"/></head><body><foo>Sacr√© bleu!</foo></body></html>(   t   superRf   RO   t   unicode_dataR   R   R   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyRO   ’   s    	c         C   s»   t  j j } t j t j É zà d Ñ  } | t  j _ d } |  j | É } | j É  } |  j t	 | t
 É É |  j | |  j | j É  É É |  j | j j É  d É Wd  t j t j É | t  j _ Xd  S(   Nc         S   s   d  S(   N(   t   None(   R*   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   noop‰   s    s   <foo>a</foo>s   utf-8(   t   bs4RS   t   chardet_dammitt   loggingt   disablet   WARNINGR   t   decodeR!   t
   isinstancet   unicodeR   t   document_forR   t   lowert   NOTSET(   R   t   chardetRj   t   asciit   soup_from_asciit   unicode_output(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   test_ascii_in_unicode_outﬁ   s    	c         C   sX   |  j  |  j É } |  j | j É  |  j É |  j | j j d É |  j | j d  É d  S(   Nu   Sacr√© bleu!(   R   Rh   R   Rp   t   fooR   R   Ri   (   R   t   soup_from_unicode(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   test_unicode_in_unicode_outÚ   s    c         C   sE   |  j  |  j É } |  j | j É  |  j É |  j | j j d É d  S(   Nu   Sacr√© bleu!(   R   R   R   Rp   Rh   R{   R   (   R   t   soup_from_utf8(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   test_utf8_in_unicode_out˙   s    c         C   s2   |  j  |  j É } |  j | j d É |  j É d  S(   Ns   utf-8(   R   Rh   R   R   R   (   R   R|   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   test_utf8_out  s    sQ   Bad HTMLParser detected; skipping test of non-ASCII characters in attribute name.c         C   s8   d } |  j  |  j | É j j d É | j d É É d  S(   Nu    <div><a ‚òÉ="snowman"></a></div>R9   (   R   R   t   divR   (   R   RJ   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt1   test_attribute_name_containing_unicode_characters  s    (   R   R   RO   Rz   R}   R   RÄ   R   t   PYTHON_2_PRE_2_7t   PYTHON_3_PRE_3_2RÇ   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyRf   —   s   							t   TestUnicodeDammitc           B   sß   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s"   Standalone tests of UnicodeDammit.c         C   s)   d } t  | É } |  j | j | É d  S(   Nu   I'm already Unicode! ‚òÉ(   R   R   t   unicode_markup(   R   RJ   RS   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   test_unicode_input  s    c         C   s)   d } t  | É } |  j | j d É d  S(   Ns   <foo>ëíìî</foo>u   <foo>‚Äò‚Äô‚Äú‚Äù</foo>(   R   R   RÜ   (   R   RJ   RS   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   test_smart_quotes_to_unicode  s    c         C   s/   d } t  | d d É} |  j | j d É d  S(   Ns   <foo>ëíìî</foo>t   smart_quotes_tot   xmls+   <foo>&#x2018;&#x2019;&#x201C;&#x201D;</foo>(   R   R   RÜ   (   R   RJ   RS   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt!   test_smart_quotes_to_xml_entities  s    c         C   s/   d } t  | d d É} |  j | j d É d  S(   Ns   <foo>ëíìî</foo>Râ   R0   s'   <foo>&lsquo;&rsquo;&ldquo;&rdquo;</foo>(   R   R   RÜ   (   R   RJ   RS   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt"   test_smart_quotes_to_html_entities!  s    c         C   s/   d } t  | d d É} |  j | j d É d  S(   Ns   <foo>ëíìî</foo>Râ   Rw   s   <foo>''""</foo>(   R   R   RÜ   (   R   RJ   RS   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   test_smart_quotes_to_ascii'  s    c         C   sB   d } t  | É } |  j | j j É  d É |  j | j d É d  S(   Ns   Sacr√© bleu! ‚òÉs   utf-8u   Sacr√© bleu! ‚òÉ(   R   R   R   Rt   RÜ   (   R   R9   RS   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   test_detect_utf8-  s    c         C   sH   d } t  | d g É } |  j | j j É  d É |  j | j d É d  S(   Ns   ÌÂÏ˘s
   iso-8859-8u   ◊ù◊ï◊ú◊©(   R   R   R   Rt   RÜ   (   R   t   hebrewRS   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   test_convert_hebrew4  s    c         C   sK   d } t  | É } |  j | j j É  d É |  j | j j d É | É d  S(   Ns   „Ç±„Éº„Çø„Ç§ Watchs   utf-8(   R   R   R   Rt   RÜ   R   (   R   t   utf_8RS   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt/   test_dont_see_smart_quotes_where_there_are_none:  s    c         C   s>   d j  d É } t | d g É } |  j | j j É  d É d  S(   Nu   R√§ksm√∂rg√•ss   utf-8s
   iso-8859-8(   R   R   R   R   Rt   (   R   R   RS   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt    test_ignore_inappropriate_codecs@  s    c         C   sX   d j  d É } xB d d d g D]1 } t | | g É } |  j | j j É  d É q Wd  S(   Nu   R√§ksm√∂rg√•ss   utf-8s   .utf8s   ...s
   utF---16.!(   R   R   R   R   Rt   (   R   R   t   bad_encodingRS   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   test_ignore_invalid_codecsE  s    c         C   sl   d j  d É } t | d d g É} |  j | j j É  d É t | d d d g É} |  j | j d  É d  S(   Nu   R√§ksm√∂rg√•ss   utf-8R   s   windows-1252(   R   R   R   R   Rt   Ri   (   R   R   RS   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyR   K  s    c         C   s1   t  d É } t | j É } d | k s- t Ç d  S(   Ns'   <?xml version="1.0" encoding="UTF-€" ?>u   utf-ÔøΩ(   R	   t   listt	   encodingst   AssertionError(   R   t   detectedRó   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pytP   test_encoding_detector_replaces_junk_in_encoding_name_with_replacement_characterY  s    	c         C   s:   x3 d D]+ } t  | d t É} |  j d | j É q Wd  S(   Ns&   <html><meta charset="euc-jp" /></html>s&   <html><meta charset='euc-jp' /></html>s$   <html><meta charset=euc-jp /></html>s#   <html><meta charset=euc-jp/></html>t   is_htmls   euc-jp(   s&   <html><meta charset="euc-jp" /></html>s&   <html><meta charset='euc-jp' /></html>s$   <html><meta charset=euc-jp /></html>s#   <html><meta charset=euc-jp/></html>(   R   R)   R   R   (   R   R   RS   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt    test_detect_html5_style_meta_tag_  s       
c         C   s≥   d } t  j j } t j t j É zm d Ñ  } | t  j _ t | É } |  j t | j	 É |  j
 d | j k É t | d É } |  j
 | j	 É Wd  t j t j É | t  j _ Xd  S(   NsT   Ôªø<?xml version="1.0" encoding="UTF-8"?>
<html><b>ÿ®ÿ™ÿ±</b>
<i>»“—ê —Ì‰</i></html>c         S   s   d  S(   N(   Ri   (   R*   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyRj   Ä  s    u   ÔøΩs   html.parser(   Rk   RS   Rl   Rm   Rn   Ro   R   R   R)   t   contains_replacement_charactersR!   RÜ   R   Ru   (   R   t   docRv   Rj   RS   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt"   test_last_ditch_entity_replacementj  s    	c         C   s<   d } t  | É } |  j d | j É |  j d | j É d  S(   Ns   ˇ˛< a > · È < / a > u   <a>√°√©</a>s   utf-16le(   R   R   RÜ   R   (   R   R   RS   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   test_byte_order_mark_removedç  s    c         C   sn   d j  d É } d j  d É } | | | } |  j t | j d É t j | É } |  j d | j d É É d  S(   Nu   ‚òÉi   R9   u   ‚ÄúHi, I like Windows!‚Äùt   windows_1252u+   ‚òÉ‚òÉ‚òÉ‚ÄúHi, I like Windows!‚Äù‚òÉ‚òÉ‚òÉu	   ‚òÉ‚òÉ‚òÉ(   R   R=   t   UnicodeDecodeErrorRp   R   t	   detwingleR   (   R   R9   R°   Rû   t   fixed(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   test_detwingleî  s    	c         C   sY   xR d D]J } | j  d É } |  j | j d É É t j | É } |  j | | É q Wd  S(   Nu   ≈ìu   ‚Çìu   √∞¬ê¬ê¬ìR9   s   ì(   u   ≈ìu   ‚Çìu   √∞¬ê¬ê¬ì(   R   R!   t   endswithR   R£   R   (   R   t   tricky_unicode_chart   inputt   output(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt+   test_detwingle_ignores_multibyte_characters¨  s      
(   R   R   Re   Rá   Rà   Rã   Rå   Rç   Ré   Rê   Rí   Rì   Rï   R   Rö   Rú   Rü   R†   R•   R™   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyRÖ     s$   														#		t   TestNamedspacedAttributec           B   s#   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s#   t  d d  É } |  j | d É d  S(   Nt   xmlns(   R   Ri   R   (   R   t   a(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   test_name_may_be_noneΩ  s    c         C   s#   t  d d É } |  j d | É d  S(   NR≠   R5   s   a:b(   R   R   (   R   R≠   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt6   test_attribute_is_equivalent_to_colon_separated_string¡  s    c         C   sû   t  d d d É } t  d d d É } |  j | | É t  d d d  É } |  j | | É t  d d d É } |  j | | É t  d d d É } |  j | | É d  S(   NR≠   R5   t   ct   z(   R   R   Ri   t   assertNotEqual(   R   R≠   R5   R∞   t   dt   e(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt;   test_attributes_are_equivalent_if_prefix_and_name_identical≈  s    (   R   R   RÆ   RØ   Rµ   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyR´   ª  s   		t)   TestAttributeValueWithCharsetSubstitutionc           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c         C   sL   t  d É } |  j d | É |  j d | j É |  j d | j d É É d  S(   Ns   euc-jpR9   (   R   R   t   original_valueR   (   R   t   value(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt!   test_content_meta_attribute_valueÿ  s    c         C   sL   t  d É } |  j d | É |  j d | j É |  j d | j d É É d  S(   Ns   text/html; charset=euc-jps   text/html; charset=utf8R9   (   R   R   R∑   R   (   R   R∏   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyRπ   ﬂ  s    (   R   R   Rπ   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyR∂   ÷  s   	(   i   i   (   i   i   (+   Re   t   pdbR    Rm   t   unittestt   sysR@   Rk   R   R   t   bs4.elementR   R   R   R   t
   bs4.dammitR   R   R	   t   bs4.testingR
   R   R'   t   bs4.builderR   R   R)   t   LXML_PRESENTt   ImportErrorR¥   RV   t   version_infoRÉ   RÑ   R   R   RI   t   TestCaseRM   Rf   RÖ   R´   R∂   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_soup.pyt   <module>   s6   "

",	E<Æ
filename:/usr/lib/python2.7/dist-packages/bs4/tests/test_builder_registry.py
__doc__
"""Tests of the builder registry."""

filename:/usr/lib/python2.7/dist-packages/bs4/tests/test_html5lib.py
__doc__
"""Tests to ensure that the html5lib tree builder generates good trees."""

import warnings

try:
    from bs4.builder import HTML5TreeBuilder
    HTML5LIB_PRESENT = True
except ImportError, e:
    HTML5LIB_PRESENT = False
from bs4.element import SoupStrainer
from bs4.testing import (
    HTML5TreeBuilderSmokeTest,
    SoupTest,
    skipIf,
)

@skipIf(
    not HTML5LIB_PRESENT,
    "html5lib seems not to be present, not testing its tree builder.")
class HTML5LibBuilderSmokeTest(SoupTest, HTML5TreeBuilderSmokeTest):
    """See ``HTML5TreeBuilderSmokeTest``."""

    @property
    def default_builder(self):
        return HTML5TreeBuilder()

    def test_soupstrainer(self):
        # The html5lib tree builder does not support SoupStrainers.
        strainer = SoupStrainer("b")
        markup = "<p>A <b>bold</b> statement.</p>"
        with warnings.catch_warnings(record=True) as w:
            soup = self.soup(markup, parse_only=strainer)
        self.assertEqual(
            soup.decode(), self.document_for(markup))

        self.assertTrue(
            "the html5lib tree builder doesn't support parse_only" in
            str(w[0].message))

    def test_correctly_nested_tables(self):
        """html5lib inserts <tbody> tags where other parsers don't."""
        markup = ('<table id="1">'
                  '<tr>'
                  "<td>Here's another table:"
                  '<table id="2">'
                  '<tr><td>foo</td></tr>'
                  '</table></td>')

        self.assertSoupEquals(
            markup,
            '<table id="1"><tbody><tr><td>Here\'s another table:'
            '<table id="2"><tbody><tr><td>foo</td></tr></tbody></table>'
            '</td></tr></tbody></table>')

        self.assertSoupEquals(
            "<table><thead><tr><td>Foo</td></tr></thead>"
            "<tbody><tr><td>Bar</td></tr></tbody>"
            "<tfoot><tr><td>Baz</td></tr></tfoot></table>")

    def test_xml_declaration_followed_by_doctype(self):
        markup = '''<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html>
  <head>
  </head>
  <body>
   <p>foo</p>
  </body>
</html>'''
        soup = self.soup(markup)
        # Verify that we can reach the <p> tag; this means the tree is connected.
        self.assertEqual(b"<p>foo</p>", soup.p.encode())

    def test_reparented_markup(self):
        markup = '<p><em>foo</p>\n<p>bar<a></a></em></p>'
        soup = self.soup(markup)
        self.assertEqual(u"<body><p><em>foo</em></p><em>\n</em><p><em>bar<a></a></em></p></body>", soup.body.decode())
        self.assertEqual(2, len(soup.find_all('p')))


    def test_reparented_markup_ends_with_whitespace(self):
        markup = '<p><em>foo</p>\n<p>bar<a></a></em></p>\n'
        soup = self.soup(markup)
        self.assertEqual(u"<body><p><em>foo</em></p><em>\n</em><p><em>bar<a></a></em></p>\n</body>", soup.body.decode())
        self.assertEqual(2, len(soup.find_all('p')))

    def test_processing_instruction(self):
        """Processing instructions become comments."""
        markup = b"""<?PITarget PIContent?>"""
        soup = self.soup(markup)
        assert str(soup).startswith("<!--?PITarget PIContent?-->")

    def test_cloned_multivalue_node(self):
        markup = b"""<a class="my_class"><p></a>"""
        soup = self.soup(markup)
        a1, a2 = soup.find_all('a')
        self.assertEqual(a1, a2)
        assert a1 is not a2

filename:/usr/lib/python2.7/dist-packages/bs4/tests/test_tree.py
__doc__
# -*- coding: utf-8 -*-
"""Tests for Beautiful Soup's tree traversal methods.

filename:/usr/lib/python2.7/dist-packages/bs4/tests/test_lxml.py
__doc__
"""Tests to ensure that the lxml tree builder generates good trees."""

import re
import warnings

try:
    import lxml.etree
    LXML_PRESENT = True
    LXML_VERSION = lxml.etree.LXML_VERSION
except ImportError, e:
    LXML_PRESENT = False
    LXML_VERSION = (0,)

if LXML_PRESENT:
    from bs4.builder import LXMLTreeBuilder, LXMLTreeBuilderForXML

from bs4 import (
    BeautifulSoup,
    BeautifulStoneSoup,
    )
from bs4.element import Comment, Doctype, SoupStrainer
from bs4.testing import skipIf
from bs4.tests import test_htmlparser
from bs4.testing import (
    HTMLTreeBuilderSmokeTest,
    XMLTreeBuilderSmokeTest,
    SoupTest,
    skipIf,
)

@skipIf(
    not LXML_PRESENT,
    "lxml seems not to be present, not testing its tree builder.")
class LXMLTreeBuilderSmokeTest(SoupTest, HTMLTreeBuilderSmokeTest):
    """See ``HTMLTreeBuilderSmokeTest``."""

    @property
    def default_builder(self):
        return LXMLTreeBuilder()

    def test_out_of_range_entity(self):
        self.assertSoupEquals(
            "<p>foo&#10000000000000;bar</p>", "<p>foobar</p>")
        self.assertSoupEquals(
            "<p>foo&#x10000000000000;bar</p>", "<p>foobar</p>")
        self.assertSoupEquals(
            "<p>foo&#1000000000;bar</p>", "<p>foobar</p>")

    # In lxml < 2.3.5, an empty doctype causes a segfault. Skip this
    # test if an old version of lxml is installed.

    @skipIf(
        not LXML_PRESENT or LXML_VERSION < (2,3,5,0),
        "Skipping doctype test for old version of lxml to avoid segfault.")
    def test_empty_doctype(self):
        soup = self.soup("<!DOCTYPE>")
        doctype = soup.contents[0]
        self.assertEqual("", doctype.strip())

    def test_beautifulstonesoup_is_xml_parser(self):
        # Make sure that the deprecated BSS class uses an xml builder
        # if one is installed.
        with warnings.catch_warnings(record=True) as w:
            soup = BeautifulStoneSoup("<b />")
        self.assertEqual(u"<b/>", unicode(soup.b))
        self.assertTrue("BeautifulStoneSoup class is deprecated" in str(w[0].message))

@skipIf(
    not LXML_PRESENT,
    "lxml seems not to be present, not testing its XML tree builder.")
class LXMLXMLTreeBuilderSmokeTest(SoupTest, XMLTreeBuilderSmokeTest):
    """See ``HTMLTreeBuilderSmokeTest``."""

    @property
    def default_builder(self):
        return LXMLTreeBuilderForXML()

filename:/usr/lib/python2.7/dist-packages/bs4/tests/test_docs.pyc
__doc__
Û
ñë¢Oc           @   s`   d  Z  e Z d g Z d d l Z d d l Z d d l Z d d l Z e j e j	 Be j
 BZ d S(   s   Test harness for doctests.t   additional_testsiˇˇˇˇN(   t   __doc__t   typet   __metaclass__t   __all__t   atexitt   doctestt   ost   unittestt   ELLIPSISt   NORMALIZE_WHITESPACEt   REPORT_NDIFFt   DOCTEST_FLAGS(    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_docs.pyt   <module>   s   	
filename:/usr/lib/python2.7/dist-packages/bs4/tests/test_soup.py
__doc__
# -*- coding: utf-8 -*-
"""Tests of Beautiful Soup as a whole."""

filename:/usr/lib/python2.7/dist-packages/bs4/tests/test_htmlparser.py
__doc__
"""Tests to ensure that the html.parser tree builder generates good
trees."""

from pdb import set_trace
import pickle
from bs4.testing import SoupTest, HTMLTreeBuilderSmokeTest
from bs4.builder import HTMLParserTreeBuilder

class HTMLParserTreeBuilderSmokeTest(SoupTest, HTMLTreeBuilderSmokeTest):

    @property
    def default_builder(self):
        return HTMLParserTreeBuilder()

    def test_namespaced_system_doctype(self):
        # html.parser can't handle namespaced doctypes, so skip this one.
        pass

    def test_namespaced_public_doctype(self):
        # html.parser can't handle namespaced doctypes, so skip this one.
        pass

    def test_builder_is_pickled(self):
        """Unlike most tree builders, HTMLParserTreeBuilder and will
        be restored after pickling.
        """
        tree = self.soup("<a><b>foo</a>")
        dumped = pickle.dumps(tree, 2)
        loaded = pickle.loads(dumped)
        self.assertTrue(isinstance(loaded.builder, type(tree.builder)))



filename:/usr/lib/python2.7/dist-packages/bs4/tests/__init__.pyc
__doc__
Û
ËÿCNc           @   s
   d  Z  d S(   s   The beautifulsoup tests.N(   t   __doc__(    (    (    s6   /usr/lib/python2.7/dist-packages/bs4/tests/__init__.pyt   <module>   s    
filename:/usr/lib/python2.7/dist-packages/bs4/tests/test_lxml.pyc
__doc__
Û
‘OêUc           @   sK  d  Z  d d l Z d d l Z y" d d l Z e Z e j j Z Wn e	 k
 ra Z
 e Z d Z n Xe rÅ d d l m Z m Z n  d d l m Z m Z d d l m Z m Z m Z d d l m Z d d l m Z d d	 l m Z m Z m Z m Z e e d
 É d e e f d Ñ  É  YÉ Z e e d É d e e f d Ñ  É  YÉ Z d S(   s@   Tests to ensure that the lxml tree builder generates good trees.iˇˇˇˇNi    (   t   LXMLTreeBuildert   LXMLTreeBuilderForXML(   t   BeautifulSoupt   BeautifulStoneSoup(   t   Commentt   Doctypet   SoupStrainer(   t   skipIf(   t   test_htmlparser(   t   HTMLTreeBuilderSmokeTestt   XMLTreeBuilderSmokeTestt   SoupTestR   s;   lxml seems not to be present, not testing its tree builder.t   LXMLTreeBuilderSmokeTestc           B   sT   e  Z d  Z e d Ñ  É Z d Ñ  Z e e p7 e d
 k  d É d Ñ  É Z	 d	 Ñ  Z
 RS(   s!   See ``HTMLTreeBuilderSmokeTest``.c         C   s   t  É  S(   N(   R    (   t   self(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_lxml.pyt   default_builder%   s    c         C   s4   |  j  d d É |  j  d d É |  j  d d É d  S(   Ns   <p>foo&#10000000000000;bar</p>s   <p>foobar</p>s   <p>foo&#x10000000000000;bar</p>s   <p>foo&#1000000000;bar</p>(   t   assertSoupEquals(   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_lxml.pyt   test_out_of_range_entity)   s    

i   i   i   i    s@   Skipping doctype test for old version of lxml to avoid segfault.c         C   s6   |  j  d É } | j d } |  j d | j É  É d  S(   Ns
   <!DOCTYPE>i    t    (   t   soupt   contentst   assertEqualt   strip(   R   R   t   doctype(    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_lxml.pyt   test_empty_doctype4   s    c         C   sd   t  j d t É è } t d É } Wd  QX|  j d t | j É É |  j d t | d j	 É k É d  S(   Nt   records   <b />u   <b/>s&   BeautifulStoneSoup class is deprecatedi    (
   t   warningst   catch_warningst   TrueR   R   t   unicodet   bt
   assertTruet   strt   message(   R   t   wR   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_lxml.pyt%   test_beautifulstonesoup_is_xml_parser<   s    (   i   i   i   i    (   t   __name__t
   __module__t   __doc__t   propertyR   R   R   t   LXML_PRESENTt   LXML_VERSIONR   R"   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_lxml.pyR      s   	s?   lxml seems not to be present, not testing its XML tree builder.t   LXMLXMLTreeBuilderSmokeTestc           B   s   e  Z d  Z e d Ñ  É Z RS(   s!   See ``HTMLTreeBuilderSmokeTest``.c         C   s   t  É  S(   N(   R   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_lxml.pyR   J   s    (   R#   R$   R%   R&   R   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_lxml.pyR)   D   s   (   i    (   R%   t   reR   t
   lxml.etreet   lxmlR   R'   t   etreeR(   t   ImportErrort   et   Falset   bs4.builderR    R   t   bs4R   R   t   bs4.elementR   R   R   t   bs4.testingR   t	   bs4.testsR   R	   R
   R   R   R)   (    (    (    s7   /usr/lib/python2.7/dist-packages/bs4/tests/test_lxml.pyt   <module>   s0   
"	"	
filename:/usr/lib/python2.7/dist-packages/bs4/tests/test_builder_registry.pyc
__doc__
Û
cÑTc           @   sÓ   d  Z  d d l Z d d l Z d d l m Z d d l m Z m Z m	 Z	 y d d l m
 Z
 e Z Wn e k
 r} e Z n Xy  d d l m Z m Z e Z Wn e k
 r∑ e Z n Xd e j f d Ñ  É  YZ d	 e j f d
 Ñ  É  YZ d S(   s   Tests of the builder registry.iˇˇˇˇN(   t   BeautifulSoup(   t   builder_registryt   HTMLParserTreeBuildert   TreeBuilderRegistry(   t   HTML5TreeBuilder(   t   LXMLTreeBuilderForXMLt   LXMLTreeBuildert   BuiltInRegistryTestc           B   s2   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s@   Test the built-in registry with the default builders registered.c         C   sè   t  r% |  j t j d d É t É n  t  rJ |  j t j d d É t É n  |  j t j d d É t É t rã |  j t j d d É t É n  d  S(   Nt   fastt   htmlt
   permissivet   xmlt   strictt   html5lib(	   t   LXML_PRESENTt   assertEqualt   registryt   lookupR   R   R   t   HTML5LIB_PRESENTR   (   t   self(    (    sC   /usr/lib/python2.7/dist-packages/bs4/tests/test_builder_registry.pyt   test_combination    s    

c         C   sì   t  r; |  j t j d É t É |  j t j d É t É nT |  j t j d É d  É t rv |  j t j d É t É n |  j t j d É t	 É d  S(   NR	   R   (
   R   R   R   R   R   R   t   NoneR   R   R   (   R   (    (    sC   /usr/lib/python2.7/dist-packages/bs4/tests/test_builder_registry.pyt   test_lookup_by_markup_type.   s    c         C   sÄ   t  rA |  j t j d d É t É |  j t j d d É t É n  t rc |  j t j d É t É n  |  j t j d É t É d  S(   Nt   lxmlR   R	   R   s   html.parser(	   R   R   R   R   R   R   R   R   R   (   R   (    (    sC   /usr/lib/python2.7/dist-packages/bs4/tests/test_builder_registry.pyt   test_named_library9   s    

c      	   C   s^   t  j d t É è- } t d d d Ét d d d d g ÉWd  QX|  j t t d d d Éd  S(   Nt   recordt    t   featuresR	   R   s   no-such-feature(   t   warningst   catch_warningst   TrueR    t   assertRaisest
   ValueError(   R   t   w(    (    sC   /usr/lib/python2.7/dist-packages/bs4/tests/test_builder_registry.pyt*   test_beautifulsoup_constructor_does_lookupF   s
    (   t   __name__t
   __module__t   __doc__R   R   R   R"   (    (    (    sC   /usr/lib/python2.7/dist-packages/bs4/tests/test_builder_registry.pyR      s
   			t   RegistryTestc           B   s_   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z RS(
   s.   Test the TreeBuilderRegistry class in general.c         C   s   t  É  |  _ d  S(   N(   R   R   (   R   (    (    sC   /usr/lib/python2.7/dist-packages/bs4/tests/test_builder_registry.pyt   setUpY   s    c         G   s=   t  d d j | É t f i | d 6É } |  j j | É | S(   Nt   Builder_t   _R   (   t   typet   joint   objectR   t   register(   R   t   feature_listt   cls(    (    sC   /usr/lib/python2.7/dist-packages/bs4/tests/test_builder_registry.pyt   builder_for_features\   s    c         C   sE   |  j  É  } |  j |  j j d É d  É |  j |  j j É  | É d  S(   Nt   foo(   R0   R   R   R   R   (   R   t   builder(    (    sC   /usr/lib/python2.7/dist-packages/bs4/tests/test_builder_registry.pyt   test_register_with_no_featuresc   s    c         C   sN   |  j  d d É } |  j |  j j d É | É |  j |  j j d É | É d  S(   NR1   t   bar(   R0   R   R   R   (   R   R2   (    (    sC   /usr/lib/python2.7/dist-packages/bs4/tests/test_builder_registry.pyt0   test_register_with_features_makes_lookup_succeedn   s    c         C   s2   |  j  d d É } |  j |  j j d É d  É d  S(   NR1   R4   t   baz(   R0   R   R   R   R   (   R   R2   (    (    sC   /usr/lib/python2.7/dist-packages/bs4/tests/test_builder_registry.pyt4   test_lookup_fails_when_no_builder_implements_features   s    c         C   s;   |  j  d É } |  j  d É } |  j |  j j É  | É d  S(   NR1   R4   (   R0   R   R   R   (   R   t   builder1t   builder2(    (    sC   /usr/lib/python2.7/dist-packages/bs4/tests/test_builder_registry.pytC   test_lookup_gets_most_recent_registration_when_no_feature_specifiedw   s    c         C   s   |  j  |  j j É  d  É d  S(   N(   R   R   R   R   (   R   (    (    sC   /usr/lib/python2.7/dist-packages/bs4/tests/test_builder_registry.pyt2   test_lookup_fails_when_no_tree_builders_registered|   s    c         C   s´   |  j  d É } |  j  d É } |  j  d d d É } |  j  d d d É } |  j  d É } |  j  d É } |  j |  j j d d É | É |  j |  j j d d d É | É d  S(   NR1   R4   R6   t   quux(   R0   R   R   R   (   R   t   has_onet   has_the_othert   has_both_earlyt   has_both_latet	   lacks_one(    (    sC   /usr/lib/python2.7/dist-packages/bs4/tests/test_builder_registry.pyt<   test_lookup_gets_most_recent_builder_supporting_all_features   s    c         C   sG   |  j  d d É } |  j  d d É } |  j |  j j d d É d  É d  S(   NR1   R4   R6   (   R0   R   R   R   R   (   R   R8   R9   (    (    sC   /usr/lib/python2.7/dist-packages/bs4/tests/test_builder_registry.pyt:   test_lookup_fails_when_cannot_reconcile_requested_featuresê   s    (   R#   R$   R%   R'   R0   R3   R5   R7   R:   R;   RB   RC   (    (    (    sC   /usr/lib/python2.7/dist-packages/bs4/tests/test_builder_registry.pyR&   V   s   								(   R%   t   unittestR   t   bs4R    t   bs4.builderR   R   R   R   R   R   R   t   ImportErrort   FalseR   R   R   t   TestCaseR   R&   (    (    (    sC   /usr/lib/python2.7/dist-packages/bs4/tests/test_builder_registry.pyt   <module>   s    



9
filename:/usr/lib/python2.7/dist-packages/bs4/tests/test_htmlparser.pyc
__doc__
Û
∆PêUc           @   se   d  Z  d d l m Z d d l Z d d l m Z m Z d d l m Z d e e f d Ñ  É  YZ	 d S(   sG   Tests to ensure that the html.parser tree builder generates good
trees.iˇˇˇˇ(   t	   set_traceN(   t   SoupTestt   HTMLTreeBuilderSmokeTest(   t   HTMLParserTreeBuildert   HTMLParserTreeBuilderSmokeTestc           B   s2   e  Z e d  Ñ  É Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s   t  É  S(   N(   R   (   t   self(    (    s=   /usr/lib/python2.7/dist-packages/bs4/tests/test_htmlparser.pyt   default_builder   s    c         C   s   d  S(   N(    (   R   (    (    s=   /usr/lib/python2.7/dist-packages/bs4/tests/test_htmlparser.pyt   test_namespaced_system_doctype   s    c         C   s   d  S(   N(    (   R   (    (    s=   /usr/lib/python2.7/dist-packages/bs4/tests/test_htmlparser.pyt   test_namespaced_public_doctype   s    c         C   sV   |  j  d É } t j | d É } t j | É } |  j t | j t | j É É É d S(   sf   Unlike most tree builders, HTMLParserTreeBuilder and will
        be restored after pickling.
        s   <a><b>foo</a>i   N(   t   soupt   picklet   dumpst   loadst
   assertTruet
   isinstancet   buildert   type(   R   t   treet   dumpedt   loaded(    (    s=   /usr/lib/python2.7/dist-packages/bs4/tests/test_htmlparser.pyt   test_builder_is_pickled   s    (   t   __name__t
   __module__t   propertyR   R   R   R   (    (    (    s=   /usr/lib/python2.7/dist-packages/bs4/tests/test_htmlparser.pyR   	   s   		(
   t   __doc__t   pdbR    R
   t   bs4.testingR   R   t   bs4.builderR   R   (    (    (    s=   /usr/lib/python2.7/dist-packages/bs4/tests/test_htmlparser.pyt   <module>   s
   
filename:/usr/lib/python2.7/dist-packages/bs4/diagnose.pyc
__doc__
Û
®”	Vc           @   so  d  Z  d Z d d l Z d d l m Z d d l m Z d d l Z d d l m Z m Z d d l m	 Z	 d d l
 Z
 d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d Ñ  Z e d	 Ñ Z d
 e f d Ñ  É  YZ d Ñ  Z d Z d Z d d Ñ Z d d Ñ Z d d Ñ Z d d Ñ Z d d d Ñ Z e d k rke e j j É  É n  d S(   s=   Diagnostic functions, mainly for use when doing tech support.t   MITiˇˇˇˇN(   t   StringIO(   t
   HTMLParser(   t   BeautifulSoupt   __version__(   t   builder_registryc   
      C   s2  d t  GHd t j GHd d d g } xK | D]C } x: t j D] } | | j k r; Pq; q; W| j | É d | GHq+ Wd | k r· | j d d g É y2 d d	 l m	 } d
 d j
 t t | j É É GHWq· t k
 r› } d GHq· Xn  d | k r'y d d l } d | j  GHWq't k
 r#} d GHq'Xn  t |  d É rE|  j É  }  n` t j j |  É rud |  GHt |  É j É  }  n0 |  j d É sì|  j d É r•d |  GHd GHd SHxÖ | D]} } d | GHt } y t |  | É }	 t } Wn& t k
 r} d | GHt j É  n X| r!d | GH|	 j É  GHn  d d GHq≠Wd S(   s/   Diagnostic suite for isolating common problems.s'   Diagnostic running on Beautiful Soup %ss   Python version %ss   html.parsert   html5libt   lxmls;   I noticed that %s is not installed. Installing it may help.t   xmliˇˇˇˇ(   t   etrees   Found lxml version %st   .s.   lxml is not installed or couldn't be imported.Ns   Found html5lib version %ss2   html5lib is not installed or couldn't be imported.t   reads7   "%s" looks like a filename. Reading data from the file.s   http:s   https:s<   "%s" looks like a URL. Beautiful Soup is not an HTTP client.sp   You need to use some other library to get the document behind the URL, and feed that document to Beautiful Soup.s#   Trying to parse your markup with %ss   %s could not parse the markup.s#   Here's what %s did with the markup:t   -iP   (   R   t   syst   versionR   t   builderst   featurest   removet   appendR   R	   t   joint   mapt   strt   LXML_VERSIONt   ImportErrorR   t   hasattrR   t   ost   patht   existst   opent
   startswitht   FalseR   t   Truet	   Exceptiont	   tracebackt	   print_exct   prettify(
   t   datat   basic_parserst   namet   builderR	   t   eR   t   parsert   successt   soup(    (    s0   /usr/lib/python2.7/dist-packages/bs4/diagnose.pyt   diagnose   s\    	
"			
		c         K   s[   d d l  m } xD | j t |  É d | | çD]$ \ } } d | | j | j f GHq/ Wd S(   só   Print out the lxml events that occur during parsing.

    This lets you see how lxml parses a document when no Beautiful
    Soup code is running.
    iˇˇˇˇ(   R	   t   htmls   %s, %4s, %sN(   R   R	   t	   iterparseR   t   tagt   text(   R$   R-   t   kwargsR	   t   eventt   element(    (    s0   /usr/lib/python2.7/dist-packages/bs4/diagnose.pyt
   lxml_traceQ   s    +t   AnnouncingParserc           B   sh   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z RS(   s?   Announces HTMLParser parse events, without doing anything else.c         C   s	   | GHd  S(   N(    (   t   selft   s(    (    s0   /usr/lib/python2.7/dist-packages/bs4/diagnose.pyt   _p^   s    c         C   s   |  j  d | É d  S(   Ns   %s START(   R8   (   R6   R&   t   attrs(    (    s0   /usr/lib/python2.7/dist-packages/bs4/diagnose.pyt   handle_starttaga   s    c         C   s   |  j  d | É d  S(   Ns   %s END(   R8   (   R6   R&   (    (    s0   /usr/lib/python2.7/dist-packages/bs4/diagnose.pyt   handle_endtagd   s    c         C   s   |  j  d | É d  S(   Ns   %s DATA(   R8   (   R6   R$   (    (    s0   /usr/lib/python2.7/dist-packages/bs4/diagnose.pyt   handle_datag   s    c         C   s   |  j  d | É d  S(   Ns
   %s CHARREF(   R8   (   R6   R&   (    (    s0   /usr/lib/python2.7/dist-packages/bs4/diagnose.pyt   handle_charrefj   s    c         C   s   |  j  d | É d  S(   Ns   %s ENTITYREF(   R8   (   R6   R&   (    (    s0   /usr/lib/python2.7/dist-packages/bs4/diagnose.pyt   handle_entityrefm   s    c         C   s   |  j  d | É d  S(   Ns
   %s COMMENT(   R8   (   R6   R$   (    (    s0   /usr/lib/python2.7/dist-packages/bs4/diagnose.pyt   handle_commentp   s    c         C   s   |  j  d | É d  S(   Ns   %s DECL(   R8   (   R6   R$   (    (    s0   /usr/lib/python2.7/dist-packages/bs4/diagnose.pyt   handle_decls   s    c         C   s   |  j  d | É d  S(   Ns   %s UNKNOWN-DECL(   R8   (   R6   R$   (    (    s0   /usr/lib/python2.7/dist-packages/bs4/diagnose.pyt   unknown_declv   s    c         C   s   |  j  d | É d  S(   Ns   %s PI(   R8   (   R6   R$   (    (    s0   /usr/lib/python2.7/dist-packages/bs4/diagnose.pyt	   handle_piy   s    (   t   __name__t
   __module__t   __doc__R8   R:   R;   R<   R=   R>   R?   R@   RA   RB   (    (    (    s0   /usr/lib/python2.7/dist-packages/bs4/diagnose.pyR5   [   s   									c         C   s   t  É  } | j |  É d S(   s£   Print out the HTMLParser events that occur during parsing.

    This lets you see how HTMLParser parses a document when no
    Beautiful Soup code is running.
    N(   R5   t   feed(   R$   R)   (    (    s0   /usr/lib/python2.7/dist-packages/bs4/diagnose.pyt   htmlparser_trace|   s    	t   aeiout   bcdfghjklmnpqrstvwxyzi   c         C   sS   d } xF t  |  É D]8 } | d d k r2 t } n t } | t j | É 7} q W| S(   s#   Generate a random word-like string.t    i   i    (   t   ranget   _consonantst   _vowelst   randomt   choice(   t   lengthR7   t   it   t(    (    s0   /usr/lib/python2.7/dist-packages/bs4/diagnose.pyt   rwordà   s    	i   c         C   s   d j  d Ñ  t |  É DÉ É S(   s'   Generate a random sentence-like string.t    c         s   s'   |  ] } t  t j d  d É É Vq d S(   i   i	   N(   RS   RN   t   randint(   t   .0RQ   (    (    s0   /usr/lib/python2.7/dist-packages/bs4/diagnose.pys	   <genexpr>ï   s    (   R   RK   (   RP   (    (    s0   /usr/lib/python2.7/dist-packages/bs4/diagnose.pyt	   rsentenceì   s    iË  c         C   sÎ   d d d d d d d g } g  } x≤ t  |  É D]§ } t j d d	 É } | d k ru t j | É } | j d
 | É q. | d k r£ | j t t j d d É É É q. | d k r. t j | É } | j d | É q. q. Wd d j | É d S(   s+   Randomly generate an invalid HTML document.t   pt   divt   spanRQ   t   bt   scriptt   tablei    i   s   <%s>i   i   i   s   </%s>s   <html>s   
s   </html>(   RK   RN   RU   RO   R   RW   R   (   t   num_elementst	   tag_namest   elementsRQ   RO   t   tag_name(    (    s0   /usr/lib/python2.7/dist-packages/bs4/diagnose.pyt   rdocó   s    "i†Ü c   
      C   sS  d t  GHt |  É } d t | É GHxú d d d g d d g D]Ç } t } y1 t j É  } t | | É } t j É  } t } Wn& t k
 r¢ } d | GHt j	 É  n X| r= d | | | f GHq= q= Wd	 d
 l
 m } t j É  } | j | É t j É  } d | | GHd	 d l }	 |	 j É  } t j É  } | j | É t j É  } d | | GHd S(   s.   Very basic head-to-head performance benchmark.s1   Comparative parser benchmark on Beautiful Soup %ss3   Generated a large invalid HTML document (%d bytes).R   R-   R   s   html.parsers   %s could not parse the markup.s"   BS4+%s parsed the markup in %.2fs.iˇˇˇˇ(   R	   s$   Raw lxml parsed the markup in %.2fs.Ns(   Raw html5lib parsed the markup in %.2fs.(   R   Rb   t   lenR   t   timeR   R   R    R!   R"   R   R	   t   HTMLR   R   t   parse(
   R^   R$   R)   R*   t   aR+   R[   R(   R	   R   (    (    s0   /usr/lib/python2.7/dist-packages/bs4/diagnose.pyt   benchmark_parsers©   s4    	
	R   c         C   sÇ   t  j É  } | j } t |  É } t d t d | d | É } t j d | | | É t j	 | É } | j
 d É | j d d É d  S(   Nt   bs4R$   R)   s   bs4.BeautifulSoup(data, parser)t
   cumulatives   _html5lib|bs4i2   (   t   tempfilet   NamedTemporaryFileR&   Rb   t   dictRi   t   cProfilet   runctxt   pstatst   Statst
   sort_statst   print_stats(   R^   R)   t
   filehandlet   filenameR$   t   varst   stats(    (    s0   /usr/lib/python2.7/dist-packages/bs4/diagnose.pyt   profile…   s    	t   __main__(    RE   t   __license__Rn   R   R   Ri   R   R   t   bs4.builderR   R   Rp   RN   Rk   Rd   R!   R   R,   R   R4   R5   RG   RM   RL   RS   RW   Rb   Rh   Rx   RC   t   stdinR   (    (    (    s0   /usr/lib/python2.7/dist-packages/bs4/diagnose.pyt   <module>   s8   	<
!		 
filename:/usr/lib/python2.7/dist-packages/bs4/__init__.pyc
__doc__
Û
≠÷	Vc           @   sd  d  Z  d Z d Z d Z d Z d g Z d d l Z d d l Z d d l Z d d	 l	 m
 Z
 m Z d d
 l m Z d d l m Z m Z m Z m Z m Z m Z m Z m Z m Z m Z m Z d d k d e f d Ñ  É  YZ e Z e Z d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e  f d Ñ  É  YZ! e" d k r`d d l# Z# e e# j$ É Z% e% j& É  GHn  d S(   sP  Beautiful Soup
Elixir and Tonic
"The Screen-Scraper's Friend"
http://www.crummy.com/software/BeautifulSoup/

Beautiful Soup uses a pluggable XML or HTML parser to parse a
(possibly invalid) document into a tree representation. Beautiful Soup
provides provides methods and Pythonic idioms that make it easy to
navigate, search, and modify the parse tree.

Beautiful Soup works with Python 2.6 and up. It works better if lxml
and/or html5lib is installed.

For more than you ever wanted to know about Beautiful Soup, see the
documentation:
http://www.crummy.com/software/BeautifulSoup/bs4/doc/
s*   Leonard Richardson (leonardr@segfault.org)s   4.4.1s*   Copyright (c) 2004-2015 Leonard Richardsont   MITt   BeautifulSoupiˇˇˇˇNi   (   t   builder_registryt   ParserRejectedMarkup(   t   UnicodeDammit(   t   CDatat   Commentt   DEFAULT_OUTPUT_ENCODINGt   Declarationt   Doctypet   NavigableStringt   PageElementt   ProcessingInstructiont	   ResultSett   SoupStrainert   Tags`   You are trying to run the Python 2 version of Beautiful Soup under Python 3. This will not work.su   You need to convert the code, either by installing it (`python setup.py install`) or by running 2to3 (`2to3 -w bs4`).c           B   s  e  Z d  Z d Z d d g Z d Z d Z d d d d d d d Ñ Z d Ñ  Z	 d	 Ñ  Z
 d
 Ñ  Z d Ñ  Z d d d Ñ Z e d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e d Ñ Z d d d Ñ Z d e d Ñ Z d Ñ  Z d d Ñ Z d Ñ  Z e e d d Ñ Z RS(   s  
    This class defines the basic interface called by the tree builders.

    These methods will be called by the parser:
      reset()
      feed(markup)

    The tree builder may call these methods from its feed() implementation:
      handle_starttag(name, attrs) # See note about return value
      handle_endtag(name)
      handle_data(data) # Appends to the current data node
      endData(containerClass=NavigableString) # Ends the current data node

    No matter how complicated the underlying parser is, you should be
    able to build a tree using 'start tag' events, 'end tag' events,
    'data' events, and "done with data" events.

    If you encounter an empty-element tag (aka a self-closing tag,
    like HTML's <br> tag), call handle_starttag and then
    handle_endtag.
    u
   [document]t   htmlt   fasts    
	s¢  No parser was explicitly specified, so I'm using the best available %(markup_type)s parser for this system ("%(parser)s"). This usually isn't a problem, but if you run this code on another system, or in a different virtual environment, it may use a different parser and behave differently.

To get rid of this warning, change this:

 BeautifulSoup([your markup])

to this:

 BeautifulSoup([your markup], "%(parser)s")
t    c            s!  d à  k r t  j d É n  d à  k r? à  d =t  j d É n  d à  k rb à  d =t  j d É n  d à  k rÖ à  d =t  j d É n  d	 à  k r® à  d	 =t  j d
 É n  á  f d Ü  } | p… | d d É } | pﬁ | d d É } t à  É d k rà  j É  j É  }	 t d |	 É Ç n  | d$ k r| }
 t | t É rE| g } n  | d$ k sct | É d k ro|  j	 } n  t
 j | å  } | d$ k r¶t d d j | É É Ç n  | É  } |
 | j k p |
 | j k s| j rﬂd } n d } t  j |  j t d | j d | É É qn  | |  _ | j |  _ |  |  j _ | |  _ t | d É rY| j É  } nDt | É d k rùt | t É rôt j j rô| j d É } n | } t } y t j j | É } Wn t k
 r–} n X| rt | t É r¯| j d É } n  t  j d | É n  | d  d k s,| d  d k rùt | t  É rGd  | k sbt | t É röd! | k röt | t É rÉ| j d É } n  t  j d" | É qöqùn  xh |  j j! | | d# | ÉD]K \ |  _" |  _# |  _$ |  _% |  j& É  y |  j' É  PWqπt( k
 rqπXqπWd$ |  _" d$ |  j _ d$ S(%   s™   The Soup object is initialized as the 'root tag', and the
        provided markup (which can be a string or a file-like object)
        is fed into the underlying parser.t   convertEntitiessà   BS4 does not respect the convertEntities argument to the BeautifulSoup constructor. Entities are always converted to Unicode characters.t   markupMassagesì   BS4 does not respect the markupMassage argument to the BeautifulSoup constructor. The tree builder is responsible for any necessary markup massage.t   smartQuotesTosä   BS4 does not respect the smartQuotesTo argument to the BeautifulSoup constructor. Smart quotes are always converted to Unicode characters.t   selfClosingTagssò   BS4 does not respect the selfClosingTags argument to the BeautifulSoup constructor. The tree builder is responsible for understanding self-closing tags.t   isHTMLsî   BS4 does not respect the isHTML argument to the BeautifulSoup constructor. Suggest you use features='lxml' for HTML and features='lxml-xml' for XML.c            s<   |  à  k r8 t  j d |  | f É à  |  } à  |  =| Sd  S(   NsL   The "%s" argument to the BeautifulSoup constructor has been renamed to "%s."(   t   warningst   warnt   None(   t   old_namet   new_namet   value(   t   kwargs(    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyt   deprecated_argument|   s    
t   parseOnlyTheset
   parse_onlyt   fromEncodingt   from_encodingi    s2   __init__() got an unexpected keyword argument '%s'sj   Couldn't find a tree builder with the features you requested: %s. Do you need to install a parser library?t   ,t   XMLt   HTMLt   parsert   markup_typet   readi   t   utf8sw   "%s" looks like a filename, not markup. You should probably open this file and pass the filehandle into Beautiful Soup.i   s   http:i   s   https:t    u    s±   "%s" looks like a URL. Beautiful Soup is not an HTTP client. You should probably use an HTTP client to get the document behind the URL, and feed that document to Beautiful Soup.t   exclude_encodingsN()   R   R   t   lent   keyst   popt	   TypeErrorR   t
   isinstancet
   basestringt   DEFAULT_BUILDER_FEATURESR   t   lookupt   FeatureNotFoundt   joint   NAMEt   ALTERNATE_NAMESt   is_xmlt   NO_PARSER_SPECIFIED_WARNINGt   dictt   buildert   soupR!   t   hasattrR)   t   unicodet   ost   patht   supports_unicode_filenamest   encodet   Falset   existst	   Exceptiont   bytest   prepare_markupt   markupt   original_encodingt   declared_html_encodingt   contains_replacement_characterst   resett   _feedR   (   t   selfRI   t   featuresR<   R!   R#   R,   R   R   t   argt   original_featurest   builder_classR(   t   possible_filenamet   is_filet   e(    (   R   s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyt   __init__R   sÆ    





								 	.

	c         C   s   t  |  É |  j É  d |  j ÉS(   NR<   (   t   typeRC   R<   (   RO   (    (    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyt   __copy__·   s    c         C   s6   t  |  j É } d | k r2 |  j j r2 | d =n  | S(   NR<   (   R;   t   __dict__R<   t	   picklable(   RO   t   d(    (    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyt   __getstate__‰   s    
c         C   sT   |  j  j É  |  j  j |  j É |  j É  x# |  j j |  j k rO |  j É  q- Wd  S(   N(	   R<   RM   t   feedRI   t   endDatat
   currentTagt   namet   ROOT_TAG_NAMEt   popTag(   RO   (    (    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyRN   Î   s
    
c         C   sg   t  j |  |  |  j |  j É d |  _ |  j j É  g  |  _ d  |  _ g  |  _	 g  |  _
 |  j |  É d  S(   Ni   (   R   RW   R<   Rb   t   hiddenRM   t   current_dataR   R`   t   tagStackt   preserve_whitespace_tag_stackt   pushTag(   RO   (    (    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyRM   ı   s    					c         K   s   t  d |  j | | | | É S(   s+   Create a new tag associated with this soup.N(   R   R   R<   (   RO   Ra   t	   namespacet   nsprefixt   attrs(    (    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyt   new_tagˇ   s    c         C   s
   | | É S(   s7   Create a new NavigableString associated with this soup.(    (   RO   t   st   subclass(    (    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyt
   new_string  s    c         C   s   t  d É Ç d  S(   Ns4   BeautifulSoup objects don't support insert_before().(   t   NotImplementedError(   RO   t	   successor(    (    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyt   insert_before  s    c         C   s   t  d É Ç d  S(   Ns3   BeautifulSoup objects don't support insert_after().(   Rp   (   RO   Rq   (    (    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyt   insert_after
  s    c         C   s^   |  j  j É  } |  j r; | |  j d k r; |  j j É  n  |  j  rW |  j  d |  _ n  |  j S(   Niˇˇˇˇ(   Rf   R/   Rg   R`   (   RO   t   tag(    (    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyRc     s    	c         C   sk   |  j  r |  j  j j | É n  |  j j | É |  j d |  _  | j |  j j k rg |  j j | É n  d  S(   Niˇˇˇˇ(   R`   t   contentst   appendRf   Ra   R<   t   preserve_whitespace_tagsRg   (   RO   Rt   (    (    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyRh     s    	c         C   sÊ   |  j  r‚ d j |  j  É } |  j s{ t } x' | D] } | |  j k r1 t } Pq1 q1 W| r{ d | k ro d } qx d } q{ n  g  |  _  |  j r∆ t |  j É d k r∆ |  j j	 s¬ |  j j
 | É r∆ d  S| | É } |  j | É n  d  S(   Nu    s   
R+   i   (   Re   R6   Rg   t   Truet   ASCII_SPACESRD   R!   R-   Rf   t   textt   searcht   object_was_parsed(   RO   t   containerClassRe   t
   strippablet   it   o(    (    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyR_     s&    				c   	      C   sõ  | p |  j  } | p |  j } d } } } t | t É rk | j } | j } | j } | sk | j } qk n  | j	 | | | | | É | |  _ | j
 j | É | j ró| j
 j | É } | d k r” | } d } n | j
 | d } } | t | j
 É d k r| j } d } n | j
 | d } } | | _ | rC| | _ n  | | _ | r^| | _ n  | | _ | ry| | _ n  | | _ | ró| | _ qón  d S(   s    Add an object to the parse tree.i    i   N(   R`   t   _most_recent_elementR   R1   R   t   next_elementt   next_siblingt   previous_siblingt   previous_elementt   setupRu   Rv   t   indexR-   (	   RO   RÄ   t   parentt   most_recent_elementRÖ   RÇ   RÑ   RÉ   Rá   (    (    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyR|   =  sD    												c         C   sù   | |  j  k r d Sd } t |  j É } xn t | d d d É D]V } |  j | } | | j k râ | | j k râ | rÖ |  j É  } n  Pn  |  j É  } q? W| S(   s‹   Pops the tag stack up to and including the most recent
        instance of the given tag. If inclusivePop is false, pops the tag
        stack up to but *not* including the most recent instqance of
        the given tag.Ni   i    iˇˇˇˇ(   Rb   R   R-   Rf   t   rangeRa   t   prefixRc   (   RO   Ra   Rj   t   inclusivePopt   most_recently_poppedt
   stack_sizeR   t   t(    (    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyt	   _popToTagk  s    c      	   C   s∫   |  j  É  |  j rN t |  j É d k rN |  j j sJ |  j j | | É rN d St |  |  j | | | | |  j	 |  j
 É } | d k rà | S|  j
 r† | |  j
 _ n  | |  _
 |  j | É | S(   s  Push a start tag on to the stack.

        If this method returns None, the tag was rejected by the
        SoupStrainer. You should proceed as if the tag had not occured
        in the document. For instance, if this was a self-closing tag,
        don't call handle_endtag.
        i   N(   R_   R!   R-   Rf   Rz   t
   search_tagR   R   R<   R`   RÅ   RÇ   Rh   (   RO   Ra   Ri   Rj   Rk   Rt   (    (    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyt   handle_starttagÇ  s    

		c         C   s   |  j  É  |  j | | É d  S(   N(   R_   Rê   (   RO   Ra   Rj   (    (    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyt   handle_endtagù  s    
c         C   s   |  j  j | É d  S(   N(   Re   Rv   (   RO   t   data(    (    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyt   handle_data¢  s    t   minimalc         C   sp   |  j  r5 d } | d k r( d | } n  d | } n d } | sJ d } n d } | t t |  É j | | | É S(   sl   Returns a string or Unicode representation of this document.
        To get Unicode, pass None for encoding.R   s    encoding="%s"u   <?xml version="1.0"%s?>
u    i    N(   R9   R   t   superR   t   decode(   RO   t   pretty_printt   eventual_encodingt	   formattert   encoding_partRã   t   indent_level(    (    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyRò   •  s    		N(   t   __name__t
   __module__t   __doc__Rb   R3   Ry   R:   R   RW   RY   R]   RN   RM   Rl   R
   Ro   Rr   Rs   Rc   Rh   R_   R|   Rx   Rê   Rí   Rì   Rï   RD   R   Rò   (    (    (    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyR   2   s4   	é			
	
						.		t   BeautifulStoneSoupc           B   s   e  Z d  Z d Ñ  Z RS(   s&   Deprecated interface to an XML parser.c         O   s4   d | d <t  j d É t t |  É j | | é  d  S(   Nt   xmlRP   sx   The BeautifulStoneSoup class is deprecated. Instead of using it, pass features="xml" into the BeautifulSoup constructor.(   R   R   Ró   R°   RW   (   RO   t   argsR   (    (    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyRW   ¡  s    
(   Rû   Rü   R†   RW   (    (    (    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyR°   æ  s   t   StopParsingc           B   s   e  Z RS(    (   Rû   Rü   (    (    (    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyR§   …  s   R5   c           B   s   e  Z RS(    (   Rû   Rü   (    (    (    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyR5   Ã  s   t   __main__('   R†   t
   __author__t   __version__t   __copyright__t   __license__t   __all__R@   t   reR   R<   R   R   t   dammitR   t   elementR   R   R   R   R	   R
   R   R   R   R   R   R   t   _st   _soupR°   RF   R§   t
   ValueErrorR5   Rû   t   syst   stdinR=   t   prettify(    (    (    s0   /usr/lib/python2.7/dist-packages/bs4/__init__.pyt   <module>   s.   	L
ˇ ä
filename:/usr/lib/python2.7/dist-packages/chardet/langhungarianmodel.py
__doc__
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Communicator client code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

# 255: Control characters that usually does not exist in any text
# 254: Carriage/Return
# 253: symbol (punctuation) that does not belong to word
# 252: 0 - 9

# Character Mapping Table:
Latin2_HungarianCharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30
253, 28, 40, 54, 45, 32, 50, 49, 38, 39, 53, 36, 41, 34, 35, 47,
 46, 71, 43, 33, 37, 57, 48, 64, 68, 55, 52,253,253,253,253,253,
253,  2, 18, 26, 17,  1, 27, 12, 20,  9, 22,  7,  6, 13,  4,  8,
 23, 67, 10,  5,  3, 21, 19, 65, 62, 16, 11,253,253,253,253,253,
159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,
175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,
191,192,193,194,195,196,197, 75,198,199,200,201,202,203,204,205,
 79,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,
221, 51, 81,222, 78,223,224,225,226, 44,227,228,229, 61,230,231,
232,233,234, 58,235, 66, 59,236,237,238, 60, 69, 63,239,240,241,
 82, 14, 74,242, 70, 80,243, 72,244, 15, 83, 77, 84, 30, 76, 85,
245,246,247, 25, 73, 42, 24,248,249,250, 31, 56, 29,251,252,253,
)

win1250HungarianCharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30
253, 28, 40, 54, 45, 32, 50, 49, 38, 39, 53, 36, 41, 34, 35, 47,
 46, 72, 43, 33, 37, 57, 48, 64, 68, 55, 52,253,253,253,253,253,
253,  2, 18, 26, 17,  1, 27, 12, 20,  9, 22,  7,  6, 13,  4,  8,
 23, 67, 10,  5,  3, 21, 19, 65, 62, 16, 11,253,253,253,253,253,
161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,
177,178,179,180, 78,181, 69,182,183,184,185,186,187,188,189,190,
191,192,193,194,195,196,197, 76,198,199,200,201,202,203,204,205,
 81,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,
221, 51, 83,222, 80,223,224,225,226, 44,227,228,229, 61,230,231,
232,233,234, 58,235, 66, 59,236,237,238, 60, 70, 63,239,240,241,
 84, 14, 75,242, 71, 82,243, 73,244, 15, 85, 79, 86, 30, 77, 87,
245,246,247, 25, 74, 42, 24,248,249,250, 31, 56, 29,251,252,253,
)

# Model Table:
# total sequences: 100%
# first 512 sequences: 94.7368%
# first 1024 sequences:5.2623%
# rest  sequences:     0.8894%
# negative sequences:  0.0009%
HungarianLangModel = (
0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,2,2,3,3,1,1,2,2,2,2,2,1,2,
3,2,2,3,3,3,3,3,2,3,3,3,3,3,3,1,2,3,3,3,3,2,3,3,1,1,3,3,0,1,1,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,
3,2,1,3,3,3,3,3,2,3,3,3,3,3,1,1,2,3,3,3,3,3,3,3,1,1,3,2,0,1,1,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,1,1,2,3,3,3,1,3,3,3,3,3,1,3,3,2,2,0,3,2,3,
0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,
3,3,3,3,3,3,2,3,3,3,2,3,3,2,3,3,3,3,3,2,3,3,2,2,3,2,3,2,0,3,2,2,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,
3,3,3,3,3,3,2,3,3,3,3,3,2,3,3,3,1,2,3,2,2,3,1,2,3,3,2,2,0,3,3,3,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,2,2,3,3,3,3,3,3,2,3,3,3,3,2,3,3,3,3,0,2,3,2,
0,0,0,1,1,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,3,1,1,1,3,3,2,1,3,2,2,3,2,1,3,2,2,1,0,3,3,1,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,2,2,3,3,3,3,3,1,2,3,3,3,3,1,2,1,3,3,3,3,2,2,3,1,1,3,2,0,1,1,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,2,2,3,3,3,3,3,2,1,3,3,3,3,3,2,2,1,3,3,3,0,1,1,2,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,2,3,3,2,3,3,3,2,0,3,2,3,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,1,0,
3,3,3,3,3,3,2,3,3,3,2,3,2,3,3,3,1,3,2,2,2,3,1,1,3,3,1,1,0,3,3,2,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,2,3,3,3,2,3,2,3,3,3,2,3,3,3,3,3,1,2,3,2,2,0,2,2,2,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,2,2,2,3,1,3,3,2,2,1,3,3,3,1,1,3,1,2,3,2,3,2,2,2,1,0,2,2,2,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,
3,1,1,3,3,3,3,3,1,2,3,3,3,3,1,2,1,3,3,3,2,2,3,2,1,0,3,2,0,1,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,1,1,3,3,3,3,3,1,2,3,3,3,3,1,1,0,3,3,3,3,0,2,3,0,0,2,1,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,2,2,3,3,2,2,2,2,3,3,0,1,2,3,2,3,2,2,3,2,1,2,0,2,2,2,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,
3,3,3,3,3,3,1,2,3,3,3,2,1,2,3,3,2,2,2,3,2,3,3,1,3,3,1,1,0,2,3,2,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,1,2,2,2,2,3,3,3,1,1,1,3,3,1,1,3,1,1,3,2,1,2,3,1,1,0,2,2,2,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,2,1,2,1,1,3,3,1,1,1,1,3,3,1,1,2,2,1,2,1,1,2,2,1,1,0,2,2,1,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,1,1,2,1,1,3,3,1,0,1,1,3,3,2,0,1,1,2,3,1,0,2,2,1,0,0,1,3,2,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,2,1,3,3,3,3,3,1,2,3,2,3,3,2,1,1,3,2,3,2,1,2,2,0,1,2,1,0,0,1,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,3,3,3,2,2,2,2,3,1,2,2,1,1,3,3,0,3,2,1,2,3,2,1,3,3,1,1,0,2,1,3,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,2,2,2,3,2,3,3,3,2,1,1,3,3,1,1,1,2,2,3,2,3,2,2,2,1,0,2,2,1,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
1,0,0,3,3,3,3,3,0,0,3,3,2,3,0,0,0,2,3,3,1,0,1,2,0,0,1,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,1,2,3,3,3,3,3,1,2,3,3,2,2,1,1,0,3,3,2,2,1,2,2,1,0,2,2,0,1,1,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,2,2,1,3,1,2,3,3,2,2,1,1,2,2,1,1,1,1,3,2,1,1,1,1,2,1,0,1,2,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,
2,3,3,1,1,1,1,1,3,3,3,0,1,1,3,3,1,1,1,1,1,2,2,0,3,1,1,2,0,2,1,1,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,1,0,1,2,1,2,2,0,1,2,3,1,2,0,0,0,2,1,1,1,1,1,2,0,0,1,1,0,0,0,0,
1,2,1,2,2,2,1,2,1,2,0,2,0,2,2,1,1,2,1,1,2,1,1,1,0,1,0,0,0,1,1,0,
1,1,1,2,3,2,3,3,0,1,2,2,3,1,0,1,0,2,1,2,2,0,1,1,0,0,1,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,3,3,2,2,1,0,0,3,2,3,2,0,0,0,1,1,3,0,0,1,1,0,0,2,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,1,1,2,2,3,3,1,0,1,3,2,3,1,1,1,0,1,1,1,1,1,3,1,0,0,2,2,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,1,1,1,2,2,2,1,0,1,2,3,3,2,0,0,0,2,1,1,1,2,1,1,1,0,1,1,1,0,0,0,
1,2,2,2,2,2,1,1,1,2,0,2,1,1,1,1,1,2,1,1,1,1,1,1,0,1,1,1,0,0,1,1,
3,2,2,1,0,0,1,1,2,2,0,3,0,1,2,1,1,0,0,1,1,1,0,1,1,1,1,0,2,1,1,1,
2,2,1,1,1,2,1,2,1,1,1,1,1,1,1,2,1,1,1,2,3,1,1,1,1,1,1,1,1,1,0,1,
2,3,3,0,1,0,0,0,3,3,1,0,0,1,2,2,1,0,0,0,0,2,0,0,1,1,1,0,2,1,1,1,
2,1,1,1,1,1,1,2,1,1,0,1,1,0,1,1,1,0,1,2,1,1,0,1,1,1,1,1,1,1,0,1,
2,3,3,0,1,0,0,0,2,2,0,0,0,0,1,2,2,0,0,0,0,1,0,0,1,1,0,0,2,0,1,0,
2,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,2,0,1,1,1,1,1,0,1,
3,2,2,0,1,0,1,0,2,3,2,0,0,1,2,2,1,0,0,1,1,1,0,0,2,1,0,1,2,2,1,1,
2,1,1,1,1,1,1,2,1,1,1,1,1,1,0,2,1,0,1,1,0,1,1,1,0,1,1,2,1,1,0,1,
2,2,2,0,0,1,0,0,2,2,1,1,0,0,2,1,1,0,0,0,1,2,0,0,2,1,0,0,2,1,1,1,
2,1,1,1,1,2,1,2,1,1,1,2,2,1,1,2,1,1,1,2,1,1,1,1,1,1,1,1,1,1,0,1,
1,2,3,0,0,0,1,0,3,2,1,0,0,1,2,1,1,0,0,0,0,2,1,0,1,1,0,0,2,1,2,1,
1,1,0,0,0,1,0,1,1,1,1,1,2,0,0,1,0,0,0,2,0,0,1,1,1,1,1,1,1,1,0,1,
3,0,0,2,1,2,2,1,0,0,2,1,2,2,0,0,0,2,1,1,1,0,1,1,0,0,1,1,2,0,0,0,
1,2,1,2,2,1,1,2,1,2,0,1,1,1,1,1,1,1,1,1,2,1,1,0,0,1,1,1,1,0,0,1,
1,3,2,0,0,0,1,0,2,2,2,0,0,0,2,2,1,0,0,0,0,3,1,1,1,1,0,0,2,1,1,1,
2,1,0,1,1,1,0,1,1,1,1,1,1,1,0,2,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,1,
2,3,2,0,0,0,1,0,2,2,0,0,0,0,2,1,1,0,0,0,0,2,1,0,1,1,0,0,2,1,1,0,
2,1,1,1,1,2,1,2,1,2,0,1,1,1,0,2,1,1,1,2,1,1,1,1,0,1,1,1,1,1,0,1,
3,1,1,2,2,2,3,2,1,1,2,2,1,1,0,1,0,2,2,1,1,1,1,1,0,0,1,1,0,1,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,2,2,0,0,0,0,0,2,2,0,0,0,0,2,2,1,0,0,0,1,1,0,0,1,2,0,0,2,1,1,1,
2,2,1,1,1,2,1,2,1,1,0,1,1,1,1,2,1,1,1,2,1,1,1,1,0,1,2,1,1,1,0,1,
1,0,0,1,2,3,2,1,0,0,2,0,1,1,0,0,0,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,
1,2,1,2,1,2,1,1,1,2,0,2,1,1,1,0,1,2,0,0,1,1,1,0,0,0,0,0,0,0,0,0,
2,3,2,0,0,0,0,0,1,1,2,1,0,0,1,1,1,0,0,0,0,2,0,0,1,1,0,0,2,1,1,1,
2,1,1,1,1,1,1,2,1,0,1,1,1,1,0,2,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,
1,2,2,0,1,1,1,0,2,2,2,0,0,0,3,2,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,0,
1,1,0,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,0,0,1,1,1,0,1,0,1,
2,1,0,2,1,1,2,2,1,1,2,1,1,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,0,0,0,
1,2,2,2,2,2,1,1,1,2,0,2,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,
1,2,3,0,0,0,1,0,2,2,0,0,0,0,2,2,0,0,0,0,0,1,0,0,1,0,0,0,2,0,1,0,
2,1,1,1,1,1,0,2,0,0,0,1,2,1,1,1,1,0,1,2,0,1,0,1,0,1,1,1,0,1,0,1,
2,2,2,0,0,0,1,0,2,1,2,0,0,0,1,1,2,0,0,0,0,1,0,0,1,1,0,0,2,1,0,1,
2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,0,1,1,1,1,1,0,1,
1,2,2,0,0,0,1,0,2,2,2,0,0,0,1,1,0,0,0,0,0,1,1,0,2,0,0,1,1,1,0,1,
1,0,1,1,1,1,1,1,0,1,1,1,1,0,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,0,1,
1,0,0,1,0,1,2,1,0,0,1,1,1,2,0,0,0,1,1,0,1,0,1,1,0,0,1,0,0,0,0,0,
0,2,1,2,1,1,1,1,1,2,0,2,0,1,1,0,1,2,1,0,1,1,1,0,0,0,0,0,0,1,0,0,
2,1,1,0,1,2,0,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,2,1,0,1,
2,2,1,1,1,1,1,2,1,1,0,1,1,1,1,2,1,1,1,2,1,1,0,1,0,1,1,1,1,1,0,1,
1,2,2,0,0,0,0,0,1,1,0,0,0,0,2,1,0,0,0,0,0,2,0,0,2,2,0,0,2,0,0,1,
2,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,
1,1,2,0,0,3,1,0,2,1,1,1,0,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,
1,2,1,0,1,1,1,2,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,0,1,0,0,
2,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,2,0,0,0,
2,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,2,1,1,0,0,1,1,1,1,1,0,1,
2,1,1,1,2,1,1,1,0,1,1,2,1,0,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,1,0,1,1,1,1,1,0,0,1,1,2,1,0,0,0,1,1,0,0,0,1,1,0,0,1,0,1,0,0,0,
1,2,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,1,0,0,
2,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,1,2,0,0,1,0,0,1,0,1,0,0,0,
0,1,1,1,1,1,1,1,1,2,0,1,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,
1,0,0,1,1,1,1,1,0,0,2,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,
0,1,1,1,1,1,1,0,1,1,0,1,0,1,1,0,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,
1,0,0,1,1,1,0,0,0,0,1,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,
0,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,
0,0,0,1,0,0,0,0,0,0,1,1,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,
2,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,1,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,
)

Latin2HungarianModel = {
  'charToOrderMap': Latin2_HungarianCharToOrderMap,
  'precedenceMatrix': HungarianLangModel,
  'mTypicalPositiveRatio': 0.947368,
  'keepEnglishLetter': True,
  'charsetName': "ISO-8859-2"
}

Win1250HungarianModel = {
  'charToOrderMap': win1250HungarianCharToOrderMap,
  'precedenceMatrix': HungarianLangModel,
  'mTypicalPositiveRatio': 0.947368,
  'keepEnglishLetter': True,
  'charsetName': "windows-1250"
}

# flake8: noqa

filename:/usr/lib/python2.7/dist-packages/chardet/langhebrewmodel.py
__doc__
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Universal charset detector code.
#
# The Initial Developer of the Original Code is
#          Simon Montagu
# Portions created by the Initial Developer are Copyright (C) 2005
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#   Shy Shalom - original C code
#   Shoshannah Forbes - original C code (?)
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

# 255: Control characters that usually does not exist in any text
# 254: Carriage/Return
# 253: symbol (punctuation) that does not belong to word
# 252: 0 - 9

# Windows-1255 language model
# Character Mapping Table:
win1255_CharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30
253, 69, 91, 79, 80, 92, 89, 97, 90, 68,111,112, 82, 73, 95, 85,  # 40
 78,121, 86, 71, 67,102,107, 84,114,103,115,253,253,253,253,253,  # 50
253, 50, 74, 60, 61, 42, 76, 70, 64, 53,105, 93, 56, 65, 54, 49,  # 60
 66,110, 51, 43, 44, 63, 81, 77, 98, 75,108,253,253,253,253,253,  # 70
124,202,203,204,205, 40, 58,206,207,208,209,210,211,212,213,214,
215, 83, 52, 47, 46, 72, 32, 94,216,113,217,109,218,219,220,221,
 34,116,222,118,100,223,224,117,119,104,125,225,226, 87, 99,227,
106,122,123,228, 55,229,230,101,231,232,120,233, 48, 39, 57,234,
 30, 59, 41, 88, 33, 37, 36, 31, 29, 35,235, 62, 28,236,126,237,
238, 38, 45,239,240,241,242,243,127,244,245,246,247,248,249,250,
  9,  8, 20, 16,  3,  2, 24, 14, 22,  1, 25, 15,  4, 11,  6, 23,
 12, 19, 13, 26, 18, 27, 21, 17,  7, 10,  5,251,252,128, 96,253,
)

# Model Table:
# total sequences: 100%
# first 512 sequences: 98.4004%
# first 1024 sequences: 1.5981%
# rest  sequences:      0.087%
# negative sequences:   0.0015%
HebrewLangModel = (
0,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,2,3,2,1,2,0,1,0,0,
3,0,3,1,0,0,1,3,2,0,1,1,2,0,2,2,2,1,1,1,1,2,1,1,1,2,0,0,2,2,0,1,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,
1,2,1,2,1,2,0,0,2,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,
1,2,1,3,1,1,0,0,2,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,0,1,2,2,1,3,
1,2,1,1,2,2,0,0,2,2,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,0,1,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,2,2,2,2,3,2,
1,2,1,2,2,2,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,2,3,2,2,3,2,2,2,1,2,2,2,2,
1,2,1,1,2,2,0,1,2,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,0,2,2,2,2,2,
0,2,0,2,2,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,0,2,2,2,
0,2,1,2,2,2,0,0,2,1,0,0,0,0,1,0,1,0,0,0,0,0,0,2,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,3,2,1,2,3,2,2,2,
1,2,1,2,2,2,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,
3,3,3,3,3,3,3,3,3,2,3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,3,1,0,2,0,2,
0,2,1,2,2,2,0,0,1,2,0,0,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,2,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,2,3,2,2,3,2,1,2,1,1,1,
0,1,1,1,1,1,3,0,1,0,0,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,0,
0,0,1,0,0,0,0,0,2,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,
0,2,0,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,2,3,3,3,2,1,2,3,3,2,3,3,3,3,2,3,2,1,2,0,2,1,2,
0,2,0,2,2,2,0,0,1,2,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,
3,3,3,3,3,3,3,3,3,2,3,3,3,1,2,2,3,3,2,3,2,3,2,2,3,1,2,2,0,2,2,2,
0,2,1,2,2,2,0,0,1,2,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,2,3,3,2,2,2,3,3,3,3,1,3,2,2,2,
0,2,0,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,3,3,3,2,3,2,2,2,1,2,2,0,2,2,2,2,
0,2,0,2,2,2,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,1,3,2,3,3,2,3,3,2,2,1,2,2,2,2,2,2,
0,2,1,2,1,2,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,2,3,2,3,3,2,3,3,3,3,2,3,2,3,3,3,3,3,2,2,2,2,2,2,2,1,
0,2,0,1,2,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,2,1,2,3,3,3,3,3,3,3,2,3,2,3,2,1,2,3,0,2,1,2,2,
0,2,1,1,2,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,2,0,
3,3,3,3,3,3,3,3,3,2,3,3,3,3,2,1,3,1,2,2,2,1,2,3,3,1,2,1,2,2,2,2,
0,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,0,2,3,3,3,1,3,3,3,1,2,2,2,2,1,1,2,2,2,2,2,2,
0,2,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,2,3,3,3,2,2,3,3,3,2,1,2,3,2,3,2,2,2,2,1,2,1,1,1,2,2,
0,2,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,
1,0,1,0,0,0,0,0,2,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,2,3,3,2,3,1,2,2,2,2,3,2,3,1,1,2,2,1,2,2,1,1,0,2,2,2,2,
0,1,0,1,2,2,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,
3,0,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,0,
0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
3,2,2,1,2,2,2,2,2,2,2,1,2,2,1,2,2,1,1,1,1,1,1,1,1,2,1,1,0,3,3,3,
0,3,0,2,2,2,2,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
2,2,2,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,1,1,1,2,0,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,0,2,2,0,0,0,0,0,0,
0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,3,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1,0,2,1,0,
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,
0,3,1,1,2,2,2,2,2,1,2,2,2,1,1,2,2,2,2,2,2,2,1,2,2,1,0,1,1,1,1,0,
0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,2,1,1,1,1,2,1,1,2,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,
0,0,2,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,1,0,0,
2,1,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,1,2,1,1,1,1,0,0,0,0,
0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,2,1,2,2,2,2,2,2,2,2,2,2,1,2,1,2,1,1,2,1,1,1,2,1,2,1,2,0,1,0,1,
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,1,2,2,2,1,2,2,2,2,2,2,2,2,1,2,1,1,1,1,1,1,2,1,2,1,1,0,1,0,1,
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,1,2,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,
0,2,0,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,2,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,0,1,1,0,0,
0,1,1,1,2,1,2,2,2,0,2,0,2,0,1,1,2,1,1,1,1,2,1,0,1,1,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,1,0,0,0,0,0,1,0,1,2,2,0,1,0,0,1,1,2,2,1,2,0,2,0,0,0,1,2,0,1,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,2,0,2,1,2,0,2,0,0,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,1,0,0,0,0,0,1,0,2,1,1,0,1,0,0,1,1,1,2,2,0,0,1,0,0,0,1,0,0,1,
1,1,2,1,0,1,1,1,0,1,0,1,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,2,2,1,
0,2,0,1,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,1,0,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,1,1,1,1,1,1,1,1,2,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,0,1,1,0,1,0,0,0,1,1,0,1,
2,0,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,0,0,1,1,2,1,1,2,0,1,0,0,0,1,1,0,1,
1,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,1,1,2,0,1,0,0,0,0,2,1,1,2,0,2,0,0,0,1,1,0,1,
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,2,1,1,0,1,0,0,2,2,1,2,1,1,0,1,0,0,0,1,1,0,1,
2,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,1,2,2,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,0,1,0,1,
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,1,2,2,0,0,0,0,2,1,1,1,0,2,1,1,0,0,0,2,1,0,1,
1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,1,1,2,0,1,0,0,1,1,0,2,1,1,0,1,0,0,0,1,1,0,1,
2,2,1,1,1,0,1,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,2,1,1,0,1,0,0,1,1,0,1,2,1,0,2,0,0,0,1,1,0,1,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,
0,1,0,0,2,0,2,1,1,0,1,0,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,1,1,2,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,0,0,1,
1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,0,0,0,0,0,1,0,1,1,0,0,1,0,0,2,1,1,1,1,1,0,1,0,0,0,0,1,0,1,
0,1,1,1,2,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,1,2,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0,0,1,1,0,0,
)

Win1255HebrewModel = {
  'charToOrderMap': win1255_CharToOrderMap,
  'precedenceMatrix': HebrewLangModel,
  'mTypicalPositiveRatio': 0.984004,
  'keepEnglishLetter': False,
  'charsetName': "windows-1255"
}

# flake8: noqa

filename:/usr/lib/python2.7/dist-packages/chardet/compat.py
__doc__
######################## BEGIN LICENSE BLOCK ########################
# Contributor(s):
#   Ian Cordasco - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

import sys


if sys.version_info < (3, 0):
    base_str = (str, unicode)
else:
    base_str = (bytes, str)


def wrap_ord(a):
    if sys.version_info < (3, 0) and isinstance(a, base_str):
        return ord(a)
    else:
        return a

filename:/usr/lib/python2.7/dist-packages/chardet/langbulgarianmodel.pyc
__doc__
Û
aÀTc           @   sh   d≈ Z  d∆ Z d« Z i e  dº 6e dΩ 6dæ dø 6e d¿ 6d¡ d¬ 6Z i e dº 6e dΩ 6dæ dø 6e d¿ 6d√ d¬ 6Z dƒ S(»   iˇ   i˛   i˝   i¸   iM   iZ   ic   id   iH   im   ik   ie   iO   iπ   iQ   if   iL   i^   iR   in   i∫   il   i[   iJ   iw   iT   i`   io   iª   is   iA   iE   iF   iB   i?   iD   ip   ig   i\   i¬   ih   i_   iV   iW   iG   it   i√   iU   i]   ia   iq   iƒ   i≈   i∆   i«   i»   i…   i    iÀ   iÃ   iÕ   iŒ   iœ   i–   i—   i“   i”   i‘   i’   i÷   i◊   iÿ   iŸ   i⁄   i€   i‹   i›   iﬁ   iﬂ   i‡   i·   i‚   i„   i‰   iÂ   iÊ   ii   iÁ   iË   iÈ   iÍ   iÎ   iÏ   i-   iÌ   iÓ   i   i    i#   i+   i%   i,   i7   i/   i(   i;   i!   i.   i&   i$   i)   i   i'   i   i"   i3   i0   i1   i5   i2   i6   i9   i=   iÔ   iC   i   i<   i8   i   i   i	   i   i   i   i   i   i   i   i   i
   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   iK   i4   iÒ   i*   i   i>   iÚ   iÛ   iÙ   i:   iı   ib   iˆ   i˜   i¯   i˘   i˙   i˚   ix   iN   i@   iS   iy   iu   iX   iz   iY   ij   iI   iP   iv   ir   i    t   charToOrderMapt   precedenceMatrixg! _BÔ?t   mTypicalPositiveRatiot   keepEnglishLetters
   ISO-8859-5t   charsetNames   windows-1251N(   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   i˛   iˇ   iˇ   i˛   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i¸   i¸   i¸   i¸   i¸   i¸   i¸   i¸   i¸   i¸   i˝   i˝   i˝   i˝   i˝   i˝   i˝   iM   iZ   ic   id   iH   im   ik   ie   iO   iπ   iQ   if   iL   i^   iR   in   i∫   il   i[   iJ   iw   iT   i`   io   iª   is   i˝   i˝   i˝   i˝   i˝   i˝   iA   iE   iF   iB   i?   iD   ip   ig   i\   i¬   ih   i_   iV   iW   iG   it   i√   iU   i]   ia   iq   iƒ   i≈   i∆   i«   i»   i˝   i˝   i˝   i˝   i˝   i¬   i√   iƒ   i≈   i∆   i«   i»   i…   i    iÀ   iÃ   iÕ   iŒ   iœ   i–   i—   i“   i”   i‘   i’   i÷   i◊   iÿ   iŸ   i⁄   i€   i‹   i›   iﬁ   iﬂ   i‡   i·   iQ   i‚   i„   i‰   iÂ   iÊ   ii   iÁ   iË   iÈ   iÍ   iÎ   iÏ   i-   iÌ   iÓ   i   i    i#   i+   i%   i,   i7   i/   i(   i;   i!   i.   i&   i$   i)   i   i'   i   i"   i3   i0   i1   i5   i2   i6   i9   i=   iÔ   iC   i   i<   i8   i   i   i	   i   i   i   i   i   i   i   i   i
   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   iK   i4   iÒ   i*   i   i>   iÚ   iÛ   iÙ   i:   iı   ib   iˆ   i˜   i¯   i˘   i˙   i˚   i[   i¸   i˝   (   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   i˛   iˇ   iˇ   i˛   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i¸   i¸   i¸   i¸   i¸   i¸   i¸   i¸   i¸   i¸   i˝   i˝   i˝   i˝   i˝   i˝   i˝   iM   iZ   ic   id   iH   im   ik   ie   iO   iπ   iQ   if   iL   i^   iR   in   i∫   il   i[   iJ   iw   iT   i`   io   iª   is   i˝   i˝   i˝   i˝   i˝   i˝   iA   iE   iF   iB   i?   iD   ip   ig   i\   i¬   ih   i_   iV   iW   iG   it   i√   iU   i]   ia   iq   iƒ   i≈   i∆   i«   i»   i˝   i˝   i˝   i˝   i˝   iŒ   iœ   i–   i—   i“   i”   i‘   i’   ix   i÷   i◊   iÿ   iŸ   i⁄   i€   i‹   i›   iN   i@   iS   iy   ib   iu   ii   iﬁ   iﬂ   i‡   i·   i‚   i„   i‰   iÂ   iX   iÊ   iÁ   iË   iÈ   iz   iY   ij   iÍ   iÎ   iÏ   iÌ   iÓ   i-   iÔ   i   iI   iP   iv   ir   iÒ   iÚ   iÛ   iÙ   iı   i>   i:   iˆ   i˜   i¯   i˘   i˙   i   i    i#   i+   i%   i,   i7   i/   i(   i;   i!   i.   i&   i$   i)   i   i'   i   i"   i3   i0   i1   i5   i2   i6   i9   i=   i˚   iC   i¸   i<   i8   i   i   i	   i   i   i   i   i   i   i   i   i
   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   iK   i4   i˝   i*   i   (   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i    i   i    i   i    i    i    i    i    i    i    i    i    i    i   i    i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i    i    i   i    i    i    i    i    i    i    i    i   i   i    i   i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i   i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i   i    i    i    i    i    i    i    i    i    i   i    i    i   i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i   i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i    i   i    i   i    i   i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i    i    i    i   i    i    i    i    i    i    i    i    i    i   i    i    i   i    i    i   i    i    i    i   i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i   i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i   i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i    i   i    i   i    i   i    i    i    i    i    i   i    i    i    i    i   i    i   i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i    i   i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i   i    i   i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i   i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i    i   i   i   i   i   i   i   i   i   i   i    i   i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i    i    i   i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i    i   i   i    i   i    i   i    i    i   i   i   i   i    i    i   i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i    i   i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i    i   i    i    i   i    i    i    i   i   i    i   i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i    i   i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i    i    i   i    i   i    i   i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i    i   i   i   i   i   i   i   i    i    i   i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i    i    i   i   i    i    i   i   i    i    i    i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i   i    i   i   i   i   i   i   i    i    i    i   i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i    i   i   i   i    i    i    i   i   i    i   i    i   i    i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i    i    i    i    i    i   i   i    i    i   i   i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i    i   i    i    i    i    i   i   i   i   i   i    i    i   i   i    i   i   i    i    i    i    i   i   i    i   i    i    i    i    i    i   i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i    i   i   i   i    i    i   i   i    i    i   i   i   i   i   i    i   i   i   i   i   i    i    i    i   i    i    i   i    i   i    i    i    i   i    i   i    i   i   i    i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i    i    i    i    i    i    i   i   i    i    i   i   i   i   i   i    i    i   i    i   i   i    i   i    i    i    i   i   i   i   i    i    i    i    i    i    i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i   i    i   i    i    i   i    i   i    i    i   i    i    i    i    i   i    i    i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i    i   i    i   i    i   i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i   i    i   i    i    i   i   i   i    i    i   i    i    i    i   i   i    i    i   i   i   i   i   i   i    i    i    i    i    i    i    i    i    i    i   i    i    i   i   i    i    i    i    i    i    i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i    i   i   i   i   i    i    i   i   i   i    i    i   i   i   i   i   i    i   i   i    i   i   i    i    i    i   i   i   i   i    i   i    i    i    i   i    i    i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i    i   i   i   i   i    i   i   i    i    i    i   i   i    i    i   i   i   i   i   i    i   i   i    i    i   i    i    i    i    i    i   i   i    i   i    i    i    i    i    i    i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i   i   i   i    i    i   i   i   i    i    i   i    i    i    i    i   i    i    i   i   i   i   i   i    i   i    i   i    i    i    i    i    i    i    i   i   i    i   i    i    i    i    i    i    i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i    i   i    i    i   i    i    i    i   i   i    i    i   i   i    i   i    i   i   i   i   i   i   i   i   i   i   i   i    i    i   i    i   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i    i    i   i   i   i   i   i    i   i    i    i    i    i   i   i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i    i   i   i   i   i   i   i    i    i   i   i   i   i    i   i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i    i   i   i    i   i   i   i   i    i   i    i   i   i   i   i    i    i    i   i   i    i    i    i   i    i    i   i   i   i    i    i   i   i    i   i   i   i   i    i   i    i   i   i   i    i    i   i   i    i    i    i    i   i    i    i    i   i    i    i   i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i    i   i   i   i   i   i    i   i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i   i    i   i   i    i   i    i   i   i   i   i   i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i    i    i    i    i   i    i    i    i    i    i    i   i   i    i   i    i    i    i    i    i    i    i    i   i    i   i   i   i   i   i   i   i   i    i    i   i   i   i   i   i    i   i   i    i   i   i   i   i   i    i    i   i    i    i    i   i   i    i   i   i   i   i   i   i    i   i   i    i   i   i   i    i    i   i    i    i   i   i   i   i    i    i    i    i    i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i    i   i    i   i    i   i    i    i   i    i    i    i    i   i    i    i   i   i   i   i   i    i    i   i    i    i   i    i    i    i    i    i    i   i    i   i    i    i    i    i    i    i    i    i   i    i   i   i   i   i   i   i   i    i    i   i   i   i   i    i   i    i   i    i    i    i    i   i   i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i    i    i   i    i   i   i    i    i    i   i    i    i   i    i   i    i    i    i    i    i    i    i    i    i    i   i   i    i    i    i   i   i   i   i   i   i   i   i   i   i    i   i    i    i   i    i    i   i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i    i    i   i    i    i   i    i    i    i    i    i    i   i    i   i    i    i    i   i    i    i    i    i    i    i    i   i   i   i    i    i   i    i    i    i   i   i    i    i   i    i   i   i    i    i    i   i   i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i    i   i    i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i    i    i   i   i   i   i   i   i   i   i    i    i   i   i   i    i    i    i    i    i    i    i    i   i    i    i   i   i   i   i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i    i    i   i    i   i    i    i    i    i    i   i   i   i    i   i    i    i    i    i    i    i    i    i   i    i    i   i    i   i    i   i    i    i   i   i   i    i   i    i   i    i   i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i    i   i   i    i   i   i    i   i   i   i    i    i   i    i   i    i   i    i    i    i    i    i    i    i    i    i   i    i   i    i    i   i    i    i    i   i   i    i    i   i    i    i   i    i    i    i   i   i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i    i    i   i    i    i    i   i    i   i    i    i    i   i    i   i    i    i    i    i    i    i    i    i    i    i    i   i    i   i    i   i   i   i    i    i   i   i   i    i   i    i    i    i    i    i    i   i   i    i    i    i    i    i    i    i    i    i    i    i   i    i   i    i    i   i   i   i   i   i   i   i   i   i   i   i    i    i   i    i   i    i    i    i    i   i   i   i   i    i    i    i   i   i   i   i   i   i   i    i    i    i   i   i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i    i    i   i    i    i    i    i    i    i    i    i   i   i    i   i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i   i   i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i   i   i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i   i   i    i   i   i   i    i    i   i    i    i   i    i   i    i    i    i   i    i    i    i    i    i   i    i    i    i    i    i    i    i   i    i   i    i    i   i   i   i   i   i   i   i   i   i   i   i    i    i   i    i   i    i    i   i    i   i    i    i   i    i    i   i   i   i    i    i   i   i    i   i    i    i    i   i    i    i   i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i   i    i   i   i   i   i   i   i   i   i    i    i    i    i    i    i   i   i    i   i   i    i    i   i   i   i    i   i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i   i   i    i   i   i   i   i   i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   (   t   Latin5_BulgarianCharToOrderMapt   win1251BulgarianCharToOrderMapt   BulgarianLangModelt   Falset   Latin5BulgarianModelt   Win1251BulgarianModel(    (    (    s>   /usr/lib/python2.7/dist-packages/chardet/langbulgarianmodel.pyt   <module>&   sV                                
                                                                                                                               

filename:/usr/lib/python2.7/dist-packages/chardet/__init__.py
__doc__
######################## BEGIN LICENSE BLOCK ########################
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

__version__ = "2.3.0"
from sys import version_info


def detect(aBuf):
    if ((version_info < (3, 0) and isinstance(aBuf, unicode)) or
            (version_info >= (3, 0) and not isinstance(aBuf, bytes))):
        raise ValueError('Expected a bytes object, not a unicode object')

    from . import universaldetector
    u = universaldetector.UniversalDetector()
    u.reset()
    u.feed(aBuf)
    u.close()
    return u.result

filename:/usr/lib/python2.7/dist-packages/chardet/jisfreq.pyc
__doc__
Û
aÀTc        P   @   s   d  Z  d Z dR Z dQ S(S   g      @i  i(   i   i   i∂   iò   i¥   i'  iO  i  i}  iﬂ  i–  i¸  i˛  i]  i∂  i∑  i  i·
  iˇ  i©  i≤  iŒ  i   i´   i¥  iﬂ  i   i≥   iœ  iX  i}  iÓ  i–  ik  i   ig  i∏  iû  ik  i§  iË   i‰   i  i  i  i  i˘  i˙  i%  i&  i0   i1   i,   i-   i±  i≤  i  i  i‰  i  iµ  iÁ  i—  i<  i  iî  ip  i—  i“  i”  i‘  i’  i÷  ig  i◊  i  iÿ  iW  iX  iŸ  i‡  ih  i"  iÌ  iø  iã  i⁄  i
  i	  i  i\  iÀ  i•  iÉ
  i/  iõ  i·  i“  i”  i  iƒ  i0  iû  iô
  ih  i˝  i‘  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i  i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i¿  iV  ij  i4  iµ  i  iÑ  iB  i  iú  i8  i9  i:  i;  i<  i=  i>  iv  i¨  i“  iî  iS  i˚  ie  i  if  iù  iù  id	  i+  iŸ  i¿  ia  iw  i”  ió  i¡  iI  iÓ  i~  i€  iΩ
  i  i?  i@  iA  iB  iC  iD  i
  i  i-  i  i  ii  i’  iπ  i  iE  i^  i.  i‚  i3  i  ii  iF  i/  iY  i∂  i„  i  iÊ  ij  i‚
  i  iG  iH  iI  iJ  iq  i   i1  i   iY  i   ik  i/   i  i2   i   i   i#   i  i   iÛ   i*   iõ   i   iö   i   i∏   i   i[   i   i\   i5   iå  i!   i!  i	   i%   i@   il  i   i'   iA  i   i   i   i4   i   i   i–   iä   i    i   i<   i  iç   ió   i-  iµ   i  i7  iS   iÑ   i√  i~   iK  i=  i   iE   i†   i;   i   iù   i7   i7  i8  im   i&   i   i   i
   i   iO   iK  i=   i~  id  i   i   iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iY   i>   iJ   i"   ip	  ip   iã   iƒ   i  iï   iT   i_  iÉ   i˝  i.   iX   iô   i´  iL   ij  ie   i  i9   iP   i    il  iy   i‰  i©   i  iD   iÎ   ië   i∑  i)   ih  i”  iF   i?   i   i+   i  i  ig  ic   i  i¬   iB   i]   iN  iŸ   i¿   i8   ij   i:   i5  i  i  i7  i   ií   iR   i4  iG   id   iÄ   i÷   iè  in   i  ih   it  i6   i3   i$   iW   iC   i˛  iπ   i:
  ix  i‰  i   i*  iV	  i  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  i  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  i∫  iu  iv  iw  ix  iy  iz  i{  i|  i˘  iÔ  i  i÷  il  i}  iˇ  i~  i  i  i	  iü  iª  iÄ  i  i◊  i
  i‡  iÿ  i  iÅ  i  i  i  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  ik  iÇ  i„
  i>  i‰
  iÂ
  i	  i†  i	  ij  i€  i•   iñ  iZ  i[  i\  i]  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i¸  i  i  iÂ  i”  iŸ  i¢  i  iò  i2  i„  i‰  i{  iT  iŸ  ia
  iØ
  i^  iÂ  i·  i|  i°  i=  i  im  ik  iû  i‰  i˙  i	  iV  iy  iü	  iâ  i
  iq	  i  i  i   iæ
  i∞	  iå   iâ  i∏  iƒ  i!  iô  i¡	  i“  i  iÛ  i∏  i§   iC  iO  i3  i  iÕ  iÊ  i¸  iù  ir	  i≤  i≥  in  iƒ  i+  i  i…  iå  iø
  ip  iq  iÂ  i;
  iA   iÊ  i˝  i·  iC  i0  iä  in  iº  ió  iÁ  iT  iC  io  i  iˇ  i
  i#	  i  iÄ  i~  i  iP  iÊ  i˙  iﬁ  i  iÙ  i◊	  i  iÿ	  iü  i$	  iz  i⁄  i‘  i&  i»  ió  iÓ  iÁ  i   i€  i¿  i˘  i√  i_  i  iØ   iU  iŸ  iΩ  is	  iŸ	  ià  i’  iI  i™  iã  iÔ  i  iå  iï  iË  i3  i‹  i  i$  iW  i1  i5  iP  iÎ	  iá  i  i  i‚  iØ  iÒ  iX  i∏  i£  iª  il  iÈ  i¡  iH  i˙  ià	  i  iÑ  i‘  i  i¥  i  iÑ
  iW  iÿ  i~  ip  i  i$  iû  i  i  i@  iL  iÁ  i⁄	  iò  iˆ  iÃ  iu  i  i  iJ  iI	  iW	  iÎ  i∏  i_  iÍ  i†	  i<  ià  i  i  i]  iD  i¬  i‹  iÅ  i  ih  iÊ  iÇ  i®  iï  i  iﬁ   if   i-  iΩ  i}   it	  iñ  i¬	  i  i»   iƒ  iç  i,  i‡   i
  ib  i¶  i¬  iX  iì  i  iF  i  i{  i`  iÏ  i˙  i+  i3  iq  i¸  im  iˆ  i4  i‚  iª  i˚  iµ  iú  iB  il  iX	  iæ  i   i%
  i´  iÖ  i%	  i2  iu  iñ  i°	  i√	  iπ  iJ  i  i|  ir  i∑  i@  i  iﬂ  i  i  i≈  iﬁ  iø  iú  i€	  iL
  i  i  i  i  iü  iΩ  ib
  iJ	  i  ic  iï  i÷  iÎ  i¯   i˚  i«  i  i4	  iR  iä  im  iT  iË  i»  i  i∂  iÏ  iÌ  i€  iÄ  ie	  iÓ  i  i?  i  iÛ  iÉ  i§  i  i-  i	  i¶  i*  iE  i¢  i–  i+  iπ  i‡  i&	  i±	  i–  iΩ  i/  i¬  i“  i.  is  i[  iÒ  i+  i  i¿
  i  iö
  iB  ic
  i¨  iË  i·  iå  i∑  i	  i)  i  i,  i◊  iu	  i  i	  i  i9  i&
  i  i  iŒ  iÑ  i•  iv	  i„  iY  iÿ  i3  i˛  i
  i„  iû  i  iD  iØ  iº  iÆ  iï  id  iß  ië  i|  i(  iy  i  iÃ  i  i£  i<  i8  iŒ	  ii  i  i  i  id
  i5  iB  iè  in  i  iÔ  i  iÔ  iÕ  i|  iÏ	  i!  i—  i)  i@  in  im  i  i≤	  i0  ia  i…  i¸  iƒ	  iz   i'  i√   i´  i≈	  iW  i  i[  iv  i…  i√  i≥	  i›  iÜ  i	  io  i  i‹	  ió  i
  i  i†  i'
  i≤  i  i"  i˚  iÅ  i9  i  iç  i  i«  iJ  iΩ  iè  ih  iÒ  ié  ie
  i  iˆ   i\  iﬁ  iâ   i   ip  i@  i  iQ  i9  iﬂ  i∫  iÓ   i	  iª   i¸  iÖ  iw	  ii  iE  i∏  iJ  iI  iÌ	  iÏ  iú  i˜  iœ  i  if  i¡  i£  iô  i
  iË  i1  iŸ  i’  i
  i÷  i§  i'	  ir  i  iµ  i‰  iÂ  i¿  iÖ  iç  ic  i›	  iq  iñ  ix  i–  i  i
  i2  i›  i•  i  i…  i¢	  i*  iÑ  iæ  ib  iF  i˘  iv  iÒ  id  i¡  iô  i·  i!  iR  i¡  i—  iQ  ié  i   ií  iP  iÔ  i  i  iô  i  ií  i‡  i(	  i‹  i©  i_  i  i`  iê  ië  if
  iì  i6  iŒ  iA  i  i›  ia  i⁄  iÚ  iu  iT  i  i2  iÓ  iµ  i  i  i∑  i  i^  iC  i◊  iÊ
  i¡  i[  iÁ  i¬  iv  i%  i¸  i·  iÂ  in  i!  iF  i¨  iZ  i^  i‚  i  i‘  id  i  iﬂ  iÊ  ix	  i≥  iß  i]  iÈ  iB  i   ic  i√  iÍ  iØ  ió  iP  iq  i	  i  iH  iY	  iÜ  iŒ  i(
  iÛ  i¡
  iœ  ig  i}  iK  i£	  iÀ  i  i4  iÙ  iW  iÖ  i§  iÌ  iC  ig
  i-  id  iÊ  ik  i  i4  i}  iì  iq  i~  i+  i¥	  iÙ  iº  ih  i@	  iâ	  i  i@  iA	  iD  i:  iß  iç  ie  iÁ
  iÁ  iq  iw  iÁ  i¶  iò  iË  iı  i⁄  iü  id  i—  iZ  i˝  i*  iM
  i[  iÚ  i©  is  iZ  iÖ
  i∫  iÈ  i>  iê  i'  i-  iÎ  iË
  i  i  i»  i)	  i  iÎ  iˆ  iÙ  it  iF  i7  i¬  it  i#  iŒ  iò  iÖ  i“  i  iY  iÅ  i£  if  ik  ib  i1  iî  iƒ  ié  i6  io  ic  i  iq  iÓ	  i˜  iü  i»  iÈ
  iu  i¥  i:  i‚  iÙ  iN
  i¬  iU  i=  iÔ	  iv  iÚ  il  iN   iÔ  i   i˝  i]  iã  i;  iÛ  i‘  i¬
  i∆  iç  il  iL  i	  i}  i†  i’  i  i”  iB	  iá   i8  iQ  iƒ  i#  i`  iT  i≈  iµ	  ix  i  ir  iœ	  i  i  ií  i‘  i‡  i	  i›  i3  in  i  iœ  i  i  i  iô  i{  i˝  ió  i@  iÏ  iÊ  i  i“  i9  i™   ià   i±  i5  ih
  id  iZ	  i’   iê  ii  i  i±  iö  iª  i  is  i-  ir  iÌ  i  i  i‘  i[  iÀ  i0  i  i  iæ  i‰  i.  iS  i	  iR  iO
  iÙ  i  iÄ  iÏ  i;  i†  i4  iy	  iõ
  i;  i¥  iz	  i¯  ip  iµ  i•  i   iÌ  i≠  i:  i(  i|  iú
  i®  i"  i≈  i“  i”  i©  iâ  i¶  iO  i˜  ie  i°  i≠  i˚   i  iC	  it  i)
  i  i6  iK   iÜ  iÂ  i8  iˆ  iP
  i  ih  i¯  iÓ  iÈ  i  i¬  i3  i$  iÍ  i‹  i*
  i=  ib   ie  i  i≈  i4  i™  iÎ  i∆	  i.  i7  iÅ  i\  i˛  i˘  i  ij  iß  i  i˙  iÜ  i˘  iπ  i„  iº   i/  i  i≤   iŸ  i®  i=  i   i^  i–  i5	  i°  i€  i§	  i\  iﬁ  i  i˚  iÌ  i9  i#  i+  i∞
  is  i,  i™  i7  i  i¸  iY  iÒ  i™  iÍ
  iM  iŒ  i+
  ii
  iQ  iÉ  i¢   i6	  iÃ  i„  iÍ  i∏  i  iy  i©  i  is  i#  i{	  i∆  iU  if  i<  i‹  iØ  iv  iﬂ  i•  i)  iÎ
  i  iô  i  iÆ  iÚ  im  i<  i  i  i•	  iÊ  iÃ  ig  i˝  iä	  il   i»  i   iD	  ib  iu  i√
  i™  iD  iB  iô  iÄ  i«  i[	  i´  i  i8  i‚  iõ  i>  i  i≠  i  iª  i≤  i‰  iÂ  i  i]  iÏ  iD  iÌ  i·   i‘  i6  iZ  iÙ  i¶	  i5  i…  iù
  iÏ
  i<  im  i»  i,  iß	  i¶  iu  i^  i∂	  i˝  i≈  ig  iÛ  iå  iI   iå  iµ  ig  iÔ  i•  i\  i:  i  iM  it   i∑	  i·  iE  iú  io   iÙ   iﬂ  i˛  i’  iE  iR  i⁄  i  i¢  iE  ij
  iÓ  ig   iW  i˜  iÜ  iK  i∏	  iC  ië  i=  i”  i]  i$  i!  i˝  iã	  i  i—  iπ  i`   iK  iv  i  i  i0  ii  i≠   i^   i‚   i¨  i3  i÷  i"  i  iõ  iÁ   i–  i  ia   ik
  i  i;  iw  iá  i∫  i´  iÊ  ië  iˇ  iÜ
  iy  i  i≤  i„  iﬂ  iP  i  i¶  i®	  iw  i£  iÅ   iÁ  it  i  i≤  iÈ  i  iË  iÓ  iJ  ia  i  i˚  i]  iË  i∆  i’  iå	  iî   i  i¥  i  iL  ih  i  iÈ  i›  iƒ
  iu  ij  ié  i  i#  iC  i÷  i§  i	  ia  iÕ   i!  is   i|	  i∞  i	  iY  iè  i
  iª  i¶  i˛  ih  iO  i5  i≥  iı  iz  ii  i±
  iS  iÚ  iL  i’  i.  iı  i&  i  i	  i<
  i7  i  is  iA  i®  iã  iM  i…  i∞  is  i·  i*  i,
  i%  i≤
  i«	  i†  ik  iÍ  i&  if  iÂ   iO  ij  i"  iΩ  i(  i-  iÇ  i[  i˛  i—  iÒ  i¸  i-  i=  i∞  i}	  iÄ  i∂  iM   iS  iü  i“  i⁄  i  i®  i  i   i¢  iÎ  i€  iá
  i
  i  i
  iÆ  i~	  iø  iJ  it  ik  iv  ie  iy  i  iÏ   iâ  i<  iÚ  if  iı  iM  ik   i   i  i™  io  i÷  iœ   iÂ  iw  iv  il  iÏ  i]  iè  i  i.  i≈
  iﬁ  iÏ  i∏  i/  if	  iq  i$  ig  iˆ  iG  iæ   i˝   in  i∂  i>  i6  i=  i¶  i≠  iß  i’  i£  iN  iÒ	  ix  iú  ie  i*	  i  ih  i  i  i‰  i$  iÆ  i‡  iî  io  ib  i,  i  iÅ  i˛  i  it  i«  iª  i	  i‹  i  iÌ
  iV  i˛  iÓ
  ii  i  iπ  i˙  iÎ  iw  i  i  ip  iH  i›  iV   i´  ii  i<  iZ  iç	  i8  ir   iw  iÇ  i&  iÀ   iÛ  iø  i/  i‚  i≠  i¡  iÌ  i>  iü  i>  iE	  ix  iÓ  i&  ie  i∆  iw  i	  iÓ  iÉ  i5  i›  i   iû
  i  i\  i≥  i¸   iô  iS  ii  i  iê  i®   i“  i2  i¡   iÔ  i  i  i+  i'  i÷  i%  iã  iÈ  ix  iO  iπ  i
  iQ
  i°  i’  i  i  iˇ  i‘  i_  iH   iœ  iæ  i  iº  ig  i  iÿ  iy  iÉ  ià
  i0  i&  i+	  i  iâ  i  i∑  iÆ  il
  i'  iü  i'  iz  iÑ  i	  i	  i±  i_  iÂ  i≈  i  iÙ  iı  i˛  i?  iÔ
  iÙ  iﬁ	  i£   iz  iÔ  im
  i|  i
  i  i	  ig	  i0  i¿  i÷  i   iı  i*  iç  iˆ  i
  i`  iw  i  iì  i  i#  i“   ic  i)  i·  iÍ  iR
  iﬁ  iŒ   iÛ  iT  iê   iœ  ir  i  iV  iõ  iÚ  i¢  i_  i  iˇ  i  iø  ir  iù  i≈  i≥
  i`  ix  iæ  iû  i
  i¯  i≥  if  i∂  i  in
  i=
  i*  iA  i  iÚ	  i(  iÚ   ix  i˙   iS
  i≥  i{   iT
  iá  i9  i  i±  iM  iÇ  ir  iÿ   i  i;  i  i(  i  i%  ië  i[  ia  ib  i  i∫  iD  iñ  i¨  i  i-
  i\	  i˜  i  i  iñ  io
  iE  im  i)  iÁ  i!  i¨  i  ic  i¿  i,	  i1  i  i]	  i´  iÇ   iÑ  i>  iI  i∞   iß  iﬂ	  iT  i  i„  i  i˜  iø  iè  iy  i  ik  iz  ix  iÈ  iN  i	  iƒ  iÜ  ià  i 	  i5  i¯  iﬂ  i"  i◊  iH  i<  id  i˘  i
  i≠  iù  ih	  iÛ	  iä  i
  ip
  iÄ  i≤  i:  iL  i1  i∆  iß  iÀ  i  i∑  i>
  i≈  iq
  i?  iZ  iM  iI  iΩ  i  iB  iK	  iD  ië  i#  i  i
  iY  i>  i˘   iÏ  i  i  i`  iÖ  iÖ  iò  iö  i  iü  iﬁ  iö  i  i¶  i˙  i˘  i   i¢  i  ic  i≥  i  iÑ  iˇ  i€  i‹   iT  iã  ia  i  i2  iy  i/  i∆  i"  iU
  i⁄   iÒ   ib  i®  i˘  i¿  i/  iÆ  i‡	  i√  i  i
  i{  i
  iã  ij  i˛   iÉ  i∫   i5  i*  iÈ  i∞  i›  i¨  ia  ix  i∆  i≠  iπ	  i  iF  iÍ  iÒ  iº  i7  i¯  iÒ  i∫	  i?  i˛  iw   i…  i  i  iÛ  i◊  i+  iÅ  i8  i   i∆
  iN  i
  iï  i«  i,  iÿ  in  iå  i  i  i˙  io  is  i_  i?  iÂ  iª	  iï  iÑ  i  iÙ	  iá  i◊  i?  i0  i·	  ié	  iı  iy  i3  if  iØ  i=  iö  iÉ  il  i  iı	  i  iv  i]  i†  i	  i	  i»  i  iz  i«
  iˆ  iy  ij  i  iu  iÑ  iÍ  ip  iÃ  ij  iü   i  i	
  ii  iz  i  i÷  ir
  i  iâ  i‡  iÔ  iÿ  ií  i  i  iF  i°  i'  i–	  i{  in  i  ix  iu   i$  i  i∏  iπ  iM  i£  i˜   i‚  ik  i   ip  i»
  i^	  iq  i  i`  i|  iæ  iÄ	  i  i

  i|  iè	  i…
  i  i∫  iê	  i
  i®  iÆ  i„  ië	  iG  i  i¯  i-  iÚ  iZ  i1  iY  iÒ  i-	  i	  ie  iÚ  iæ  i[  iC  iˇ   iæ  i°  ie  i∞  i.  i-  i  i˜  i◊  i	  i†  iñ  iâ
  iü
  i7	  ib  il  i	  iû   iÙ  iÛ  i{  iÙ  i.  i	  iÖ  i»  iz  i∏  iÃ  i†
  i†  i?
  iÛ  i  i9  i  iä
  iÕ  i  iî  i}  i£  i°
  ia  ií  iˆ	  i
  iQ   ií	  id  i;  iV
  i⁄  i/  i^  iD  iÿ  i?  im  iÕ  iŒ  i9  iI  iã
  i‹  iﬁ  i
  i  iŸ  i 
  i{  i}  i   i˚  i  iÄ  ií  iÜ   i&  i◊  i~  i‰  iX  iˇ  i˚  i}  iœ  i÷  i9  iÜ  iË  i:  i¢  i"  i\  i  i·  i
  i_	  i”   i8  iW  i~  i^  i%  iP  is  i±  iw  iö  iæ  i  i8	  i¸  iL  i‡  i  i.
  iË  iù  i–  iÙ  i  iN  i«   i”  iP  i•  iS  iì  i·  iÍ  i:  iR  i'  i0  ib  i  iª  i¥
  iı  iÕ  iõ  iÎ  iz  i  i˜	  i  i  i  i  iK  i«  i∆   i‡  i¢
  ir  iö  iq  i
  iÊ  i‡  in  iL	  i  i©  i  iÆ  i≥  i†  iÅ  iı  iÂ  iX  i@
  iÁ  ig  ii   i°   iº  i4  i®  i:  i  iÜ  ió  ir  i©	  iû  iQ  iÒ
  i  i	  i;  i'  i˝  i>  i‚  ib  im  i√  iw  iﬂ   iˆ  i˜  is
  iﬂ  i  i≠  iA
  iÄ  it
  i9	  i  i¯  i  i  iì	  io  i^  ià  iä  i2  iØ  ic  i‚  i  i€   i≤  i  ir  iç  iÅ  i˛  i!  i  it  i  i1  i{  i·  iÿ  iÉ  i©  iì   i∂  is  i  i¥  iı  iñ  iø  i   ix   i  iv   ia  ip  i˘  i‰  i  i√  iL  iO  iˆ  i  iU  i§  i.  i  i‘   i)  i.	  iÇ  iE  iÅ	  i"  i  iy  i  i	  i˚  iÇ  iÕ  i¶   i(  iÄ  i  iø  iq  iE  i6  i
  iÀ
  i2  iu  i6  i¿  i˚  i¨  i∆  i.  i∑  ii	  i  iÿ  iV  iû  i  is  iÃ
  ié  i¢  iG  iG  ij  it  ié  iW  i  iÇ	  iê  iÆ  i`  i˜  iÉ  iá  iu  i‚  i  iµ
  iÚ  i{  iQ  i  i¯	  iO  iC  i≥  i˙  iÅ  i‚  iJ  i˘	  i	  i	  i$  i”  i¯  iŸ  i/	  iÀ  i  i_  i  i∆  i  ij	  iR  i∞  i7  i  i¥  i/
  i  i3  iD  iu
  i6  iX  i4  i˘  iÊ  i  i  i˚  i  i>  iÄ  i  i  i0
  i`  i`	  i
  iÒ  i¸  iŸ  iU  i…  i   i£
  ir  i  i¥  i)  i◊  i5  iÎ  iH  iÀ  i 
  iú  i  i~  ir  i˝  iå
  i˛  iÔ  iå  iú  iî	  iú   i  i]  iŒ  iØ  i  i∂  i  iÎ  i  i@  iΩ  i…  i∂
  ia  iŒ  iv  i˜  ié  iò  i/  i!  i6  iÍ  i’  iß  i7  iw  i¡  i	  i3  ic  i8  ix  i  i•  iˆ  iB
  i‹  i◊  iM	  iˇ  iè   iF	  i¿  ig  i  i§  iÑ  i(  i°  i  i:	  i   i‰  iH  iÅ  iÕ
  if  i◊   ià  i"  i—  i~  i˝  i–  i„  iç
  iy  i  i  i¶  iÚ  i   i!  iN  i“  i4  iA  iœ  id  ie  iÈ   iı   iz  i  iä  i„  i‰  iÃ  i  i∂  i0	  iÌ  iˇ  i  iº  iÖ  iû  i  iÌ  i{  iÿ  iœ  iá  i§
  i˙  if  i(  il  iË  iG  i™	  iÖ  i≈   i^  iB  im  iF  i|  i  iU  iﬁ  iö  i2  iR  i‹  i‡  i#  iÓ  iÇ  iõ  iÁ  iF  i›   i  iU   iπ  i∫  i˚  i1  i¬  ic  ik  i©  iN	  iS  i´	  iÖ   iÔ   iÚ
  i«  i¯  i$  iO	  iõ  i  iY  iã  i¡  ià  i   iﬁ  iG  i  i  i¸  iW
  i	  iC
  i?  iµ  i  iñ   i~  i„  iê  iU  iF  i«  i®  iü  i  iÈ  iﬂ  iù  iÉ  iC  iº	  ió  iÀ  i  ie  i  iŸ  i°  i™  i  i/  iQ  i_  iv
  i;  i∂  i∑  iP  i)  i„   iG  im  iï	  ië  iç  iG  i,  iI  iz  i_   iÉ	  i…   i	  i9  in  iá  i∑
  iA  i˙	  ié
  iX
  iË  i#  iV  i)  i<  i%  iÜ  i}  i¡  i•  iH  iw
  i5  iî  ip  i.  i  iƒ  i´  im  i  iØ  iœ  iÑ  i#  ih  i|  ib  i¸  ià  iÇ  i@  i(  i^  iz  i√  i  iA  iÛ
  i   i  i"  i  ig  iï  i|  i‘  i»  ií  ié   i√  i6  i¨  iX  iÇ  iˇ  i,  i—  iÏ  i		  i  iÂ  i$  i#  iI  ik	  i∞  i  iá  ià  i:  i	  iâ  iQ  i  io  ih  iV  i$  iÖ  iÒ  it  iê  i¥  i£  iY
  i,  i–  i  i
  iâ  iD  iø  i»	  i~  i”  iÜ  iπ  iΩ  i%  i∫  i  i   i©  i∑   iä  i  i¬  i‘  i   i7  i/  i
	  iÆ   i”  iÊ   iñ	  iE  iV  iÛ  i’  iE  iu  iä  i&  i   i˜  i  i∏  i—	  iÌ  io  iâ  i˝  iZ  iè  ii  i∑  iä  i	  i  ií  iû  iß   i!  i⁄  in  i8  iÓ  i'  iì  iΩ   iê  i  i«  i  i›  ió	  iï  iG  iã  iR  i2  iÚ  i  i:  iÅ  i,  iÌ   i  iZ
  il  iã  i(  iX  iP	  i?  i∫  i  iÑ	  io  iå  i  iß  iˆ  iƒ  iÉ  iW  i*  i  i   i;  i8  iç  i&  i)  i§  iÂ  i
  io  i   i  iØ  i≠  iH  i_  iò  i™  i0  i√  ix
  i˘  i0  iù  i;	  iì  i  iá  iˇ  iX  i°  i	  iÃ   i—  i1  i˛  iZ   i*  i%  i…	  iø   i  i|   id  i`  i  iö  iS  ij  i}  i\  i  i€  i¯  iG	  iß  i  iò	  if  iq   i%  iB  iÉ  i1
  ip  iÇ  i"  i  iä  i⁄  ié  iå  i|  i∫  iÒ  i  i“	  iÛ  il	  i2
  i±   iè
  i÷  i  iá  i@  ih  iò  i;  i˙  i¨   i  i	  iè  i	  i∂  iº  i&  i  iÄ  iË  i}  ië  i%  iç  i±  i  i  i?  i§  i¨	  i€  ia	  iy
  i  i∏
  i—  iı  i˚	  i∑  i=  i1  iä  i<  iˇ  i{  i#  i  i    i„  iì  iŒ
  iA  iõ  i
  ié  it  i†  iù  iô	  iè  i>  i
  iK  i3
  iµ  iî  i=  iÍ   i  i\  iÊ  iÁ  i'  iA  i+  ig  i   ib	  iK  i°  i⁄  iˇ  iÁ  i  iƒ  i
  i–  i4
  i¥  i*  iê  im	  i≠	  i¿  i•
  io  iN  i   i0  i(  ii  iı  i$  i4  i   i{  i  i§  i¢  iQ	  iÀ  ië  iU  iÈ  iª  iµ  i,  i`  i  i”	  iº  i  iœ
  ij  i)  i   iÕ  i-  i6  i—   iÖ	  iF  i2  i)  i  i  i*  iπ  iY  iZ  iJ  ií  iH  iÀ  i  i  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  is  i^  i_  iÅ  i`  ia  ib  ic  id  i?  ie  if  i@  ig  ih  i%  ii  ij  i  ik  ik  i¸	  i5
  iA  i  iÇ  il  im  in  io  iB  ip  iq  ir  i–
  i1	  i  iC  iD  it  i  iá  is  i&  iE  iF  it  i€  iu  i  i  i◊  iv  iw  ix  i≈  i¢  ià  i'  iG  iy  iz  iÆ	  i  i{  iH  i  i|  i}  i£  i~  iÿ  i(  iI  i  i)  iÄ  i  iÙ
  iÅ  iÇ  i!
  iÉ  iÑ  iJ  iÉ  iº  iK  iÑ  iÖ  iL  iÜ  iá  i*  iÖ  iM  ià  iâ  i∫  iä  iã  iå  iç  iÜ  iN  i  iá  ié  iè  iŸ  iê  ië  i+  iO  i,  ií  i-  iì  i.  iî  iï  i  iñ  ió  iò  i  iô  iG  iö  iõ  i  ià  iú  iù  iû  i  iü  i†  i  iì  i°  iP  i  i¢  i£  iª  iˆ  i§  iî  i‚	  i/  i•  iQ  i¶  iß  i®  iË  i©  i™  iR  iï  iΩ  i´  i¨  iÍ  i  i≠  iÆ  i  iØ  i∞  iS  i±  iH  iT  i≤  iU  i≥  iÈ  i¥  i  iµ  iâ  i∂  i∑  i∏  i⁄  iπ  iV  i  i∫  iW  iX  iª  iº  iΩ  iæ  i  iä  iø  iY  iã  i0  i¿  iå  iZ  i¡  i¬  i√  iƒ  i≈  i[  i\  i]  i∆  i«  i^  i»  i…  i_  i   iÀ  i`  iÃ  ia  ib  i?  iÕ  ic  iŒ  id  iœ  i  i–  ie  iñ  i1  i—  i 	  if  iu  i“  iÍ  ig  iç  i”  i€  i∆  i2  i  ió  i[
  i  iº  i@  i∞  i¬  i‘  iI  i’  ih  i"
  i+  iA  i
  iò  ié  ii  i,  ij  ik  iz
  i-  il  i÷  i.  i  i/  i◊  iÿ  iŸ  iè  i⁄  i€  i‹  i›  i3  i  im  iﬁ  iﬂ  iô  i  i‡  in  iD
  i·  iΩ  i‚  iR	  i„  i‰  iö  iê  io  ià  ip  iJ  iÂ  il  i  i4  i2  iÊ  iı
  iæ  i  iê
  i  i„	  iB  iˆ
  i®  iÁ  i—
  iË  iq  ir  iK  iÈ  iÍ  i‹  iÎ  iÏ  ië
  i  iª  i5  iE
  i	  iI  iÌ  i
  i6  i˝	  i  i  iÓ  iv  iø  iõ  iÔ  i7  is  i8  i˛	  i
  iL  iw  i  iÒ  i9  iÚ  it  i  iÛ  iÙ  i  iı  iˆ  i:  i˜  iu  ië  i¯  i  i;  i˘  i˙  i˚  i¸  i˝  iâ  i˛  i   iˇ  i   i  i  i  i  i<  i  i  i  i  iK  i	  i
  i	  ix  iv  i  i  i  i  i!  i=  i  i  i>  i  i  i  i  ií  i  i  i	  i  i  i  i?  i  i  i@  i  iú  i  i  i  i  iì  i  iw  i   iæ  i!  i"  i"  iî  i#  i$  i0  i%  i&  i  i'  i(  i)  i*  i1  i+  ié  i,  i-  iä  i.  i<	  i#  i
  i/  i$  iè  i  i0  i  i1  ix  i2  i3  i¿  iy  i4  iy  i5  i%  i&  ií
  i  iz  i6  iC  i7  iz  i8  iÎ  iL  i  iB  i'  iA  i  iÜ  i  iB  iï  i(  iñ  i{  i|  i)  i¯  iC  i*  i¡  i9  i˜
  iã  i  i:  i;  i<  ió  iå  i}  i~  i=  iD  iê  i>  i  i?  i@  iA  iB  iÄ  iÅ  iÇ  iÉ  iC  iD  iD  ic	  i  iE  iF  i“
  i  iG  iÑ  iH  iI  iJ  iK  iL  iM  iN  i{  iO  iÖ  i+  iP  i3  iQ  iÜ  i¯
  iR  iΩ	  iE  iS  iT  iU  iV  i˜  iá  iW  iX  iY  i2  iZ  i[  i\  i]  i^  i_  i`  i©  ià  ia  ib  iâ  ic  id  im  iE  iF  ie  if  iä  ig  ih  iã  ii  ij  ik  iJ  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  iç  iG  ix  iy  iz  iå  i,  iù  i-  iç  i.  i  iM  ié  i{  iè  iê  ië  iÏ  i|  ië  iH  i}  ií  i~  iì  i/  in  iI  i  i  iÄ  i0  iJ  iÅ  iK  iÇ  iÉ  i#
  iÑ  iÖ  iÜ  iá  i3  ià  iâ  iä  iã  iå  iç  ié  iî  iè  iê  ië  ií  iì  iî  i1  iï  iñ  ió  iò  i2  iM  iï  i3  iô  iö  iõ  iL  iû  iú  iù  iû  iò  i4  iü  i†  iÌ  i¶
  i°  i›  iM  iÓ  i4  i¢  i£  iô  i5  i¬  iﬁ  i˘
  i6  i§  i•  i¶  iñ  ió  iß  iü  i®  iò  i†  iô  ié  i©  i™  i´  i7  i¨  i°  iN  i≠  iO  i˙
  iP  i|  iö  iÆ  iQ  iØ  i∞  iæ	  iK  iﬂ  i±  i≤  iè  i≥  i8  i¥  i«  i}  iµ  i  i‰	  iö  i  i∂  i  iN  i9  i∑  iL  iR  iõ  i:  i»  i;  i∏  iõ  iF  i…  i{
  iπ  iS  i∫  iª  iú  i<  iº  iΩ  i=  iæ  i™  iø  ií  i‡  i¿  iì  iê  i¡  i¬  iT  iù  i√  iƒ  i±  i√  i>  i≈  iO  i5  iû  i∆  i«  i~  i»  i?  i…  i  i  i   ië  iü  i˚
  i@  i@  iƒ  iÄ  i
  iú  iù  iÅ  iA  iÀ  i  io  iÃ  iG  iÕ  i‹  iŒ  iû  i  i  i”
  iœ  i–  i6  iø	  i†  i—  i  i“  i≈  iπ
  i°  iU  i·  i”  i  i∆  i‘  i’  i÷  i  i◊  iÿ  i¢  i£  iŸ  ií  iü  iB  iC  i⁄  i7  i  i€  i§  iV  i‹  iN  i›  iﬁ  iﬂ  iD  i•  i‡  i   i·  i¶  i‚  i‚  iW  iÈ  i¢  i„  iX  iì
  i‰  iE  iF  i  iÔ  iY  i„  iÂ  iÊ  i4  iÁ  iË  iG  iÈ  iÍ  iH  in	  iÂ	  ip  iÎ  iZ  iS	  iÏ  iß  iÌ  i[  iÓ  ic  iI  iÇ  iÉ  iÔ  i  i®  iÒ  i  iÚ  iÛ  i8  iÙ  iì  i  i9  i†  iı  iH  iˆ  i  i¸
  i\  i:  iÑ  i˜  i  iî  i¯  i  i˘  iJ  i°  i˙  i˚  i¸  i
  i˝  i]  i©  i˛  iˇ  i   i  i  iï  iÖ  i¢  i  i£  i  i  iÃ  i  i  i  i™  i  i  i	  i
  i  i  i  i´  i¨  i   i  iñ  i  i  i‰  i£  i§  i  i  i  iI  i•  i§  i  i  i  i  i  iP  i  i  i  i  iÜ  iá  i  i  i≠  iK  i  iÆ  iØ  i∞  i  i   i!  i^  i"  i#  ió  i$  i∫
  i%  iL  i&  i'  i(  i)  i*  i+  i±  i,  i-  ià  iß
  i.  iJ  i/  i0  iQ  iî  i1  iM  i2  i3  i4  iÊ	  iÃ  i5  i6  i7  iª
  i8  i9  i:  i≤  i;  i;  iN  iO  i<  iÂ  i=  iP  iQ  i>  i?  i@  iA  i•  iB  i¶  i≥  iC  iD  i<  i¥  iR  iE  iF  iµ  i‘
  iG  iH  iI  iJ  iK  iî
  i  i˝
  iS  iL  iM  i∂  i∑  iò  iN  iO  iP  iQ  iT  i  iR  iR  iß  iS  iT  i®  iU  iV  i∏  iS  i_  iW  iX  iY  iZ  i[  i  i\  i¶  i]  i^  i_  i`  ia  ib  ic  i  id  i©  ie  iπ  i∫  if  i˛
  i´  ig  ih  ii  iU  ij  ik  il  im  i=  in  io  iô  i`  ip  iß  iq  ir  i~  is  i  i®  it  iu  iv  ia  iª  iV  iÊ  iº  iW  iw  iΩ  ix  iy  iæ  iz  iø  iÁ  i¿  i{  i|  i}  iö  i~  iM  i  iÄ  ib  i¡  i™  iÅ  iÇ  iX  iÉ  i´  iÑ  iÖ  iÜ  iá  ià  iâ  i¬  iä  iã  iå  i¨  iç  ié  iè  iê  i  i√  iõ  ië  iƒ  ic  ií  i≠  iì  iî  id  iï  iÆ  iØ  iñ  i  i«  i   ió  iú  iò  iô  iö  iY  iõ  iZ  ie  i[  i»  i≈  iú  iT  i∞  i+  iù  iû  i±  iü  i  i†  iî  i°  i∆  i¢  i£  i≤  i>  i§  i•  i«  i≥  i¥  i¶  iß  iË  i®  i©  iµ  i\  i™  if  i´  i¨  i]  i≠  iÆ  ig  i»  iØ  i∞  i±  i  iÀ  iö	  i≤  i©  iU  i  i≥  i…  i  i   iÈ  i^  i¥  iµ  i_  iÀ  iÃ  i∂  iõ	  i`  i∑  ia  i∏  iπ  i∂  i   i∫  iÕ  iŒ  iª  iº  iœ  ih  ii  ij  iΩ  i∑  iæ  iø  ib  iÍ  i!  i¿  i¡  i–  i—  i¬  ic  i“  i[  i√  iÎ  iƒ  i≈  i  i∆  i«  i  i∏  iï
  iV  ik  id  i»  il  i…  i   i"  i#  iÀ  iÃ  i”  iÕ  iŒ  iœ  i–  ie  i?  i—  i“  i‘  i”  i‘  i’  i÷  if  i◊  i5  iÿ  iŸ  i’  i⁄  i™  i€  i÷  im  i‹  i›  iﬁ  i@  in  ig  iﬂ  i◊  i‡  iÿ  i$  i·  iÔ  io  i‚  iW  i„  i‰  iÂ  ip  iq  iÊ  ir  i  iÁ  i  iÏ  iâ  iù  i\
  iË  i®
  iÈ  iä  i´  iÍ  iπ  ih  iÎ  iŸ  iÏ  iÌ  iÓ  iÔ  is  i  iÒ  iÚ  i⁄  iÛ  iÙ  it  iı  i€  iˆ  i’
  iÌ  i˜  i‹  i¯  i˘  i˙  i˚  iA  iB  i¸  i!  iÓ  i˝  iÔ  i  i˛  iˇ  i   i  i  i  i∫  i  i  i›  i  ii  i¨  i  iC  i  iu  iD  i6  i  ij  i  iÜ	  i	  i
  i≠  i÷
  iﬁ  i  i  iﬂ  i‡  i  i·  ik  iE  iÀ	  i  i‚  iÁ	  i  i  i…  iª  iK  i  i  i  i  i  il  i  i%  im  i©
  iF  i  i  i  i  i  i„  iF
  iv  iº  in  i‰  iw  i  iL  ix  io  iÂ  iÊ  iy  i  i  i"  iÁ  i  ip  i  i  i  iË  i   iz  i   iq  i!  i"  iñ
  i#  iÈ  ir  i$  i%  iN  i&  i'  iÍ  i(  i{  iÒ  i7  i)  i*  i+  i,  is  i-  ió
  i.  i/  i0  iÀ  i  iÎ  i1  i  iÒ  i2  iÏ  i3  i4  it  iÌ  iÚ  i5  i  iÓ  iÆ  i6  iÔ  i&  i  iÒ  iΩ  i7  iq  i'  iÚ  iÛ  i8  i9  i≈  i:  i|  i;  i<  i=  i>  i?  i@  iÙ  iA  iB  iC  iD  iE  iF  iØ  iG  iH  iI  iû  iü  iJ  i†  iX  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iı  iV  iW  iæ  iX  iY  iã  iZ  i[  i}  i\  i]  iÛ  iø  i^  iÙ  i_  i6
  iˆ  i
  i`  ia  iï  iG  iH  i˜  i◊
  i°  i(  i~  i¯  i)  i¿  i*  iI  i™
  i¢  i˘  ib  iM  ic  iu  i˙  i¿	  i£  i˚  iÎ  id  ie  if  i=	  i¸  iv  ig  ih  i∞  ii  ij  i  i}  ik  il  im  iw  in  iÿ
  ix  io  ip  iq  ir  i¡  is  iı  iÄ  i˝  i¬  i˛  it  iu  iâ  i+  i√  iv  iy  iÚ  iw  iË	  i±  i,  ix  iƒ  iy  iñ  iO  i∞  iz  iÃ  iÅ  iY  i§  iÇ  i9  iz  i{  i⁄  i$
  i≤  iÉ  iˇ  i{  i≥  i   i¥  i7
  iŸ
  i  iµ  iJ  iZ  i  i¯  i∂  iˇ
  i|  i}  i~  iˆ  i8  iÕ  i|  i  i≈  i}  iÄ  iÅ  i∆  iÇ  iÉ  iÑ  iÖ  iÜ  iá  iÈ	  ià  iâ  iä  iã  iå  iç  ié  i~  iè  iê  i∑  iK  iÑ  i˜  ië  ií  iÖ  iì  iî  iï  iL  iñ  iå  ió  i-  i«  iú	  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i  i∏  i  i£  i§  i•  i¶  i  i  iŒ  i]
  iß  i®  i  i.  i©  i™  i  i´  i¨  i≠  iÆ  iØ  i∞  iÍ	  i±  i≤  i≥  i»  iN  iπ  i  i…  iP  i  iÜ  ir  i¥  iœ  iµ  ió  iÄ  iç  iÅ  iM  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iù	  i∫  iø  i¿  iá  iO  i¡  i¬  i√  i   iN  iƒ  i≈  i  iO  i  iÀ  iÛ  i∆  i«  i»  i•  i¨  i…  i	  i   iÀ  iÃ  iª  i
  iÕ  iŒ  ià  i  iœ  i¯  i 	  i  i–  iâ  i[  iÃ  i  i  iÇ  iÉ  i  iÑ  iä  i—  iº  i  i  i–  iP  i  i  i“  i”  i‘  i’  i  i÷  i⁄
  i◊  iÖ  iÜ  iÿ  i  ié  i/  iŸ  i⁄  iè  i€  i  iÕ  i‹  i›  iŒ  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iã  iË  i  iÈ  iÍ  iÎ  i  iÏ  iÌ  iÓ  iá  iœ  ià  iÔ  i  i  i–  i≠  i0  iÒ  iQ  iÚ  i—  iÛ  iÙ  iı  iˆ  i˜  i¯  is  i  i  iâ  i˘  iG
  i1  iå  i€
  i˙  i˚  i  i¸  iÙ  i˝  ià  i  i˛  i  iç  i—  i  iˇ  i   iR  i  i¶  i  i  i“  i  i  i   i   i\  iä  i”  i|
  i‘  i  i’  i  i  i	  iÕ  i÷  i
  i  i  i  iP  i2  iQ  iã  iê  i  i  i  iò  ié  iå  i◊  i  iÆ  i  iØ	  i  i  iç  i  i  i  i  i  i   i  i!  iô  ié  i"  i  iß  i  i  i#  iè  i  i!  i´
  i  i$  i  i   i!  iÿ  i"  i!  i#  i$  iê  i%  i&  i%  ië  i&  i'  i	  i'  i(  i(  i)  i)  i#  i*  i+  i˘  i,  i˙  i*  i-  iŸ  iS  i+  i.  i⁄  i2	  i3  iH	  ië  iΩ  i/  i0  i1  i2  i3  ií  i4  i,  i“  i}
  i5  i®  i-  iH
  iR  i.  i6  i!	  i7  i/  i8  i9  i:  i0  i1  i”  iè  iì  i;  i   i<  i=  i>  i?  i@  iA  iB  i2  iî  iï  iC  iD  iE  i~
  iF  i3  iG  iQ  iñ  iH  ió  iI  i‘	  iJ  iò  i"  ií  iK  iL  iM  i4  iN  iO  iô  i#  iP  iQ  iR  iS  iæ  iö  iT  iU  i5  iV  iW  i‘  iØ  i6  i7  iì  i4  i8  i"  i©  i9  iX  iY  iZ  i:  i[  i;  i$  iõ  iú  i€  i\  iê  i™  i]  i^  i<  i_  i∞  i5  i‹  iî  i`  ia  ib  ic  id  ie  iù  iø  if  i  ig  i›  i=  iû  i¿  ih  ië  iü  i’  ii  ij  i´  ik  il  im  iﬁ  i†  i>  in  i#  i6  io  ip  i?  iq  i°  ir  is  iT  it  iu  ií  i¢  iì  iv  i
  i£  i@  iA  i§  iw  i÷  iî  ix  i•  iy  iz  i{  iU  i|  i}  iB  iC  iD  i3	  iE  i~  iI
  i¶  i  iï  iÄ  iÅ  iß  iÇ  iÉ  i®  i©  iF  iÑ  iñ  i™  iÖ  iÜ  iá  i˚  ià  ió  iG  iâ  iH  iä  iã  iå  iç  i¡  ié  i´  iè  iê  ië  iò  i¸  ií  i¨  i¬  iô  iì  i˝  iî  i◊  iï  iï  iñ  iI  ió  iò  iô  iö  iõ  iú  iJ  iK  iù  i≠  iû  iü  i†  iﬂ  i°  i¢  iL  i£  i§  iM  i•  iÆ  i¶  i¨  i‹
  iÕ  iN  iÍ  iŒ  iß  i®  i˛  iØ  iT	  i©  i™  i´  i∞  i¨  iö  iO  i≠  iÆ  iØ  iP  i∞  i±  i≤  iÃ  i≥  iQ  i¥  iµ  i∂  i∑  i7  i∏  i8  i‡  i9  iπ  i∫  iª  iõ  iº  iΩ  i:  iæ  i√  iø  iƒ  iÿ  i¿  i¡  i±  i¬  iR  i≤  iÎ  i√  i;  i≥  iS  iñ  iˇ  iƒ  iT  i≈  i∆  i«  i»  iU  i≠  iV  i≈  iW  i¥  i…  i’	  iX  iú  iY  iS  i   iZ  i[  iù  i÷	  iµ  iÀ  iÃ  iò
  iû  iÕ  iŒ  iœ  iV  i\  iW  i–  iU	  iÆ  i·  i—  i"	  i“  i”  i‘  i’  iı  i÷  i]  i◊  iÿ  iŸ  i⁄  i^  i∂  i€  i‹  i±  i›  iˆ  iﬁ  i_  iﬂ  i‡  i·  i`  i$  ia  i‚  i∑  i„  ib  i]  i∏  i‰  ic  iÂ  id  iA  iÊ  ie  iÁ  iË  iÄ  i   if  iÈ  iÍ  i^  iπ  i<  i  iÎ  i∆  iÏ  i$  iÌ  iÓ  iÔ  i∫  i«  i^
  i_  ig  iª  i  i»  i  i%  iº  iΩ  iÒ  i=  iÚ  i>  iÛ  iÙ  i…  i%  i	  i?  iı  iˆ  iö  i‚  it  i˜  i¯  i˘  i@  iX  i`  i˙  iæ  iø  i¿  i˚  ih  i¸  i˝  iü  i˛  iˇ  i   i  i  i„  i  iY  i%  i¡  i  i&  iˇ	  iZ  i  i  iT  i  i  iØ  i	  ia  i¬  i
  i˜  i9  i  ió  ii  i√  iƒ  iR  i†  i‰  i  iÂ  i  i   iu  iÀ  i°  ij  ik  iÃ  i  il  i¯  i  i≈  i  i  i  i  i  im  iA  i  i:  i  i  i  i  iÕ  i  i∆  iB  i  in  i  i  iÕ  i[  i  i
  i  iÊ  i  i  i   i¢  i\  i!  io  i"  ip  i£  iŒ  i∞  iJ
  iq  i]  i«  i§  i#  i$  i%  i&  iC  i•  ir  i'  i(  i)  i*  is  it  i+  i,  i•  i¶  i-  i.  i/  i^  iu  i0  iá	  i1  iß  iò  iŸ  i2  iD  io	  iv  i3  i®  i4  iw  i_
  i5  i6  i¨
  i»  i&  i;  i7  i8  i©  i9  i…  ix  i:  i;  i™  i<  i_  i&  i`  i  i›
  iﬁ
  i'  i  i   i˘  i=  iÁ  iS  i>  i?  iU  iû	  iË  iÀ  iÈ  iy  iz  i'  i´  i
  i(  iÃ  iÍ  iœ  i¨  i@  iE  iﬂ
  iA  i`
  i™  iV  iÕ  i{  i´  iW  iX  iB  i(  i|  i}  iŒ  i~  i  i–  i'  iC  iD  iõ  iŒ  iE  iF  iÄ  iG  iH  iI  iJ  iÅ  iK  ib  iœ  iÇ  iL  ia  i–  i≠  iÆ  iF  iM  iÎ  iÉ  iØ  iN  iO  iÏ  iP  iÑ  iQ  iô  iÖ  i∞  iÌ  i  iœ  iR  iS  i≠
  i—  iT  i“  iU  i)  i—  iV  i  iÃ	  iW  iX  i±  i)  i≤  i8
  iY  iZ  i[  i\  i]  i^  i  iG  iÓ  iº
  i_  i`  i”  iÜ  ia  ib  ic  id  iá  i≤  ie  i‘  ib  iø  iÔ  i’  if  ig  ih  ii  ià  ij  ik  iâ  i≥  i“  il  im  in  i˙  iä  i÷  iY  io  ip  i  iq  iZ  ir  is  i◊  it  iu  iv  iw  ix  iy  iã  iz  iÿ  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iå  iÖ  iÜ  iá  iç  ià  i”  iâ  iŸ  iä  iã  iå  i  i‘  i¥  iµ  iÒ  iç  i<  ié  ié  iè  iê  iT  ië  i’  iH  ií  iì  iî  i∂  iï  iñ  ió  iè  iò  iô  iê  iö  iõ  i∑  iv  iú  iù  ië  iû  i⁄  iü  i∏  i†  i°  i¢  i€  i‹  iI  i£  i›  i±  i§  ií  i•  i¶  iß  i®  i÷  iﬁ  i©  i™  iì  i´  iπ  i¨  i≠  iÆ  i∫  iî  iØ  i∞  iï  i[  i±  iñ  i≤  iJ  i≥  i¥  iÆ
  iﬂ  i‡  i·  iµ  i∂  i∑  i∏  iπ  i≤  ió  i‚  i∫  iÚ  iª  i  iU  i
  ic  i–  i„  i≥  iº  i‰  iΩ  iö  i◊  iò  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≥  i⁄  i≈  iÛ  i∆  iô  i«  i»  i…  i   iÀ  iÂ  iK  iÃ  i€  iÕ  iö  iŒ  iœ  i–  i—  iÙ  i“  i”  ic  iÿ  i‘  i’  iÊ  i÷  iõ  iÁ  iú  i◊  iL  iÿ  iŸ  iù  iË  iª  iŸ  i⁄  id  i  i›  i€  i9
  i‹  iÈ  i  i›  iÍ  iV  iﬁ  iﬂ  iõ  iû  i‡  iÎ  i·  iº  i‚  i„  i‰  iÏ  iÏ  iÂ  iü  iÊ  iÁ  iË  iÌ  i†  i⁄  iÈ  iÍ  i°  i¥  iÓ  iÎ  iÏ  iÌ  i±  i¢  iÓ  iÔ  id  i  iÄ
  i  iÏ  iÕ	  iΩ  iÒ  i  i1  iÚ  iÅ
  i*  iÛ  iM  iı  ip  i£  i§  iú  iÙ  i•  iı  iˆ  i˜  i	  iˆ  i¯  iÔ  i˜  i¶  i€  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  iæ  i>	  i  iÒ  i˚  i	  i   i  iÚ  i
  iN  iÌ  iø  i  iß  iO  i*  i¿  iÛ  i(  i  iµ  i  i  i®  i©  i  i  i‹  i‡
  i  i	  i
  i  i+  i  i  i=  i™  i  i  iP  i¡  i¯  i  i  i  i´  i  i¨  i¬  i≠  iÆ  iØ  i  i  i  i∞  i±  iú  i  i‡  i  i≤  iù  iÙ  i:  i˘  i  iı  i  i≥  i;  i,  i  i√  i˙  i¥  i  i˚  i  iµ  i—  i›  iˆ  iƒ  i≈  i∆  i-  i  i˜  i  i∂  i  i   i∑  i∏  iﬁ  i!  i"  i#  iπ  i$  i%  i&  i'  i¯  i∫  i(  i)  i*  iª  i+  i«  ie  i,  i-  i.  i/  iQ  i0  i‹  iº  i¸  i1  i2  i3  i4  i5  i6  i7  iΩ  iæ  i8  i9  i:  i;  iR  ie  i<  i=  i>  i?  iK
  iø  i@  i¿  i˘  iA  iB  i 
  iC  iD  iE  iF  iS  iG  iH  iI  iJ  iK  i»  iW  iL  iM  iN  iO  iP  iT  iQ  i¡  i…  iR  iS  i¬  i   iT  i˝  iU  iV  i√  iU  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  i  ia  iÀ  iƒ  i˛  ib  i›  i≈  ic  id  iÃ  ie  if  i˙  ig  i  ih  ii  if  i?	  ij  i\  i∆  i«  iÕ  ik  il  iˇ  i»  i…  im  i.  i+  in  io  ip  iq  ir  is  it  i  i˚  iu  iv  if  i,  iﬂ  i   iw  ix  iÀ  iy  iz  i¸  iŒ  iÃ  iœ  i   i{  i|  iﬁ  i}  i~  iÕ  i˝  iÇ
  i  i“  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iV  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i    i   i   i   i   i   i   i   i   i	   i
   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i!   i"   i#   i$   i%   i&   i'   i(   i)   i*   i+   i,   i-   i.   i/   i0   i1   i2   i3   i4   i5   i6   i7   i8   i9   i:   i;   i<   i=   i>   i?   i@   iA   iB   iC   iD   iE   iF   iG   iH   iI   iJ   iK   iL   iM   iN   iO   N(P   i(   i   i   i∂   iò   i¥   i'  iO  i  i}  iﬂ  i–  i¸  i˛  i]  i∂  i∑  i  i·
  iˇ  i©  i≤  iŒ  i   i´   i¥  iﬂ  i   i≥   iœ  iX  i}  iÓ  i–  ik  i   ig  i∏  iû  ik  i§  iË   i‰   i  i  i  i  i˘  i˙  i%  i&  i0   i1   i,   i-   i±  i≤  i  i  i‰  i  iµ  iÁ  i—  i<  i  iî  ip  i—  i“  i”  i‘  i’  i÷  ig  i◊  i  iÿ  iW  iX  iŸ  i‡  ih  i"  iÌ  iø  iã  i⁄  i
  i	  i  i\  iÀ  i•  iÉ
  i/  iõ  i·  i“  i”  i  iƒ  i0  iû  iô
  ih  i˝  i‘  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i  i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i¿  iV  ij  i4  iµ  i  iÑ  iB  i  iú  i8  i9  i:  i;  i<  i=  i>  iv  i¨  i“  iî  iS  i˚  ie  i  if  iù  iù  id	  i+  iŸ  i¿  ia  iw  i”  ió  i¡  iI  iÓ  i~  i€  iΩ
  i  i?  i@  iA  iB  iC  iD  i
  i  i-  i  i  ii  i’  iπ  i  iE  i^  i.  i‚  i3  i  ii  iF  i/  iY  i∂  i„  i  iÊ  ij  i‚
  i  iG  iH  iI  iJ  iq  i   i1  i   iY  i   ik  i/   i  i2   i   i   i#   i  i   iÛ   i*   iõ   i   iö   i   i∏   i   i[   i   i\   i5   iå  i!   i!  i	   i%   i@   il  i   i'   iA  i   i   i   i4   i   i   i–   iä   i    i   i<   i  iç   ió   i-  iµ   i  i7  iS   iÑ   i√  i~   iK  i=  i   iE   i†   i;   i   iù   i7   i7  i8  im   i&   i   i   i
   i   iO   iK  i=   i~  id  i   i   iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iY   i>   iJ   i"   ip	  ip   iã   iƒ   i  iï   iT   i_  iÉ   i˝  i.   iX   iô   i´  iL   ij  ie   i  i9   iP   i    il  iy   i‰  i©   i  iD   iÎ   ië   i∑  i)   ih  i”  iF   i?   i   i+   i  i  ig  ic   i  i¬   iB   i]   iN  iŸ   i¿   i8   ij   i:   i5  i  i  i7  i   ií   iR   i4  iG   id   iÄ   i÷   iè  in   i  ih   it  i6   i3   i$   iW   iC   i˛  iπ   i:
  ix  i‰  i   i*  iV	  i  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  i  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  i∫  iu  iv  iw  ix  iy  iz  i{  i|  i˘  iÔ  i  i÷  il  i}  iˇ  i~  i  i  i	  iü  iª  iÄ  i  i◊  i
  i‡  iÿ  i  iÅ  i  i  i  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  ik  iÇ  i„
  i>  i‰
  iÂ
  i	  i†  i	  ij  i€  i•   iñ  iZ  i[  i\  i]  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i¸  i  i  iÂ  i”  iŸ  i¢  i  iò  i2  i„  i‰  i{  iT  iŸ  ia
  iØ
  i^  iÂ  i·  i|  i°  i=  i  im  ik  iû  i‰  i˙  i	  iV  iy  iü	  iâ  i
  iq	  i  i  i   iæ
  i∞	  iå   iâ  i∏  iƒ  i!  iô  i¡	  i“  i  iÛ  i∏  i§   iC  iO  i3  i  iÕ  iÊ  i¸  iù  ir	  i≤  i≥  in  iƒ  i+  i  i…  iå  iø
  ip  iq  iÂ  i;
  iA   iÊ  i˝  i·  iC  i0  iä  in  iº  ió  iÁ  iT  iC  io  i  iˇ  i
  i#	  i  iÄ  i~  i  iP  iÊ  i˙  iﬁ  i  iÙ  i◊	  i  iÿ	  iü  i$	  iz  i⁄  i‘  i&  i»  ió  iÓ  iÁ  i   i€  i¿  i˘  i√  i_  i  iØ   iU  iŸ  iΩ  is	  iŸ	  ià  i’  iI  i™  iã  iÔ  i  iå  iï  iË  i3  i‹  i  i$  iW  i1  i5  iP  iÎ	  iá  i  i  i‚  iØ  iÒ  iX  i∏  i£  iª  il  iÈ  i¡  iH  i˙  ià	  i  iÑ  i‘  i  i¥  i  iÑ
  iW  iÿ  i~  ip  i  i$  iû  i  i  i@  iL  iÁ  i⁄	  iò  iˆ  iÃ  iu  i  i  iJ  iI	  iW	  iÎ  i∏  i_  iÍ  i†	  i<  ià  i  i  i]  iD  i¬  i‹  iÅ  i  ih  iÊ  iÇ  i®  iï  i  iﬁ   if   i-  iΩ  i}   it	  iñ  i¬	  i  i»   iƒ  iç  i,  i‡   i
  ib  i¶  i¬  iX  iì  i  iF  i  i{  i`  iÏ  i˙  i+  i3  iq  i¸  im  iˆ  i4  i‚  iª  i˚  iµ  iú  iB  il  iX	  iæ  i   i%
  i´  iÖ  i%	  i2  iu  iñ  i°	  i√	  iπ  iJ  i  i|  ir  i∑  i@  i  iﬂ  i  i  i≈  iﬁ  iø  iú  i€	  iL
  i  i  i  i  iü  iΩ  ib
  iJ	  i  ic  iï  i÷  iÎ  i¯   i˚  i«  i  i4	  iR  iä  im  iT  iË  i»  i  i∂  iÏ  iÌ  i€  iÄ  ie	  iÓ  i  i?  i  iÛ  iÉ  i§  i  i-  i	  i¶  i*  iE  i¢  i–  i+  iπ  i‡  i&	  i±	  i–  iΩ  i/  i¬  i“  i.  is  i[  iÒ  i+  i  i¿
  i  iö
  iB  ic
  i¨  iË  i·  iå  i∑  i	  i)  i  i,  i◊  iu	  i  i	  i  i9  i&
  i  i  iŒ  iÑ  i•  iv	  i„  iY  iÿ  i3  i˛  i
  i„  iû  i  iD  iØ  iº  iÆ  iï  id  iß  ië  i|  i(  iy  i  iÃ  i  i£  i<  i8  iŒ	  ii  i  i  i  id
  i5  iB  iè  in  i  iÔ  i  iÔ  iÕ  i|  iÏ	  i!  i—  i)  i@  in  im  i  i≤	  i0  ia  i…  i¸  iƒ	  iz   i'  i√   i´  i≈	  iW  i  i[  iv  i…  i√  i≥	  i›  iÜ  i	  io  i  i‹	  ió  i
  i  i†  i'
  i≤  i  i"  i˚  iÅ  i9  i  iç  i  i«  iJ  iΩ  iè  ih  iÒ  ié  ie
  i  iˆ   i\  iﬁ  iâ   i   ip  i@  i  iQ  i9  iﬂ  i∫  iÓ   i	  iª   i¸  iÖ  iw	  ii  iE  i∏  iJ  iI  iÌ	  iÏ  iú  i˜  iœ  i  if  i¡  i£  iô  i
  iË  i1  iŸ  i’  i
  i÷  i§  i'	  ir  i  iµ  i‰  iÂ  i¿  iÖ  iç  ic  i›	  iq  iñ  ix  i–  i  i
  i2  i›  i•  i  i…  i¢	  i*  iÑ  iæ  ib  iF  i˘  iv  iÒ  id  i¡  iô  i·  i!  iR  i¡  i—  iQ  ié  i   ií  iP  iÔ  i  i  iô  i  ií  i‡  i(	  i‹  i©  i_  i  i`  iê  ië  if
  iì  i6  iŒ  iA  i  i›  ia  i⁄  iÚ  iu  iT  i  i2  iÓ  iµ  i  i  i∑  i  i^  iC  i◊  iÊ
  i¡  i[  iÁ  i¬  iv  i%  i¸  i·  iÂ  in  i!  iF  i¨  iZ  i^  i‚  i  i‘  id  i  iﬂ  iÊ  ix	  i≥  iß  i]  iÈ  iB  i   ic  i√  iÍ  iØ  ió  iP  iq  i	  i  iH  iY	  iÜ  iŒ  i(
  iÛ  i¡
  iœ  ig  i}  iK  i£	  iÀ  i  i4  iÙ  iW  iÖ  i§  iÌ  iC  ig
  i-  id  iÊ  ik  i  i4  i}  iì  iq  i~  i+  i¥	  iÙ  iº  ih  i@	  iâ	  i  i@  iA	  iD  i:  iß  iç  ie  iÁ
  iÁ  iq  iw  iÁ  i¶  iò  iË  iı  i⁄  iü  id  i—  iZ  i˝  i*  iM
  i[  iÚ  i©  is  iZ  iÖ
  i∫  iÈ  i>  iê  i'  i-  iÎ  iË
  i  i  i»  i)	  i  iÎ  iˆ  iÙ  it  iF  i7  i¬  it  i#  iŒ  iò  iÖ  i“  i  iY  iÅ  i£  if  ik  ib  i1  iî  iƒ  ié  i6  io  ic  i  iq  iÓ	  i˜  iü  i»  iÈ
  iu  i¥  i:  i‚  iÙ  iN
  i¬  iU  i=  iÔ	  iv  iÚ  il  iN   iÔ  i   i˝  i]  iã  i;  iÛ  i‘  i¬
  i∆  iç  il  iL  i	  i}  i†  i’  i  i”  iB	  iá   i8  iQ  iƒ  i#  i`  iT  i≈  iµ	  ix  i  ir  iœ	  i  i  ií  i‘  i‡  i	  i›  i3  in  i  iœ  i  i  i  iô  i{  i˝  ió  i@  iÏ  iÊ  i  i“  i9  i™   ià   i±  i5  ih
  id  iZ	  i’   iê  ii  i  i±  iö  iª  i  is  i-  ir  iÌ  i  i  i‘  i[  iÀ  i0  i  i  iæ  i‰  i.  iS  i	  iR  iO
  iÙ  i  iÄ  iÏ  i;  i†  i4  iy	  iõ
  i;  i¥  iz	  i¯  ip  iµ  i•  i   iÌ  i≠  i:  i(  i|  iú
  i®  i"  i≈  i“  i”  i©  iâ  i¶  iO  i˜  ie  i°  i≠  i˚   i  iC	  it  i)
  i  i6  iK   iÜ  iÂ  i8  iˆ  iP
  i  ih  i¯  iÓ  iÈ  i  i¬  i3  i$  iÍ  i‹  i*
  i=  ib   ie  i  i≈  i4  i™  iÎ  i∆	  i.  i7  iÅ  i\  i˛  i˘  i  ij  iß  i  i˙  iÜ  i˘  iπ  i„  iº   i/  i  i≤   iŸ  i®  i=  i   i^  i–  i5	  i°  i€  i§	  i\  iﬁ  i  i˚  iÌ  i9  i#  i+  i∞
  is  i,  i™  i7  i  i¸  iY  iÒ  i™  iÍ
  iM  iŒ  i+
  ii
  iQ  iÉ  i¢   i6	  iÃ  i„  iÍ  i∏  i  iy  i©  i  is  i#  i{	  i∆  iU  if  i<  i‹  iØ  iv  iﬂ  i•  i)  iÎ
  i  iô  i  iÆ  iÚ  im  i<  i  i  i•	  iÊ  iÃ  ig  i˝  iä	  il   i»  i   iD	  ib  iu  i√
  i™  iD  iB  iô  iÄ  i«  i[	  i´  i  i8  i‚  iõ  i>  i  i≠  i  iª  i≤  i‰  iÂ  i  i]  iÏ  iD  iÌ  i·   i‘  i6  iZ  iÙ  i¶	  i5  i…  iù
  iÏ
  i<  im  i»  i,  iß	  i¶  iu  i^  i∂	  i˝  i≈  ig  iÛ  iå  iI   iå  iµ  ig  iÔ  i•  i\  i:  i  iM  it   i∑	  i·  iE  iú  io   iÙ   iﬂ  i˛  i’  iE  iR  i⁄  i  i¢  iE  ij
  iÓ  ig   iW  i˜  iÜ  iK  i∏	  iC  ië  i=  i”  i]  i$  i!  i˝  iã	  i  i—  iπ  i`   iK  iv  i  i  i0  ii  i≠   i^   i‚   i¨  i3  i÷  i"  i  iõ  iÁ   i–  i  ia   ik
  i  i;  iw  iá  i∫  i´  iÊ  ië  iˇ  iÜ
  iy  i  i≤  i„  iﬂ  iP  i  i¶  i®	  iw  i£  iÅ   iÁ  it  i  i≤  iÈ  i  iË  iÓ  iJ  ia  i  i˚  i]  iË  i∆  i’  iå	  iî   i  i¥  i  iL  ih  i  iÈ  i›  iƒ
  iu  ij  ié  i  i#  iC  i÷  i§  i	  ia  iÕ   i!  is   i|	  i∞  i	  iY  iè  i
  iª  i¶  i˛  ih  iO  i5  i≥  iı  iz  ii  i±
  iS  iÚ  iL  i’  i.  iı  i&  i  i	  i<
  i7  i  is  iA  i®  iã  iM  i…  i∞  is  i·  i*  i,
  i%  i≤
  i«	  i†  ik  iÍ  i&  if  iÂ   iO  ij  i"  iΩ  i(  i-  iÇ  i[  i˛  i—  iÒ  i¸  i-  i=  i∞  i}	  iÄ  i∂  iM   iS  iü  i“  i⁄  i  i®  i  i   i¢  iÎ  i€  iá
  i
  i  i
  iÆ  i~	  iø  iJ  it  ik  iv  ie  iy  i  iÏ   iâ  i<  iÚ  if  iı  iM  ik   i   i  i™  io  i÷  iœ   iÂ  iw  iv  il  iÏ  i]  iè  i  i.  i≈
  iﬁ  iÏ  i∏  i/  if	  iq  i$  ig  iˆ  iG  iæ   i˝   in  i∂  i>  i6  i=  i¶  i≠  iß  i’  i£  iN  iÒ	  ix  iú  ie  i*	  i  ih  i  i  i‰  i$  iÆ  i‡  iî  io  ib  i,  i  iÅ  i˛  i  it  i«  iª  i	  i‹  i  iÌ
  iV  i˛  iÓ
  ii  i  iπ  i˙  iÎ  iw  i  i  ip  iH  i›  iV   i´  ii  i<  iZ  iç	  i8  ir   iw  iÇ  i&  iÀ   iÛ  iø  i/  i‚  i≠  i¡  iÌ  i>  iü  i>  iE	  ix  iÓ  i&  ie  i∆  iw  i	  iÓ  iÉ  i5  i›  i   iû
  i  i\  i≥  i¸   iô  iS  ii  i  iê  i®   i“  i2  i¡   iÔ  i  i  i+  i'  i÷  i%  iã  iÈ  ix  iO  iπ  i
  iQ
  i°  i’  i  i  iˇ  i‘  i_  iH   iœ  iæ  i  iº  ig  i  iÿ  iy  iÉ  ià
  i0  i&  i+	  i  iâ  i  i∑  iÆ  il
  i'  iü  i'  iz  iÑ  i	  i	  i±  i_  iÂ  i≈  i  iÙ  iı  i˛  i?  iÔ
  iÙ  iﬁ	  i£   iz  iÔ  im
  i|  i
  i  i	  ig	  i0  i¿  i÷  i   iı  i*  iç  iˆ  i
  i`  iw  i  iì  i  i#  i“   ic  i)  i·  iÍ  iR
  iﬁ  iŒ   iÛ  iT  iê   iœ  ir  i  iV  iõ  iÚ  i¢  i_  i  iˇ  i  iø  ir  iù  i≈  i≥
  i`  ix  iæ  iû  i
  i¯  i≥  if  i∂  i  in
  i=
  i*  iA  i  iÚ	  i(  iÚ   ix  i˙   iS
  i≥  i{   iT
  iá  i9  i  i±  iM  iÇ  ir  iÿ   i  i;  i  i(  i  i%  ië  i[  ia  ib  i  i∫  iD  iñ  i¨  i  i-
  i\	  i˜  i  i  iñ  io
  iE  im  i)  iÁ  i!  i¨  i  ic  i¿  i,	  i1  i  i]	  i´  iÇ   iÑ  i>  iI  i∞   iß  iﬂ	  iT  i  i„  i  i˜  iø  iè  iy  i  ik  iz  ix  iÈ  iN  i	  iƒ  iÜ  ià  i 	  i5  i¯  iﬂ  i"  i◊  iH  i<  id  i˘  i
  i≠  iù  ih	  iÛ	  iä  i
  ip
  iÄ  i≤  i:  iL  i1  i∆  iß  iÀ  i  i∑  i>
  i≈  iq
  i?  iZ  iM  iI  iΩ  i  iB  iK	  iD  ië  i#  i  i
  iY  i>  i˘   iÏ  i  i  i`  iÖ  iÖ  iò  iö  i  iü  iﬁ  iö  i  i¶  i˙  i˘  i   i¢  i  ic  i≥  i  iÑ  iˇ  i€  i‹   iT  iã  ia  i  i2  iy  i/  i∆  i"  iU
  i⁄   iÒ   ib  i®  i˘  i¿  i/  iÆ  i‡	  i√  i  i
  i{  i
  iã  ij  i˛   iÉ  i∫   i5  i*  iÈ  i∞  i›  i¨  ia  ix  i∆  i≠  iπ	  i  iF  iÍ  iÒ  iº  i7  i¯  iÒ  i∫	  i?  i˛  iw   i…  i  i  iÛ  i◊  i+  iÅ  i8  i   i∆
  iN  i
  iï  i«  i,  iÿ  in  iå  i  i  i˙  io  is  i_  i?  iÂ  iª	  iï  iÑ  i  iÙ	  iá  i◊  i?  i0  i·	  ié	  iı  iy  i3  if  iØ  i=  iö  iÉ  il  i  iı	  i  iv  i]  i†  i	  i	  i»  i  iz  i«
  iˆ  iy  ij  i  iu  iÑ  iÍ  ip  iÃ  ij  iü   i  i	
  ii  iz  i  i÷  ir
  i  iâ  i‡  iÔ  iÿ  ií  i  i  iF  i°  i'  i–	  i{  in  i  ix  iu   i$  i  i∏  iπ  iM  i£  i˜   i‚  ik  i   ip  i»
  i^	  iq  i  i`  i|  iæ  iÄ	  i  i

  i|  iè	  i…
  i  i∫  iê	  i
  i®  iÆ  i„  ië	  iG  i  i¯  i-  iÚ  iZ  i1  iY  iÒ  i-	  i	  ie  iÚ  iæ  i[  iC  iˇ   iæ  i°  ie  i∞  i.  i-  i  i˜  i◊  i	  i†  iñ  iâ
  iü
  i7	  ib  il  i	  iû   iÙ  iÛ  i{  iÙ  i.  i	  iÖ  i»  iz  i∏  iÃ  i†
  i†  i?
  iÛ  i  i9  i  iä
  iÕ  i  iî  i}  i£  i°
  ia  ií  iˆ	  i
  iQ   ií	  id  i;  iV
  i⁄  i/  i^  iD  iÿ  i?  im  iÕ  iŒ  i9  iI  iã
  i‹  iﬁ  i
  i  iŸ  i 
  i{  i}  i   i˚  i  iÄ  ií  iÜ   i&  i◊  i~  i‰  iX  iˇ  i˚  i}  iœ  i÷  i9  iÜ  iË  i:  i¢  i"  i\  i  i·  i
  i_	  i”   i8  iW  i~  i^  i%  iP  is  i±  iw  iö  iæ  i  i8	  i¸  iL  i‡  i  i.
  iË  iù  i–  iÙ  i  iN  i«   i”  iP  i•  iS  iì  i·  iÍ  i:  iR  i'  i0  ib  i  iª  i¥
  iı  iÕ  iõ  iÎ  iz  i  i˜	  i  i  i  i  iK  i«  i∆   i‡  i¢
  ir  iö  iq  i
  iÊ  i‡  in  iL	  i  i©  i  iÆ  i≥  i†  iÅ  iı  iÂ  iX  i@
  iÁ  ig  ii   i°   iº  i4  i®  i:  i  iÜ  ió  ir  i©	  iû  iQ  iÒ
  i  i	  i;  i'  i˝  i>  i‚  ib  im  i√  iw  iﬂ   iˆ  i˜  is
  iﬂ  i  i≠  iA
  iÄ  it
  i9	  i  i¯  i  i  iì	  io  i^  ià  iä  i2  iØ  ic  i‚  i  i€   i≤  i  ir  iç  iÅ  i˛  i!  i  it  i  i1  i{  i·  iÿ  iÉ  i©  iì   i∂  is  i  i¥  iı  iñ  iø  i   ix   i  iv   ia  ip  i˘  i‰  i  i√  iL  iO  iˆ  i  iU  i§  i.  i  i‘   i)  i.	  iÇ  iE  iÅ	  i"  i  iy  i  i	  i˚  iÇ  iÕ  i¶   i(  iÄ  i  iø  iq  iE  i6  i
  iÀ
  i2  iu  i6  i¿  i˚  i¨  i∆  i.  i∑  ii	  i  iÿ  iV  iû  i  is  iÃ
  ié  i¢  iG  iG  ij  it  ié  iW  i  iÇ	  iê  iÆ  i`  i˜  iÉ  iá  iu  i‚  i  iµ
  iÚ  i{  iQ  i  i¯	  iO  iC  i≥  i˙  iÅ  i‚  iJ  i˘	  i	  i	  i$  i”  i¯  iŸ  i/	  iÀ  i  i_  i  i∆  i  ij	  iR  i∞  i7  i  i¥  i/
  i  i3  iD  iu
  i6  iX  i4  i˘  iÊ  i  i  i˚  i  i>  iÄ  i  i  i0
  i`  i`	  i
  iÒ  i¸  iŸ  iU  i…  i   i£
  ir  i  i¥  i)  i◊  i5  iÎ  iH  iÀ  i 
  iú  i  i~  ir  i˝  iå
  i˛  iÔ  iå  iú  iî	  iú   i  i]  iŒ  iØ  i  i∂  i  iÎ  i  i@  iΩ  i…  i∂
  ia  iŒ  iv  i˜  ié  iò  i/  i!  i6  iÍ  i’  iß  i7  iw  i¡  i	  i3  ic  i8  ix  i  i•  iˆ  iB
  i‹  i◊  iM	  iˇ  iè   iF	  i¿  ig  i  i§  iÑ  i(  i°  i  i:	  i   i‰  iH  iÅ  iÕ
  if  i◊   ià  i"  i—  i~  i˝  i–  i„  iç
  iy  i  i  i¶  iÚ  i   i!  iN  i“  i4  iA  iœ  id  ie  iÈ   iı   iz  i  iä  i„  i‰  iÃ  i  i∂  i0	  iÌ  iˇ  i  iº  iÖ  iû  i  iÌ  i{  iÿ  iœ  iá  i§
  i˙  if  i(  il  iË  iG  i™	  iÖ  i≈   i^  iB  im  iF  i|  i  iU  iﬁ  iö  i2  iR  i‹  i‡  i#  iÓ  iÇ  iõ  iÁ  iF  i›   i  iU   iπ  i∫  i˚  i1  i¬  ic  ik  i©  iN	  iS  i´	  iÖ   iÔ   iÚ
  i«  i¯  i$  iO	  iõ  i  iY  iã  i¡  ià  i   iﬁ  iG  i  i  i¸  iW
  i	  iC
  i?  iµ  i  iñ   i~  i„  iê  iU  iF  i«  i®  iü  i  iÈ  iﬂ  iù  iÉ  iC  iº	  ió  iÀ  i  ie  i  iŸ  i°  i™  i  i/  iQ  i_  iv
  i;  i∂  i∑  iP  i)  i„   iG  im  iï	  ië  iç  iG  i,  iI  iz  i_   iÉ	  i…   i	  i9  in  iá  i∑
  iA  i˙	  ié
  iX
  iË  i#  iV  i)  i<  i%  iÜ  i}  i¡  i•  iH  iw
  i5  iî  ip  i.  i  iƒ  i´  im  i  iØ  iœ  iÑ  i#  ih  i|  ib  i¸  ià  iÇ  i@  i(  i^  iz  i√  i  iA  iÛ
  i   i  i"  i  ig  iï  i|  i‘  i»  ií  ié   i√  i6  i¨  iX  iÇ  iˇ  i,  i—  iÏ  i		  i  iÂ  i$  i#  iI  ik	  i∞  i  iá  ià  i:  i	  iâ  iQ  i  io  ih  iV  i$  iÖ  iÒ  it  iê  i¥  i£  iY
  i,  i–  i  i
  iâ  iD  iø  i»	  i~  i”  iÜ  iπ  iΩ  i%  i∫  i  i   i©  i∑   iä  i  i¬  i‘  i   i7  i/  i
	  iÆ   i”  iÊ   iñ	  iE  iV  iÛ  i’  iE  iu  iä  i&  i   i˜  i  i∏  i—	  iÌ  io  iâ  i˝  iZ  iè  ii  i∑  iä  i	  i  ií  iû  iß   i!  i⁄  in  i8  iÓ  i'  iì  iΩ   iê  i  i«  i  i›  ió	  iï  iG  iã  iR  i2  iÚ  i  i:  iÅ  i,  iÌ   i  iZ
  il  iã  i(  iX  iP	  i?  i∫  i  iÑ	  io  iå  i  iß  iˆ  iƒ  iÉ  iW  i*  i  i   i;  i8  iç  i&  i)  i§  iÂ  i
  io  i   i  iØ  i≠  iH  i_  iò  i™  i0  i√  ix
  i˘  i0  iù  i;	  iì  i  iá  iˇ  iX  i°  i	  iÃ   i—  i1  i˛  iZ   i*  i%  i…	  iø   i  i|   id  i`  i  iö  iS  ij  i}  i\  i  i€  i¯  iG	  iß  i  iò	  if  iq   i%  iB  iÉ  i1
  ip  iÇ  i"  i  iä  i⁄  ié  iå  i|  i∫  iÒ  i  i“	  iÛ  il	  i2
  i±   iè
  i÷  i  iá  i@  ih  iò  i;  i˙  i¨   i  i	  iè  i	  i∂  iº  i&  i  iÄ  iË  i}  ië  i%  iç  i±  i  i  i?  i§  i¨	  i€  ia	  iy
  i  i∏
  i—  iı  i˚	  i∑  i=  i1  iä  i<  iˇ  i{  i#  i  i    i„  iì  iŒ
  iA  iõ  i
  ié  it  i†  iù  iô	  iè  i>  i
  iK  i3
  iµ  iî  i=  iÍ   i  i\  iÊ  iÁ  i'  iA  i+  ig  i   ib	  iK  i°  i⁄  iˇ  iÁ  i  iƒ  i
  i–  i4
  i¥  i*  iê  im	  i≠	  i¿  i•
  io  iN  i   i0  i(  ii  iı  i$  i4  i   i{  i  i§  i¢  iQ	  iÀ  ië  iU  iÈ  iª  iµ  i,  i`  i  i”	  iº  i  iœ
  ij  i)  i   iÕ  i-  i6  i—   iÖ	  iF  i2  i)  i  i  i*  iπ  iY  iZ  iJ  ií  iH  iÀ  i  i  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  is  i^  i_  iÅ  i`  ia  ib  ic  id  i?  ie  if  i@  ig  ih  i%  ii  ij  i  ik  ik  i¸	  i5
  iA  i  iÇ  il  im  in  io  iB  ip  iq  ir  i–
  i1	  i  iC  iD  it  i  iá  is  i&  iE  iF  it  i€  iu  i  i  i  i◊  iv  iw  ix  i≈  i¢  ià  i'  iG  iy  iz  iÆ	  i  i{  iH  i  i|  i}  i£  i~  iÿ  i(  iI  i  i)  iÄ  i  iÙ
  iÅ  iÇ  i!
  iÉ  iÑ  iJ  iÉ  iº  iK  iÑ  iÖ  iL  iÜ  iá  i*  iÖ  iM  ià  iâ  i∫  iä  iã  iå  iç  iÜ  iN  i  iá  ié  iè  iŸ  iê  ië  i+  iO  i,  ií  i-  iì  i.  iî  iï  i  iñ  ió  iò  i  iô  iG  iö  iõ  i  ià  iú  iù  iû  i  iü  i†  i  iì  i°  iP  i  i¢  i£  iª  iˆ  i§  iî  i‚	  i/  i•  iQ  i¶  iß  i®  iË  i©  i™  iR  iï  iΩ  i´  i¨  iÍ  i  i≠  iÆ  i  iØ  i∞  iS  i±  iH  iT  i≤  iU  i≥  iÈ  i¥  i  iµ  iâ  i∂  i∑  i∏  i⁄  iπ  iV  i  i∫  iW  iX  iª  iº  iΩ  iæ  i  iä  iø  iY  iã  i0  i¿  iå  iZ  i¡  i¬  i√  iƒ  i≈  i[  i\  i]  i∆  i«  i^  i»  i…  i_  i   iÀ  i`  iÃ  ia  ib  i?  iÕ  ic  iŒ  id  iœ  i  i–  ie  iñ  i1  i—  i 	  if  iu  i“  iÍ  ig  iç  i”  i€  i∆  i2  i  ió  i[
  i  iº  i@  i∞  i¬  i‘  iI  i’  ih  i"
  i+  iA  i
  iò  ié  ii  i,  ij  ik  iz
  i-  il  i÷  i.  i  i/  i◊  iÿ  iŸ  iè  i⁄  i€  i‹  i›  i3  i  im  iﬁ  iﬂ  iô  i  i‡  in  iD
  i·  iΩ  i‚  iR	  i„  i‰  iö  iê  io  ià  ip  iJ  iÂ  il  i  i4  i2  iÊ  iı
  iæ  i  iê
  i  i„	  iB  iˆ
  i®  iÁ  i—
  iË  iq  ir  iK  iÈ  iÍ  i‹  iÎ  iÏ  ië
  i  iª  i5  iE
  i	  iI  iÌ  i
  i6  i˝	  i  i  iÓ  iv  iø  iõ  iÔ  i7  is  i8  i˛	  i
  iL  iw  i  iÒ  i9  iÚ  it  i  iÛ  iÙ  i  iı  iˆ  i:  i˜  iu  ië  i¯  i  i;  i˘  i˙  i˚  i¸  i˝  iâ  i˛  i   iˇ  i   i  i  i  i  i<  i  i  i  i  iK  i	  i
  i	  ix  iv  i  i  i  i  i!  i=  i  i  i>  i  i  i  i  ií  i  i  i	  i  i  i  i?  i  i  i@  i  iú  i  i  i  i  iì  i  iw  i   iæ  i!  i"  i"  iî  i#  i$  i0  i%  i&  i  i'  i(  i)  i*  i1  i+  ié  i,  i-  iä  i.  i<	  i#  i
  i/  i$  iè  i  i0  i  i1  ix  i2  i3  i¿  iy  i4  iy  i5  i%  i&  ií
  i  iz  i6  iC  i7  iz  i8  iÎ  iL  i  iB  i'  iA  i  iÜ  i  iB  iï  i(  iñ  i{  i|  i)  i¯  iC  i*  i¡  i9  i˜
  iã  i  i:  i;  i<  ió  iå  i}  i~  i=  iD  iê  i>  i  i?  i@  iA  iB  iÄ  iÅ  iÇ  iÉ  iC  iD  iD  ic	  i  iE  iF  i“
  i  iG  iÑ  iH  iI  iJ  iK  iL  iM  iN  i{  iO  iÖ  i+  iP  i3  iQ  iÜ  i¯
  iR  iΩ	  iE  iS  iT  iU  iV  i˜  iá  iW  iX  iY  i2  iZ  i[  i\  i]  i^  i_  i`  i©  ià  ia  ib  iâ  ic  id  im  iE  iF  ie  if  iä  ig  ih  iã  ii  ij  ik  iJ  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  iç  iG  ix  iy  iz  iå  i,  iù  i-  iç  i.  i  iM  ié  i{  iè  iê  ië  iÏ  i|  ië  iH  i}  ií  i~  iì  i/  in  iI  i  i  iÄ  i0  iJ  iÅ  iK  iÇ  iÉ  i#
  iÑ  iÖ  iÜ  iá  i3  ià  iâ  iä  iã  iå  iç  ié  iî  iè  iê  ië  ií  iì  iî  i1  iï  iñ  ió  iò  i2  iM  iï  i3  iô  iö  iõ  iL  iû  iú  iù  iû  iò  i4  iü  i†  iÌ  i¶
  i°  i›  iM  iÓ  i4  i¢  i£  iô  i5  i¬  iﬁ  i˘
  i6  i§  i•  i¶  iñ  ió  iß  iü  i®  iò  i†  iô  ié  i©  i™  i´  i7  i¨  i°  iN  i≠  iO  i˙
  iP  i|  iö  iÆ  iQ  iØ  i∞  iæ	  iK  iﬂ  i±  i≤  iè  i≥  i8  i¥  i«  i}  iµ  i  i‰	  iö  i  i∂  i  iN  i9  i∑  iL  iR  iõ  i:  i»  i;  i∏  iõ  iF  i…  i{
  iπ  iS  i∫  iª  iú  i<  iº  iΩ  i=  iæ  i™  iø  ií  i‡  i¿  iì  iê  i¡  i¬  iT  iù  i√  iƒ  i±  i√  i>  i≈  iO  i5  iû  i∆  i«  i~  i»  i?  i…  i  i  i   ië  iü  i˚
  i@  i@  iƒ  iÄ  i
  iú  iù  iÅ  iA  iÀ  i  io  iÃ  iG  iÕ  i‹  iŒ  iû  i  i  i”
  iœ  i–  i6  iø	  i†  i—  i  i“  i≈  iπ
  i°  iU  i·  i”  i  i∆  i‘  i’  i÷  i  i◊  iÿ  i¢  i£  iŸ  ií  iü  iB  iC  i⁄  i7  i  i€  i§  iV  i‹  iN  i›  iﬁ  iﬂ  iD  i•  i‡  i   i·  i¶  i‚  i‚  iW  iÈ  i¢  i„  iX  iì
  i‰  iE  iF  i  iÔ  iY  i„  iÂ  iÊ  i4  iÁ  iË  iG  iÈ  iÍ  iH  in	  iÂ	  ip  iÎ  iZ  iS	  iÏ  iß  iÌ  i[  iÓ  ic  iI  iÇ  iÉ  iÔ  i  i®  iÒ  i  iÚ  iÛ  i8  iÙ  iì  i  i9  i†  iı  iH  iˆ  i  i¸
  i\  i:  iÑ  i˜  i  iî  i¯  i  i˘  iJ  i°  i˙  i˚  i¸  i
  i˝  i]  i©  i˛  iˇ  i   i  i  iï  iÖ  i¢  i  i£  i  i  iÃ  i  i  i  i™  i  i  i	  i
  i  i  i  i´  i¨  i   i  iñ  i  i  i‰  i£  i§  i  i  i  iI  i•  i§  i  i  i  i  i  iP  i  i  i  i  iÜ  iá  i  i  i≠  iK  i  iÆ  iØ  i∞  i  i   i!  i^  i"  i#  ió  i$  i∫
  i%  iL  i&  i'  i(  i)  i*  i+  i±  i,  i-  ià  iß
  i.  iJ  i/  i0  iQ  iî  i1  iM  i2  i3  i4  iÊ	  iÃ  i5  i6  i7  iª
  i8  i9  i:  i≤  i;  i;  iN  iO  i<  iÂ  i=  iP  iQ  i>  i?  i@  iA  i•  iB  i¶  i≥  iC  iD  i<  i¥  iR  iE  iF  iµ  i‘
  iG  iH  iI  iJ  iK  iî
  i  i˝
  iS  iL  iM  i∂  i∑  iò  iN  iO  iP  iQ  iT  i  iR  iR  iß  iS  iT  i®  iU  iV  i∏  iS  i_  iW  iX  iY  iZ  i[  i  i\  i¶  i]  i^  i_  i`  ia  ib  ic  i  id  i©  ie  iπ  i∫  if  i˛
  i´  ig  ih  ii  iU  ij  ik  il  im  i=  in  io  iô  i`  ip  iß  iq  ir  i~  is  i  i®  it  iu  iv  ia  iª  iV  iÊ  iº  iW  iw  iΩ  ix  iy  iæ  iz  iø  iÁ  i¿  i{  i|  i}  iö  i~  iM  i  iÄ  ib  i¡  i™  iÅ  iÇ  iX  iÉ  i´  iÑ  iÖ  iÜ  iá  ià  iâ  i¬  iä  iã  iå  i¨  iç  ié  iè  iê  i  i√  iõ  ië  iƒ  ic  ií  i≠  iì  iî  id  iï  iÆ  iØ  iñ  i  i«  i   ió  iú  iò  iô  iö  iY  iõ  iZ  ie  i[  i»  i≈  iú  iT  i∞  i+  iù  iû  i±  iü  i  i†  iî  i°  i∆  i¢  i£  i≤  i>  i§  i•  i«  i≥  i¥  i¶  iß  iË  i®  i©  iµ  i\  i™  if  i´  i¨  i]  i≠  iÆ  ig  i»  iØ  i∞  i±  i  iÀ  iö	  i≤  i©  iU  i  i≥  i…  i  i   iÈ  i^  i¥  iµ  i_  iÀ  iÃ  i∂  iõ	  i`  i∑  ia  i∏  iπ  i∂  i   i∫  iÕ  iŒ  iª  iº  iœ  ih  ii  ij  iΩ  i∑  iæ  iø  ib  iÍ  i!  i¿  i¡  i–  i—  i¬  ic  i“  i[  i√  iÎ  iƒ  i≈  i  i∆  i«  i  i∏  iï
  iV  ik  id  i»  il  i…  i   i"  i#  iÀ  iÃ  i”  iÕ  iŒ  iœ  i–  ie  i?  i—  i“  i‘  i”  i‘  i’  i÷  if  i◊  i5  iÿ  iŸ  i’  i⁄  i™  i€  i÷  im  i‹  i›  iﬁ  i@  in  ig  iﬂ  i◊  i‡  iÿ  i$  i·  iÔ  io  i‚  iW  i„  i‰  iÂ  ip  iq  iÊ  ir  i  iÁ  i  iÏ  iâ  iù  i\
  iË  i®
  iÈ  iä  i´  iÍ  iπ  ih  iÎ  iŸ  iÏ  iÌ  iÓ  iÔ  is  i  iÒ  iÚ  i⁄  iÛ  iÙ  it  iı  i€  iˆ  i’
  iÌ  i˜  i‹  i¯  i˘  i˙  i˚  iA  iB  i¸  i!  iÓ  i˝  iÔ  i  i˛  iˇ  i   i  i  i  i∫  i  i  i›  i  ii  i¨  i  iC  i  iu  iD  i6  i  ij  i  iÜ	  i	  i
  i≠  i÷
  iﬁ  i  i  iﬂ  i‡  i  i·  ik  iE  iÀ	  i  i‚  iÁ	  i  i  i…  iª  iK  i  i  i  i  i  il  i  i%  im  i©
  iF  i  i  i  i  i  i„  iF
  iv  iº  in  i‰  iw  i  iL  ix  io  iÂ  iÊ  iy  i  i  i"  iÁ  i  ip  i  i  i  iË  i   iz  i   iq  i!  i"  iñ
  i#  iÈ  ir  i$  i%  iN  i&  i'  iÍ  i(  i{  iÒ  i7  i)  i*  i+  i,  is  i-  ió
  i.  i/  i0  iÀ  i  iÎ  i1  i  iÒ  i2  iÏ  i3  i4  it  iÌ  iÚ  i5  i  iÓ  iÆ  i6  iÔ  i&  i  iÒ  iΩ  i7  iq  i'  iÚ  iÛ  i8  i9  i≈  i:  i|  i;  i<  i=  i>  i?  i@  iÙ  iA  iB  iC  iD  iE  iF  iØ  iG  iH  iI  iû  iü  iJ  i†  iX  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iı  iV  iW  iæ  iX  iY  iã  iZ  i[  i}  i\  i]  iÛ  iø  i^  iÙ  i_  i6
  iˆ  i
  i`  ia  iï  iG  iH  i˜  i◊
  i°  i(  i~  i¯  i)  i¿  i*  iI  i™
  i¢  i˘  ib  iM  ic  iu  i˙  i¿	  i£  i˚  iÎ  id  ie  if  i=	  i¸  iv  ig  ih  i∞  ii  ij  i  i}  ik  il  im  iw  in  iÿ
  ix  io  ip  iq  ir  i¡  is  iı  iÄ  i˝  i¬  i˛  it  iu  iâ  i+  i√  iv  iy  iÚ  iw  iË	  i±  i,  ix  iƒ  iy  iñ  iO  i∞  iz  iÃ  iÅ  iY  i§  iÇ  i9  iz  i{  i⁄  i$
  i≤  iÉ  iˇ  i{  i≥  i   i¥  i7
  iŸ
  i  iµ  iJ  iZ  i  i¯  i∂  iˇ
  i|  i}  i~  iˆ  i8  iÕ  i|  i  i≈  i}  iÄ  iÅ  i∆  iÇ  iÉ  iÑ  iÖ  iÜ  iá  iÈ	  ià  iâ  iä  iã  iå  iç  ié  i~  iè  iê  i∑  iK  iÑ  i˜  ië  ií  iÖ  iì  iî  iï  iL  iñ  iå  ió  i-  i«  iú	  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i  i∏  i  i£  i§  i•  i¶  i  i  iŒ  i]
  iß  i®  i  i.  i©  i™  i  i´  i¨  i≠  iÆ  iØ  i∞  iÍ	  i±  i≤  i≥  i»  iN  iπ  i  i…  iP  i  iÜ  ir  i¥  iœ  iµ  ió  iÄ  iç  iÅ  iM  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iù	  i∫  iø  i¿  iá  iO  i¡  i¬  i√  i   iN  iƒ  i≈  i  iO  i  iÀ  iÛ  i∆  i«  i»  i•  i¨  i…  i	  i   iÀ  iÃ  iª  i
  iÕ  iŒ  ià  i  iœ  i¯  i 	  i  i–  iâ  i[  iÃ  i  i  iÇ  iÉ  i  iÑ  iä  i—  iº  i  i  i–  iP  i  i  i“  i”  i‘  i’  i  i÷  i⁄
  i◊  iÖ  iÜ  iÿ  i  ié  i/  iŸ  i⁄  iè  i€  i  iÕ  i‹  i›  iŒ  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iã  iË  i  iÈ  iÍ  iÎ  i  iÏ  iÌ  iÓ  iá  iœ  ià  iÔ  i  i  i–  i≠  i0  iÒ  iQ  iÚ  i—  iÛ  iÙ  iı  iˆ  i˜  i¯  is  i  i  iâ  i˘  iG
  i1  iå  i€
  i˙  i˚  i  i¸  iÙ  i˝  ià  i  i˛  i  iç  i—  i  iˇ  i   iR  i  i¶  i  i  i“  i  i  i   i   i\  iä  i”  i|
  i‘  i  i’  i  i  i	  iÕ  i÷  i
  i  i  i  iP  i2  iQ  iã  iê  i  i  i  iò  ié  iå  i◊  i  iÆ  i  iØ	  i  i  iç  i  i  i  i  i  i   i  i!  iô  ié  i"  i  iß  i  i  i#  iè  i  i!  i´
  i  i$  i  i   i!  iÿ  i"  i!  i#  i$  iê  i%  i&  i%  ië  i&  i'  i	  i'  i(  i(  i)  i)  i#  i*  i+  i˘  i,  i˙  i*  i-  iŸ  iS  i+  i.  i⁄  i2	  i3  iH	  ië  iΩ  i/  i0  i1  i2  i3  ií  i4  i,  i“  i}
  i5  i®  i-  iH
  iR  i.  i6  i!	  i7  i/  i8  i9  i:  i0  i1  i”  iè  iì  i;  i   i<  i=  i>  i?  i@  iA  iB  i2  iî  iï  iC  iD  iE  i~
  iF  i3  iG  iQ  iñ  iH  ió  iI  i‘	  iJ  iò  i"  ií  iK  iL  iM  i4  iN  iO  iô  i#  iP  iQ  iR  iS  iæ  iö  iT  iU  i5  iV  iW  i‘  iØ  i6  i7  iì  i4  i8  i"  i©  i9  iX  iY  iZ  i:  i[  i;  i$  iõ  iú  i€  i\  iê  i™  i]  i^  i<  i_  i∞  i5  i‹  iî  i`  ia  ib  ic  id  ie  iù  iø  if  i  ig  i›  i=  iû  i¿  ih  ië  iü  i’  ii  ij  i´  ik  il  im  iﬁ  i†  i>  in  i#  i6  io  ip  i?  iq  i°  ir  is  iT  it  iu  ií  i¢  iì  iv  i
  i£  i@  iA  i§  iw  i÷  iî  ix  i•  iy  iz  i{  iU  i|  i}  iB  iC  iD  i3	  iE  i~  iI
  i¶  i  iï  iÄ  iÅ  iß  iÇ  iÉ  i®  i©  iF  iÑ  iñ  i™  iÖ  iÜ  iá  i˚  ià  ió  iG  iâ  iH  iä  iã  iå  iç  i¡  ié  i´  iè  iê  ië  iò  i¸  ií  i¨  i¬  iô  iì  i˝  iî  i◊  iï  iï  iñ  iI  ió  iò  iô  iö  iõ  iú  iJ  iK  iù  i≠  iû  iü  i†  iﬂ  i°  i¢  iL  i£  i§  iM  i•  iÆ  i¶  i¨  i‹
  iÕ  iN  iÍ  iŒ  iß  i®  i˛  iØ  iT	  i©  i™  i´  i∞  i¨  iö  iO  i≠  iÆ  iØ  iP  i∞  i±  i≤  iÃ  i≥  iQ  i¥  iµ  i∂  i∑  i7  i∏  i8  i‡  i9  iπ  i∫  iª  iõ  iº  iΩ  i:  iæ  i√  iø  iƒ  iÿ  i¿  i¡  i±  i¬  iR  i≤  iÎ  i√  i;  i≥  iS  iñ  iˇ  iƒ  iT  i≈  i∆  i«  i»  iU  i≠  iV  i≈  iW  i¥  i…  i’	  iX  iú  iY  iS  i   iZ  i[  iù  i÷	  iµ  iÀ  iÃ  iò
  iû  iÕ  iŒ  iœ  iV  i\  iW  i–  iU	  iÆ  i·  i—  i"	  i“  i”  i‘  i’  iı  i÷  i]  i◊  iÿ  iŸ  i⁄  i^  i∂  i€  i‹  i±  i›  iˆ  iﬁ  i_  iﬂ  i‡  i·  i`  i$  ia  i‚  i∑  i„  ib  i]  i∏  i‰  ic  iÂ  id  iA  iÊ  ie  iÁ  iË  iÄ  i   if  iÈ  iÍ  i^  iπ  i<  i  iÎ  i∆  iÏ  i$  iÌ  iÓ  iÔ  i∫  i«  i^
  i_  ig  iª  i  i»  i  i%  iº  iΩ  iÒ  i=  iÚ  i>  iÛ  iÙ  i…  i%  i	  i?  iı  iˆ  iö  i‚  it  i˜  i¯  i˘  i@  iX  i`  i˙  iæ  iø  i¿  i˚  ih  i¸  i˝  iü  i˛  iˇ  i   i  i  i„  i  iY  i%  i¡  i  i&  iˇ	  iZ  i  i  iT  i  i  iØ  i	  ia  i¬  i
  i˜  i9  i  ió  ii  i√  iƒ  iR  i†  i‰  i  iÂ  i  i   iu  iÀ  i°  ij  ik  iÃ  i  il  i¯  i  i≈  i  i  i  i  i  im  iA  i  i:  i  i  i  i  iÕ  i  i∆  iB  i  in  i  i  iÕ  i[  i  i
  i  iÊ  i  i  i   i¢  i\  i!  io  i"  ip  i£  iŒ  i∞  iJ
  iq  i]  i«  i§  i#  i$  i%  i&  iC  i•  ir  i'  i(  i)  i*  is  it  i+  i,  i•  i¶  i-  i.  i/  i^  iu  i0  iá	  i1  iß  iò  iŸ  i2  iD  io	  iv  i3  i®  i4  iw  i_
  i5  i6  i¨
  i»  i&  i;  i7  i8  i©  i9  i…  ix  i:  i;  i™  i<  i_  i&  i`  i  i›
  iﬁ
  i'  i  i   i˘  i=  iÁ  iS  i>  i?  iU  iû	  iË  iÀ  iÈ  iy  iz  i'  i´  i
  i(  iÃ  iÍ  iœ  i¨  i@  iE  iﬂ
  iA  i`
  i™  iV  iÕ  i{  i´  iW  iX  iB  i(  i|  i}  iŒ  i~  i  i–  i'  iC  iD  iõ  iŒ  iE  iF  iÄ  iG  iH  iI  iJ  iÅ  iK  ib  iœ  iÇ  iL  ia  i–  i≠  iÆ  iF  iM  iÎ  iÉ  iØ  iN  iO  iÏ  iP  iÑ  iQ  iô  iÖ  i∞  iÌ  i  iœ  iR  iS  i≠
  i—  iT  i“  iU  i)  i—  iV  i  iÃ	  iW  iX  i±  i)  i≤  i8
  iY  iZ  i[  i\  i]  i^  i  iG  iÓ  iº
  i_  i`  i”  iÜ  ia  ib  ic  id  iá  i≤  ie  i‘  ib  iø  iÔ  i’  if  ig  ih  ii  ià  ij  ik  iâ  i≥  i“  il  im  in  i˙  iä  i÷  iY  io  ip  i  iq  iZ  ir  is  i◊  it  iu  iv  iw  ix  iy  iã  iz  iÿ  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iå  iÖ  iÜ  iá  iç  ià  i”  iâ  iŸ  iä  iã  iå  i  i‘  i¥  iµ  iÒ  iç  i<  ié  ié  iè  iê  iT  ië  i’  iH  ií  iì  iî  i∂  iï  iñ  ió  iè  iò  iô  iê  iö  iõ  i∑  iv  iú  iù  ië  iû  i⁄  iü  i∏  i†  i°  i¢  i€  i‹  iI  i£  i›  i±  i§  ií  i•  i¶  iß  i®  i÷  iﬁ  i©  i™  iì  i´  iπ  i¨  i≠  iÆ  i∫  iî  iØ  i∞  iï  i[  i±  iñ  i≤  iJ  i≥  i¥  iÆ
  iﬂ  i‡  i·  iµ  i∂  i∑  i∏  iπ  i≤  ió  i‚  i∫  iÚ  iª  i  iU  i
  ic  i–  i„  i≥  iº  i‰  iΩ  iö  i◊  iò  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≥  i⁄  i≈  iÛ  i∆  iô  i«  i»  i…  i   iÀ  iÂ  iK  iÃ  i€  iÕ  iö  iŒ  iœ  i–  i—  iÙ  i“  i”  ic  iÿ  i‘  i’  iÊ  i÷  iõ  iÁ  iú  i◊  iL  iÿ  iŸ  iù  iË  iª  iŸ  i⁄  id  i  i›  i€  i9
  i‹  iÈ  i  i›  iÍ  iV  iﬁ  iﬂ  iõ  iû  i‡  iÎ  i·  iº  i‚  i„  i‰  iÏ  iÏ  iÂ  iü  iÊ  iÁ  iË  iÌ  i†  i⁄  iÈ  iÍ  i°  i¥  iÓ  iÎ  iÏ  iÌ  i±  i¢  iÓ  iÔ  id  i  iÄ
  i  iÏ  iÕ	  iΩ  iÒ  i  i1  iÚ  iÅ
  i*  iÛ  iM  iı  ip  i£  i§  iú  iÙ  i•  iı  iˆ  i˜  i	  iˆ  i¯  iÔ  i˜  i¶  i€  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  iæ  i>	  i  iÒ  i˚  i	  i   i  iÚ  i
  iN  iÌ  iø  i  iß  iO  i*  i¿  iÛ  i(  i  iµ  i  i  i®  i©  i  i  i‹  i‡
  i  i	  i
  i  i+  i  i  i=  i™  i  i  iP  i¡  i¯  i  i  i  i´  i  i¨  i¬  i≠  iÆ  iØ  i  i  i  i∞  i±  iú  i  i‡  i  i≤  iù  iÙ  i:  i˘  i  iı  i  i≥  i;  i,  i  i√  i˙  i¥  i  i˚  i  iµ  i—  i›  iˆ  iƒ  i≈  i∆  i-  i  i˜  i  i∂  i  i   i∑  i∏  iﬁ  i!  i"  i#  iπ  i$  i%  i&  i'  i¯  i∫  i(  i)  i*  iª  i+  i«  ie  i,  i-  i.  i/  iQ  i0  i‹  iº  i¸  i1  i2  i3  i4  i5  i6  i7  iΩ  iæ  i8  i9  i:  i;  iR  ie  i<  i=  i>  i?  iK
  iø  i@  i¿  i˘  iA  iB  i 
  iC  iD  iE  iF  iS  iG  iH  iI  iJ  iK  i»  iW  iL  iM  iN  iO  iP  iT  iQ  i¡  i…  iR  iS  i¬  i   iT  i˝  iU  iV  i√  iU  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  i  ia  iÀ  iƒ  i˛  ib  i›  i≈  ic  id  iÃ  ie  if  i˙  ig  i  ih  ii  if  i?	  ij  i\  i∆  i«  iÕ  ik  il  iˇ  i»  i…  im  i.  i+  in  io  ip  iq  ir  is  it  i  i˚  iu  iv  if  i,  iﬂ  i   iw  ix  iÀ  iy  iz  i¸  iŒ  iÃ  iœ  i   i{  i|  iﬁ  i}  i~  iÕ  i˝  iÇ
  i  i“  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iV  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i    i   i   i   i   i   i   i   i   i	   i
   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i!   i"   i#   i$   i%   i&   i'   i(   i)   i*   i+   i,   i-   i.   i/   i0   i1   i2   i3   i4   i5   i6   i7   i8   i9   i:   i;   i<   i=   i>   i?   i@   iA   iB   iC   iD   iE   iF   iG   iH   iI   iJ   iK   iL   iM   iN   iO   (   t   JIS_TYPICAL_DISTRIBUTION_RATIOt   JIS_TABLE_SIZEt   JISCharToFreqOrder(    (    (    s3   /usr/lib/python2.7/dist-packages/chardet/jisfreq.pyt   <module>,   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
filename:/usr/lib/python2.7/dist-packages/chardet/euckrfreq.pyc
__doc__
Û
aÀTc        &"  @   s   d  Z  d Z d("Z d'"S()"  g      @i0	  i   iÇ   ix   it  i·  i∑  i∏  iH  ia  i‘   iπ  i√  iê  i+  i∫  iW   iu  iª  ih   i  i]  i≥  iº  iÛ  i≠  iÙ  i¸  iΩ  iæ  iø  i¿  iv  iw  i¡  i¬  i√  iç   im  iF  i!  ip  iƒ  i  iË  i   i≈  iı  i∆  i±  ix  i«  i/   ià  iˆ  i»  i…  i  i¯   i   iô  i9  i  i≠  iÀ  it   i€  i-  iy  i´  iK   i¥  ië   iÃ  iÕ  iŒ  iœ  i   iO  iõ  in  iƒ  i–  i—  i“  i∆  i  i0  iÅ   i”  i<   i4  i{   i§  i‘  i’  i÷  i◊  ii  iÿ  ir  iŸ  i⁄  i€  i‹  iç  i›  iﬁ  iﬂ  i‡  i·  i‚  iX  iX  i„  i‰  iÂ  iÊ  iY   ië  i¢  i&  iâ  iP  iÁ  iË  iÈ  i≤  iµ  i≈  iÍ  i^  iÎ  iÒ   iÏ  iÌ  iÓ  i˜  iÔ  i9  i  iÁ  iÒ  iÚ  iÛ  iÙ  iQ  iÔ  i"  i   it  i˛   iı  i±   iä  i  i]  i{  i7  iˆ  i   i˜  i{  i¯  i;  i˘  iu  iÚ  iz  i/  i˙  i|  iÀ   i∂  i˚  i∆  i7  i¸  iß  i.  i˝  i˛  i∑  i˛  i  iˇ  i   i∏  i  i  i  i  i  i{  i  i  i  i#  i|  i}  iÑ  i~  i®  it  i8  i  i_  i	  i
  i  i  i  i!  i  i  i  i_  i  iÖ  i   i⁄  i  i  i*  iÉ  iu  i  i`  i"  iÜ  i  i|  i  i  iÄ  iì  i  i  ia  i  i  i  i  i  i  i?  i  iR  i!  i   i/  i©  iπ  i!  i"  i=  iÅ  i˛  i#  i∫  i$  i%  i&  i'  i(  i)  i,  i“  i'  ib  i$  i*  iπ  i+  iÑ  i-  iÀ  i,  iÇ  i  iÉ  i  iá  i&  iU  iª  i–  i#  i  iÑ  i-  i.  i'   i  iÖ  if  i/  is  iù  i0  i≈  iï  i  i  i”  i   iˇ  i9  ie  i[   i1  ià  iÆ  i  iZ  iÜ  i•  i:  i…  iá  ià  i2  i3  i€  iG  i   iâ  i  iy   i4  i›  iì  iä  i5  i6  i7  i,  iw   i«  iº  is  i8  i¯  iœ   i9  i:  i  iΩ  i~  i;  i  i<  i;  i}  i=  i>  i?  io  i)  iÁ  iü  i@  ió  iA  iB  iº  i◊  i2  iY  iC  iD  ià  i<  iE  iF  iG  iH  iI  i%  iJ  iK  iL  iM  iN  iO  i  i`   i>  iP  iˆ  i=  iQ  iæ  iR  iã  iS  iT  i;  i—  iã  iå  iç  i  iU  ié  iV  iW  iX  i4  iY  i   i  iZ  i[  iø  i\  i]  i   i  i^  i˘  iè  i_  i"   iP  iî  iÉ  i`  i;  ié  i~  iH  ia  i    iv  i˙  iz   i?  i  iå  i™  ib  i˚  iö  i<  ic  id  id   ie  if  ic  i0   iâ  id  i  ig  iy  iÖ  i¸  ih  ii  is   i0  ij  i=  ik  i∂  il  iç  iﬁ  iê  i<  ib  ië  i≥  iU   i  iÚ  i  iä  iI  im  in  io  i  ip  iq  ir  is  it  iu  i   i√  iã  i‹  i6  iv  iw  ií  i*  i¿  i]   ix  iy  i˝  i¡  iz  iZ  i˜  i-   i:   iµ   ib  i  i{  i|  iÉ   i&  i'  iª  iË  i5  iì  iΩ  i  i>  i}  i~  iw  i  ig  iÄ  iØ  iÅ  i6  iÇ  i%  iÉ  iÑ  i(   iñ  iv   i¥  i   i´  iw  iÄ  i‚  iÆ   iÖ  iE   iä  iÿ  iî  ié  iÜ  i˛  i¬  iˇ  iÇ  if  iŸ   iV  iã  i7  iá  ià  iâ  iä  iB  iã  iN   iå  i[  iç  i'  ié  iè  iê  ië  i∂  iå  i–   iS  ií  iì  iî  iï  i√  ie  iñ  i  ix  iï  iñ  iƒ  ió  ió  iò  iô  iö  iõ  i   iñ   i˛  iò  iú  iù  iû  iü  i†  i°  i¢  iÛ  i?  i£  iô  i  i§  iq  i•  if  iæ  i(  i)  i≈  i¶  i~  iÈ  i\  i«  iÄ  iö  i›  iÏ  i)  i  iç  iß  i  iÍ  i  i∆  i®  i©  i™  i´  i$   i  i‰   iÒ  i˜   i∆  i¨  il  i¶  i≠  iÆ  i  i~   i–  iÍ  iC  ià   i†  i  i¨  i@  iõ  iŸ  iØ  i∞  i”  i2   iÜ  i„   iK  i  iz  iV  i  i»  i   ió   i†   iQ  ir  if  i  i  i  iÖ   iå   i   ih  i+  i3  i  i1  ié   i  i±  i≤  i≥  i   ig   i(  i∑  ió  i˙  iz  iﬁ  i¥  iµ  i∂  i∑  iÖ  i∏  iπ  i∫  iª  iº  iΩ  iÏ   iæ  iú  iø  i¿  iA  i¿   i<  ij  i  ié  iM  ig  i¡  i2  i«  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  iV  ih  i  iÍ  iJ  i   iÀ  i0  iﬂ   i  ib   i   iΩ   iä  i“  i  iÃ  iù  iÕ  i   iY  i˙   iß  i  iÍ   i   i‚   ia   i!  i*   iß   iŒ  i…   iœ  i–  iK  iD  i8  i  iR  i  iB  i∂   i@  i¥  iû  iü  i  iÙ  i—  i≥  iy  i“  i”  i‘  i’  i  iX  i:  iø  i÷  i#  i◊  iµ  i‚  ii  iÿ  iG   i†  iÈ  ik  i∞  iŸ  i=  i⁄  i€  iì   i‹  i!   i¥  i›  iﬁ  iJ   i‡   iﬂ  i=   iø   iñ  iè  i}  i‡  i  ij  i  iÜ  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iE  iÎ  iÏ  iÌ  iÓ  i≥   ij  iO  i4   i‘  iˆ   iÔ  i  iÒ  iÚ  iè  i…  iÛ  i	  iv  i]  iè  iC  iê  iÙ  iı  iˆ  i°  iê  i˜  io  i¯  i˘  i˝   ië  i
  i˙  i¢  ií   il  ic  iA  i±  i˚  i»  iœ  ií  iø  i∏  iµ  i  iT   iÑ  i‡  ik  iü   i‹   i∆   iß  i¸  iÙ  i3  i*  i£  iq   i…  i¬   i>  iÎ  i  i˝  i˛  iˇ  i   i+  i  i  i  i  i  i;   ië  ip   i  ix  i  i«  iê   i„  i  i  i  i©  iÛ  i	  i¿  i
  i  i¯  i  i  i   iÄ  i©   iı   il  i  i  iû  i§  i  i  i)   iÎ   i  iù   i¸   im  i8  ió  i  iD  i  i’  i  i  i  i  i  i•  i  i¶  i  i  i7   iL  iB   iß  i  iD  i  i   i  i¿  iı  it  i  i  i  i   i!  i  i"  i#  i$  i%  iR  i&  i'  i(  i)  i*  i∫   i+  i,  i¥   i,  i-  i.  im   iÀ  i
  i^  i/  ic  i®  iE  iﬂ  iì  iû  ia  im  i0  iE  i1  i2  i3  i  i©  i™  i4  iT  iî  iˆ  iÃ  i5  i´  i  iï  iÕ  i6  i7  i  in  i¨  iµ  io  i8  i9  iF  i≠  iÆ  iØ  i:  iG  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  i$  iF  iG  iŒ  iœ  i%  i∞  iï  ip  iH  iI  iJ  iK  iL  i–  iΩ  i  i‡  i±  iü  iÏ  iM  iN  iO  iP  iQ  iR  i   i°  iS  i/  iT  iÅ  iU  iÀ  i  i  iV  iñ  iI   iH  iÁ   i  i¬  i≤  i°  iW  i≥  iX  iò   iq  iY  iZ  i[  i\  iÌ  ir  i¥  is  i]  i^  i_  i`  i   iv  iL  ia  iö   i–  i.   iµ  ib  iF  i>  i—  i—  ij   ic  iZ   i¨  iŒ  iB  i6  ió  i`  id  ie  i  i“  i|   i  if  i∂  i˘  i5  ig  iÆ  ih  iâ  ii  iH   i≠   ij  iÃ  iü  ik  i∑  il  i”  i1  im  in  io  ip  iq  ir  iC  is  it  iu  iv  iw  iÎ  ix  iy  iz  i{  i∏  iù  i|  i}  i~  i  iÄ  iπ  iÅ  i   i  i  iÇ  iO  iŸ  iÉ  iç  iÑ  iÖ  iÜ  i  iá  ià  i∫  iâ  iä  iE  iã  iå  iq  iç  i  iI  i˜  i\  ié  i-  i®  iè  iS  i∫  iê  ië  i
   ií  ie  i®  iì  i”  il   i¡  iM  i   i¨   iQ   i  iP   i  i  i^  i  i  i-  iF  iò  iî  i¢  i  iï  iñ  iª  i⁄  i˙  ió  iò  iô  iö  iº  iõ  i·  iú  iù  i
  i.  i√  it  iû  iü  i†  iò  iJ  iÃ  i°  i¢  i£  iô  iΩ  iæ  ig  i§  i•  i¶  iß  i®  iø  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¿  i‘  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  i  iº  iΩ  i»   iæ  i›  iu  iø  i¿  i€  i9  i	  i¡  i¬  i√  i	  iÊ  i$  iƒ  i≈  i∆  i¡  i  i5   i%  iâ   ik  iL   iû   i«  i  i¬  i’  iå  i¯  i  i»  i»  iA  i∫  i˜  iˇ  iË  i≠  i’  iö  i√  i…  iR   i≤   iu  iõ  iÕ  i   i  iÀ  i)  iÃ  iÕ  i:  iŒ  iœ  i–  i   i¬  iŒ   i—  i"  i$  iv  i“  iˇ  i¢   ic   iZ  i§   iﬂ  i”  iƒ  i≈  i   i*  iW  i  iK  i‘  iL  i’  i+   i´   i  iã   i◊   i÷  i◊  iÕ  i  iÿ  i	  iB  iÿ   iŸ  i?  i⁄  iï   i€  i  i‹  i›  iæ  i÷  iá   iM  i[  i5  iﬁ  i‰  iﬂ  in  iè  iÓ   iÓ  i∆  i‡  iC   i·  i'  i‚  i„  iÕ  i‰  iﬁ  iÆ  iú  iÂ  i
  iÊ  iÁ  iË  i	  iÈ  i  iÍ  iÎ  iÏ  iÌ  iÓ  iF   iT  i/  iÔ  i  iÒ  iÚ  i   i8   i˝  iu   i∞  iÛ  iÙ  iK  i‘  i(  iM  iî   i  ii   iâ  iú  i◊  iÛ  iı  iª   iˆ  i  i«  i˜  iT  i¯  i?   i  iÊ   i˘  i˙  i  i˚  i  ie   i   i(  iÓ  i˚  i¸  i˝  iá  i˛  i%   i0  i   i   iˇ  iO   i£  i 	  i8  i	  i	  i	  i	  i	  i»  i   i  i	  i	  i	  i   i÷  i#   i   iÂ   i		  i∑  i“   iV   i
  i   i  iP  i  i    iM   iW  iƒ  i
	  i  i	  iı  i|  i	  i	  iS   i’  iô   i±  i  i…  i   iÀ  i	  i	  iÃ  iÃ  i	  i	  i	  i	  i	  i	  iÕ  i	  i	  iÄ   i9   iD   i  i  i”   i™   iÿ  i   i	  i3   i≥  iÊ  i	  i	  i	  i{  i	  i  i»  i	  i	  i	  i©  i 	  iŒ  iè   i˚  i  iØ  i!	  ik  iò  iœ  i   i–  iN  iÛ   iY  i—  i"	  i#	  i$	  i%	  i&	  i'	  i(	  i]  i)	  i*	  i+	  i,	  i-	  i.	  iã  i/	  i“  i”  i>   i  i¶   i·   i1	  iú  i£  iŸ  iä   i\  i†  i2	  iù  i3	  i‘  i’  i4	  i5	  i6	  iw  i7	  i∏  i8	  iÉ  i3  i  i™  i‹  i9	  i:	  iL  i   iﬁ   iú   i;	  iË   i<	  iÅ  i  iê  i  i÷  i◊  i  i†  i‡  iÿ  i=	  i˘  iJ  i>	  i?	  i@	  iŸ  iA	  iÚ   iB	  iC	  iD	  i⁄  iE	  i≈  i…  iF	  iG	  iH	  iI	  i‰  i÷  i€  i∞  i‹  iÔ  iJ	  iK	  i  i›  iL	  iM	  iN	  i  iI  iO	  iP	  iﬁ  iQ	  iR	  iS	  i§  iT	  iﬂ  iU	  iV	  iW	  iX	  i⁄  iY	  iZ	  i[	  i\	  i]	  i‚  i∂  i^	  i_	  i`	  ia	  i‡  i  ib	  ic	  id	  ie	  i  iÌ  if	  ig	  iU  iŒ  ix  i   ih	  iû  i·  ii	  ij	  iˇ   i  iﬂ  i4  i&  i÷   i‚  i„  i!  iù  iÔ   iº  iS  iy  i  i‰  iÂ  i"  i  iÊ  i#  ik	  iÁ  il	  im	  in	  i∞   iø  iÒ  ip  iQ  iô  i.  io	  iU  i•   iO  iË  ip	  iÈ  iq	  ir	  is	  ix  it	  iº  iu	  iv	  iw	  i  i   i$  ix	  iü  iy	  i„  i`  iz	  i{	  i|	  i}	  i›   i~	  i	  iÄ	  iÅ	  iÇ	  iÉ	  iÑ	  iÖ	  i√   iC  i÷  iº   iÅ  i◊  i%  iy  iÑ  i  io  iÜ	  iƒ  iá	  ià	  iâ	  iä	  iã	  iå	  ií  iç	  ié	  iè	  iê	  iì  iÈ  ië	  iÍ  i†  ií	  iì	  i  i@   i´  iÔ  iî	  iG  iï	  i„  iÂ  i  i2  i’   iÎ  iÏ  iö  iñ	  ió	  iò	  iô	  iN  iö	  i  i‰  i  i¡  i€  iõ	  iú	  iù	  iû	  iü	  ir   i†	  iÌ  iz  in  i£   iÏ  i¡  iP  i°	  i#  i¢	  i&  iQ  i£	  iÌ  im  i§	  ic  i∑  i‹  i•	  i'  i¶	  iw  iß	  i®	  i⁄   i(  il  i@  iÙ  iÓ  iÔ  i)  i  i*  i©	  i™	  i´	  i¨	  iÂ  i≠	  iÆ	  iØ	  i∞	  iô  i°  i±	  iî  iÒ  i≤	  i≥	  i¥	  iH  i¨  iµ	  i∂	  i  i∑	  i  i¢  i∏	  iπ	  i∫	  iÚ  iª	  iº	  ir  iΩ	  i  i£  iA   iæ	  i≤  iÕ   iœ  i§  iø	  i}   i,  iá  ií  i:  iª  i  ié  iõ   i  i  iI  i¿	  iN  i˘  i1  i¡	  iW  iÙ   i€   iï  i˙  i∏  iÜ  iÛ  i¬	  i+  i√	  iƒ	  i1   iÿ  ib  iÂ  i≈	  iq  i∆	  i,  i«	  i˚  iæ   ie  iı  iÎ  i_   i  id  i»	  i…	  i 	  iÀ	  iÃ	  iÕ	  iÜ   iÙ  i2  i¶  iı  iÇ  iŒ	  i°   iœ	  i–	  i—	  i“	  i  i”	  iˆ  i‘	  i’	  iõ  i-  i÷	  iÿ  i˜  i◊	  iÿ	  iŸ	  i⁄	  i€	  i‹	  iŸ  i›	  iﬁ	  iﬂ	  i‡	  i·	  i‚	  i¸  i„	  i›  i‰	  iÂ	  i   iÃ   i7  iÊ	  i  iÁ	  i  iË	  iÈ	  iÍ	  iÎ	  iÏ	  iÌ	  iÓ	  i«   i¿  i¯  i‘  iˆ  ië  i¯  iƒ   i,   iG  iﬁ  i  iÓ  iÔ	  i˝  i^  i	  iÒ	  i.  iÚ	  iÑ   ig  i•  iÛ	  i‹  iÙ	  iı	  iˆ	  i•  i˘  i˜	  i  iﬂ  i  i_  i°  i¯	  i˘	  i˙	  i¢  i∑   ih  ih  i  i{  i˚	  i|  i¸  iπ  i˘   i3  i¸	  i˝	  i˛	  i“  iÁ  iˇ	  i 
  i
  i\   i  i™  i§  i  i
  i
  i
  i
  i
  i
  i
  iπ   i	
  i

  i
  i
  i  i˙  ií  i
  ij  i
  ii  iö  i4  i  i
  i
  i
  i
  i
  i
  i˚  i˚   i
  i
  i
  i
  i¸  i6   id  iÌ   i/  i
  i
  i  iò  iá  io   i
  i˝  iR  i—  i   i   i	   i&   i
  ik   in   iz  i—   i   i·  iÚ  i
  i˛  i
  iØ  i    iX   iˇ  id  i  iS  iî  i}  i
  i}  i   i⁄  i~  iΩ  i‡  i  iŒ  i 
  i!
  iN  i"
  iæ  iπ  i∏   i·  i‚  i◊  i#
  iõ  i¡   is  i$
  i%
  i&
  if   iD  i  i1  i'
  i•  i  i(
  i@  i)
  i^   iØ   i≈   iñ  i*
  iÀ  i+
  i,
  i-
  i.
  i/
  iJ  i+  i0
  i1
  i2
  i¬  iT  iÖ  i3
  i4
  i5
  i6
  iÈ   i7
  iA  i.  i£  i∫  i„  i8
  i9
  i  i"  i:
  i;
  iÒ  i<
  i=
  i>
  i  i≤  i0  i?
  iª  i@
  i  iA
  iB
  i  iC
  iD
  iE
  iF
  iG
  iú  ià  i_  i[  iH
  iI
  i¶  i  i`  ia  iJ
  iÇ  i  iû  i¶  iK
  iL
  iM
  iN
  i®   iO
  iå  ii  i  i  i  iP
  iQ
  iR
  iS
  iT
  iU
  iV
  iW
  iX
  iY
  iZ
  i[
  i\
  i]
  i^
  i_
  i`
  ia
  ib
  ic
  id
  ie
  if
  ig
  ih
  ii
  ij
  ik
  il
  im
  in
  io
  ip
  iq
  ir
  is
  it
  iu
  iv
  iw
  ix
  iy
  iz
  i{
  i|
  i}
  i~
  i
  iÄ
  iÅ
  iÇ
  iÉ
  iÑ
  iÖ
  iÜ
  iá
  ià
  iâ
  iä
  iã
  i  ip  iå
  iç
  ié
  iè
  iê
  ië
  ií
  iì
  iî
  iï
  iñ
  ió
  iò
  iô
  iö
  iõ
  iú
  iù
  iû
  iü
  i†
  i°
  i¢
  i£
  i§
  i•
  i  i¶
  iß
  i®
  i©
  i™
  i´
  i¨
  i  i≠
  iÆ
  iØ
  i∞
  i±
  i≤
  i≥
  i¥
  iµ
  i∂
  i∑
  i∏
  iπ
  i∫
  iª
  iº
  iΩ
  iæ
  iø
  i¿
  i¡
  i¬
  i	  i√
  iƒ
  i≈
  i∆
  i«
  i»
  i…
  i 
  iÀ
  iÃ
  iÕ
  iŒ
  i
  iœ
  i  i–
  i—
  i“
  i”
  i‘
  i’
  i÷
  i◊
  iÿ
  iŸ
  i⁄
  i€
  i‹
  i›
  iﬁ
  iﬂ
  i‡
  i·
  i‚
  i  i„
  i‰
  iÂ
  iU  iÊ
  iÁ
  iË
  iÈ
  iÍ
  iÎ
  iÏ
  iÌ
  iÓ
  iÔ
  i
  iÒ
  iÚ
  iÛ
  iÙ
  iı
  iˆ
  i˜
  i¯
  i˘
  i˙
  i˚
  i¸
  i1  i˝
  i˛
  iˇ
  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i  i)  i*  i+  i,  i  i-  i.  i  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  iV  i2  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  i3  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  i‰  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i  i≈  i∆  i«  i»  i…  i  i   i4  iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  i  iÎ  iÏ  iÌ  i  i  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i  i	  i
  i  iÂ  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  iÄ  i%  i&  i'  i(  i)  i  i*  i+  i,  i-  iW  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  i5  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  i  iv  iw  i6  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  i  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i7  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i8  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  i9  iW  iX  iY  iZ  i[  i:  i\  i]  i^  i  i  i_  i`  ia  ib  ic  id  ie  if  ig  iÊ  ih  ii  ij  i;  ik  il  im  in  io  i  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  iÁ  i  iÄ  iÅ  iÇ  iÉ  i  iß  iÑ  i   i!  iÖ  iÜ  iá  i"  ià  iâ  iä  iã  iå  i#  iç  ié  iè  iê  ië  i$  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  i<  iü  i†  i°  i¢  i£  i§  i˝  i•  i¶  iß  i®  i©  i™  i%  i´  i=  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i>  i∏  iπ  i∫  iª  iº  i&  i?  iΩ  iæ  iø  i'  i¿  i(  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i)  i˝  i˛  i*  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i+  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i,  i.  i/  i-  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  i.  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  i®  iu  iv  iw  ix  iË  iy  iz  i{  i|  i/  iÈ  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  i0  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i@  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i1  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i2  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  iA  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  iB  i3  i‘  i’  i4  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iC  iﬂ  i‡  i·  i‚  i„  i5  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  i6  iÓ  iÔ  i7  iD  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i8  i˜  i¯  i9  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  iE  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i:  i  i  i  i  i  i  i  i  i  i  i  i;  i  i  i   i!  i<  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i=  i/  i0  i1  i2  i3  i4  i5  i6  i7  i>  i8  i9  i:  i?  i@  i;  iF  i<  iG  i=  i>  iH  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iÍ  iU  iV  iW  iX  iY  iZ  i[  i©  i\  iA  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  iB  ih  ii  ij  ik  il  iC  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  iD  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iI  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iJ  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  iK  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  iE  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  iF  i›  iﬁ  iﬂ  i‡  iG  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  i™  iÌ  iÓ  iH  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  iI  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  iÎ  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i´  i  i  i  iJ  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  iL  i*  i+  i,  i-  i.  i/  i0  iK  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  iL  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iM  iÑ  iM  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iN  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  i¨  iN  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  iO  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iP  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  iQ  i	  i
  i  i  i  iR  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iS  iA  iB  iC  iD  iE  iF  iG  iH  iI  iX  iJ  iK  iL  iM  iN  iT  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  iÏ  iÌ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  iO  ih  ii  ij  ik  il  im  in  io  ip  iq  iU  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  i  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iV  iß  i®  i©  iW  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  iP  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  iœ  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  iX  i‹  i›  iﬁ  iﬂ  i‡  iY  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iZ  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  i[  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i\  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  iQ  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  iR  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  i]  iK  iL  iM  iN  iO  i^  iP  iQ  iR  iS  iÅ  iT  iU  iV  iY  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  i≠  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  i_  iÄ  i`  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  ia  iâ  iä  iã  iå  iç  iÓ  ié  iè  iê  ië  ií  iS  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  ib  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  ic  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  id  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  ie  i«  i»  i…  if  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  ig  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i5  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  ih  i  i  ii  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  ij  i0  i1  i2  iT  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  ik  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  il  iu  iv  iw  ix  im  iy  iz  in  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  io  ié  ip  iè  iê  ië  ií  iì  iî  i6  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  iU  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  iq  i∞  i±  i≤  i≥  i¥  iµ  iV  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  ir  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  is  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  it  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iW  iˇ  i   i  i  i  i  i  i  i  i  i	  iu  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  iX  i  iv  i  iY  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  iZ  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iw  iO  iP  iQ  iR  ix  iS  iT  iU  iV  i[  iW  i\  iX  iY  iZ  i[  i]  i\  i]  i^  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iy  iÄ  iÅ  iÇ  iÉ  iz  iÔ  iÑ  iÖ  iÜ  iá  ià  i_  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i{  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  i|  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i`  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  iÆ  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i}  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i~  i%  i&  i'  i(  i  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  iÄ  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  iÇ  ig  ih  ii  ij  ik  il  im  iÅ  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  ia  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  iZ  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  ib  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  ic  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  id  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  ie  i   i  i  i  i  i  i  i  i  i  i  i  iÇ  i  i  i  i   i!  i"  i#  i$  iÉ  i%  iÑ  i&  i'  i(  i)  i*  i+  i,  i-  i.  iÉ  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iÖ  iC  iD  iE  iF  iG  iH  iI  iÜ  iJ  iK  iL  iM  iN  iá  iO  iP  iQ  iR  if  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  ià  i^  i_  iâ  iä  i`  ia  ib  ic  id  ie  if  ig  ih  iã  ii  ij  ik  il  im  in  io  ip  iå  iq  ir  is  it  iu  iv  iw  ig  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iç  iâ  iä  iã  iå  iç  ié  ié  iè  iê  iÊ  ië  ií  iì  iî  iï  iñ  ió  iò  iô  ih  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  iè  i©  i™  i´  i[  i\  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  iê  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  ië  iÈ  iÍ  iÎ  ií  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  iì  i¯  iî  i˘  i˙  i˚  i¸  iï  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  iñ  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  ió  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iò  iô  iA  iØ  iB  iC  iD  iE  iF  iG  iH  iI  iö  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  ii  i^  ij  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iÒ  iå  iç  iõ  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  iú  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iù  iÙ  iı  iˆ  i˜  i¯  iû  i˘  i˙  i˚  i¸  i˝  iü  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i†  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  i°  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  i¢  in  io  ip  iq  ir  is  it  iu  iv  iw  i∞  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  i£  iü  i†  i§  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  i•  iƒ  i≈  i∆  i«  i»  ik  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i¶  i  i  i  i  i  i  i  i  i  iß  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i®  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  iÚ  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  i©  i™  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  il  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  i´  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i¨  i  i	  i
  i  i  i  i  i  i  i  i  i±  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  im  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  in  i≠  iQ  iR  iS  iT  iU  iV  iÆ  iW  iX  iY  iZ  io  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  ip  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i≤  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iØ  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iq  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i∞  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  i±  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i≤  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  ir  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  i≥  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  i¥  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  is  i(  i)  i*  i+  i,  i-  iµ  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  i∂  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i    i   i   i   i   i   i   i   i   i	   i
   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i!   i"   i#   i$   i%   i&   i'   i(   i)   i*   i+   i,   i-   i.   i/   i0   i1   i2   i3   i4   i5   i6   i7   i8   i9   i:   i;   i<   i=   i>   i?   i@   iA   iB   iC   iD   iE   iF   iG   iH   iI   iJ   iK   iL   iM   iN   iO   iP   iQ   iR   iS   iT   iU   iV   iW   iX   iY   iZ   i[   i\   i]   i^   i_   i`   ia   ib   ic   id   ie   if   ig   ih   ii   ij   ik   il   im   in   io   ip   iq   ir   is   it   iu   iv   iw   ix   iy   iz   i{   i|   i}   i~   i   iÄ   iÅ   iÇ   iÉ   iÑ   iÖ   iÜ   iá   ià   iâ   iä   iã   iå   iç   ié   iè   iê   ië   ií   iì   iî   iï   iñ   ió   iò   iô   iö   iõ   iú   iù   iû   iü   i†   i°   i¢   i£   i§   i•   i¶   iß   i®   i©   i™   i´   i¨   i≠   iÆ   iØ   i∞   i±   i≤   i≥   i¥   iµ   i∂   i∑   i∏   iπ   i∫   iª   iº   iΩ   iæ   iø   i¿   i¡   i¬   i√   iƒ   i≈   i∆   i«   i»   i…   i    iÀ   iÃ   iÕ   iŒ   iœ   i–   i—   i“   i”   i‘   i’   i÷   i◊   iÿ   iŸ   i⁄   i€   i‹   i›   iﬁ   iﬂ   i‡   i·   i‚   i„   i‰   iÂ   iÊ   iÁ   iË   iÈ   iÍ   iÎ   iÏ   iÌ   iÓ   iÔ   i   iÒ   iÚ   iÛ   iÙ   iı   iˆ   i˜   i¯   i˘   i˙   i˚   i¸   i˝   i˛   iˇ   i !  i!  i!  i!  i!  i!  i!  i!  i!  i	!  i
!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i !  i!!  i"!  i#!  i$!  i%!  i&!  i'!  i(!  i)!  i*!  i+!  i,!  i-!  i.!  i/!  i0!  i1!  i2!  i3!  i4!  i5!  i6!  i7!  i8!  i9!  i:!  i;!  i<!  i=!  i>!  i?!  i@!  iA!  iB!  iC!  iD!  iE!  iF!  iG!  iH!  iI!  iJ!  iK!  iL!  iM!  iN!  iO!  iP!  iQ!  iR!  iS!  iT!  iU!  iV!  iW!  iX!  iY!  iZ!  i[!  i\!  i]!  i^!  i_!  i`!  ia!  ib!  ic!  id!  ie!  if!  ig!  ih!  ii!  ij!  ik!  il!  im!  in!  io!  ip!  iq!  ir!  is!  it!  iu!  iv!  iw!  ix!  iy!  iz!  i{!  i|!  i}!  i~!  i!  iÄ!  iÅ!  iÇ!  iÉ!  iÑ!  iÖ!  iÜ!  iá!  ià!  iâ!  iä!  iã!  iå!  iç!  ié!  iè!  iê!  ië!  ií!  iì!  iî!  iï!  iñ!  ió!  iò!  iô!  iö!  iõ!  iú!  iù!  iû!  iü!  i†!  i°!  i¢!  i£!  i§!  i•!  i¶!  iß!  i®!  i©!  i™!  i´!  i¨!  i≠!  iÆ!  iØ!  i∞!  i±!  i≤!  i≥!  i¥!  iµ!  i∂!  i∑!  i∏!  iπ!  i∫!  iª!  iº!  iΩ!  iæ!  iø!  i¿!  i¡!  i¬!  i√!  iƒ!  i≈!  i∆!  i«!  i»!  i…!  i !  iÀ!  iÃ!  iÕ!  iŒ!  iœ!  i–!  i—!  i“!  i”!  i‘!  i’!  i÷!  i◊!  iÿ!  iŸ!  i⁄!  i€!  i‹!  i›!  iﬁ!  iﬂ!  i‡!  i·!  i‚!  i„!  i‰!  iÂ!  iÊ!  iÁ!  iË!  iÈ!  iÍ!  iÎ!  iÏ!  iÌ!  iÓ!  iÔ!  i!  iÒ!  iÚ!  iÛ!  iÙ!  iı!  iˆ!  i˜!  i¯!  i˘!  i˙!  i˚!  i¸!  i˝!  i˛!  iˇ!  i "  i"  i"  i"  i"  i"  i"  i"  i"  i	"  i
"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i "  i!"  i""  i#"  i$"  i%"  N(&"  i   iÇ   ix   it  i·  i∑  i∏  iH  ia  i‘   iπ  i√  iê  i+  i∫  iW   iu  iª  ih   i  i]  i≥  iº  iÛ  i≠  iÙ  i¸  iΩ  iæ  iø  i¿  iv  iw  i¡  i¬  i√  iç   im  iF  i!  ip  iƒ  i  iË  i   i≈  iı  i∆  i±  ix  i«  i/   ià  iˆ  i»  i…  i  i¯   i   iô  i9  i  i≠  iÀ  it   i€  i-  iy  i´  iK   i¥  ië   iÃ  iÕ  iŒ  iœ  i   iO  iõ  in  iƒ  i–  i—  i“  i∆  i  i0  iÅ   i”  i<   i4  i{   i§  i‘  i’  i÷  i◊  ii  iÿ  ir  iŸ  i⁄  i€  i‹  iç  i›  iﬁ  iﬂ  i‡  i·  i‚  iX  iX  i„  i‰  iÂ  iÊ  iY   ië  i¢  i&  iâ  iP  iÁ  iË  iÈ  i≤  iµ  i≈  iÍ  i^  iÎ  iÒ   iÏ  iÌ  iÓ  i˜  iÔ  i9  i  iÁ  iÒ  iÚ  iÛ  iÙ  iQ  iÔ  i"  i   it  i˛   iı  i±   iä  i  i]  i{  i7  iˆ  i   i˜  i{  i¯  i;  i˘  iu  iÚ  iz  i/  i˙  i|  iÀ   i∂  i˚  i∆  i7  i¸  iß  i.  i˝  i˛  i∑  i˛  i  iˇ  i   i∏  i  i  i  i  i  i{  i  i  i  i#  i|  i}  iÑ  i~  i®  it  i8  i  i_  i	  i
  i  i  i  i!  i  i  i  i_  i  iÖ  i   i⁄  i  i  i*  iÉ  iu  i  i`  i"  iÜ  i  i|  i  i  iÄ  iì  i  i  ia  i  i  i  i  i  i  i?  i  iR  i!  i   i/  i©  iπ  i!  i"  i=  iÅ  i˛  i#  i∫  i$  i%  i&  i'  i(  i)  i,  i“  i'  ib  i$  i*  iπ  i+  iÑ  i-  iÀ  i,  iÇ  i  iÉ  i  iá  i&  iU  iª  i–  i#  i  iÑ  i-  i.  i'   i  iÖ  if  i/  is  iù  i0  i≈  iï  i  i  i”  i   iˇ  i9  ie  i[   i1  ià  iÆ  i  iZ  iÜ  i•  i:  i…  iá  ià  i2  i3  i€  iG  i   iâ  i  iy   i4  i›  iì  iä  i5  i6  i7  i,  iw   i«  iº  is  i8  i¯  iœ   i9  i:  i  iΩ  i~  i;  i  i<  i;  i}  i=  i>  i?  io  i)  iÁ  iü  i@  ió  iA  iB  iº  i◊  i2  iY  iC  iD  ià  i<  iE  iF  iG  iH  iI  i%  iJ  iK  iL  iM  iN  iO  i  i`   i>  iP  iˆ  i=  iQ  iæ  iR  iã  iS  iT  i;  i—  iã  iå  iç  i  iU  ié  iV  iW  iX  i4  iY  i   i  iZ  i[  iø  i\  i]  i   i  i^  i˘  iè  i_  i"   iP  iî  iÉ  i`  i;  ié  i~  iH  ia  i    iv  i˙  iz   i?  i  iå  i™  ib  i˚  iö  i<  ic  id  id   ie  if  ic  i0   iâ  id  i  ig  iy  iÖ  i¸  ih  ii  is   i0  ij  i=  ik  i∂  il  iç  iﬁ  iê  i<  ib  ië  i≥  iU   i  iÚ  i  iä  iI  im  in  io  i  ip  iq  ir  is  it  iu  i   i√  iã  i‹  i6  iv  iw  ií  i*  i¿  i]   ix  iy  i˝  i¡  iz  iZ  i˜  i-   i:   iµ   ib  i  i{  i|  iÉ   i&  i'  iª  iË  i5  iì  iΩ  i  i>  i}  i~  iw  i  ig  iÄ  iØ  iÅ  i6  iÇ  i%  iÉ  iÑ  i(   iñ  iv   i¥  i   i´  iw  iÄ  i‚  iÆ   iÖ  iE   iä  iÿ  iî  ié  iÜ  i˛  i¬  iˇ  iÇ  if  iŸ   iV  iã  i7  iá  ià  iâ  iä  iB  iã  iN   iå  i[  iç  i'  ié  iè  iê  ië  i∂  iå  i–   iS  ií  iì  iî  iï  i√  ie  iñ  i  ix  iï  iñ  iƒ  ió  ió  iò  iô  iö  iõ  i   iñ   i˛  iò  iú  iù  iû  iü  i†  i°  i¢  iÛ  i?  i£  iô  i  i§  iq  i•  if  iæ  i(  i)  i≈  i¶  i~  iÈ  i\  i«  iÄ  iö  i›  iÏ  i)  i  iç  iß  i  iÍ  i  i∆  i®  i©  i™  i´  i$   i  i‰   iÒ  i˜   i∆  i¨  il  i¶  i≠  iÆ  i  i~   i–  iÍ  iC  ià   i†  i  i¨  i@  iõ  iŸ  iØ  i∞  i”  i2   iÜ  i„   iK  i  iz  iV  i  i»  i   ió   i†   iQ  ir  if  i  i  i  iÖ   iå   i   ih  i+  i3  i  i1  ié   i  i±  i≤  i≥  i   ig   i(  i∑  ió  i˙  iz  iﬁ  i¥  iµ  i∂  i∑  iÖ  i∏  iπ  i∫  iª  iº  iΩ  iÏ   iæ  iú  iø  i¿  iA  i¿   i<  ij  i  ié  iM  ig  i¡  i2  i«  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  iV  ih  i  iÍ  iJ  i   iÀ  i0  iﬂ   i  ib   i   iΩ   iä  i“  i  iÃ  iù  iÕ  i   iY  i˙   iß  i  iÍ   i   i‚   ia   i!  i*   iß   iŒ  i…   iœ  i–  iK  iD  i8  i  iR  i  iB  i∂   i@  i¥  iû  iü  i  iÙ  i—  i≥  iy  i“  i”  i‘  i’  i  iX  i:  iø  i÷  i#  i◊  iµ  i‚  ii  iÿ  iG   i†  iÈ  ik  i∞  iŸ  i=  i⁄  i€  iì   i‹  i!   i¥  i›  iﬁ  iJ   i‡   iﬂ  i=   iø   iñ  iè  i}  i‡  i  ij  i  iÜ  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iE  iÎ  iÏ  iÌ  iÓ  i≥   ij  iO  i4   i‘  iˆ   iÔ  i  iÒ  iÚ  iè  i…  iÛ  i	  iv  i]  iè  iC  iê  iÙ  iı  iˆ  i°  iê  i˜  io  i¯  i˘  i˝   ië  i
  i˙  i¢  ií   il  ic  iA  i±  i˚  i»  iœ  ií  iø  i∏  iµ  i  iT   iÑ  i‡  ik  iü   i‹   i∆   iß  i¸  iÙ  i3  i*  i£  iq   i…  i¬   i>  iÎ  i  i˝  i˛  iˇ  i   i+  i  i  i  i  i  i;   ië  ip   i  ix  i  i«  iê   i„  i  i  i  i©  iÛ  i	  i¿  i
  i  i¯  i  i  i   iÄ  i©   iı   il  i  i  iû  i§  i  i  i)   iÎ   i  iù   i¸   im  i8  ió  i  iD  i  i’  i  i  i  i  i  i•  i  i¶  i  i  i7   iL  iB   iß  i  iD  i  i   i  i¿  iı  it  i  i  i  i   i!  i  i"  i#  i$  i%  iR  i&  i'  i(  i)  i*  i∫   i+  i,  i¥   i,  i-  i.  im   iÀ  i
  i^  i/  ic  i®  iE  iﬂ  iì  iû  ia  im  i0  iE  i1  i2  i3  i  i©  i™  i4  iT  iî  iˆ  iÃ  i5  i´  i  iï  iÕ  i6  i7  i  in  i¨  iµ  io  i8  i9  iF  i≠  iÆ  iØ  i:  iG  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  i$  iF  iG  iŒ  iœ  i%  i∞  iï  ip  iH  iI  iJ  iK  iL  i–  iΩ  i  i‡  i±  iü  iÏ  iM  iN  iO  iP  iQ  iR  i   i°  iS  i/  iT  iÅ  iU  iÀ  i  i  iV  iñ  iI   iH  iÁ   i  i¬  i≤  i°  iW  i≥  iX  iò   iq  iY  iZ  i[  i\  iÌ  ir  i¥  is  i]  i^  i_  i`  i   iv  iL  ia  iö   i–  i.   iµ  ib  iF  i>  i—  i—  ij   ic  iZ   i¨  iŒ  iB  i6  ió  i`  id  ie  i  i“  i|   i  if  i∂  i˘  i5  ig  iÆ  ih  iâ  ii  iH   i≠   ij  iÃ  iü  ik  i∑  il  i”  i1  im  in  io  ip  iq  ir  iC  is  it  iu  iv  iw  iÎ  ix  iy  iz  i{  i∏  iù  i|  i}  i~  i  iÄ  iπ  iÅ  i   i  i  iÇ  iO  iŸ  iÉ  iç  iÑ  iÖ  iÜ  i  iá  ià  i∫  iâ  iä  iE  iã  iå  iq  iç  i  iI  i˜  i\  ié  i-  i®  iè  iS  i∫  iê  ië  i
   ií  ie  i®  iì  i”  il   i¡  iM  i   i¨   iQ   i  iP   i  i  i^  i  i  i-  iF  iò  iî  i¢  i  iï  iñ  iª  i⁄  i˙  ió  iò  iô  iö  iº  iõ  i·  iú  iù  i
  i.  i√  it  iû  iü  i†  iò  iJ  iÃ  i°  i¢  i£  iô  iΩ  iæ  ig  i§  i•  i¶  iß  i®  iø  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¿  i‘  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  i  iº  iΩ  i»   iæ  i›  iu  iø  i¿  i€  i9  i	  i¡  i¬  i√  i	  iÊ  i$  iƒ  i≈  i∆  i¡  i  i5   i%  iâ   ik  iL   iû   i«  i  i¬  i’  iå  i¯  i  i»  i»  iA  i∫  i˜  iˇ  iË  i≠  i’  iö  i√  i…  iR   i≤   iu  iõ  iÕ  i   i  iÀ  i)  iÃ  iÕ  i:  iŒ  iœ  i–  i   i¬  iŒ   i—  i"  i$  iv  i“  iˇ  i¢   ic   iZ  i§   iﬂ  i”  iƒ  i≈  i   i*  iW  i  iK  i‘  iL  i’  i+   i´   i  iã   i◊   i÷  i◊  iÕ  i  iÿ  i	  iB  iÿ   iŸ  i?  i⁄  iï   i€  i  i‹  i›  iæ  i÷  iá   iM  i[  i5  iﬁ  i‰  iﬂ  in  iè  iÓ   iÓ  i∆  i‡  iC   i·  i'  i‚  i„  iÕ  i‰  iﬁ  iÆ  iú  iÂ  i
  iÊ  iÁ  iË  i	  iÈ  i  iÍ  iÎ  iÏ  iÌ  iÓ  iF   iT  i/  iÔ  i  iÒ  iÚ  i   i8   i˝  iu   i∞  iÛ  iÙ  iK  i‘  i(  iM  iî   i  ii   iâ  iú  i◊  iÛ  iı  iª   iˆ  i  i«  i˜  iT  i¯  i?   i  iÊ   i˘  i˙  i  i˚  i  ie   i   i(  iÓ  i˚  i¸  i˝  iá  i˛  i%   i0  i   i   iˇ  iO   i£  i 	  i8  i	  i	  i	  i	  i	  i»  i   i  i	  i	  i	  i   i÷  i#   i   iÂ   i		  i∑  i“   iV   i
  i   i  iP  i  i    iM   iW  iƒ  i
	  i  i	  iı  i|  i	  i	  iS   i’  iô   i±  i  i…  i   iÀ  i	  i	  iÃ  iÃ  i	  i	  i	  i	  i	  i	  iÕ  i	  i	  iÄ   i9   iD   i  i  i”   i™   iÿ  i   i	  i3   i≥  iÊ  i	  i	  i	  i{  i	  i  i»  i	  i	  i	  i©  i 	  iŒ  iè   i˚  i  iØ  i!	  ik  iò  iœ  i   i–  iN  iÛ   iY  i—  i"	  i#	  i$	  i%	  i&	  i'	  i(	  i]  i)	  i*	  i+	  i,	  i-	  i.	  iã  i/	  i“  i”  i>   i  i¶   i·   i0	  i1	  iú  i£  iŸ  iä   i\  i†  i2	  iù  i3	  i‘  i’  i4	  i5	  i6	  iw  i7	  i∏  i8	  iÉ  i3  i  i™  i‹  i9	  i:	  iL  i   iﬁ   iú   i;	  iË   i<	  iÅ  i  iê  i  i÷  i◊  i  i†  i‡  iÿ  i=	  i˘  iJ  i>	  i?	  i@	  iŸ  iA	  iÚ   iB	  iC	  iD	  i⁄  iE	  i≈  i…  iF	  iG	  iH	  iI	  i‰  i÷  i€  i∞  i‹  iÔ  iJ	  iK	  i  i›  iL	  iM	  iN	  i  iI  iO	  iP	  iﬁ  iQ	  iR	  iS	  i§  iT	  iﬂ  iU	  iV	  iW	  iX	  i⁄  iY	  iZ	  i[	  i\	  i]	  i‚  i∂  i^	  i_	  i`	  ia	  i‡  i  ib	  ic	  id	  ie	  i  iÌ  if	  ig	  iU  iŒ  ix  i   ih	  iû  i·  ii	  ij	  iˇ   i  iﬂ  i4  i&  i÷   i‚  i„  i!  iù  iÔ   iº  iS  iy  i  i‰  iÂ  i"  i  iÊ  i#  ik	  iÁ  il	  im	  in	  i∞   iø  iÒ  ip  iQ  iô  i.  io	  iU  i•   iO  iË  ip	  iÈ  iq	  ir	  is	  ix  it	  iº  iu	  iv	  iw	  i  i   i$  ix	  iü  iy	  i„  i`  iz	  i{	  i|	  i}	  i›   i~	  i	  iÄ	  iÅ	  iÇ	  iÉ	  iÑ	  iÖ	  i√   iC  i÷  iº   iÅ  i◊  i%  iy  iÑ  i  io  iÜ	  iƒ  iá	  ià	  iâ	  iä	  iã	  iå	  ií  iç	  ié	  iè	  iê	  iì  iÈ  ië	  iÍ  i†  ií	  iì	  i  i@   i´  iÔ  iî	  iG  iï	  i„  iÂ  i  i2  i’   iÎ  iÏ  iö  iñ	  ió	  iò	  iô	  iN  iö	  i  i‰  i  i¡  i€  iõ	  iú	  iù	  iû	  iü	  ir   i†	  iÌ  iz  in  i£   iÏ  i¡  iP  i°	  i#  i¢	  i&  iQ  i£	  iÌ  im  i§	  ic  i∑  i‹  i•	  i'  i¶	  iw  iß	  i®	  i⁄   i(  il  i@  iÙ  iÓ  iÔ  i)  i  i*  i©	  i™	  i´	  i¨	  iÂ  i≠	  iÆ	  iØ	  i∞	  iô  i°  i±	  iî  iÒ  i≤	  i≥	  i¥	  iH  i¨  iµ	  i∂	  i  i∑	  i  i¢  i∏	  iπ	  i∫	  iÚ  iª	  iº	  ir  iΩ	  i  i£  iA   iæ	  i≤  iÕ   iœ  i§  iø	  i}   i,  iá  ií  i:  iª  i  ié  iõ   i  i  iI  i¿	  iN  i˘  i1  i¡	  iW  iÙ   i€   iï  i˙  i∏  iÜ  iÛ  i¬	  i+  i√	  iƒ	  i1   iÿ  ib  iÂ  i≈	  iq  i∆	  i,  i«	  i˚  iæ   ie  iı  iÎ  i_   i  id  i»	  i…	  i 	  iÀ	  iÃ	  iÕ	  iÜ   iÙ  i2  i¶  iı  iÇ  iŒ	  i°   iœ	  i–	  i—	  i“	  i  i”	  iˆ  i‘	  i’	  iõ  i-  i÷	  iÿ  i˜  i◊	  iÿ	  iŸ	  i⁄	  i€	  i‹	  iŸ  i›	  iﬁ	  iﬂ	  i‡	  i·	  i‚	  i¸  i„	  i›  i‰	  iÂ	  i   iÃ   i7  iÊ	  i  iÁ	  i  iË	  iÈ	  iÍ	  iÎ	  iÏ	  iÌ	  iÓ	  i«   i¿  i¯  i‘  iˆ  ië  i¯  iƒ   i,   iG  iﬁ  i  iÓ  iÔ	  i˝  i^  i	  iÒ	  i.  iÚ	  iÑ   ig  i•  iÛ	  i‹  iÙ	  iı	  iˆ	  i•  i˘  i˜	  i  iﬂ  i  i_  i°  i¯	  i˘	  i˙	  i¢  i∑   ih  ih  i  i{  i˚	  i|  i¸  iπ  i˘   i3  i¸	  i˝	  i˛	  i“  iÁ  iˇ	  i 
  i
  i\   i  i™  i§  i  i
  i
  i
  i
  i
  i
  i
  iπ   i	
  i

  i
  i
  i  i˙  ií  i
  ij  i
  ii  iö  i4  i  i
  i
  i
  i
  i
  i
  i˚  i˚   i
  i
  i
  i
  i¸  i6   id  iÌ   i/  i
  i
  i  iò  iá  io   i
  i˝  iR  i—  i   i   i	   i&   i
  ik   in   iz  i—   i   i·  iÚ  i
  i˛  i
  iØ  i    iX   iˇ  id  i  iS  iî  i}  i
  i}  i   i⁄  i~  iΩ  i‡  i  iŒ  i 
  i!
  iN  i"
  iæ  iπ  i∏   i·  i‚  i◊  i#
  iõ  i¡   is  i$
  i%
  i&
  if   iD  i  i1  i'
  i•  i  i(
  i@  i)
  i^   iØ   i≈   iñ  i*
  iÀ  i+
  i,
  i-
  i.
  i/
  iJ  i+  i0
  i1
  i2
  i¬  iT  iÖ  i3
  i4
  i5
  i6
  iÈ   i7
  iA  i.  i£  i∫  i„  i8
  i9
  i  i"  i:
  i;
  iÒ  i<
  i=
  i>
  i  i≤  i0  i?
  iª  i@
  i  iA
  iB
  i  iC
  iD
  iE
  iF
  iG
  iú  ià  i_  i[  iH
  iI
  i¶  i  i`  ia  iJ
  iÇ  i  iû  i¶  iK
  iL
  iM
  iN
  i®   iO
  iå  ii  i  i  i  iP
  iQ
  iR
  iS
  iT
  iU
  iV
  iW
  iX
  iY
  iZ
  i[
  i\
  i]
  i^
  i_
  i`
  ia
  ib
  ic
  id
  ie
  if
  ig
  ih
  ii
  ij
  ik
  il
  im
  in
  io
  ip
  iq
  ir
  is
  it
  iu
  iv
  iw
  ix
  iy
  iz
  i{
  i|
  i}
  i~
  i
  iÄ
  iÅ
  iÇ
  iÉ
  iÑ
  iÖ
  iÜ
  iá
  ià
  iâ
  iä
  iã
  i  ip  iå
  iç
  ié
  iè
  iê
  ië
  ií
  iì
  iî
  iï
  iñ
  ió
  iò
  iô
  iö
  iõ
  iú
  iù
  iû
  iü
  i†
  i°
  i¢
  i£
  i§
  i•
  i  i¶
  iß
  i®
  i©
  i™
  i´
  i¨
  i  i≠
  iÆ
  iØ
  i∞
  i±
  i≤
  i≥
  i¥
  iµ
  i∂
  i∑
  i∏
  iπ
  i∫
  iª
  iº
  iΩ
  iæ
  iø
  i¿
  i¡
  i¬
  i	  i√
  iƒ
  i≈
  i∆
  i«
  i»
  i…
  i 
  iÀ
  iÃ
  iÕ
  iŒ
  i
  iœ
  i  i–
  i—
  i“
  i”
  i‘
  i’
  i÷
  i◊
  iÿ
  iŸ
  i⁄
  i€
  i‹
  i›
  iﬁ
  iﬂ
  i‡
  i·
  i‚
  i  i„
  i‰
  iÂ
  iU  iÊ
  iÁ
  iË
  iÈ
  iÍ
  iÎ
  iÏ
  iÌ
  iÓ
  iÔ
  i
  iÒ
  iÚ
  iÛ
  iÙ
  iı
  iˆ
  i˜
  i¯
  i˘
  i˙
  i˚
  i¸
  i1  i˝
  i˛
  iˇ
  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i  i)  i*  i+  i,  i  i-  i.  i  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  iV  i2  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  i3  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  i‰  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i  i≈  i∆  i«  i»  i…  i  i   i4  iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  i  iÎ  iÏ  iÌ  i  i  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i  i	  i
  i  iÂ  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  iÄ  i%  i&  i'  i(  i)  i  i*  i+  i,  i-  iW  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  i5  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  i  iv  iw  i6  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  i  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i7  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i8  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  i9  iW  iX  iY  iZ  i[  i:  i\  i]  i^  i  i  i_  i`  ia  ib  ic  id  ie  if  ig  iÊ  ih  ii  ij  i;  ik  il  im  in  io  i  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  iÁ  i  iÄ  iÅ  iÇ  iÉ  i  iß  iÑ  i   i!  iÖ  iÜ  iá  i"  ià  iâ  iä  iã  iå  i#  iç  ié  iè  iê  ië  i$  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  i<  iü  i†  i°  i¢  i£  i§  i˝  i•  i¶  iß  i®  i©  i™  i%  i´  i=  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i>  i∏  iπ  i∫  iª  iº  i&  i?  iΩ  iæ  iø  i'  i¿  i(  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i)  i˝  i˛  i*  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i+  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i,  i.  i/  i-  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  i.  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  i®  iu  iv  iw  ix  iË  iy  iz  i{  i|  i/  iÈ  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  i0  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i@  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i1  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i2  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  iA  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  iB  i3  i‘  i’  i4  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iC  iﬂ  i‡  i·  i‚  i„  i5  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  i6  iÓ  iÔ  i7  iD  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i8  i˜  i¯  i9  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  iE  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i:  i  i  i  i  i  i  i  i  i  i  i  i;  i  i  i   i!  i<  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i=  i/  i0  i1  i2  i3  i4  i5  i6  i7  i>  i8  i9  i:  i?  i@  i;  iF  i<  iG  i=  i>  iH  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iÍ  iU  iV  iW  iX  iY  iZ  i[  i©  i\  iA  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  iB  ih  ii  ij  ik  il  iC  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  iD  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iI  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iJ  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  iK  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  iE  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  iF  i›  iﬁ  iﬂ  i‡  iG  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  i™  iÌ  iÓ  iH  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  iI  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  iÎ  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i´  i  i  i  iJ  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  iL  i*  i+  i,  i-  i.  i/  i0  iK  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  iL  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iM  iÑ  iM  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iN  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  i¨  iN  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  iO  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iP  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  iQ  i	  i
  i  i  i  iR  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iS  iA  iB  iC  iD  iE  iF  iG  iH  iI  iX  iJ  iK  iL  iM  iN  iT  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  iÏ  iÌ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  iO  ih  ii  ij  ik  il  im  in  io  ip  iq  iU  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  i  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iV  iß  i®  i©  iW  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  iP  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  iœ  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  iX  i‹  i›  iﬁ  iﬂ  i‡  iY  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iZ  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  i[  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i\  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  iQ  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  iR  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  i]  iK  iL  iM  iN  iO  i^  iP  iQ  iR  iS  iÅ  iT  iU  iV  iY  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  i≠  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  i_  iÄ  i`  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  ia  iâ  iä  iã  iå  iç  iÓ  ié  iè  iê  ië  ií  iS  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  ib  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  ic  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  id  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  ie  i«  i»  i…  if  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  ig  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i5  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  ih  i  i  ii  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  ij  i0  i1  i2  iT  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  ik  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  il  iu  iv  iw  ix  im  iy  iz  in  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  io  ié  ip  iè  iê  ië  ií  iì  iî  i6  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  iU  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  iq  i∞  i±  i≤  i≥  i¥  iµ  iV  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  ir  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  is  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  it  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iW  iˇ  i   i  i  i  i  i  i  i  i  i	  iu  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  iX  i  iv  i  iY  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  iZ  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iw  iO  iP  iQ  iR  ix  iS  iT  iU  iV  i[  iW  i\  iX  iY  iZ  i[  i]  i\  i]  i^  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iy  iÄ  iÅ  iÇ  iÉ  iz  iÔ  iÑ  iÖ  iÜ  iá  ià  i_  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i{  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  i|  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i`  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  iÆ  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i}  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i~  i%  i&  i'  i(  i  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  iÄ  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  iÇ  ig  ih  ii  ij  ik  il  im  iÅ  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  ia  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  iZ  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  ib  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  ic  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  id  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  ie  i   i  i  i  i  i  i  i  i  i  i  i  iÇ  i  i  i  i   i!  i"  i#  i$  iÉ  i%  iÑ  i&  i'  i(  i)  i*  i+  i,  i-  i.  iÉ  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iÖ  iC  iD  iE  iF  iG  iH  iI  iÜ  iJ  iK  iL  iM  iN  iá  iO  iP  iQ  iR  if  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  ià  i^  i_  iâ  iä  i`  ia  ib  ic  id  ie  if  ig  ih  iã  ii  ij  ik  il  im  in  io  ip  iå  iq  ir  is  it  iu  iv  iw  ig  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iç  iâ  iä  iã  iå  iç  ié  ié  iè  iê  iÊ  ië  ií  iì  iî  iï  iñ  ió  iò  iô  ih  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  iè  i©  i™  i´  i[  i\  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  iê  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  ië  iÈ  iÍ  iÎ  ií  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  iì  i¯  iî  i˘  i˙  i˚  i¸  iï  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  iñ  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  ió  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iò  iô  iA  iØ  iB  iC  iD  iE  iF  iG  iH  iI  iö  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  ii  i^  ij  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iÒ  iå  iç  iõ  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  iú  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iù  iÙ  iı  iˆ  i˜  i¯  iû  i˘  i˙  i˚  i¸  i˝  iü  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i†  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  i°  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  i¢  in  io  ip  iq  ir  is  it  iu  iv  iw  i∞  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  i£  iü  i†  i§  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  i•  iƒ  i≈  i∆  i«  i»  ik  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i¶  i  i  i  i  i  i  i  i  i  iß  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i®  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  iÚ  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  i©  i™  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  il  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  i´  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i¨  i  i	  i
  i  i  i  i  i  i  i  i  i±  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  im  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  in  i≠  iQ  iR  iS  iT  iU  iV  iÆ  iW  iX  iY  iZ  io  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  ip  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i≤  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iØ  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iq  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i∞  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  i±  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i≤  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  ir  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  i≥  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  i¥  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  is  i(  i)  i*  i+  i,  i-  iµ  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  i∂  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i   i  i  i  i  i  i  i  i  i	  i
  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i   i!  i"  i#  i$  i%  i&  i'  i(  i)  i*  i+  i,  i-  i.  i/  i0  i1  i2  i3  i4  i5  i6  i7  i8  i9  i:  i;  i<  i=  i>  i?  i@  iA  iB  iC  iD  iE  iF  iG  iH  iI  iJ  iK  iL  iM  iN  iO  iP  iQ  iR  iS  iT  iU  iV  iW  iX  iY  iZ  i[  i\  i]  i^  i_  i`  ia  ib  ic  id  ie  if  ig  ih  ii  ij  ik  il  im  in  io  ip  iq  ir  is  it  iu  iv  iw  ix  iy  iz  i{  i|  i}  i~  i  iÄ  iÅ  iÇ  iÉ  iÑ  iÖ  iÜ  iá  ià  iâ  iä  iã  iå  iç  ié  iè  iê  ië  ií  iì  iî  iï  iñ  ió  iò  iô  iö  iõ  iú  iù  iû  iü  i†  i°  i¢  i£  i§  i•  i¶  iß  i®  i©  i™  i´  i¨  i≠  iÆ  iØ  i∞  i±  i≤  i≥  i¥  iµ  i∂  i∑  i∏  iπ  i∫  iª  iº  iΩ  iæ  iø  i¿  i¡  i¬  i√  iƒ  i≈  i∆  i«  i»  i…  i   iÀ  iÃ  iÕ  iŒ  iœ  i–  i—  i“  i”  i‘  i’  i÷  i◊  iÿ  iŸ  i⁄  i€  i‹  i›  iﬁ  iﬂ  i‡  i·  i‚  i„  i‰  iÂ  iÊ  iÁ  iË  iÈ  iÍ  iÎ  iÏ  iÌ  iÓ  iÔ  i  iÒ  iÚ  iÛ  iÙ  iı  iˆ  i˜  i¯  i˘  i˙  i˚  i¸  i˝  i˛  iˇ  i    i   i   i   i   i   i   i   i   i	   i
   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i!   i"   i#   i$   i%   i&   i'   i(   i)   i*   i+   i,   i-   i.   i/   i0   i1   i2   i3   i4   i5   i6   i7   i8   i9   i:   i;   i<   i=   i>   i?   i@   iA   iB   iC   iD   iE   iF   iG   iH   iI   iJ   iK   iL   iM   iN   iO   iP   iQ   iR   iS   iT   iU   iV   iW   iX   iY   iZ   i[   i\   i]   i^   i_   i`   ia   ib   ic   id   ie   if   ig   ih   ii   ij   ik   il   im   in   io   ip   iq   ir   is   it   iu   iv   iw   ix   iy   iz   i{   i|   i}   i~   i   iÄ   iÅ   iÇ   iÉ   iÑ   iÖ   iÜ   iá   ià   iâ   iä   iã   iå   iç   ié   iè   iê   ië   ií   iì   iî   iï   iñ   ió   iò   iô   iö   iõ   iú   iù   iû   iü   i†   i°   i¢   i£   i§   i•   i¶   iß   i®   i©   i™   i´   i¨   i≠   iÆ   iØ   i∞   i±   i≤   i≥   i¥   iµ   i∂   i∑   i∏   iπ   i∫   iª   iº   iΩ   iæ   iø   i¿   i¡   i¬   i√   iƒ   i≈   i∆   i«   i»   i…   i    iÀ   iÃ   iÕ   iŒ   iœ   i–   i—   i“   i”   i‘   i’   i÷   i◊   iÿ   iŸ   i⁄   i€   i‹   i›   iﬁ   iﬂ   i‡   i·   i‚   i„   i‰   iÂ   iÊ   iÁ   iË   iÈ   iÍ   iÎ   iÏ   iÌ   iÓ   iÔ   i   iÒ   iÚ   iÛ   iÙ   iı   iˆ   i˜   i¯   i˘   i˙   i˚   i¸   i˝   i˛   iˇ   i !  i!  i!  i!  i!  i!  i!  i!  i!  i	!  i
!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i!  i !  i!!  i"!  i#!  i$!  i%!  i&!  i'!  i(!  i)!  i*!  i+!  i,!  i-!  i.!  i/!  i0!  i1!  i2!  i3!  i4!  i5!  i6!  i7!  i8!  i9!  i:!  i;!  i<!  i=!  i>!  i?!  i@!  iA!  iB!  iC!  iD!  iE!  iF!  iG!  iH!  iI!  iJ!  iK!  iL!  iM!  iN!  iO!  iP!  iQ!  iR!  iS!  iT!  iU!  iV!  iW!  iX!  iY!  iZ!  i[!  i\!  i]!  i^!  i_!  i`!  ia!  ib!  ic!  id!  ie!  if!  ig!  ih!  ii!  ij!  ik!  il!  im!  in!  io!  ip!  iq!  ir!  is!  it!  iu!  iv!  iw!  ix!  iy!  iz!  i{!  i|!  i}!  i~!  i!  iÄ!  iÅ!  iÇ!  iÉ!  iÑ!  iÖ!  iÜ!  iá!  ià!  iâ!  iä!  iã!  iå!  iç!  ié!  iè!  iê!  ië!  ií!  iì!  iî!  iï!  iñ!  ió!  iò!  iô!  iö!  iõ!  iú!  iù!  iû!  iü!  i†!  i°!  i¢!  i£!  i§!  i•!  i¶!  iß!  i®!  i©!  i™!  i´!  i¨!  i≠!  iÆ!  iØ!  i∞!  i±!  i≤!  i≥!  i¥!  iµ!  i∂!  i∑!  i∏!  iπ!  i∫!  iª!  iº!  iΩ!  iæ!  iø!  i¿!  i¡!  i¬!  i√!  iƒ!  i≈!  i∆!  i«!  i»!  i…!  i !  iÀ!  iÃ!  iÕ!  iŒ!  iœ!  i–!  i—!  i“!  i”!  i‘!  i’!  i÷!  i◊!  iÿ!  iŸ!  i⁄!  i€!  i‹!  i›!  iﬁ!  iﬂ!  i‡!  i·!  i‚!  i„!  i‰!  iÂ!  iÊ!  iÁ!  iË!  iÈ!  iÍ!  iÎ!  iÏ!  iÌ!  iÓ!  iÔ!  i!  iÒ!  iÚ!  iÛ!  iÙ!  iı!  iˆ!  i˜!  i¯!  i˘!  i˙!  i˚!  i¸!  i˝!  i˛!  iˇ!  i "  i"  i"  i"  i"  i"  i"  i"  i"  i	"  i
"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i"  i "  i!"  i""  i#"  i$"  i%"  (   t    EUCKR_TYPICAL_DISTRIBUTION_RATIOt   EUCKR_TABLE_SIZEt   EUCKRCharToFreqOrder(    (    (    s5   /usr/lib/python2.7/dist-packages/chardet/euckrfreq.pyt   <module>)   sH                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
filename:/usr/lib/python2.7/dist-packages/chardet/sjisprober.pyc
__doc__
Û
≤ 4Tc           @   sÜ   d  d l  Z  d d l m Z d d l m Z d d l m Z d d l m Z d d l	 m
 Z
 d d l m Z d	 e f d
 Ñ  É  YZ d S(   iˇˇˇˇNi   (   t   MultiByteCharSetProber(   t   CodingStateMachine(   t   SJISDistributionAnalysis(   t   SJISContextAnalysis(   t   SJISSMModel(   t	   constantst
   SJISProberc           B   s5   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   sB   t  j |  É t t É |  _ t É  |  _ t É  |  _ |  j	 É  d  S(   N(
   R    t   __init__R   R   t
   _mCodingSMR   t   _mDistributionAnalyzerR   t   _mContextAnalyzert   reset(   t   self(    (    s6   /usr/lib/python2.7/dist-packages/chardet/sjisprober.pyR   &   s
    c         C   s   t  j |  É |  j j É  d  S(   N(   R    R   R
   (   R   (    (    s6   /usr/lib/python2.7/dist-packages/chardet/sjisprober.pyR   -   s    c         C   s   |  j  j É  S(   N(   R
   t   get_charset_name(   R   (    (    s6   /usr/lib/python2.7/dist-packages/chardet/sjisprober.pyR   1   s    c         C   sŸ  t  | É } x`t d | É D]O} |  j j | | É } | t j k rã t j r{ t j j	 |  j
 É  d t | É d É n  t j |  _ Pq | t j k r™ t j |  _ Pq | t j k r |  j j É  } | d k r| d |  j d <|  j j |  j d | | É |  j j |  j | É qk|  j j | | d | | d | !| É |  j j | | d | d !| É q q W| | d |  j d <|  j É  t j k rœ|  j j É  rœ|  j É  t j k rœt j |  _ qœn  |  j É  S(   Ni    s    prober hit error at byte s   
i   i   i   (   t   lent   rangeR   t
   next_stateR   t   eErrort   _debugt   syst   stderrt   writeR   t   strt   eNotMet   _mStatet   eItsMet   eFoundItt   eStartt   get_current_charlent
   _mLastCharR
   t   feedR	   t	   get_statet
   eDetectingt   got_enough_datat   get_confidencet   SHORTCUT_THRESHOLD(   R   t   aBuft   aLent   it   codingStatet   charLen(    (    s6   /usr/lib/python2.7/dist-packages/chardet/sjisprober.pyR   4   s:    		"c         C   s+   |  j  j É  } |  j j É  } t | | É S(   N(   R
   R"   R	   t   max(   R   t   contxtCft	   distribCf(    (    s6   /usr/lib/python2.7/dist-packages/chardet/sjisprober.pyR"   X   s    (   t   __name__t
   __module__R   R   R   R   R"   (    (    (    s6   /usr/lib/python2.7/dist-packages/chardet/sjisprober.pyR   %   s
   				$(   R   t   mbcharsetproberR    t   codingstatemachineR   t   chardistributionR   t   jpcntxR   t   mbcssmR   t    R   R   (    (    (    s6   /usr/lib/python2.7/dist-packages/chardet/sjisprober.pyt   <module>   s   
filename:/usr/lib/python2.7/dist-packages/chardet/langhebrewmodel.pyc
__doc__
Û
aÀTc           @   s9   dø Z  d¿ Z i e  d∑ 6e d∏ 6dπ d∫ 6e dª 6dº dΩ 6Z dæ S(¡   iˇ   i˛   i˝   i¸   iE   i[   iO   iP   i\   iY   ia   iZ   iD   io   ip   iR   iI   i_   iU   iN   iy   iV   iG   iC   if   ik   iT   ir   ig   is   i2   iJ   i<   i=   i*   iL   iF   i@   i5   ii   i]   i8   iA   i6   i1   iB   in   i3   i+   i,   i?   iQ   iM   ib   iK   il   i|   i    iÀ   iÃ   iÕ   i(   i:   iŒ   iœ   i–   i—   i“   i”   i‘   i’   i÷   i◊   iS   i4   i/   i.   iH   i    i^   iÿ   iq   iŸ   im   i⁄   i€   i‹   i›   i"   it   iﬁ   iv   id   iﬂ   i‡   iu   iw   ih   i}   i·   i‚   iW   ic   i„   ij   iz   i{   i‰   i7   iÂ   iÊ   ie   iÁ   iË   ix   iÈ   i0   i'   i9   iÍ   i   i;   i)   iX   i!   i%   i$   i   i   i#   iÎ   i>   i   iÏ   i~   iÌ   iÓ   i&   i-   iÔ   i   iÒ   iÚ   iÛ   i   iÙ   iı   iˆ   i˜   i¯   i˘   i˙   i	   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i
   i   i˚   iÄ   i`   i    t   charToOrderMapt   precedenceMatrixgC‰Ùı|Ô?t   mTypicalPositiveRatiot   keepEnglishLetters   windows-1255t   charsetNameN(   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   i˛   iˇ   iˇ   i˛   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   iˇ   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i˝   i¸   i¸   i¸   i¸   i¸   i¸   i¸   i¸   i¸   i¸   i˝   i˝   i˝   i˝   i˝   i˝   i˝   iE   i[   iO   iP   i\   iY   ia   iZ   iD   io   ip   iR   iI   i_   iU   iN   iy   iV   iG   iC   if   ik   iT   ir   ig   is   i˝   i˝   i˝   i˝   i˝   i˝   i2   iJ   i<   i=   i*   iL   iF   i@   i5   ii   i]   i8   iA   i6   i1   iB   in   i3   i+   i,   i?   iQ   iM   ib   iK   il   i˝   i˝   i˝   i˝   i˝   i|   i    iÀ   iÃ   iÕ   i(   i:   iŒ   iœ   i–   i—   i“   i”   i‘   i’   i÷   i◊   iS   i4   i/   i.   iH   i    i^   iÿ   iq   iŸ   im   i⁄   i€   i‹   i›   i"   it   iﬁ   iv   id   iﬂ   i‡   iu   iw   ih   i}   i·   i‚   iW   ic   i„   ij   iz   i{   i‰   i7   iÂ   iÊ   ie   iÁ   iË   ix   iÈ   i0   i'   i9   iÍ   i   i;   i)   iX   i!   i%   i$   i   i   i#   iÎ   i>   i   iÏ   i~   iÌ   iÓ   i&   i-   iÔ   i   iÒ   iÚ   iÛ   i   iÙ   iı   iˆ   i˜   i¯   i˘   i˙   i	   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i
   i   i˚   i¸   iÄ   i`   i˝   (   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i    i   i    i   i   i    i    i   i   i   i    i   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i    i    i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i    i   i    i    i    i    i    i   i    i   i    i    i    i    i    i    i   i    i    i    i    i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i    i   i    i    i    i   i    i   i    i   i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i    i    i   i   i    i    i    i    i   i    i   i    i    i    i   i    i    i    i    i    i    i   i    i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i    i   i    i    i    i    i    i   i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i    i    i    i    i    i    i    i   i    i    i    i   i    i    i    i    i    i    i    i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i    i   i    i   i   i   i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i    i   i   i   i   i   i    i    i   i   i    i    i    i    i   i    i   i    i    i    i    i    i    i   i    i    i    i    i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i    i   i    i    i    i    i    i   i    i    i    i    i    i    i    i    i   i    i    i    i    i    i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i   i    i   i   i   i   i   i    i    i   i   i    i    i    i    i   i    i   i    i    i    i    i    i    i   i    i    i    i   i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i    i   i    i    i    i    i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i    i   i   i    i    i   i    i    i   i    i    i    i    i    i    i   i    i    i    i    i    i   i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i   i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i    i   i    i   i   i   i    i    i   i   i    i    i    i    i   i    i   i    i    i    i    i    i    i    i    i    i    i   i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i    i   i   i   i   i   i    i    i   i   i    i    i    i    i   i    i    i    i    i    i   i    i    i   i    i    i    i   i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i   i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i    i   i    i   i   i   i    i    i   i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i    i    i   i    i    i    i    i    i   i    i    i    i    i    i   i    i    i   i    i    i    i    i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i   i   i   i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i    i   i   i   i   i   i    i    i   i    i    i    i    i    i   i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i    i    i    i    i    i    i    i    i   i    i    i    i    i    i   i    i    i   i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i   i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i    i    i   i    i    i    i    i    i   i    i   i    i    i    i    i    i   i    i    i    i    i    i   i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i    i   i    i   i   i   i    i    i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i   i    i   i    i    i   i   i    i   i    i    i   i   i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i   i    i   i    i   i   i    i   i   i    i    i    i   i   i    i   i   i   i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i   i   i    i   i    i   i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i    i   i    i   i   i   i   i    i    i   i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i    i    i    i    i    i    i    i    i    i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i    i    i   i   i   i   i    i   i   i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i    i    i   i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i    i   i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i   i   i    i    i    i    i   i   i    i    i   i   i    i    i    i    i    i    i   i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i   i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i    i   i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i    i   i    i   i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i   i    i    i    i   i    i    i    i    i    i    i    i    i    i    i   i    i   i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i    i   i   i    i   i    i    i   i    i    i   i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i   i   i   i    i   i    i    i    i   i   i    i   i   i    i    i    i    i    i   i   i    i    i    i   i   i   i   i   i   i   i   i    i   i    i   i    i   i   i   i   i   i   i   i   i   i    i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i   i    i    i    i    i    i   i    i   i   i   i    i   i    i    i   i   i   i   i   i   i    i   i    i    i    i   i   i    i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i   i   i   i    i   i    i    i   i   i   i   i   i   i    i   i    i    i    i   i    i    i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i   i    i   i   i   i    i   i    i    i   i   i   i   i   i    i    i   i    i    i    i   i    i    i   i   i   i   i   i    i   i   i   i    i   i    i   i   i   i   i    i    i    i   i    i   i    i    i    i    i    i    i    i    i   i   i   i    i   i    i   i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i    i    i   i    i   i   i   i   i    i    i    i    i    i   i    i    i    i    i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i    i    i    i    i   i   i   i    i   i   i    i   i    i    i    i   i   i    i   i   i    i   i    i   i    i   i    i    i   i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i   i   i   i    i   i    i    i   i   i   i   i   i   i    i   i    i    i    i   i   i    i   i   i    i    i   i    i    i   i    i    i    i   i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i   i   i   i    i   i    i    i    i    i   i   i   i   i    i   i    i    i    i   i   i    i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i   i   i   i    i   i    i    i   i   i   i   i   i   i    i   i    i    i    i   i   i    i   i   i    i   i    i    i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i    i    i    i    i    i   i   i    i   i    i    i   i    i    i    i    i   i    i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i    i    i    i    i   i   i   i   i    i   i   i   i    i    i    i   i   i    i   i   i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i   i   i   i    i   i    i    i   i   i    i   i   i   i    i   i    i    i    i   i   i    i   i   i   i   i   i   i    i   i   i    i   i   i    i   i    i    i    i    i    i    i   i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i   i   i   i    i   i    i    i   i   i    i   i   i   i    i   i    i    i    i   i   i    i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i   i    i    i   i    i   i   i   i    i   i    i   i    i    i   i    i    i    i    i   i    i    i    i   i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i   i    i    i   i    i    i   i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i   i   i   i    i   i    i    i   i   i   i    i   i    i    i   i    i    i    i   i    i    i   i   i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i   i    i   i   i    i    i   i    i    i   i   i   i   i   i   i    i   i    i    i    i    i   i    i   i    i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i    i    i    i    i    i   i   i   i   i   i    i   i    i    i    i   i   i    i    (   t   win1255_CharToOrderMapt   HebrewLangModelt   Falset   Win1255HebrewModel(    (    (    s;   /usr/lib/python2.7/dist-packages/chardet/langhebrewmodel.pyt   <module>&   s*                 
                                                                                                                               
filename:/usr/lib/python2.7/dist-packages/chardet/langgreekmodel.py
__doc__
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Communicator client code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

# 255: Control characters that usually does not exist in any text
# 254: Carriage/Return
# 253: symbol (punctuation) that does not belong to word
# 252: 0 - 9

# Character Mapping Table:
Latin7_CharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30
253, 82,100,104, 94, 98,101,116,102,111,187,117, 92, 88,113, 85,  # 40
 79,118,105, 83, 67,114,119, 95, 99,109,188,253,253,253,253,253,  # 50
253, 72, 70, 80, 81, 60, 96, 93, 89, 68,120, 97, 77, 86, 69, 55,  # 60
 78,115, 65, 66, 58, 76,106,103, 87,107,112,253,253,253,253,253,  # 70
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 80
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 90
253,233, 90,253,253,253,253,253,253,253,253,253,253, 74,253,253,  # a0
253,253,253,253,247,248, 61, 36, 46, 71, 73,253, 54,253,108,123,  # b0
110, 31, 51, 43, 41, 34, 91, 40, 52, 47, 44, 53, 38, 49, 59, 39,  # c0
 35, 48,250, 37, 33, 45, 56, 50, 84, 57,120,121, 17, 18, 22, 15,  # d0
124,  1, 29, 20, 21,  3, 32, 13, 25,  5, 11, 16, 10,  6, 30,  4,  # e0
  9,  8, 14,  7,  2, 12, 28, 23, 42, 24, 64, 75, 19, 26, 27,253,  # f0
)

win1253_CharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30
253, 82,100,104, 94, 98,101,116,102,111,187,117, 92, 88,113, 85,  # 40
 79,118,105, 83, 67,114,119, 95, 99,109,188,253,253,253,253,253,  # 50
253, 72, 70, 80, 81, 60, 96, 93, 89, 68,120, 97, 77, 86, 69, 55,  # 60
 78,115, 65, 66, 58, 76,106,103, 87,107,112,253,253,253,253,253,  # 70
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 80
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 90
253,233, 61,253,253,253,253,253,253,253,253,253,253, 74,253,253,  # a0
253,253,253,253,247,253,253, 36, 46, 71, 73,253, 54,253,108,123,  # b0
110, 31, 51, 43, 41, 34, 91, 40, 52, 47, 44, 53, 38, 49, 59, 39,  # c0
 35, 48,250, 37, 33, 45, 56, 50, 84, 57,120,121, 17, 18, 22, 15,  # d0
124,  1, 29, 20, 21,  3, 32, 13, 25,  5, 11, 16, 10,  6, 30,  4,  # e0
  9,  8, 14,  7,  2, 12, 28, 23, 42, 24, 64, 75, 19, 26, 27,253,  # f0
)

# Model Table:
# total sequences: 100%
# first 512 sequences: 98.2851%
# first 1024 sequences:1.7001%
# rest  sequences:     0.0359%
# negative sequences:  0.0148%
GreekLangModel = (
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3,2,2,3,3,3,3,3,3,3,3,1,3,3,3,0,2,2,3,3,0,3,0,3,2,0,3,3,3,0,
3,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,0,3,3,0,3,2,3,3,0,3,2,3,3,3,0,0,3,0,3,0,3,3,2,0,0,0,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,
0,2,3,2,2,3,3,3,3,3,3,3,3,0,3,3,3,3,0,2,3,3,0,3,3,3,3,2,3,3,3,0,
2,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,0,2,1,3,3,3,3,2,3,3,2,3,3,2,0,
0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,0,3,3,3,3,3,3,0,3,3,0,3,3,3,3,3,3,3,3,3,3,0,3,2,3,3,0,
2,0,1,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,2,3,0,0,0,0,3,3,0,3,1,3,3,3,0,3,3,0,3,3,3,3,0,0,0,0,
2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,0,3,0,3,3,3,3,3,0,3,2,2,2,3,0,2,3,3,3,3,3,2,3,3,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,3,2,2,2,3,3,3,3,0,3,1,3,3,3,3,2,3,3,3,3,3,3,3,2,2,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,2,0,3,0,0,0,3,3,2,3,3,3,3,3,0,0,3,2,3,0,2,3,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,0,3,3,3,3,0,0,3,3,0,2,3,0,3,0,3,3,3,0,0,3,0,3,0,2,2,3,3,0,0,
0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,2,0,3,2,3,3,3,3,0,3,3,3,3,3,0,3,3,2,3,2,3,3,2,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,2,3,2,3,3,3,3,3,3,0,2,3,2,3,2,2,2,3,2,3,3,2,3,0,2,2,2,3,0,
2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3,0,0,0,3,3,3,2,3,3,0,0,3,0,3,0,0,0,3,2,0,3,0,3,0,0,2,0,2,0,
0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,0,3,3,3,3,3,3,0,3,3,0,3,0,0,0,3,3,0,3,3,3,0,0,1,2,3,0,
3,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,2,0,0,3,2,2,3,3,0,3,3,3,3,3,2,1,3,0,3,2,3,3,2,1,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3,3,0,2,3,3,3,3,3,3,0,0,3,0,3,0,0,0,3,3,0,3,2,3,0,0,3,3,3,0,
3,0,0,0,2,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,0,3,3,3,3,3,3,0,0,3,0,3,0,0,0,3,2,0,3,2,3,0,0,3,2,3,0,
2,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3,1,2,2,3,3,3,3,3,3,0,2,3,0,3,0,0,0,3,3,0,3,0,2,0,0,2,3,1,0,
2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,0,3,3,3,3,0,3,0,3,3,2,3,0,3,3,3,3,3,3,0,3,3,3,0,2,3,0,0,3,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,0,3,3,3,0,0,3,0,0,0,3,3,0,3,0,2,3,3,0,0,3,0,3,0,3,3,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3,0,0,0,3,3,3,3,3,3,0,0,3,0,2,0,0,0,3,3,0,3,0,3,0,0,2,0,2,0,
0,0,0,0,1,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,3,0,3,0,2,0,3,2,0,3,2,3,2,3,0,0,3,2,3,2,3,3,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3,0,0,2,3,3,3,3,3,0,0,0,3,0,2,1,0,0,3,2,2,2,0,3,0,0,2,2,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,0,3,3,3,2,0,3,0,3,0,3,3,0,2,1,2,3,3,0,0,3,0,3,0,3,3,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,3,3,3,0,3,3,3,3,3,3,0,2,3,0,3,0,0,0,2,1,0,2,2,3,0,0,2,2,2,0,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3,0,0,2,3,3,3,2,3,0,0,1,3,0,2,0,0,0,0,3,0,1,0,2,0,0,1,1,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,1,0,3,0,0,0,3,2,0,3,2,3,3,3,0,0,3,0,3,2,2,2,1,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,0,3,3,3,0,0,3,0,0,0,0,2,0,2,3,3,2,2,2,2,3,0,2,0,2,2,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,2,0,0,0,0,0,0,2,3,0,2,0,2,3,2,0,0,3,0,3,0,3,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,3,2,3,3,2,2,3,0,2,0,3,0,0,0,2,0,0,0,0,1,2,0,2,0,2,0,
0,2,0,2,0,2,2,0,0,1,0,2,2,2,0,2,2,2,0,2,2,2,0,0,2,0,0,1,0,0,0,0,
0,2,0,3,3,2,0,0,0,0,0,0,1,3,0,2,0,2,2,2,0,0,2,0,3,0,0,2,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,0,2,3,2,0,2,2,0,2,0,2,2,0,2,0,2,2,2,0,0,0,0,0,0,2,3,0,0,0,2,
0,1,2,0,0,0,0,2,2,0,0,0,2,1,0,2,2,0,0,0,0,0,0,1,0,2,0,0,0,0,0,0,
0,0,2,1,0,2,3,2,2,3,2,3,2,0,0,3,3,3,0,0,3,2,0,0,0,1,1,0,2,0,2,2,
0,2,0,2,0,2,2,0,0,2,0,2,2,2,0,2,2,2,2,0,0,2,0,0,0,2,0,1,0,0,0,0,
0,3,0,3,3,2,2,0,3,0,0,0,2,2,0,2,2,2,1,2,0,0,1,2,2,0,0,3,0,0,0,2,
0,1,2,0,0,0,1,2,0,0,0,0,0,0,0,2,2,0,1,0,0,2,0,0,0,2,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,3,3,2,2,0,0,0,2,0,2,3,3,0,2,0,0,0,0,0,0,2,2,2,0,2,2,0,2,0,2,
0,2,2,0,0,2,2,2,2,1,0,0,2,2,0,2,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,
0,2,0,3,2,3,0,0,0,3,0,0,2,2,0,2,0,2,2,2,0,0,2,0,0,0,0,0,0,0,0,2,
0,0,2,2,0,0,2,2,2,0,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,2,0,0,3,2,0,2,2,2,2,2,0,0,0,2,0,0,0,0,2,0,1,0,0,2,0,1,0,0,0,
0,2,2,2,0,2,2,0,1,2,0,2,2,2,0,2,2,2,2,1,2,2,0,0,2,0,0,0,0,0,0,0,
0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
0,2,0,2,0,2,2,0,0,0,0,1,2,1,0,0,2,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,3,2,3,0,0,2,0,0,0,2,2,0,2,0,0,0,1,0,0,2,0,2,0,2,2,0,0,0,0,
0,0,2,0,0,0,0,2,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,
0,2,2,3,2,2,0,0,0,0,0,0,1,3,0,2,0,2,2,0,0,0,1,0,2,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,2,0,3,2,0,2,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
0,0,2,0,0,0,0,1,1,0,0,2,1,2,0,2,2,0,1,0,0,1,0,0,0,2,0,0,0,0,0,0,
0,3,0,2,2,2,0,0,2,0,0,0,2,0,0,0,2,3,0,2,0,0,0,0,0,0,2,2,0,0,0,2,
0,1,2,0,0,0,1,2,2,1,0,0,0,2,0,0,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,1,2,0,2,2,0,2,0,0,2,0,0,0,0,1,2,1,0,2,1,0,0,0,0,0,0,0,0,0,0,
0,0,2,0,0,0,3,1,2,2,0,2,0,0,0,0,2,0,0,0,2,0,0,3,0,0,0,0,2,2,2,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,1,0,2,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,0,2,
0,2,2,0,0,2,2,2,2,2,0,1,2,0,0,0,2,2,0,1,0,2,0,0,2,2,0,0,0,0,0,0,
0,0,0,0,1,0,0,0,0,0,0,0,3,0,0,2,0,0,0,0,0,0,0,0,2,0,2,0,0,0,0,2,
0,1,2,0,0,0,0,2,2,1,0,1,0,1,0,2,2,2,1,0,0,0,0,0,0,1,0,0,0,0,0,0,
0,2,0,1,2,0,0,0,0,0,0,0,0,0,0,2,0,0,2,2,0,0,0,0,1,0,0,0,0,0,0,2,
0,2,2,0,0,0,0,2,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,2,0,0,0,
0,2,2,2,2,0,0,0,3,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,1,
0,0,2,0,0,0,0,1,2,0,0,0,0,0,0,2,2,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,
0,2,0,2,2,2,0,0,2,0,0,0,0,0,0,0,2,2,2,0,0,0,2,0,0,0,0,0,0,0,0,2,
0,0,1,0,0,0,0,2,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
0,3,0,2,0,0,0,0,0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,2,
0,0,2,0,0,0,0,2,2,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,2,2,1,0,0,0,0,0,0,2,0,0,2,0,2,2,2,0,0,0,0,0,0,2,0,0,0,0,2,
0,0,2,0,0,2,0,2,2,0,0,0,0,2,0,2,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,
0,0,3,0,0,0,2,2,0,2,2,0,0,0,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,2,0,0,0,0,0,
0,2,2,2,2,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,
0,0,0,0,0,0,0,2,1,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,2,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
0,2,0,0,0,2,0,0,0,0,0,1,0,0,0,0,2,2,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,2,0,0,0,
0,2,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,2,0,2,0,0,0,
0,0,0,0,0,0,0,0,2,1,0,0,0,0,0,0,2,0,0,0,1,2,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
)

Latin7GreekModel = {
  'charToOrderMap': Latin7_CharToOrderMap,
  'precedenceMatrix': GreekLangModel,
  'mTypicalPositiveRatio': 0.982851,
  'keepEnglishLetter': False,
  'charsetName': "ISO-8859-7"
}

Win1253GreekModel = {
  'charToOrderMap': win1253_CharToOrderMap,
  'precedenceMatrix': GreekLangModel,
  'mTypicalPositiveRatio': 0.982851,
  'keepEnglishLetter': False,
  'charsetName': "windows-1253"
}

# flake8: noqa

filename:/usr/lib/python2.7/dist-packages/chardet/codingstatemachine.pyc
__doc__
Û
aÀTc           @   s7   d  d l  m Z d  d l m Z d d d Ñ  É  YZ d S(   i   (   t   eStart(   t   wrap_ordt   CodingStateMachinec           B   s5   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s)   | |  _  d |  _ d |  _ |  j É  d  S(   Ni    (   t   _mModelt   _mCurrentBytePost   _mCurrentCharLent   reset(   t   selft   sm(    (    s>   /usr/lib/python2.7/dist-packages/chardet/codingstatemachine.pyt   __init__!   s    			c         C   s   t  |  _ d  S(   N(   R    t   _mCurrentState(   R   (    (    s>   /usr/lib/python2.7/dist-packages/chardet/codingstatemachine.pyR   '   s    c         C   sà   |  j  d t | É } |  j t k rF d |  _ |  j  d | |  _ n  |  j |  j  d | } |  j  d | |  _ |  j d 7_ |  j S(   Nt
   classTablei    t   charLenTablet   classFactort
   stateTablei   (   R   R   R
   R    R   R   (   R   t   ct   byteClst
   curr_state(    (    s>   /usr/lib/python2.7/dist-packages/chardet/codingstatemachine.pyt
   next_state*   s    	c         C   s   |  j  S(   N(   R   (   R   (    (    s>   /usr/lib/python2.7/dist-packages/chardet/codingstatemachine.pyt   get_current_charlen9   s    c         C   s   |  j  d S(   Nt   name(   R   (   R   (    (    s>   /usr/lib/python2.7/dist-packages/chardet/codingstatemachine.pyt   get_coding_state_machine<   s    (   t   __name__t
   __module__R	   R   R   R   R   (    (    (    s>   /usr/lib/python2.7/dist-packages/chardet/codingstatemachine.pyR       s
   				N(    (   t	   constantsR    t   compatR   R   (    (    (    s>   /usr/lib/python2.7/dist-packages/chardet/codingstatemachine.pyt   <module>   s   
filename:/usr/lib/python2.7/dist-packages/chardet/latin1prober.py
__doc__
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Universal charset detector code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 2001
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#   Shy Shalom - original C code
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from .charsetprober import CharSetProber
from .constants import eNotMe
from .compat import wrap_ord

FREQ_CAT_NUM = 4

UDF = 0  # undefined
OTH = 1  # other
ASC = 2  # ascii capital letter
ASS = 3  # ascii small letter
ACV = 4  # accent capital vowel
ACO = 5  # accent capital other
ASV = 6  # accent small vowel
ASO = 7  # accent small other
CLASS_NUM = 8  # total classes

Latin1_CharToClass = (
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 00 - 07
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 08 - 0F
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 10 - 17
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 18 - 1F
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 20 - 27
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 28 - 2F
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 30 - 37
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 38 - 3F
    OTH, ASC, ASC, ASC, ASC, ASC, ASC, ASC,   # 40 - 47
    ASC, ASC, ASC, ASC, ASC, ASC, ASC, ASC,   # 48 - 4F
    ASC, ASC, ASC, ASC, ASC, ASC, ASC, ASC,   # 50 - 57
    ASC, ASC, ASC, OTH, OTH, OTH, OTH, OTH,   # 58 - 5F
    OTH, ASS, ASS, ASS, ASS, ASS, ASS, ASS,   # 60 - 67
    ASS, ASS, ASS, ASS, ASS, ASS, ASS, ASS,   # 68 - 6F
    ASS, ASS, ASS, ASS, ASS, ASS, ASS, ASS,   # 70 - 77
    ASS, ASS, ASS, OTH, OTH, OTH, OTH, OTH,   # 78 - 7F
    OTH, UDF, OTH, ASO, OTH, OTH, OTH, OTH,   # 80 - 87
    OTH, OTH, ACO, OTH, ACO, UDF, ACO, UDF,   # 88 - 8F
    UDF, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 90 - 97
    OTH, OTH, ASO, OTH, ASO, UDF, ASO, ACO,   # 98 - 9F
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # A0 - A7
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # A8 - AF
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # B0 - B7
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # B8 - BF
    ACV, ACV, ACV, ACV, ACV, ACV, ACO, ACO,   # C0 - C7
    ACV, ACV, ACV, ACV, ACV, ACV, ACV, ACV,   # C8 - CF
    ACO, ACO, ACV, ACV, ACV, ACV, ACV, OTH,   # D0 - D7
    ACV, ACV, ACV, ACV, ACV, ACO, ACO, ACO,   # D8 - DF
    ASV, ASV, ASV, ASV, ASV, ASV, ASO, ASO,   # E0 - E7
    ASV, ASV, ASV, ASV, ASV, ASV, ASV, ASV,   # E8 - EF
    ASO, ASO, ASV, ASV, ASV, ASV, ASV, OTH,   # F0 - F7
    ASV, ASV, ASV, ASV, ASV, ASO, ASO, ASO,   # F8 - FF
)

# 0 : illegal
# 1 : very unlikely
# 2 : normal
# 3 : very likely
Latin1ClassModel = (
    # UDF OTH ASC ASS ACV ACO ASV ASO
    0,  0,  0,  0,  0,  0,  0,  0,  # UDF
    0,  3,  3,  3,  3,  3,  3,  3,  # OTH
    0,  3,  3,  3,  3,  3,  3,  3,  # ASC
    0,  3,  3,  3,  1,  1,  3,  3,  # ASS
    0,  3,  3,  3,  1,  2,  1,  2,  # ACV
    0,  3,  3,  3,  3,  3,  3,  3,  # ACO
    0,  3,  1,  3,  1,  1,  1,  3,  # ASV
    0,  3,  1,  3,  1,  1,  3,  3,  # ASO
)


class Latin1Prober(CharSetProber):
    def __init__(self):
        CharSetProber.__init__(self)
        self.reset()

    def reset(self):
        self._mLastCharClass = OTH
        self._mFreqCounter = [0] * FREQ_CAT_NUM
        CharSetProber.reset(self)

    def get_charset_name(self):
        return "windows-1252"

    def feed(self, aBuf):
        aBuf = self.filter_with_english_letters(aBuf)
        for c in aBuf:
            charClass = Latin1_CharToClass[wrap_ord(c)]
            freq = Latin1ClassModel[(self._mLastCharClass * CLASS_NUM)
                                    + charClass]
            if freq == 0:
                self._mState = eNotMe
                break
            self._mFreqCounter[freq] += 1
            self._mLastCharClass = charClass

        return self.get_state()

    def get_confidence(self):
        if self.get_state() == eNotMe:
            return 0.01

        total = sum(self._mFreqCounter)
        if total < 0.01:
            confidence = 0.0
        else:
            confidence = ((self._mFreqCounter[3] - self._mFreqCounter[1] * 20.0)
                          / total)
        if confidence < 0.0:
            confidence = 0.0
        # lower the confidence of latin1 so that other more accurate
        # detector can take priority.
        confidence = confidence * 0.73
        return confidence

filename:/usr/lib/python2.7/dist-packages/chardet/charsetgroupprober.pyc
__doc__
Û
aÀTc           @   sF   d  d l  m Z d d l Z d  d l m Z d e f d Ñ  É  YZ d S(   i   (   t	   constantsiˇˇˇˇN(   t   CharSetProbert   CharSetGroupProberc           B   s5   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s,   t  j |  É d |  _ g  |  _ d  |  _ d  S(   Ni    (   R   t   __init__t   _mActiveNumt	   _mProberst   Nonet   _mBestGuessProber(   t   self(    (    s>   /usr/lib/python2.7/dist-packages/chardet/charsetgroupprober.pyR   "   s    		c         C   sb   t  j |  É d |  _ x< |  j D]1 } | r  | j É  t | _ |  j d 7_ q  q  Wd  |  _ d  S(   Ni    i   (   R   t   resetR   R   t   Truet   activeR   R   (   R   t   prober(    (    s>   /usr/lib/python2.7/dist-packages/chardet/charsetgroupprober.pyR	   (   s    	
	c         C   s0   |  j  s# |  j É  |  j  s# d  Sn  |  j  j É  S(   N(   R   t   get_confidenceR   t   get_charset_name(   R   (    (    s>   /usr/lib/python2.7/dist-packages/chardet/charsetgroupprober.pyR   2   s
    	
	c         C   s≈   x∏ |  j  D]≠ } | s q
 n  | j s+ q
 n  | j | É } | sF q
 n  | t j k rh | |  _ |  j É  S| t j k r
 t | _ |  j	 d 8_	 |  j	 d k r∑ t j |  _
 |  j É  Sq
 q
 W|  j É  S(   Ni   i    (   R   R   t   feedR    t   eFoundItR   t	   get_statet   eNotMet   FalseR   t   _mState(   R   t   aBufR   t   st(    (    s>   /usr/lib/python2.7/dist-packages/chardet/charsetgroupprober.pyR   :   s$    		
	c         C   s˝   |  j  É  } | t j k r d S| t j k r2 d Sd } d  |  _ x® |  j D]ù } | s] qK n  | j sí t j rK t	 j
 j | j É  d É qK qK n  | j É  } t j r  t	 j
 j d | j É  | f É n  | | k  rK | } | |  _ qK qK W|  j s˘ d S| S(   NgÆG·zÆÔ?g{ÆG·zÑ?g        s    not active
s   %s confidence = %s
(   R   R    R   R   R   R   R   R   t   _debugt   syst   stderrt   writeR   R   (   R   R   t   bestConfR   t   cf(    (    s>   /usr/lib/python2.7/dist-packages/chardet/charsetgroupprober.pyR   N   s2    					(   t   __name__t
   __module__R   R	   R   R   R   (    (    (    s>   /usr/lib/python2.7/dist-packages/chardet/charsetgroupprober.pyR   !   s
   		
		(   t    R    R   t   charsetproberR   R   (    (    (    s>   /usr/lib/python2.7/dist-packages/chardet/charsetgroupprober.pyt   <module>   s   
filename:/usr/lib/python2.7/dist-packages/chardet/sbcharsetprober.py
__doc__
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Universal charset detector code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 2001
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#   Shy Shalom - original C code
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

import sys
from . import constants
from .charsetprober import CharSetProber
from .compat import wrap_ord

SAMPLE_SIZE = 64
SB_ENOUGH_REL_THRESHOLD = 1024
POSITIVE_SHORTCUT_THRESHOLD = 0.95
NEGATIVE_SHORTCUT_THRESHOLD = 0.05
SYMBOL_CAT_ORDER = 250
NUMBER_OF_SEQ_CAT = 4
POSITIVE_CAT = NUMBER_OF_SEQ_CAT - 1
#NEGATIVE_CAT = 0


class SingleByteCharSetProber(CharSetProber):
    def __init__(self, model, reversed=False, nameProber=None):
        CharSetProber.__init__(self)
        self._mModel = model
        # TRUE if we need to reverse every pair in the model lookup
        self._mReversed = reversed
        # Optional auxiliary prober for name decision
        self._mNameProber = nameProber
        self.reset()

    def reset(self):
        CharSetProber.reset(self)
        # char order of last character
        self._mLastOrder = 255
        self._mSeqCounters = [0] * NUMBER_OF_SEQ_CAT
        self._mTotalSeqs = 0
        self._mTotalChar = 0
        # characters that fall in our sampling range
        self._mFreqChar = 0

    def get_charset_name(self):
        if self._mNameProber:
            return self._mNameProber.get_charset_name()
        else:
            return self._mModel['charsetName']

    def feed(self, aBuf):
        if not self._mModel['keepEnglishLetter']:
            aBuf = self.filter_without_english_letters(aBuf)
        aLen = len(aBuf)
        if not aLen:
            return self.get_state()
        for c in aBuf:
            order = self._mModel['charToOrderMap'][wrap_ord(c)]
            if order < SYMBOL_CAT_ORDER:
                self._mTotalChar += 1
            if order < SAMPLE_SIZE:
                self._mFreqChar += 1
                if self._mLastOrder < SAMPLE_SIZE:
                    self._mTotalSeqs += 1
                    if not self._mReversed:
                        i = (self._mLastOrder * SAMPLE_SIZE) + order
                        model = self._mModel['precedenceMatrix'][i]
                    else:  # reverse the order of the letters in the lookup
                        i = (order * SAMPLE_SIZE) + self._mLastOrder
                        model = self._mModel['precedenceMatrix'][i]
                    self._mSeqCounters[model] += 1
            self._mLastOrder = order

        if self.get_state() == constants.eDetecting:
            if self._mTotalSeqs > SB_ENOUGH_REL_THRESHOLD:
                cf = self.get_confidence()
                if cf > POSITIVE_SHORTCUT_THRESHOLD:
                    if constants._debug:
                        sys.stderr.write('%s confidence = %s, we have a'
                                         'winner\n' %
                                         (self._mModel['charsetName'], cf))
                    self._mState = constants.eFoundIt
                elif cf < NEGATIVE_SHORTCUT_THRESHOLD:
                    if constants._debug:
                        sys.stderr.write('%s confidence = %s, below negative'
                                         'shortcut threshhold %s\n' %
                                         (self._mModel['charsetName'], cf,
                                          NEGATIVE_SHORTCUT_THRESHOLD))
                    self._mState = constants.eNotMe

        return self.get_state()

    def get_confidence(self):
        r = 0.01
        if self._mTotalSeqs > 0:
            r = ((1.0 * self._mSeqCounters[POSITIVE_CAT]) / self._mTotalSeqs
                 / self._mModel['mTypicalPositiveRatio'])
            r = r * self._mFreqChar / self._mTotalChar
            if r >= 1.0:
                r = 0.99
        return r

filename:/usr/lib/python2.7/dist-packages/chardet/euckrfreq.py
__doc__
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Communicator client code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

# Sampling from about 20M text materials include literature and computer technology

# 128  --> 0.79
# 256  --> 0.92
# 512  --> 0.986
# 1024 --> 0.99944
# 2048 --> 0.99999
#
# Idea Distribution Ratio = 0.98653 / (1-0.98653) = 73.24
# Random Distribution Ration = 512 / (2350-512) = 0.279.
# 
# Typical Distribution Ratio  

EUCKR_TYPICAL_DISTRIBUTION_RATIO = 6.0

EUCKR_TABLE_SIZE = 2352

# Char to FreqOrder table , 
EUCKRCharToFreqOrder = ( \
  13, 130, 120,1396, 481,1719,1720, 328, 609, 212,1721, 707, 400, 299,1722,  87,
1397,1723, 104, 536,1117,1203,1724,1267, 685,1268, 508,1725,1726,1727,1728,1398,
1399,1729,1730,1731, 141, 621, 326,1057, 368,1732, 267, 488,  20,1733,1269,1734,
 945,1400,1735,  47, 904,1270,1736,1737, 773, 248,1738, 409, 313, 786, 429,1739,
 116, 987, 813,1401, 683,  75,1204, 145,1740,1741,1742,1743,  16, 847, 667, 622,
 708,1744,1745,1746, 966, 787, 304, 129,1747,  60, 820, 123, 676,1748,1749,1750,
1751, 617,1752, 626,1753,1754,1755,1756, 653,1757,1758,1759,1760,1761,1762, 856,
 344,1763,1764,1765,1766,  89, 401, 418, 806, 905, 848,1767,1768,1769, 946,1205,
 709,1770,1118,1771, 241,1772,1773,1774,1271,1775, 569,1776, 999,1777,1778,1779,
1780, 337, 751,1058,  28, 628, 254,1781, 177, 906, 270, 349, 891,1079,1782,  19,
1783, 379,1784, 315,1785, 629, 754,1402, 559,1786, 636, 203,1206,1787, 710, 567,
1788, 935, 814,1789,1790,1207, 766, 528,1791,1792,1208,1793,1794,1795,1796,1797,
1403,1798,1799, 533,1059,1404,1405,1156,1406, 936, 884,1080,1800, 351,1801,1802,
1803,1804,1805, 801,1806,1807,1808,1119,1809,1157, 714, 474,1407,1810, 298, 899,
 885,1811,1120, 802,1158,1812, 892,1813,1814,1408, 659,1815,1816,1121,1817,1818,
1819,1820,1821,1822, 319,1823, 594, 545,1824, 815, 937,1209,1825,1826, 573,1409,
1022,1827,1210,1828,1829,1830,1831,1832,1833, 556, 722, 807,1122,1060,1834, 697,
1835, 900, 557, 715,1836,1410, 540,1411, 752,1159, 294, 597,1211, 976, 803, 770,
1412,1837,1838,  39, 794,1413, 358,1839, 371, 925,1840, 453, 661, 788, 531, 723,
 544,1023,1081, 869,  91,1841, 392, 430, 790, 602,1414, 677,1082, 457,1415,1416,
1842,1843, 475, 327,1024,1417, 795, 121,1844, 733, 403,1418,1845,1846,1847, 300,
 119, 711,1212, 627,1848,1272, 207,1849,1850, 796,1213, 382,1851, 519,1852,1083,
 893,1853,1854,1855, 367, 809, 487, 671,1856, 663,1857,1858, 956, 471, 306, 857,
1859,1860,1160,1084,1861,1862,1863,1864,1865,1061,1866,1867,1868,1869,1870,1871,
 282,  96, 574,1872, 502,1085,1873,1214,1874, 907,1875,1876, 827, 977,1419,1420,
1421, 268,1877,1422,1878,1879,1880, 308,1881,   2, 537,1882,1883,1215,1884,1885,
 127, 791,1886,1273,1423,1887,  34, 336, 404, 643,1888, 571, 654, 894, 840,1889,
   0, 886,1274, 122, 575, 260, 908, 938,1890,1275, 410, 316,1891,1892, 100,1893,
1894,1123,  48,1161,1124,1025,1895, 633, 901,1276,1896,1897, 115, 816,1898, 317,
1899, 694,1900, 909, 734,1424, 572, 866,1425, 691,  85, 524,1010, 543, 394, 841,
1901,1902,1903,1026,1904,1905,1906,1907,1908,1909,  30, 451, 651, 988, 310,1910,
1911,1426, 810,1216,  93,1912,1913,1277,1217,1914, 858, 759,  45,  58, 181, 610,
 269,1915,1916, 131,1062, 551, 443,1000, 821,1427, 957, 895,1086,1917,1918, 375,
1919, 359,1920, 687,1921, 822,1922, 293,1923,1924,  40, 662, 118, 692,  29, 939,
 887, 640, 482, 174,1925,  69,1162, 728,1428, 910,1926,1278,1218,1279, 386, 870,
 217, 854,1163, 823,1927,1928,1929,1930, 834,1931,  78,1932, 859,1933,1063,1934,
1935,1936,1937, 438,1164, 208, 595,1938,1939,1940,1941,1219,1125,1942, 280, 888,
1429,1430,1220,1431,1943,1944,1945,1946,1947,1280, 150, 510,1432,1948,1949,1950,
1951,1952,1953,1954,1011,1087,1955,1433,1043,1956, 881,1957, 614, 958,1064,1065,
1221,1958, 638,1001, 860, 967, 896,1434, 989, 492, 553,1281,1165,1959,1282,1002,
1283,1222,1960,1961,1962,1963,  36, 383, 228, 753, 247, 454,1964, 876, 678,1965,
1966,1284, 126, 464, 490, 835, 136, 672, 529, 940,1088,1435, 473,1967,1968, 467,
  50, 390, 227, 587, 279, 378, 598, 792, 968, 240, 151, 160, 849, 882,1126,1285,
 639,1044, 133, 140, 288, 360, 811, 563,1027, 561, 142, 523,1969,1970,1971,   7,
 103, 296, 439, 407, 506, 634, 990,1972,1973,1974,1975, 645,1976,1977,1978,1979,
1980,1981, 236,1982,1436,1983,1984,1089, 192, 828, 618, 518,1166, 333,1127,1985,
 818,1223,1986,1987,1988,1989,1990,1991,1992,1993, 342,1128,1286, 746, 842,1994,
1995, 560, 223,1287,  98,   8, 189, 650, 978,1288,1996,1437,1997,  17, 345, 250,
 423, 277, 234, 512, 226,  97, 289,  42, 167,1998, 201,1999,2000, 843, 836, 824,
 532, 338, 783,1090, 182, 576, 436,1438,1439, 527, 500,2001, 947, 889,2002,2003,
2004,2005, 262, 600, 314, 447,2006, 547,2007, 693, 738,1129,2008,  71,1440, 745,
 619, 688,2009, 829,2010,2011, 147,2012,  33, 948,2013,2014,  74, 224,2015,  61,
 191, 918, 399, 637,2016,1028,1130, 257, 902,2017,2018,2019,2020,2021,2022,2023,
2024,2025,2026, 837,2027,2028,2029,2030, 179, 874, 591,  52, 724, 246,2031,2032,
2033,2034,1167, 969,2035,1289, 630, 605, 911,1091,1168,2036,2037,2038,1441, 912,
2039, 623,2040,2041, 253,1169,1290,2042,1442, 146, 620, 611, 577, 433,2043,1224,
 719,1170, 959, 440, 437, 534,  84, 388, 480,1131, 159, 220, 198, 679,2044,1012,
 819,1066,1443, 113,1225, 194, 318,1003,1029,2045,2046,2047,2048,1067,2049,2050,
2051,2052,2053,  59, 913, 112,2054, 632,2055, 455, 144, 739,1291,2056, 273, 681,
 499,2057, 448,2058,2059, 760,2060,2061, 970, 384, 169, 245,1132,2062,2063, 414,
1444,2064,2065,  41, 235,2066, 157, 252, 877, 568, 919, 789, 580,2067, 725,2068,
2069,1292,2070,2071,1445,2072,1446,2073,2074,  55, 588,  66,1447, 271,1092,2075,
1226,2076, 960,1013, 372,2077,2078,2079,2080,2081,1293,2082,2083,2084,2085, 850,
2086,2087,2088,2089,2090, 186,2091,1068, 180,2092,2093,2094, 109,1227, 522, 606,
2095, 867,1448,1093, 991,1171, 926, 353,1133,2096, 581,2097,2098,2099,1294,1449,
1450,2100, 596,1172,1014,1228,2101,1451,1295,1173,1229,2102,2103,1296,1134,1452,
 949,1135,2104,2105,1094,1453,1454,1455,2106,1095,2107,2108,2109,2110,2111,2112,
2113,2114,2115,2116,2117, 804,2118,2119,1230,1231, 805,1456, 405,1136,2120,2121,
2122,2123,2124, 720, 701,1297, 992,1457, 927,1004,2125,2126,2127,2128,2129,2130,
  22, 417,2131, 303,2132, 385,2133, 971, 520, 513,2134,1174,  73,1096, 231, 274,
 962,1458, 673,2135,1459,2136, 152,1137,2137,2138,2139,2140,1005,1138,1460,1139,
2141,2142,2143,2144,  11, 374, 844,2145, 154,1232,  46,1461,2146, 838, 830, 721,
1233, 106,2147,  90, 428, 462, 578, 566,1175, 352,2148,2149, 538,1234, 124,1298,
2150,1462, 761, 565,2151, 686,2152, 649,2153,  72, 173,2154, 460, 415,2155,1463,
2156,1235, 305,2157,2158,2159,2160,2161,2162, 579,2163,2164,2165,2166,2167, 747,
2168,2169,2170,2171,1464, 669,2172,2173,2174,2175,2176,1465,2177,  23, 530, 285,
2178, 335, 729,2179, 397,2180,2181,2182,1030,2183,2184, 698,2185,2186, 325,2187,
2188, 369,2189, 799,1097,1015, 348,2190,1069, 680,2191, 851,1466,2192,2193,  10,
2194, 613, 424,2195, 979, 108, 449, 589,  27, 172,  81,1031,  80, 774, 281, 350,
1032, 525, 301, 582,1176,2196, 674,1045,2197,2198,1467, 730, 762,2199,2200,2201,
2202,1468,2203, 993,2204,2205, 266,1070, 963,1140,2206,2207,2208, 664,1098, 972,
2209,2210,2211,1177,1469,1470, 871,2212,2213,2214,2215,2216,1471,2217,2218,2219,
2220,2221,2222,2223,2224,2225,2226,2227,1472,1236,2228,2229,2230,2231,2232,2233,
2234,2235,1299,2236,2237, 200,2238, 477, 373,2239,2240, 731, 825, 777,2241,2242,
2243, 521, 486, 548,2244,2245,2246,1473,1300,  53, 549, 137, 875,  76, 158,2247,
1301,1474, 469, 396,1016, 278, 712,2248, 321, 442, 503, 767, 744, 941,1237,1178,
1475,2249,  82, 178,1141,1179, 973,2250,1302,2251, 297,2252,2253, 570,2254,2255,
2256,  18, 450, 206,2257, 290, 292,1142,2258, 511, 162,  99, 346, 164, 735,2259,
1476,1477,   4, 554, 343, 798,1099,2260,1100,2261,  43, 171,1303, 139, 215,2262,
2263, 717, 775,2264,1033, 322, 216,2265, 831,2266, 149,2267,1304,2268,2269, 702,
1238, 135, 845, 347, 309,2270, 484,2271, 878, 655, 238,1006,1478,2272,  67,2273,
 295,2274,2275, 461,2276, 478, 942, 412,2277,1034,2278,2279,2280, 265,2281, 541,
2282,2283,2284,2285,2286,  70, 852,1071,2287,2288,2289,2290,  21,  56, 509, 117,
 432,2291,2292, 331, 980, 552,1101, 148, 284, 105, 393,1180,1239, 755,2293, 187,
2294,1046,1479,2295, 340,2296,  63,1047, 230,2297,2298,1305, 763,1306, 101, 800,
 808, 494,2299,2300,2301, 903,2302,  37,1072,  14,   5,2303,  79, 675,2304, 312,
2305,2306,2307,2308,2309,1480,   6,1307,2310,2311,2312,   1, 470,  35,  24, 229,
2313, 695, 210,  86, 778,  15, 784, 592, 779,  32,  77, 855, 964,2314, 259,2315,
 501, 380,2316,2317,  83, 981, 153, 689,1308,1481,1482,1483,2318,2319, 716,1484,
2320,2321,2322,2323,2324,2325,1485,2326,2327, 128,  57,  68, 261,1048, 211, 170,
1240,  31,2328,  51, 435, 742,2329,2330,2331, 635,2332, 264, 456,2333,2334,2335,
 425,2336,1486, 143, 507, 263, 943,2337, 363, 920,1487, 256,1488,1102, 243, 601,
1489,2338,2339,2340,2341,2342,2343,2344, 861,2345,2346,2347,2348,2349,2350, 395,
2351,1490,1491,  62, 535, 166, 225,2352,2353, 668, 419,1241, 138, 604, 928,2354,
1181,2355,1492,1493,2356,2357,2358,1143,2359, 696,2360, 387, 307,1309, 682, 476,
2361,2362, 332,  12, 222, 156,2363, 232,2364, 641, 276, 656, 517,1494,1495,1035,
 416, 736,1496,2365,1017, 586,2366,2367,2368,1497,2369, 242,2370,2371,2372,1498,
2373, 965, 713,2374,2375,2376,2377, 740, 982,1499, 944,1500,1007,2378,2379,1310,
1501,2380,2381,2382, 785, 329,2383,2384,1502,2385,2386,2387, 932,2388,1503,2389,
2390,2391,2392,1242,2393,2394,2395,2396,2397, 994, 950,2398,2399,2400,2401,1504,
1311,2402,2403,2404,2405,1049, 749,2406,2407, 853, 718,1144,1312,2408,1182,1505,
2409,2410, 255, 516, 479, 564, 550, 214,1506,1507,1313, 413, 239, 444, 339,1145,
1036,1508,1509,1314,1037,1510,1315,2411,1511,2412,2413,2414, 176, 703, 497, 624,
 593, 921, 302,2415, 341, 165,1103,1512,2416,1513,2417,2418,2419, 376,2420, 700,
2421,2422,2423, 258, 768,1316,2424,1183,2425, 995, 608,2426,2427,2428,2429, 221,
2430,2431,2432,2433,2434,2435,2436,2437, 195, 323, 726, 188, 897, 983,1317, 377,
 644,1050, 879,2438, 452,2439,2440,2441,2442,2443,2444, 914,2445,2446,2447,2448,
 915, 489,2449,1514,1184,2450,2451, 515,  64, 427, 495,2452, 583,2453, 483, 485,
1038, 562, 213,1515, 748, 666,2454,2455,2456,2457, 334,2458, 780, 996,1008, 705,
1243,2459,2460,2461,2462,2463, 114,2464, 493,1146, 366, 163,1516, 961,1104,2465,
 291,2466,1318,1105,2467,1517, 365,2468, 355, 951,1244,2469,1319,2470, 631,2471,
2472, 218,1320, 364, 320, 756,1518,1519,1321,1520,1322,2473,2474,2475,2476, 997,
2477,2478,2479,2480, 665,1185,2481, 916,1521,2482,2483,2484, 584, 684,2485,2486,
 797,2487,1051,1186,2488,2489,2490,1522,2491,2492, 370,2493,1039,1187,  65,2494,
 434, 205, 463,1188,2495, 125, 812, 391, 402, 826, 699, 286, 398, 155, 781, 771,
 585,2496, 590, 505,1073,2497, 599, 244, 219, 917,1018, 952, 646,1523,2498,1323,
2499,2500,  49, 984, 354, 741,2501, 625,2502,1324,2503,1019, 190, 357, 757, 491,
  95, 782, 868,2504,2505,2506,2507,2508,2509, 134,1524,1074, 422,1525, 898,2510,
 161,2511,2512,2513,2514, 769,2515,1526,2516,2517, 411,1325,2518, 472,1527,2519,
2520,2521,2522,2523,2524, 985,2525,2526,2527,2528,2529,2530, 764,2531,1245,2532,
2533,  25, 204, 311,2534, 496,2535,1052,2536,2537,2538,2539,2540,2541,2542, 199,
 704, 504, 468, 758, 657,1528, 196,  44, 839,1246, 272, 750,2543, 765, 862,2544,
2545,1326,2546, 132, 615, 933,2547, 732,2548,2549,2550,1189,1529,2551, 283,1247,
1053, 607, 929,2552,2553,2554, 930, 183, 872, 616,1040,1147,2555,1148,1020, 441,
 249,1075,2556,2557,2558, 466, 743,2559,2560,2561,  92, 514, 426, 420, 526,2562,
2563,2564,2565,2566,2567,2568, 185,2569,2570,2571,2572, 776,1530, 658,2573, 362,
2574, 361, 922,1076, 793,2575,2576,2577,2578,2579,2580,1531, 251,2581,2582,2583,
2584,1532,  54, 612, 237,1327,2585,2586, 275, 408, 647, 111,2587,1533,1106, 465,
   3, 458,   9,  38,2588, 107, 110, 890, 209,  26, 737, 498,2589,1534,2590, 431,
 202,  88,1535, 356, 287,1107, 660,1149,2591, 381,1536, 986,1150, 445,1248,1151,
 974,2592,2593, 846,2594, 446, 953, 184,1249,1250, 727,2595, 923, 193, 883,2596,
2597,2598, 102, 324, 539, 817,2599, 421,1041,2600, 832,2601,  94, 175, 197, 406,
2602, 459,2603,2604,2605,2606,2607, 330, 555,2608,2609,2610, 706,1108, 389,2611,
2612,2613,2614, 233,2615, 833, 558, 931, 954,1251,2616,2617,1537, 546,2618,2619,
1009,2620,2621,2622,1538, 690,1328,2623, 955,2624,1539,2625,2626, 772,2627,2628,
2629,2630,2631, 924, 648, 863, 603,2632,2633, 934,1540, 864, 865,2634, 642,1042,
 670,1190,2635,2636,2637,2638, 168,2639, 652, 873, 542,1054,1541,2640,2641,2642,  # 512, 256
#Everything below is of no interest for detection purpose
2643,2644,2645,2646,2647,2648,2649,2650,2651,2652,2653,2654,2655,2656,2657,2658,
2659,2660,2661,2662,2663,2664,2665,2666,2667,2668,2669,2670,2671,2672,2673,2674,
2675,2676,2677,2678,2679,2680,2681,2682,2683,2684,2685,2686,2687,2688,2689,2690,
2691,2692,2693,2694,2695,2696,2697,2698,2699,1542, 880,2700,2701,2702,2703,2704,
2705,2706,2707,2708,2709,2710,2711,2712,2713,2714,2715,2716,2717,2718,2719,2720,
2721,2722,2723,2724,2725,1543,2726,2727,2728,2729,2730,2731,2732,1544,2733,2734,
2735,2736,2737,2738,2739,2740,2741,2742,2743,2744,2745,2746,2747,2748,2749,2750,
2751,2752,2753,2754,1545,2755,2756,2757,2758,2759,2760,2761,2762,2763,2764,2765,
2766,1546,2767,1547,2768,2769,2770,2771,2772,2773,2774,2775,2776,2777,2778,2779,
2780,2781,2782,2783,2784,2785,2786,1548,2787,2788,2789,1109,2790,2791,2792,2793,
2794,2795,2796,2797,2798,2799,2800,2801,2802,2803,2804,2805,2806,2807,2808,2809,
2810,2811,2812,1329,2813,2814,2815,2816,2817,2818,2819,2820,2821,2822,2823,2824,
2825,2826,2827,2828,2829,2830,2831,2832,2833,2834,2835,2836,2837,2838,2839,2840,
2841,2842,2843,2844,2845,2846,2847,2848,2849,2850,2851,2852,2853,2854,2855,2856,
1549,2857,2858,2859,2860,1550,2861,2862,1551,2863,2864,2865,2866,2867,2868,2869,
2870,2871,2872,2873,2874,1110,1330,2875,2876,2877,2878,2879,2880,2881,2882,2883,
2884,2885,2886,2887,2888,2889,2890,2891,2892,2893,2894,2895,2896,2897,2898,2899,
2900,2901,2902,2903,2904,2905,2906,2907,2908,2909,2910,2911,2912,2913,2914,2915,
2916,2917,2918,2919,2920,2921,2922,2923,2924,2925,2926,2927,2928,2929,2930,1331,
2931,2932,2933,2934,2935,2936,2937,2938,2939,2940,2941,2942,2943,1552,2944,2945,
2946,2947,2948,2949,2950,2951,2952,2953,2954,2955,2956,2957,2958,2959,2960,2961,
2962,2963,2964,1252,2965,2966,2967,2968,2969,2970,2971,2972,2973,2974,2975,2976,
2977,2978,2979,2980,2981,2982,2983,2984,2985,2986,2987,2988,2989,2990,2991,2992,
2993,2994,2995,2996,2997,2998,2999,3000,3001,3002,3003,3004,3005,3006,3007,3008,
3009,3010,3011,3012,1553,3013,3014,3015,3016,3017,1554,3018,1332,3019,3020,3021,
3022,3023,3024,3025,3026,3027,3028,3029,3030,3031,3032,3033,3034,3035,3036,3037,
3038,3039,3040,3041,3042,3043,3044,3045,3046,3047,3048,3049,3050,1555,3051,3052,
3053,1556,1557,3054,3055,3056,3057,3058,3059,3060,3061,3062,3063,3064,3065,3066,
3067,1558,3068,3069,3070,3071,3072,3073,3074,3075,3076,1559,3077,3078,3079,3080,
3081,3082,3083,1253,3084,3085,3086,3087,3088,3089,3090,3091,3092,3093,3094,3095,
3096,3097,3098,3099,3100,3101,3102,3103,3104,3105,3106,3107,3108,1152,3109,3110,
3111,3112,3113,1560,3114,3115,3116,3117,1111,3118,3119,3120,3121,3122,3123,3124,
3125,3126,3127,3128,3129,3130,3131,3132,3133,3134,3135,3136,3137,3138,3139,3140,
3141,3142,3143,3144,3145,3146,3147,3148,3149,3150,3151,3152,3153,3154,3155,3156,
3157,3158,3159,3160,3161,3162,3163,3164,3165,3166,3167,3168,3169,3170,3171,3172,
3173,3174,3175,3176,1333,3177,3178,3179,3180,3181,3182,3183,3184,3185,3186,3187,
3188,3189,1561,3190,3191,1334,3192,3193,3194,3195,3196,3197,3198,3199,3200,3201,
3202,3203,3204,3205,3206,3207,3208,3209,3210,3211,3212,3213,3214,3215,3216,3217,
3218,3219,3220,3221,3222,3223,3224,3225,3226,3227,3228,3229,3230,3231,3232,3233,
3234,1562,3235,3236,3237,3238,3239,3240,3241,3242,3243,3244,3245,3246,3247,3248,
3249,3250,3251,3252,3253,3254,3255,3256,3257,3258,3259,3260,3261,3262,3263,3264,
3265,3266,3267,3268,3269,3270,3271,3272,3273,3274,3275,3276,3277,1563,3278,3279,
3280,3281,3282,3283,3284,3285,3286,3287,3288,3289,3290,3291,3292,3293,3294,3295,
3296,3297,3298,3299,3300,3301,3302,3303,3304,3305,3306,3307,3308,3309,3310,3311,
3312,3313,3314,3315,3316,3317,3318,3319,3320,3321,3322,3323,3324,3325,3326,3327,
3328,3329,3330,3331,3332,3333,3334,3335,3336,3337,3338,3339,3340,3341,3342,3343,
3344,3345,3346,3347,3348,3349,3350,3351,3352,3353,3354,3355,3356,3357,3358,3359,
3360,3361,3362,3363,3364,1335,3365,3366,3367,3368,3369,3370,3371,3372,3373,3374,
3375,3376,3377,3378,3379,3380,3381,3382,3383,3384,3385,3386,3387,1336,3388,3389,
3390,3391,3392,3393,3394,3395,3396,3397,3398,3399,3400,3401,3402,3403,3404,3405,
3406,3407,3408,3409,3410,3411,3412,3413,3414,1337,3415,3416,3417,3418,3419,1338,
3420,3421,3422,1564,1565,3423,3424,3425,3426,3427,3428,3429,3430,3431,1254,3432,
3433,3434,1339,3435,3436,3437,3438,3439,1566,3440,3441,3442,3443,3444,3445,3446,
3447,3448,3449,3450,3451,3452,3453,3454,1255,3455,3456,3457,3458,3459,1567,1191,
3460,1568,1569,3461,3462,3463,1570,3464,3465,3466,3467,3468,1571,3469,3470,3471,
3472,3473,1572,3474,3475,3476,3477,3478,3479,3480,3481,3482,3483,3484,3485,3486,
1340,3487,3488,3489,3490,3491,3492,1021,3493,3494,3495,3496,3497,3498,1573,3499,
1341,3500,3501,3502,3503,3504,3505,3506,3507,3508,3509,3510,3511,1342,3512,3513,
3514,3515,3516,1574,1343,3517,3518,3519,1575,3520,1576,3521,3522,3523,3524,3525,
3526,3527,3528,3529,3530,3531,3532,3533,3534,3535,3536,3537,3538,3539,3540,3541,
3542,3543,3544,3545,3546,3547,3548,3549,3550,3551,3552,3553,3554,3555,3556,3557,
3558,3559,3560,3561,3562,3563,3564,3565,3566,3567,3568,3569,3570,3571,3572,3573,
3574,3575,3576,3577,3578,3579,3580,1577,3581,3582,1578,3583,3584,3585,3586,3587,
3588,3589,3590,3591,3592,3593,3594,3595,3596,3597,3598,3599,3600,3601,3602,3603,
3604,1579,3605,3606,3607,3608,3609,3610,3611,3612,3613,3614,3615,3616,3617,3618,
3619,3620,3621,3622,3623,3624,3625,3626,3627,3628,3629,1580,3630,3631,1581,3632,
3633,3634,3635,3636,3637,3638,3639,3640,3641,3642,3643,3644,3645,3646,3647,3648,
3649,3650,3651,3652,3653,3654,3655,3656,1582,3657,3658,3659,3660,3661,3662,3663,
3664,3665,3666,3667,3668,3669,3670,3671,3672,3673,3674,3675,3676,3677,3678,3679,
3680,3681,3682,3683,3684,3685,3686,3687,3688,3689,3690,3691,3692,3693,3694,3695,
3696,3697,3698,3699,3700,1192,3701,3702,3703,3704,1256,3705,3706,3707,3708,1583,
1257,3709,3710,3711,3712,3713,3714,3715,3716,1584,3717,3718,3719,3720,3721,3722,
3723,3724,3725,3726,3727,3728,3729,3730,3731,3732,3733,3734,3735,3736,3737,3738,
3739,3740,3741,3742,3743,3744,3745,1344,3746,3747,3748,3749,3750,3751,3752,3753,
3754,3755,3756,1585,3757,3758,3759,3760,3761,3762,3763,3764,3765,3766,1586,3767,
3768,3769,3770,3771,3772,3773,3774,3775,3776,3777,3778,1345,3779,3780,3781,3782,
3783,3784,3785,3786,3787,3788,3789,3790,3791,3792,3793,3794,3795,1346,1587,3796,
3797,1588,3798,3799,3800,3801,3802,3803,3804,3805,3806,1347,3807,3808,3809,3810,
3811,1589,3812,3813,3814,3815,3816,3817,3818,3819,3820,3821,1590,3822,3823,1591,
1348,3824,3825,3826,3827,3828,3829,3830,1592,3831,3832,1593,3833,3834,3835,3836,
3837,3838,3839,3840,3841,3842,3843,3844,1349,3845,3846,3847,3848,3849,3850,3851,
3852,3853,3854,3855,3856,3857,3858,1594,3859,3860,3861,3862,3863,3864,3865,3866,
3867,3868,3869,1595,3870,3871,3872,3873,1596,3874,3875,3876,3877,3878,3879,3880,
3881,3882,3883,3884,3885,3886,1597,3887,3888,3889,3890,3891,3892,3893,3894,3895,
1598,3896,3897,3898,1599,1600,3899,1350,3900,1351,3901,3902,1352,3903,3904,3905,
3906,3907,3908,3909,3910,3911,3912,3913,3914,3915,3916,3917,3918,3919,3920,3921,
3922,3923,3924,1258,3925,3926,3927,3928,3929,3930,3931,1193,3932,1601,3933,3934,
3935,3936,3937,3938,3939,3940,3941,3942,3943,1602,3944,3945,3946,3947,3948,1603,
3949,3950,3951,3952,3953,3954,3955,3956,3957,3958,3959,3960,3961,3962,3963,3964,
3965,1604,3966,3967,3968,3969,3970,3971,3972,3973,3974,3975,3976,3977,1353,3978,
3979,3980,3981,3982,3983,3984,3985,3986,3987,3988,3989,3990,3991,1354,3992,3993,
3994,3995,3996,3997,3998,3999,4000,4001,4002,4003,4004,4005,4006,4007,4008,4009,
4010,4011,4012,4013,4014,4015,4016,4017,4018,4019,4020,4021,4022,4023,1355,4024,
4025,4026,4027,4028,4029,4030,4031,4032,4033,4034,4035,4036,4037,4038,4039,4040,
1605,4041,4042,4043,4044,4045,4046,4047,4048,4049,4050,4051,4052,4053,4054,4055,
4056,4057,4058,4059,4060,1606,4061,4062,4063,4064,1607,4065,4066,4067,4068,4069,
4070,4071,4072,4073,4074,4075,4076,1194,4077,4078,1608,4079,4080,4081,4082,4083,
4084,4085,4086,4087,1609,4088,4089,4090,4091,4092,4093,4094,4095,4096,4097,4098,
4099,4100,4101,4102,4103,4104,4105,4106,4107,4108,1259,4109,4110,4111,4112,4113,
4114,4115,4116,4117,4118,4119,4120,4121,4122,4123,4124,1195,4125,4126,4127,1610,
4128,4129,4130,4131,4132,4133,4134,4135,4136,4137,1356,4138,4139,4140,4141,4142,
4143,4144,1611,4145,4146,4147,4148,4149,4150,4151,4152,4153,4154,4155,4156,4157,
4158,4159,4160,4161,4162,4163,4164,4165,4166,4167,4168,4169,4170,4171,4172,4173,
4174,4175,4176,4177,4178,4179,4180,4181,4182,4183,4184,4185,4186,4187,4188,4189,
4190,4191,4192,4193,4194,4195,4196,4197,4198,4199,4200,4201,4202,4203,4204,4205,
4206,4207,4208,4209,4210,4211,4212,4213,4214,4215,4216,4217,4218,4219,1612,4220,
4221,4222,4223,4224,4225,4226,4227,1357,4228,1613,4229,4230,4231,4232,4233,4234,
4235,4236,4237,4238,4239,4240,4241,4242,4243,1614,4244,4245,4246,4247,4248,4249,
4250,4251,4252,4253,4254,4255,4256,4257,4258,4259,4260,4261,4262,4263,4264,4265,
4266,4267,4268,4269,4270,1196,1358,4271,4272,4273,4274,4275,4276,4277,4278,4279,
4280,4281,4282,4283,4284,4285,4286,4287,1615,4288,4289,4290,4291,4292,4293,4294,
4295,4296,4297,4298,4299,4300,4301,4302,4303,4304,4305,4306,4307,4308,4309,4310,
4311,4312,4313,4314,4315,4316,4317,4318,4319,4320,4321,4322,4323,4324,4325,4326,
4327,4328,4329,4330,4331,4332,4333,4334,1616,4335,4336,4337,4338,4339,4340,4341,
4342,4343,4344,4345,4346,4347,4348,4349,4350,4351,4352,4353,4354,4355,4356,4357,
4358,4359,4360,1617,4361,4362,4363,4364,4365,1618,4366,4367,4368,4369,4370,4371,
4372,4373,4374,4375,4376,4377,4378,4379,4380,4381,4382,4383,4384,4385,4386,4387,
4388,4389,4390,4391,4392,4393,4394,4395,4396,4397,4398,4399,4400,4401,4402,4403,
4404,4405,4406,4407,4408,4409,4410,4411,4412,4413,4414,4415,4416,1619,4417,4418,
4419,4420,4421,4422,4423,4424,4425,1112,4426,4427,4428,4429,4430,1620,4431,4432,
4433,4434,4435,4436,4437,4438,4439,4440,4441,4442,1260,1261,4443,4444,4445,4446,
4447,4448,4449,4450,4451,4452,4453,4454,4455,1359,4456,4457,4458,4459,4460,4461,
4462,4463,4464,4465,1621,4466,4467,4468,4469,4470,4471,4472,4473,4474,4475,4476,
4477,4478,4479,4480,4481,4482,4483,4484,4485,4486,4487,4488,4489,1055,4490,4491,
4492,4493,4494,4495,4496,4497,4498,4499,4500,4501,4502,4503,4504,4505,4506,4507,
4508,4509,4510,4511,4512,4513,4514,4515,4516,4517,4518,1622,4519,4520,4521,1623,
4522,4523,4524,4525,4526,4527,4528,4529,4530,4531,4532,4533,4534,4535,1360,4536,
4537,4538,4539,4540,4541,4542,4543, 975,4544,4545,4546,4547,4548,4549,4550,4551,
4552,4553,4554,4555,4556,4557,4558,4559,4560,4561,4562,4563,4564,4565,4566,4567,
4568,4569,4570,4571,1624,4572,4573,4574,4575,4576,1625,4577,4578,4579,4580,4581,
4582,4583,4584,1626,4585,4586,4587,4588,4589,4590,4591,4592,4593,4594,4595,1627,
4596,4597,4598,4599,4600,4601,4602,4603,4604,4605,4606,4607,4608,4609,4610,4611,
4612,4613,4614,4615,1628,4616,4617,4618,4619,4620,4621,4622,4623,4624,4625,4626,
4627,4628,4629,4630,4631,4632,4633,4634,4635,4636,4637,4638,4639,4640,4641,4642,
4643,4644,4645,4646,4647,4648,4649,1361,4650,4651,4652,4653,4654,4655,4656,4657,
4658,4659,4660,4661,1362,4662,4663,4664,4665,4666,4667,4668,4669,4670,4671,4672,
4673,4674,4675,4676,4677,4678,4679,4680,4681,4682,1629,4683,4684,4685,4686,4687,
1630,4688,4689,4690,4691,1153,4692,4693,4694,1113,4695,4696,4697,4698,4699,4700,
4701,4702,4703,4704,4705,4706,4707,4708,4709,4710,4711,1197,4712,4713,4714,4715,
4716,4717,4718,4719,4720,4721,4722,4723,4724,4725,4726,4727,4728,4729,4730,4731,
4732,4733,4734,4735,1631,4736,1632,4737,4738,4739,4740,4741,4742,4743,4744,1633,
4745,4746,4747,4748,4749,1262,4750,4751,4752,4753,4754,1363,4755,4756,4757,4758,
4759,4760,4761,4762,4763,4764,4765,4766,4767,4768,1634,4769,4770,4771,4772,4773,
4774,4775,4776,4777,4778,1635,4779,4780,4781,4782,4783,4784,4785,4786,4787,4788,
4789,1636,4790,4791,4792,4793,4794,4795,4796,4797,4798,4799,4800,4801,4802,4803,
4804,4805,4806,1637,4807,4808,4809,1638,4810,4811,4812,4813,4814,4815,4816,4817,
4818,1639,4819,4820,4821,4822,4823,4824,4825,4826,4827,4828,4829,4830,4831,4832,
4833,1077,4834,4835,4836,4837,4838,4839,4840,4841,4842,4843,4844,4845,4846,4847,
4848,4849,4850,4851,4852,4853,4854,4855,4856,4857,4858,4859,4860,4861,4862,4863,
4864,4865,4866,4867,4868,4869,4870,4871,4872,4873,4874,4875,4876,4877,4878,4879,
4880,4881,4882,4883,1640,4884,4885,1641,4886,4887,4888,4889,4890,4891,4892,4893,
4894,4895,4896,4897,4898,4899,4900,4901,4902,4903,4904,4905,4906,4907,4908,4909,
4910,4911,1642,4912,4913,4914,1364,4915,4916,4917,4918,4919,4920,4921,4922,4923,
4924,4925,4926,4927,4928,4929,4930,4931,1643,4932,4933,4934,4935,4936,4937,4938,
4939,4940,4941,4942,4943,4944,4945,4946,4947,4948,4949,4950,4951,4952,4953,4954,
4955,4956,4957,4958,4959,4960,4961,4962,4963,4964,4965,4966,4967,4968,4969,4970,
4971,4972,4973,4974,4975,4976,4977,4978,4979,4980,1644,4981,4982,4983,4984,1645,
4985,4986,1646,4987,4988,4989,4990,4991,4992,4993,4994,4995,4996,4997,4998,4999,
5000,5001,5002,5003,5004,5005,1647,5006,1648,5007,5008,5009,5010,5011,5012,1078,
5013,5014,5015,5016,5017,5018,5019,5020,5021,5022,5023,5024,5025,5026,5027,5028,
1365,5029,5030,5031,5032,5033,5034,5035,5036,5037,5038,5039,1649,5040,5041,5042,
5043,5044,5045,1366,5046,5047,5048,5049,5050,5051,5052,5053,5054,5055,1650,5056,
5057,5058,5059,5060,5061,5062,5063,5064,5065,5066,5067,5068,5069,5070,5071,5072,
5073,5074,5075,5076,5077,1651,5078,5079,5080,5081,5082,5083,5084,5085,5086,5087,
5088,5089,5090,5091,5092,5093,5094,5095,5096,5097,5098,5099,5100,5101,5102,5103,
5104,5105,5106,5107,5108,5109,5110,1652,5111,5112,5113,5114,5115,5116,5117,5118,
1367,5119,5120,5121,5122,5123,5124,5125,5126,5127,5128,5129,1653,5130,5131,5132,
5133,5134,5135,5136,5137,5138,5139,5140,5141,5142,5143,5144,5145,5146,5147,5148,
5149,1368,5150,1654,5151,1369,5152,5153,5154,5155,5156,5157,5158,5159,5160,5161,
5162,5163,5164,5165,5166,5167,5168,5169,5170,5171,5172,5173,5174,5175,5176,5177,
5178,1370,5179,5180,5181,5182,5183,5184,5185,5186,5187,5188,5189,5190,5191,5192,
5193,5194,5195,5196,5197,5198,1655,5199,5200,5201,5202,1656,5203,5204,5205,5206,
1371,5207,1372,5208,5209,5210,5211,1373,5212,5213,1374,5214,5215,5216,5217,5218,
5219,5220,5221,5222,5223,5224,5225,5226,5227,5228,5229,5230,5231,5232,5233,5234,
5235,5236,5237,5238,5239,5240,5241,5242,5243,5244,5245,5246,5247,1657,5248,5249,
5250,5251,1658,1263,5252,5253,5254,5255,5256,1375,5257,5258,5259,5260,5261,5262,
5263,5264,5265,5266,5267,5268,5269,5270,5271,5272,5273,5274,5275,5276,5277,5278,
5279,5280,5281,5282,5283,1659,5284,5285,5286,5287,5288,5289,5290,5291,5292,5293,
5294,5295,5296,5297,5298,5299,5300,1660,5301,5302,5303,5304,5305,5306,5307,5308,
5309,5310,5311,5312,5313,5314,5315,5316,5317,5318,5319,5320,5321,1376,5322,5323,
5324,5325,5326,5327,5328,5329,5330,5331,5332,5333,1198,5334,5335,5336,5337,5338,
5339,5340,5341,5342,5343,1661,5344,5345,5346,5347,5348,5349,5350,5351,5352,5353,
5354,5355,5356,5357,5358,5359,5360,5361,5362,5363,5364,5365,5366,5367,5368,5369,
5370,5371,5372,5373,5374,5375,5376,5377,5378,5379,5380,5381,5382,5383,5384,5385,
5386,5387,5388,5389,5390,5391,5392,5393,5394,5395,5396,5397,5398,1264,5399,5400,
5401,5402,5403,5404,5405,5406,5407,5408,5409,5410,5411,5412,1662,5413,5414,5415,
5416,1663,5417,5418,5419,5420,5421,5422,5423,5424,5425,5426,5427,5428,5429,5430,
5431,5432,5433,5434,5435,5436,5437,5438,1664,5439,5440,5441,5442,5443,5444,5445,
5446,5447,5448,5449,5450,5451,5452,5453,5454,5455,5456,5457,5458,5459,5460,5461,
5462,5463,5464,5465,5466,5467,5468,5469,5470,5471,5472,5473,5474,5475,5476,5477,
5478,1154,5479,5480,5481,5482,5483,5484,5485,1665,5486,5487,5488,5489,5490,5491,
5492,5493,5494,5495,5496,5497,5498,5499,5500,5501,5502,5503,5504,5505,5506,5507,
5508,5509,5510,5511,5512,5513,5514,5515,5516,5517,5518,5519,5520,5521,5522,5523,
5524,5525,5526,5527,5528,5529,5530,5531,5532,5533,5534,5535,5536,5537,5538,5539,
5540,5541,5542,5543,5544,5545,5546,5547,5548,1377,5549,5550,5551,5552,5553,5554,
5555,5556,5557,5558,5559,5560,5561,5562,5563,5564,5565,5566,5567,5568,5569,5570,
1114,5571,5572,5573,5574,5575,5576,5577,5578,5579,5580,5581,5582,5583,5584,5585,
5586,5587,5588,5589,5590,5591,5592,1378,5593,5594,5595,5596,5597,5598,5599,5600,
5601,5602,5603,5604,5605,5606,5607,5608,5609,5610,5611,5612,5613,5614,1379,5615,
5616,5617,5618,5619,5620,5621,5622,5623,5624,5625,5626,5627,5628,5629,5630,5631,
5632,5633,5634,1380,5635,5636,5637,5638,5639,5640,5641,5642,5643,5644,5645,5646,
5647,5648,5649,1381,1056,5650,5651,5652,5653,5654,5655,5656,5657,5658,5659,5660,
1666,5661,5662,5663,5664,5665,5666,5667,5668,1667,5669,1668,5670,5671,5672,5673,
5674,5675,5676,5677,5678,1155,5679,5680,5681,5682,5683,5684,5685,5686,5687,5688,
5689,5690,5691,5692,5693,5694,5695,5696,5697,5698,1669,5699,5700,5701,5702,5703,
5704,5705,1670,5706,5707,5708,5709,5710,1671,5711,5712,5713,5714,1382,5715,5716,
5717,5718,5719,5720,5721,5722,5723,5724,5725,1672,5726,5727,1673,1674,5728,5729,
5730,5731,5732,5733,5734,5735,5736,1675,5737,5738,5739,5740,5741,5742,5743,5744,
1676,5745,5746,5747,5748,5749,5750,5751,1383,5752,5753,5754,5755,5756,5757,5758,
5759,5760,5761,5762,5763,5764,5765,5766,5767,5768,1677,5769,5770,5771,5772,5773,
1678,5774,5775,5776, 998,5777,5778,5779,5780,5781,5782,5783,5784,5785,1384,5786,
5787,5788,5789,5790,5791,5792,5793,5794,5795,5796,5797,5798,5799,5800,1679,5801,
5802,5803,1115,1116,5804,5805,5806,5807,5808,5809,5810,5811,5812,5813,5814,5815,
5816,5817,5818,5819,5820,5821,5822,5823,5824,5825,5826,5827,5828,5829,5830,5831,
5832,5833,5834,5835,5836,5837,5838,5839,5840,5841,5842,5843,5844,5845,5846,5847,
5848,5849,5850,5851,5852,5853,5854,5855,1680,5856,5857,5858,5859,5860,5861,5862,
5863,5864,1681,5865,5866,5867,1682,5868,5869,5870,5871,5872,5873,5874,5875,5876,
5877,5878,5879,1683,5880,1684,5881,5882,5883,5884,1685,5885,5886,5887,5888,5889,
5890,5891,5892,5893,5894,5895,5896,5897,5898,5899,5900,5901,5902,5903,5904,5905,
5906,5907,1686,5908,5909,5910,5911,5912,5913,5914,5915,5916,5917,5918,5919,5920,
5921,5922,5923,5924,5925,5926,5927,5928,5929,5930,5931,5932,5933,5934,5935,1687,
5936,5937,5938,5939,5940,5941,5942,5943,5944,5945,5946,5947,5948,5949,5950,5951,
5952,1688,1689,5953,1199,5954,5955,5956,5957,5958,5959,5960,5961,1690,5962,5963,
5964,5965,5966,5967,5968,5969,5970,5971,5972,5973,5974,5975,5976,5977,5978,5979,
5980,5981,1385,5982,1386,5983,5984,5985,5986,5987,5988,5989,5990,5991,5992,5993,
5994,5995,5996,5997,5998,5999,6000,6001,6002,6003,6004,6005,6006,6007,6008,6009,
6010,6011,6012,6013,6014,6015,6016,6017,6018,6019,6020,6021,6022,6023,6024,6025,
6026,6027,1265,6028,6029,1691,6030,6031,6032,6033,6034,6035,6036,6037,6038,6039,
6040,6041,6042,6043,6044,6045,6046,6047,6048,6049,6050,6051,6052,6053,6054,6055,
6056,6057,6058,6059,6060,6061,6062,6063,6064,6065,6066,6067,6068,6069,6070,6071,
6072,6073,6074,6075,6076,6077,6078,6079,6080,6081,6082,6083,6084,1692,6085,6086,
6087,6088,6089,6090,6091,6092,6093,6094,6095,6096,6097,6098,6099,6100,6101,6102,
6103,6104,6105,6106,6107,6108,6109,6110,6111,6112,6113,6114,6115,6116,6117,6118,
6119,6120,6121,6122,6123,6124,6125,6126,6127,6128,6129,6130,6131,1693,6132,6133,
6134,6135,6136,1694,6137,6138,6139,6140,6141,1695,6142,6143,6144,6145,6146,6147,
6148,6149,6150,6151,6152,6153,6154,6155,6156,6157,6158,6159,6160,6161,6162,6163,
6164,6165,6166,6167,6168,6169,6170,6171,6172,6173,6174,6175,6176,6177,6178,6179,
6180,6181,6182,6183,6184,6185,1696,6186,6187,6188,6189,6190,6191,6192,6193,6194,
6195,6196,6197,6198,6199,6200,6201,6202,6203,6204,6205,6206,6207,6208,6209,6210,
6211,6212,6213,6214,6215,6216,6217,6218,6219,1697,6220,6221,6222,6223,6224,6225,
6226,6227,6228,6229,6230,6231,6232,6233,6234,6235,6236,6237,6238,6239,6240,6241,
6242,6243,6244,6245,6246,6247,6248,6249,6250,6251,6252,6253,1698,6254,6255,6256,
6257,6258,6259,6260,6261,6262,6263,1200,6264,6265,6266,6267,6268,6269,6270,6271,  #1024
6272,6273,6274,6275,6276,6277,6278,6279,6280,6281,6282,6283,6284,6285,6286,6287,
6288,6289,6290,6291,6292,6293,6294,6295,6296,6297,6298,6299,6300,6301,6302,1699,
6303,6304,1700,6305,6306,6307,6308,6309,6310,6311,6312,6313,6314,6315,6316,6317,
6318,6319,6320,6321,6322,6323,6324,6325,6326,6327,6328,6329,6330,6331,6332,6333,
6334,6335,6336,6337,6338,6339,1701,6340,6341,6342,6343,6344,1387,6345,6346,6347,
6348,6349,6350,6351,6352,6353,6354,6355,6356,6357,6358,6359,6360,6361,6362,6363,
6364,6365,6366,6367,6368,6369,6370,6371,6372,6373,6374,6375,6376,6377,6378,6379,
6380,6381,6382,6383,6384,6385,6386,6387,6388,6389,6390,6391,6392,6393,6394,6395,
6396,6397,6398,6399,6400,6401,6402,6403,6404,6405,6406,6407,6408,6409,6410,6411,
6412,6413,1702,6414,6415,6416,6417,6418,6419,6420,6421,6422,1703,6423,6424,6425,
6426,6427,6428,6429,6430,6431,6432,6433,6434,6435,6436,6437,6438,1704,6439,6440,
6441,6442,6443,6444,6445,6446,6447,6448,6449,6450,6451,6452,6453,6454,6455,6456,
6457,6458,6459,6460,6461,6462,6463,6464,6465,6466,6467,6468,6469,6470,6471,6472,
6473,6474,6475,6476,6477,6478,6479,6480,6481,6482,6483,6484,6485,6486,6487,6488,
6489,6490,6491,6492,6493,6494,6495,6496,6497,6498,6499,6500,6501,6502,6503,1266,
6504,6505,6506,6507,6508,6509,6510,6511,6512,6513,6514,6515,6516,6517,6518,6519,
6520,6521,6522,6523,6524,6525,6526,6527,6528,6529,6530,6531,6532,6533,6534,6535,
6536,6537,6538,6539,6540,6541,6542,6543,6544,6545,6546,6547,6548,6549,6550,6551,
1705,1706,6552,6553,6554,6555,6556,6557,6558,6559,6560,6561,6562,6563,6564,6565,
6566,6567,6568,6569,6570,6571,6572,6573,6574,6575,6576,6577,6578,6579,6580,6581,
6582,6583,6584,6585,6586,6587,6588,6589,6590,6591,6592,6593,6594,6595,6596,6597,
6598,6599,6600,6601,6602,6603,6604,6605,6606,6607,6608,6609,6610,6611,6612,6613,
6614,6615,6616,6617,6618,6619,6620,6621,6622,6623,6624,6625,6626,6627,6628,6629,
6630,6631,6632,6633,6634,6635,6636,6637,1388,6638,6639,6640,6641,6642,6643,6644,
1707,6645,6646,6647,6648,6649,6650,6651,6652,6653,6654,6655,6656,6657,6658,6659,
6660,6661,6662,6663,1708,6664,6665,6666,6667,6668,6669,6670,6671,6672,6673,6674,
1201,6675,6676,6677,6678,6679,6680,6681,6682,6683,6684,6685,6686,6687,6688,6689,
6690,6691,6692,6693,6694,6695,6696,6697,6698,6699,6700,6701,6702,6703,6704,6705,
6706,6707,6708,6709,6710,6711,6712,6713,6714,6715,6716,6717,6718,6719,6720,6721,
6722,6723,6724,6725,1389,6726,6727,6728,6729,6730,6731,6732,6733,6734,6735,6736,
1390,1709,6737,6738,6739,6740,6741,6742,1710,6743,6744,6745,6746,1391,6747,6748,
6749,6750,6751,6752,6753,6754,6755,6756,6757,1392,6758,6759,6760,6761,6762,6763,
6764,6765,6766,6767,6768,6769,6770,6771,6772,6773,6774,6775,6776,6777,6778,6779,
6780,1202,6781,6782,6783,6784,6785,6786,6787,6788,6789,6790,6791,6792,6793,6794,
6795,6796,6797,6798,6799,6800,6801,6802,6803,6804,6805,6806,6807,6808,6809,1711,
6810,6811,6812,6813,6814,6815,6816,6817,6818,6819,6820,6821,6822,6823,6824,6825,
6826,6827,6828,6829,6830,6831,6832,6833,6834,6835,6836,1393,6837,6838,6839,6840,
6841,6842,6843,6844,6845,6846,6847,6848,6849,6850,6851,6852,6853,6854,6855,6856,
6857,6858,6859,6860,6861,6862,6863,6864,6865,6866,6867,6868,6869,6870,6871,6872,
6873,6874,6875,6876,6877,6878,6879,6880,6881,6882,6883,6884,6885,6886,6887,6888,
6889,6890,6891,6892,6893,6894,6895,6896,6897,6898,6899,6900,6901,6902,1712,6903,
6904,6905,6906,6907,6908,6909,6910,1713,6911,6912,6913,6914,6915,6916,6917,6918,
6919,6920,6921,6922,6923,6924,6925,6926,6927,6928,6929,6930,6931,6932,6933,6934,
6935,6936,6937,6938,6939,6940,6941,6942,6943,6944,6945,6946,6947,6948,6949,6950,
6951,6952,6953,6954,6955,6956,6957,6958,6959,6960,6961,6962,6963,6964,6965,6966,
6967,6968,6969,6970,6971,6972,6973,6974,1714,6975,6976,6977,6978,6979,6980,6981,
6982,6983,6984,6985,6986,6987,6988,1394,6989,6990,6991,6992,6993,6994,6995,6996,
6997,6998,6999,7000,1715,7001,7002,7003,7004,7005,7006,7007,7008,7009,7010,7011,
7012,7013,7014,7015,7016,7017,7018,7019,7020,7021,7022,7023,7024,7025,7026,7027,
7028,1716,7029,7030,7031,7032,7033,7034,7035,7036,7037,7038,7039,7040,7041,7042,
7043,7044,7045,7046,7047,7048,7049,7050,7051,7052,7053,7054,7055,7056,7057,7058,
7059,7060,7061,7062,7063,7064,7065,7066,7067,7068,7069,7070,7071,7072,7073,7074,
7075,7076,7077,7078,7079,7080,7081,7082,7083,7084,7085,7086,7087,7088,7089,7090,
7091,7092,7093,7094,7095,7096,7097,7098,7099,7100,7101,7102,7103,7104,7105,7106,
7107,7108,7109,7110,7111,7112,7113,7114,7115,7116,7117,7118,7119,7120,7121,7122,
7123,7124,7125,7126,7127,7128,7129,7130,7131,7132,7133,7134,7135,7136,7137,7138,
7139,7140,7141,7142,7143,7144,7145,7146,7147,7148,7149,7150,7151,7152,7153,7154,
7155,7156,7157,7158,7159,7160,7161,7162,7163,7164,7165,7166,7167,7168,7169,7170,
7171,7172,7173,7174,7175,7176,7177,7178,7179,7180,7181,7182,7183,7184,7185,7186,
7187,7188,7189,7190,7191,7192,7193,7194,7195,7196,7197,7198,7199,7200,7201,7202,
7203,7204,7205,7206,7207,1395,7208,7209,7210,7211,7212,7213,1717,7214,7215,7216,
7217,7218,7219,7220,7221,7222,7223,7224,7225,7226,7227,7228,7229,7230,7231,7232,
7233,7234,7235,7236,7237,7238,7239,7240,7241,7242,7243,7244,7245,7246,7247,7248,
7249,7250,7251,7252,7253,7254,7255,7256,7257,7258,7259,7260,7261,7262,7263,7264,
7265,7266,7267,7268,7269,7270,7271,7272,7273,7274,7275,7276,7277,7278,7279,7280,
7281,7282,7283,7284,7285,7286,7287,7288,7289,7290,7291,7292,7293,7294,7295,7296,
7297,7298,7299,7300,7301,7302,7303,7304,7305,7306,7307,7308,7309,7310,7311,7312,
7313,1718,7314,7315,7316,7317,7318,7319,7320,7321,7322,7323,7324,7325,7326,7327,
7328,7329,7330,7331,7332,7333,7334,7335,7336,7337,7338,7339,7340,7341,7342,7343,
7344,7345,7346,7347,7348,7349,7350,7351,7352,7353,7354,7355,7356,7357,7358,7359,
7360,7361,7362,7363,7364,7365,7366,7367,7368,7369,7370,7371,7372,7373,7374,7375,
7376,7377,7378,7379,7380,7381,7382,7383,7384,7385,7386,7387,7388,7389,7390,7391,
7392,7393,7394,7395,7396,7397,7398,7399,7400,7401,7402,7403,7404,7405,7406,7407,
7408,7409,7410,7411,7412,7413,7414,7415,7416,7417,7418,7419,7420,7421,7422,7423,
7424,7425,7426,7427,7428,7429,7430,7431,7432,7433,7434,7435,7436,7437,7438,7439,
7440,7441,7442,7443,7444,7445,7446,7447,7448,7449,7450,7451,7452,7453,7454,7455,
7456,7457,7458,7459,7460,7461,7462,7463,7464,7465,7466,7467,7468,7469,7470,7471,
7472,7473,7474,7475,7476,7477,7478,7479,7480,7481,7482,7483,7484,7485,7486,7487,
7488,7489,7490,7491,7492,7493,7494,7495,7496,7497,7498,7499,7500,7501,7502,7503,
7504,7505,7506,7507,7508,7509,7510,7511,7512,7513,7514,7515,7516,7517,7518,7519,
7520,7521,7522,7523,7524,7525,7526,7527,7528,7529,7530,7531,7532,7533,7534,7535,
7536,7537,7538,7539,7540,7541,7542,7543,7544,7545,7546,7547,7548,7549,7550,7551,
7552,7553,7554,7555,7556,7557,7558,7559,7560,7561,7562,7563,7564,7565,7566,7567,
7568,7569,7570,7571,7572,7573,7574,7575,7576,7577,7578,7579,7580,7581,7582,7583,
7584,7585,7586,7587,7588,7589,7590,7591,7592,7593,7594,7595,7596,7597,7598,7599,
7600,7601,7602,7603,7604,7605,7606,7607,7608,7609,7610,7611,7612,7613,7614,7615,
7616,7617,7618,7619,7620,7621,7622,7623,7624,7625,7626,7627,7628,7629,7630,7631,
7632,7633,7634,7635,7636,7637,7638,7639,7640,7641,7642,7643,7644,7645,7646,7647,
7648,7649,7650,7651,7652,7653,7654,7655,7656,7657,7658,7659,7660,7661,7662,7663,
7664,7665,7666,7667,7668,7669,7670,7671,7672,7673,7674,7675,7676,7677,7678,7679,
7680,7681,7682,7683,7684,7685,7686,7687,7688,7689,7690,7691,7692,7693,7694,7695,
7696,7697,7698,7699,7700,7701,7702,7703,7704,7705,7706,7707,7708,7709,7710,7711,
7712,7713,7714,7715,7716,7717,7718,7719,7720,7721,7722,7723,7724,7725,7726,7727,
7728,7729,7730,7731,7732,7733,7734,7735,7736,7737,7738,7739,7740,7741,7742,7743,
7744,7745,7746,7747,7748,7749,7750,7751,7752,7753,7754,7755,7756,7757,7758,7759,
7760,7761,7762,7763,7764,7765,7766,7767,7768,7769,7770,7771,7772,7773,7774,7775,
7776,7777,7778,7779,7780,7781,7782,7783,7784,7785,7786,7787,7788,7789,7790,7791,
7792,7793,7794,7795,7796,7797,7798,7799,7800,7801,7802,7803,7804,7805,7806,7807,
7808,7809,7810,7811,7812,7813,7814,7815,7816,7817,7818,7819,7820,7821,7822,7823,
7824,7825,7826,7827,7828,7829,7830,7831,7832,7833,7834,7835,7836,7837,7838,7839,
7840,7841,7842,7843,7844,7845,7846,7847,7848,7849,7850,7851,7852,7853,7854,7855,
7856,7857,7858,7859,7860,7861,7862,7863,7864,7865,7866,7867,7868,7869,7870,7871,
7872,7873,7874,7875,7876,7877,7878,7879,7880,7881,7882,7883,7884,7885,7886,7887,
7888,7889,7890,7891,7892,7893,7894,7895,7896,7897,7898,7899,7900,7901,7902,7903,
7904,7905,7906,7907,7908,7909,7910,7911,7912,7913,7914,7915,7916,7917,7918,7919,
7920,7921,7922,7923,7924,7925,7926,7927,7928,7929,7930,7931,7932,7933,7934,7935,
7936,7937,7938,7939,7940,7941,7942,7943,7944,7945,7946,7947,7948,7949,7950,7951,
7952,7953,7954,7955,7956,7957,7958,7959,7960,7961,7962,7963,7964,7965,7966,7967,
7968,7969,7970,7971,7972,7973,7974,7975,7976,7977,7978,7979,7980,7981,7982,7983,
7984,7985,7986,7987,7988,7989,7990,7991,7992,7993,7994,7995,7996,7997,7998,7999,
8000,8001,8002,8003,8004,8005,8006,8007,8008,8009,8010,8011,8012,8013,8014,8015,
8016,8017,8018,8019,8020,8021,8022,8023,8024,8025,8026,8027,8028,8029,8030,8031,
8032,8033,8034,8035,8036,8037,8038,8039,8040,8041,8042,8043,8044,8045,8046,8047,
8048,8049,8050,8051,8052,8053,8054,8055,8056,8057,8058,8059,8060,8061,8062,8063,
8064,8065,8066,8067,8068,8069,8070,8071,8072,8073,8074,8075,8076,8077,8078,8079,
8080,8081,8082,8083,8084,8085,8086,8087,8088,8089,8090,8091,8092,8093,8094,8095,
8096,8097,8098,8099,8100,8101,8102,8103,8104,8105,8106,8107,8108,8109,8110,8111,
8112,8113,8114,8115,8116,8117,8118,8119,8120,8121,8122,8123,8124,8125,8126,8127,
8128,8129,8130,8131,8132,8133,8134,8135,8136,8137,8138,8139,8140,8141,8142,8143,
8144,8145,8146,8147,8148,8149,8150,8151,8152,8153,8154,8155,8156,8157,8158,8159,
8160,8161,8162,8163,8164,8165,8166,8167,8168,8169,8170,8171,8172,8173,8174,8175,
8176,8177,8178,8179,8180,8181,8182,8183,8184,8185,8186,8187,8188,8189,8190,8191,
8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,
8208,8209,8210,8211,8212,8213,8214,8215,8216,8217,8218,8219,8220,8221,8222,8223,
8224,8225,8226,8227,8228,8229,8230,8231,8232,8233,8234,8235,8236,8237,8238,8239,
8240,8241,8242,8243,8244,8245,8246,8247,8248,8249,8250,8251,8252,8253,8254,8255,
8256,8257,8258,8259,8260,8261,8262,8263,8264,8265,8266,8267,8268,8269,8270,8271,
8272,8273,8274,8275,8276,8277,8278,8279,8280,8281,8282,8283,8284,8285,8286,8287,
8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,
8304,8305,8306,8307,8308,8309,8310,8311,8312,8313,8314,8315,8316,8317,8318,8319,
8320,8321,8322,8323,8324,8325,8326,8327,8328,8329,8330,8331,8332,8333,8334,8335,
8336,8337,8338,8339,8340,8341,8342,8343,8344,8345,8346,8347,8348,8349,8350,8351,
8352,8353,8354,8355,8356,8357,8358,8359,8360,8361,8362,8363,8364,8365,8366,8367,
8368,8369,8370,8371,8372,8373,8374,8375,8376,8377,8378,8379,8380,8381,8382,8383,
8384,8385,8386,8387,8388,8389,8390,8391,8392,8393,8394,8395,8396,8397,8398,8399,
8400,8401,8402,8403,8404,8405,8406,8407,8408,8409,8410,8411,8412,8413,8414,8415,
8416,8417,8418,8419,8420,8421,8422,8423,8424,8425,8426,8427,8428,8429,8430,8431,
8432,8433,8434,8435,8436,8437,8438,8439,8440,8441,8442,8443,8444,8445,8446,8447,
8448,8449,8450,8451,8452,8453,8454,8455,8456,8457,8458,8459,8460,8461,8462,8463,
8464,8465,8466,8467,8468,8469,8470,8471,8472,8473,8474,8475,8476,8477,8478,8479,
8480,8481,8482,8483,8484,8485,8486,8487,8488,8489,8490,8491,8492,8493,8494,8495,
8496,8497,8498,8499,8500,8501,8502,8503,8504,8505,8506,8507,8508,8509,8510,8511,
8512,8513,8514,8515,8516,8517,8518,8519,8520,8521,8522,8523,8524,8525,8526,8527,
8528,8529,8530,8531,8532,8533,8534,8535,8536,8537,8538,8539,8540,8541,8542,8543,
8544,8545,8546,8547,8548,8549,8550,8551,8552,8553,8554,8555,8556,8557,8558,8559,
8560,8561,8562,8563,8564,8565,8566,8567,8568,8569,8570,8571,8572,8573,8574,8575,
8576,8577,8578,8579,8580,8581,8582,8583,8584,8585,8586,8587,8588,8589,8590,8591,
8592,8593,8594,8595,8596,8597,8598,8599,8600,8601,8602,8603,8604,8605,8606,8607,
8608,8609,8610,8611,8612,8613,8614,8615,8616,8617,8618,8619,8620,8621,8622,8623,
8624,8625,8626,8627,8628,8629,8630,8631,8632,8633,8634,8635,8636,8637,8638,8639,
8640,8641,8642,8643,8644,8645,8646,8647,8648,8649,8650,8651,8652,8653,8654,8655,
8656,8657,8658,8659,8660,8661,8662,8663,8664,8665,8666,8667,8668,8669,8670,8671,
8672,8673,8674,8675,8676,8677,8678,8679,8680,8681,8682,8683,8684,8685,8686,8687,
8688,8689,8690,8691,8692,8693,8694,8695,8696,8697,8698,8699,8700,8701,8702,8703,
8704,8705,8706,8707,8708,8709,8710,8711,8712,8713,8714,8715,8716,8717,8718,8719,
8720,8721,8722,8723,8724,8725,8726,8727,8728,8729,8730,8731,8732,8733,8734,8735,
8736,8737,8738,8739,8740,8741)

# flake8: noqa

filename:/usr/lib/python2.7/dist-packages/chardet/mbcssm.pyc
__doc__
Û
≤ 4Tc           @   sX	  d  d l  m Z m Z m Z d" Z e e e d e e e e e e e e e e e e e e e e e e e e f Z d# Z i e d 6d d 6e d	 6e d
 6d d 6Z d$ Z e e d e e e d d e d e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e fF Z	 d% Z
 i e d 6d d 6e	 d	 6e
 d
 6d d 6Z d& Z d d d d e e e e e e e e e e e e e e e e e e e e e e e e e e d e d e e e e e e e f( Z d' Z i e d 6d d 6e d	 6e d
 6d d 6Z d( Z e e d e e e e e e e e e e e e e f Z d) Z i e d 6d d 6e d	 6e d
 6d d 6Z d* Z e e e d d d d e e e e e e e e e e e e e e e e e e e e e e e e e d e e e e e e e e e e e e e e e f0 Z d+ Z i e d 6d d 6e d	 6e d
 6d d 6Z d, Z e e e e e e d e e e e e e e e e e e e e e e e e d e e e e e e e e e d e e e e e e e e e e e e e f0 Z d- Z i e d 6d d 6e d	 6e d
 6d d 6Z d. Z e e e d e e e e e e e e e e e e e e e e e e e e f Z d/ Z i e d 6d d 6e d	 6e d
 6d d 6Z d0 Z  d d d e d d e e e e e e e e e e e e d d d d e e d d d d d e d d d d d d d d d e d d d d e d d d d d d d e e e e f8 Z! d1 Z" i e  d 6d d 6e! d	 6e" d
 6d d 6Z# d2 Z$ d d d d d d e e e e e e e e e e e e d d d e e e d d d e d e d d d d d d d d d e d d d e e e d d d d d e d e e e f8 Z% d3 Z& i e$ d 6d d 6e% d	 6e& d
 6d d 6Z' d4 Z( e e e e e e d d d d d d d d d d e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e d d d d e e e e e e e e e e e e e d d d e e e e e e e e e e e e d d d d e e e e e e e e e e e e e e d d e e e e e e e e e e e e d d d d e e e e e e e e e e e e e e e d e e e e e e e e e e e e d d d d e e e e e e e e e e e e e e e d e e e e e e e e e e e e d d d e e e e e e e e e e e e e e e e e e e e e e e e e e e f– Z) d5 Z* i e( d 6d d 6e) d	 6e* d
 6d  d 6Z+ d! S(6   i   (   t   eStartt   eErrort   eItsMei    i   i   i   t
   classTablei   t   classFactort
   stateTablet   charLenTablet   Big5t   namei   i   i   i	   i
   t   CP949s   EUC-JPs   EUC-KRs   x-euc-twt   GB2312t	   Shift_JISs   UTF-16BEs   UTF-16LEi   i   i   i   i   i   s   UTF-8N(   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i    i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    (   i    i   i   i   i    (   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i    i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i	   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    (
   i    i   i   i    i   i   i   i   i    i   (   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   (   i   i   i   i   i   i    (   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i    i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    (   i    i   i   i    (   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i    i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    (   i    i    i   i   i   i   i   (   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i    i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    (   i    i   i   i   i   i   i   (   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i    i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i    i    (   i    i   i   i   i    i    (   i    i    i    i    i    i    i    i    i    i    i   i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   (   i   i   i   i    i   i   (   i    i    i    i    i    i    i    i    i    i    i   i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i   i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   i   i   i   i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i    i   i   (   i   i   i   i   i   i   (   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i    i   i   i   i   i   i   i   i   i   i   i   i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i    i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i	   i   i   i
   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i    (   i    i   i    i    i    i    i   i   i   i   i   i   i   i   i   i   (,   t	   constantsR    R   R   t   BIG5_clst   BIG5_stt   Big5CharLenTablet   Big5SMModelt	   CP949_clst   CP949_stt   CP949CharLenTablet   CP949SMModelt	   EUCJP_clst   EUCJP_stt   EUCJPCharLenTablet   EUCJPSMModelt	   EUCKR_clst   EUCKR_stt   EUCKRCharLenTablet   EUCKRSMModelt	   EUCTW_clst   EUCTW_stt   EUCTWCharLenTablet   EUCTWSMModelt
   GB2312_clst	   GB2312_stt   GB2312CharLenTablet   GB2312SMModelt   SJIS_clst   SJIS_stt   SJISCharLenTablet   SJISSMModelt
   UCS2BE_clst	   UCS2BE_stt   UCS2BECharLenTablet   UCS2BESMModelt
   UCS2LE_clst	   UCS2LE_stt   UCS2LECharLenTablet   UCS2LESMModelt   UTF8_clst   UTF8_stt   UTF8CharLenTablet   UTF8SMModel(    (    (    s2   /usr/lib/python2.7/dist-packages/chardet/mbcssm.pyt   <module>   sh                                 

               $

                               

                               

                               

                               

                               

                               

                               

                               

filename:/usr/lib/python2.7/dist-packages/chardet/chardistribution.py
__doc__
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Communicator client code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from .euctwfreq import (EUCTWCharToFreqOrder, EUCTW_TABLE_SIZE,
                        EUCTW_TYPICAL_DISTRIBUTION_RATIO)
from .euckrfreq import (EUCKRCharToFreqOrder, EUCKR_TABLE_SIZE,
                        EUCKR_TYPICAL_DISTRIBUTION_RATIO)
from .gb2312freq import (GB2312CharToFreqOrder, GB2312_TABLE_SIZE,
                         GB2312_TYPICAL_DISTRIBUTION_RATIO)
from .big5freq import (Big5CharToFreqOrder, BIG5_TABLE_SIZE,
                       BIG5_TYPICAL_DISTRIBUTION_RATIO)
from .jisfreq import (JISCharToFreqOrder, JIS_TABLE_SIZE,
                      JIS_TYPICAL_DISTRIBUTION_RATIO)
from .compat import wrap_ord

ENOUGH_DATA_THRESHOLD = 1024
SURE_YES = 0.99
SURE_NO = 0.01
MINIMUM_DATA_THRESHOLD = 3


class CharDistributionAnalysis:
    def __init__(self):
        # Mapping table to get frequency order from char order (get from
        # GetOrder())
        self._mCharToFreqOrder = None
        self._mTableSize = None  # Size of above table
        # This is a constant value which varies from language to language,
        # used in calculating confidence.  See
        # http://www.mozilla.org/projects/intl/UniversalCharsetDetection.html
        # for further detail.
        self._mTypicalDistributionRatio = None
        self.reset()

    def reset(self):
        """reset analyser, clear any state"""
        # If this flag is set to True, detection is done and conclusion has
        # been made
        self._mDone = False
        self._mTotalChars = 0  # Total characters encountered
        # The number of characters whose frequency order is less than 512
        self._mFreqChars = 0

    def feed(self, aBuf, aCharLen):
        """feed a character with known length"""
        if aCharLen == 2:
            # we only care about 2-bytes character in our distribution analysis
            order = self.get_order(aBuf)
        else:
            order = -1
        if order >= 0:
            self._mTotalChars += 1
            # order is valid
            if order < self._mTableSize:
                if 512 > self._mCharToFreqOrder[order]:
                    self._mFreqChars += 1

    def get_confidence(self):
        """return confidence based on existing data"""
        # if we didn't receive any character in our consideration range,
        # return negative answer
        if self._mTotalChars <= 0 or self._mFreqChars <= MINIMUM_DATA_THRESHOLD:
            return SURE_NO

        if self._mTotalChars != self._mFreqChars:
            r = (self._mFreqChars / ((self._mTotalChars - self._mFreqChars)
                 * self._mTypicalDistributionRatio))
            if r < SURE_YES:
                return r

        # normalize confidence (we don't want to be 100% sure)
        return SURE_YES

    def got_enough_data(self):
        # It is not necessary to receive all data to draw conclusion.
        # For charset detection, certain amount of data is enough
        return self._mTotalChars > ENOUGH_DATA_THRESHOLD

    def get_order(self, aBuf):
        # We do not handle characters based on the original encoding string,
        # but convert this encoding string to a number, here called order.
        # This allows multiple encodings of a language to share one frequency
        # table.
        return -1


class EUCTWDistributionAnalysis(CharDistributionAnalysis):
    def __init__(self):
        CharDistributionAnalysis.__init__(self)
        self._mCharToFreqOrder = EUCTWCharToFreqOrder
        self._mTableSize = EUCTW_TABLE_SIZE
        self._mTypicalDistributionRatio = EUCTW_TYPICAL_DISTRIBUTION_RATIO

    def get_order(self, aBuf):
        # for euc-TW encoding, we are interested
        #   first  byte range: 0xc4 -- 0xfe
        #   second byte range: 0xa1 -- 0xfe
        # no validation needed here. State machine has done that
        first_char = wrap_ord(aBuf[0])
        if first_char >= 0xC4:
            return 94 * (first_char - 0xC4) + wrap_ord(aBuf[1]) - 0xA1
        else:
            return -1


class EUCKRDistributionAnalysis(CharDistributionAnalysis):
    def __init__(self):
        CharDistributionAnalysis.__init__(self)
        self._mCharToFreqOrder = EUCKRCharToFreqOrder
        self._mTableSize = EUCKR_TABLE_SIZE
        self._mTypicalDistributionRatio = EUCKR_TYPICAL_DISTRIBUTION_RATIO

    def get_order(self, aBuf):
        # for euc-KR encoding, we are interested
        #   first  byte range: 0xb0 -- 0xfe
        #   second byte range: 0xa1 -- 0xfe
        # no validation needed here. State machine has done that
        first_char = wrap_ord(aBuf[0])
        if first_char >= 0xB0:
            return 94 * (first_char - 0xB0) + wrap_ord(aBuf[1]) - 0xA1
        else:
            return -1


class GB2312DistributionAnalysis(CharDistributionAnalysis):
    def __init__(self):
        CharDistributionAnalysis.__init__(self)
        self._mCharToFreqOrder = GB2312CharToFreqOrder
        self._mTableSize = GB2312_TABLE_SIZE
        self._mTypicalDistributionRatio = GB2312_TYPICAL_DISTRIBUTION_RATIO

    def get_order(self, aBuf):
        # for GB2312 encoding, we are interested
        #  first  byte range: 0xb0 -- 0xfe
        #  second byte range: 0xa1 -- 0xfe
        # no validation needed here. State machine has done that
        first_char, second_char = wrap_ord(aBuf[0]), wrap_ord(aBuf[1])
        if (first_char >= 0xB0) and (second_char >= 0xA1):
            return 94 * (first_char - 0xB0) + second_char - 0xA1
        else:
            return -1


class Big5DistributionAnalysis(CharDistributionAnalysis):
    def __init__(self):
        CharDistributionAnalysis.__init__(self)
        self._mCharToFreqOrder = Big5CharToFreqOrder
        self._mTableSize = BIG5_TABLE_SIZE
        self._mTypicalDistributionRatio = BIG5_TYPICAL_DISTRIBUTION_RATIO

    def get_order(self, aBuf):
        # for big5 encoding, we are interested
        #   first  byte range: 0xa4 -- 0xfe
        #   second byte range: 0x40 -- 0x7e , 0xa1 -- 0xfe
        # no validation needed here. State machine has done that
        first_char, second_char = wrap_ord(aBuf[0]), wrap_ord(aBuf[1])
        if first_char >= 0xA4:
            if second_char >= 0xA1:
                return 157 * (first_char - 0xA4) + second_char - 0xA1 + 63
            else:
                return 157 * (first_char - 0xA4) + second_char - 0x40
        else:
            return -1


class SJISDistributionAnalysis(CharDistributionAnalysis):
    def __init__(self):
        CharDistributionAnalysis.__init__(self)
        self._mCharToFreqOrder = JISCharToFreqOrder
        self._mTableSize = JIS_TABLE_SIZE
        self._mTypicalDistributionRatio = JIS_TYPICAL_DISTRIBUTION_RATIO

    def get_order(self, aBuf):
        # for sjis encoding, we are interested
        #   first  byte range: 0x81 -- 0x9f , 0xe0 -- 0xfe
        #   second byte range: 0x40 -- 0x7e,  0x81 -- oxfe
        # no validation needed here. State machine has done that
        first_char, second_char = wrap_ord(aBuf[0]), wrap_ord(aBuf[1])
        if (first_char >= 0x81) and (first_char <= 0x9F):
            order = 188 * (first_char - 0x81)
        elif (first_char >= 0xE0) and (first_char <= 0xEF):
            order = 188 * (first_char - 0xE0 + 31)
        else:
            return -1
        order = order + second_char - 0x40
        if second_char > 0x7F:
            order = -1
        return order


class EUCJPDistributionAnalysis(CharDistributionAnalysis):
    def __init__(self):
        CharDistributionAnalysis.__init__(self)
        self._mCharToFreqOrder = JISCharToFreqOrder
        self._mTableSize = JIS_TABLE_SIZE
        self._mTypicalDistributionRatio = JIS_TYPICAL_DISTRIBUTION_RATIO

    def get_order(self, aBuf):
        # for euc-JP encoding, we are interested
        #   first  byte range: 0xa0 -- 0xfe
        #   second byte range: 0xa1 -- 0xfe
        # no validation needed here. State machine has done that
        char = wrap_ord(aBuf[0])
        if char >= 0xA0:
            return 94 * (char - 0xA1) + wrap_ord(aBuf[1]) - 0xa1
        else:
            return -1

filename:/usr/lib/python2.7/dist-packages/chardet/euctwprober.py
__doc__
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is mozilla.org code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from .mbcharsetprober import MultiByteCharSetProber
from .codingstatemachine import CodingStateMachine
from .chardistribution import EUCTWDistributionAnalysis
from .mbcssm import EUCTWSMModel

class EUCTWProber(MultiByteCharSetProber):
    def __init__(self):
        MultiByteCharSetProber.__init__(self)
        self._mCodingSM = CodingStateMachine(EUCTWSMModel)
        self._mDistributionAnalyzer = EUCTWDistributionAnalysis()
        self.reset()

    def get_charset_name(self):
        return "EUC-TW"

filename:/usr/lib/python2.7/dist-packages/chardet/eucjpprober.py
__doc__
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is mozilla.org code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

import sys
from . import constants
from .mbcharsetprober import MultiByteCharSetProber
from .codingstatemachine import CodingStateMachine
from .chardistribution import EUCJPDistributionAnalysis
from .jpcntx import EUCJPContextAnalysis
from .mbcssm import EUCJPSMModel


class EUCJPProber(MultiByteCharSetProber):
    def __init__(self):
        MultiByteCharSetProber.__init__(self)
        self._mCodingSM = CodingStateMachine(EUCJPSMModel)
        self._mDistributionAnalyzer = EUCJPDistributionAnalysis()
        self._mContextAnalyzer = EUCJPContextAnalysis()
        self.reset()

    def reset(self):
        MultiByteCharSetProber.reset(self)
        self._mContextAnalyzer.reset()

    def get_charset_name(self):
        return "EUC-JP"

    def feed(self, aBuf):
        aLen = len(aBuf)
        for i in range(0, aLen):
            # PY3K: aBuf is a byte array, so aBuf[i] is an int, not a byte
            codingState = self._mCodingSM.next_state(aBuf[i])
            if codingState == constants.eError:
                if constants._debug:
                    sys.stderr.write(self.get_charset_name()
                                     + ' prober hit error at byte ' + str(i)
                                     + '\n')
                self._mState = constants.eNotMe
                break
            elif codingState == constants.eItsMe:
                self._mState = constants.eFoundIt
                break
            elif codingState == constants.eStart:
                charLen = self._mCodingSM.get_current_charlen()
                if i == 0:
                    self._mLastChar[1] = aBuf[0]
                    self._mContextAnalyzer.feed(self._mLastChar, charLen)
                    self._mDistributionAnalyzer.feed(self._mLastChar, charLen)
                else:
                    self._mContextAnalyzer.feed(aBuf[i - 1:i + 1], charLen)
                    self._mDistributionAnalyzer.feed(aBuf[i - 1:i + 1],
                                                     charLen)

        self._mLastChar[0] = aBuf[aLen - 1]

        if self.get_state() == constants.eDetecting:
            if (self._mContextAnalyzer.got_enough_data() and
               (self.get_confidence() > constants.SHORTCUT_THRESHOLD)):
                self._mState = constants.eFoundIt

        return self.get_state()

    def get_confidence(self):
        contxtCf = self._mContextAnalyzer.get_confidence()
        distribCf = self._mDistributionAnalyzer.get_confidence()
        return max(contxtCf, distribCf)

filename:/usr/lib/python2.7/dist-packages/chardet/hebrewprober.py
__doc__
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Universal charset detector code.
#
# The Initial Developer of the Original Code is
#          Shy Shalom
# Portions created by the Initial Developer are Copyright (C) 2005
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from .charsetprober import CharSetProber
from .constants import eNotMe, eDetecting
from .compat import wrap_ord

# This prober doesn't actually recognize a language or a charset.
# It is a helper prober for the use of the Hebrew model probers

### General ideas of the Hebrew charset recognition ###
#
# Four main charsets exist in Hebrew:
# "ISO-8859-8" - Visual Hebrew
# "windows-1255" - Logical Hebrew
# "ISO-8859-8-I" - Logical Hebrew
# "x-mac-hebrew" - ?? Logical Hebrew ??
#
# Both "ISO" charsets use a completely identical set of code points, whereas
# "windows-1255" and "x-mac-hebrew" are two different proper supersets of
# these code points. windows-1255 defines additional characters in the range
# 0x80-0x9F as some misc punctuation marks as well as some Hebrew-specific
# diacritics and additional 'Yiddish' ligature letters in the range 0xc0-0xd6.
# x-mac-hebrew defines similar additional code points but with a different
# mapping.
#
# As far as an average Hebrew text with no diacritics is concerned, all four
# charsets are identical with respect to code points. Meaning that for the
# main Hebrew alphabet, all four map the same values to all 27 Hebrew letters
# (including final letters).
#
# The dominant difference between these charsets is their directionality.
# "Visual" directionality means that the text is ordered as if the renderer is
# not aware of a BIDI rendering algorithm. The renderer sees the text and
# draws it from left to right. The text itself when ordered naturally is read
# backwards. A buffer of Visual Hebrew generally looks like so:
# "[last word of first line spelled backwards] [whole line ordered backwards
# and spelled backwards] [first word of first line spelled backwards]
# [end of line] [last word of second line] ... etc' "
# adding punctuation marks, numbers and English text to visual text is
# naturally also "visual" and from left to right.
#
# "Logical" directionality means the text is ordered "naturally" according to
# the order it is read. It is the responsibility of the renderer to display
# the text from right to left. A BIDI algorithm is used to place general
# punctuation marks, numbers and English text in the text.
#
# Texts in x-mac-hebrew are almost impossible to find on the Internet. From
# what little evidence I could find, it seems that its general directionality
# is Logical.
#
# To sum up all of the above, the Hebrew probing mechanism knows about two
# charsets:
# Visual Hebrew - "ISO-8859-8" - backwards text - Words and sentences are
#    backwards while line order is natural. For charset recognition purposes
#    the line order is unimportant (In fact, for this implementation, even
#    word order is unimportant).
# Logical Hebrew - "windows-1255" - normal, naturally ordered text.
#
# "ISO-8859-8-I" is a subset of windows-1255 and doesn't need to be
#    specifically identified.
# "x-mac-hebrew" is also identified as windows-1255. A text in x-mac-hebrew
#    that contain special punctuation marks or diacritics is displayed with
#    some unconverted characters showing as question marks. This problem might
#    be corrected using another model prober for x-mac-hebrew. Due to the fact
#    that x-mac-hebrew texts are so rare, writing another model prober isn't
#    worth the effort and performance hit.
#
#### The Prober ####
#
# The prober is divided between two SBCharSetProbers and a HebrewProber,
# all of which are managed, created, fed data, inquired and deleted by the
# SBCSGroupProber. The two SBCharSetProbers identify that the text is in
# fact some kind of Hebrew, Logical or Visual. The final decision about which
# one is it is made by the HebrewProber by combining final-letter scores
# with the scores of the two SBCharSetProbers to produce a final answer.
#
# The SBCSGroupProber is responsible for stripping the original text of HTML
# tags, English characters, numbers, low-ASCII punctuation characters, spaces
# and new lines. It reduces any sequence of such characters to a single space.
# The buffer fed to each prober in the SBCS group prober is pure text in
# high-ASCII.
# The two SBCharSetProbers (model probers) share the same language model:
# Win1255Model.
# The first SBCharSetProber uses the model normally as any other
# SBCharSetProber does, to recognize windows-1255, upon which this model was
# built. The second SBCharSetProber is told to make the pair-of-letter
# lookup in the language model backwards. This in practice exactly simulates
# a visual Hebrew model using the windows-1255 logical Hebrew model.
#
# The HebrewProber is not using any language model. All it does is look for
# final-letter evidence suggesting the text is either logical Hebrew or visual
# Hebrew. Disjointed from the model probers, the results of the HebrewProber
# alone are meaningless. HebrewProber always returns 0.00 as confidence
# since it never identifies a charset by itself. Instead, the pointer to the
# HebrewProber is passed to the model probers as a helper "Name Prober".
# When the Group prober receives a positive identification from any prober,
# it asks for the name of the charset identified. If the prober queried is a
# Hebrew model prober, the model prober forwards the call to the
# HebrewProber to make the final decision. In the HebrewProber, the
# decision is made according to the final-letters scores maintained and Both
# model probers scores. The answer is returned in the form of the name of the
# charset identified, either "windows-1255" or "ISO-8859-8".

# windows-1255 / ISO-8859-8 code points of interest
FINAL_KAF = 0xea
NORMAL_KAF = 0xeb
FINAL_MEM = 0xed
NORMAL_MEM = 0xee
FINAL_NUN = 0xef
NORMAL_NUN = 0xf0
FINAL_PE = 0xf3
NORMAL_PE = 0xf4
FINAL_TSADI = 0xf5
NORMAL_TSADI = 0xf6

# Minimum Visual vs Logical final letter score difference.
# If the difference is below this, don't rely solely on the final letter score
# distance.
MIN_FINAL_CHAR_DISTANCE = 5

# Minimum Visual vs Logical model score difference.
# If the difference is below this, don't rely at all on the model score
# distance.
MIN_MODEL_DISTANCE = 0.01

VISUAL_HEBREW_NAME = "ISO-8859-8"
LOGICAL_HEBREW_NAME = "windows-1255"


class HebrewProber(CharSetProber):
    def __init__(self):
        CharSetProber.__init__(self)
        self._mLogicalProber = None
        self._mVisualProber = None
        self.reset()

    def reset(self):
        self._mFinalCharLogicalScore = 0
        self._mFinalCharVisualScore = 0
        # The two last characters seen in the previous buffer,
        # mPrev and mBeforePrev are initialized to space in order to simulate
        # a word delimiter at the beginning of the data
        self._mPrev = ' '
        self._mBeforePrev = ' '
        # These probers are owned by the group prober.

    def set_model_probers(self, logicalProber, visualProber):
        self._mLogicalProber = logicalProber
        self._mVisualProber = visualProber

    def is_final(self, c):
        return wrap_ord(c) in [FINAL_KAF, FINAL_MEM, FINAL_NUN, FINAL_PE,
                               FINAL_TSADI]

    def is_non_final(self, c):
        # The normal Tsadi is not a good Non-Final letter due to words like
        # 'lechotet' (to chat) containing an apostrophe after the tsadi. This
        # apostrophe is converted to a space in FilterWithoutEnglishLetters
        # causing the Non-Final tsadi to appear at an end of a word even
        # though this is not the case in the original text.
        # The letters Pe and Kaf rarely display a related behavior of not being
        # a good Non-Final letter. Words like 'Pop', 'Winamp' and 'Mubarak'
        # for example legally end with a Non-Final Pe or Kaf. However, the
        # benefit of these letters as Non-Final letters outweighs the damage
        # since these words are quite rare.
        return wrap_ord(c) in [NORMAL_KAF, NORMAL_MEM, NORMAL_NUN, NORMAL_PE]

    def feed(self, aBuf):
        # Final letter analysis for logical-visual decision.
        # Look for evidence that the received buffer is either logical Hebrew
        # or visual Hebrew.
        # The following cases are checked:
        # 1) A word longer than 1 letter, ending with a final letter. This is
        #    an indication that the text is laid out "naturally" since the
        #    final letter really appears at the end. +1 for logical score.
        # 2) A word longer than 1 letter, ending with a Non-Final letter. In
        #    normal Hebrew, words ending with Kaf, Mem, Nun, Pe or Tsadi,
        #    should not end with the Non-Final form of that letter. Exceptions
        #    to this rule are mentioned above in isNonFinal(). This is an
        #    indication that the text is laid out backwards. +1 for visual
        #    score
        # 3) A word longer than 1 letter, starting with a final letter. Final
        #    letters should not appear at the beginning of a word. This is an
        #    indication that the text is laid out backwards. +1 for visual
        #    score.
        #
        # The visual score and logical score are accumulated throughout the
        # text and are finally checked against each other in GetCharSetName().
        # No checking for final letters in the middle of words is done since
        # that case is not an indication for either Logical or Visual text.
        #
        # We automatically filter out all 7-bit characters (replace them with
        # spaces) so the word boundary detection works properly. [MAP]

        if self.get_state() == eNotMe:
            # Both model probers say it's not them. No reason to continue.
            return eNotMe

        aBuf = self.filter_high_bit_only(aBuf)

        for cur in aBuf:
            if cur == ' ':
                # We stand on a space - a word just ended
                if self._mBeforePrev != ' ':
                    # next-to-last char was not a space so self._mPrev is not a
                    # 1 letter word
                    if self.is_final(self._mPrev):
                        # case (1) [-2:not space][-1:final letter][cur:space]
                        self._mFinalCharLogicalScore += 1
                    elif self.is_non_final(self._mPrev):
                        # case (2) [-2:not space][-1:Non-Final letter][
                        #  cur:space]
                        self._mFinalCharVisualScore += 1
            else:
                # Not standing on a space
                if ((self._mBeforePrev == ' ') and
                        (self.is_final(self._mPrev)) and (cur != ' ')):
                    # case (3) [-2:space][-1:final letter][cur:not space]
                    self._mFinalCharVisualScore += 1
            self._mBeforePrev = self._mPrev
            self._mPrev = cur

        # Forever detecting, till the end or until both model probers return
        # eNotMe (handled above)
        return eDetecting

    def get_charset_name(self):
        # Make the decision: is it Logical or Visual?
        # If the final letter score distance is dominant enough, rely on it.
        finalsub = self._mFinalCharLogicalScore - self._mFinalCharVisualScore
        if finalsub >= MIN_FINAL_CHAR_DISTANCE:
            return LOGICAL_HEBREW_NAME
        if finalsub <= -MIN_FINAL_CHAR_DISTANCE:
            return VISUAL_HEBREW_NAME

        # It's not dominant enough, try to rely on the model scores instead.
        modelsub = (self._mLogicalProber.get_confidence()
                    - self._mVisualProber.get_confidence())
        if modelsub > MIN_MODEL_DISTANCE:
            return LOGICAL_HEBREW_NAME
        if modelsub < -MIN_MODEL_DISTANCE:
            return VISUAL_HEBREW_NAME

        # Still no good, back to final letter distance, maybe it'll save the
        # day.
        if finalsub < 0.0:
            return VISUAL_HEBREW_NAME

        # (finalsub > 0 - Logical) or (don't know what to do) default to
        # Logical.
        return LOGICAL_HEBREW_NAME

    def get_state(self):
        # Remain active as long as any of the model probers are active.
        if (self._mLogicalProber.get_state() == eNotMe) and \
           (self._mVisualProber.get_state() == eNotMe):
            return eNotMe
        return eDetecting

filename:/usr/lib/python2.7/dist-packages/chardet/jpcntx.pyc
__doc__
Û
≤ 4Tc        •   @   s+R  d  d l  m Z d Z d Z d Z d Z d Z d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d  d d d d d d d d d d d d d d d d d d d d d d d d d d d d  d d d d  d d d d d d d d d d d  fS d d d d d d	 d d d d	 d d d d d d	 d	 d d	 d d	 d	 d d d	 d	 d	 d d d  d d	 d	 d  d
 d d	 d d	 d d	 d
 d	 d d	 d
 d d d d	 d  d d	 d	 d d	 d	 d d  d  d d d	 d d	 d	 d d d d d d	 d
 d
 d
 d
 d d d d  d d	 d fS d d d  d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d  d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d fS d d d d
 d d
 d d d d d
 d d d	 d
 d	 d
 d  d
 d	 d d	 d d d	 d d	 d	 d d	 d
 d d d	 d
 d
 d	 d
 d
 d
 d	 d
 d
 d	 d d
 d
 d	 d  d	 d d d	 d d d d d d d d  d
 d	 d d	 d
 d d d d d d
 d d d
 d d
 d d d d d d fS d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d fS d d	 d d d d	 d d	 d d d
 d d	 d	 d	 d	 d d	 d
 d d d	 d
 d d d	 d d	 d d d d d
 d	 d d d	 d d
 d
 d d
 d
 d  d d
 d d	 d d	 d	 d  d	 d	 d d d d d	 d	 d  d
 d	 d	 d	 d
 d d d d	 d d d d	 d d	 d	 d d d  d  d	 d fS d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d  d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d fS d d d d	 d d	 d d d d	 d d d	 d d d  d d  d	 d  d	 d	 d	 d	 d	 d d	 d  d	 d	 d
 d	 d	 d d d	 d d
 d d	 d	 d
 d d d	 d d d
 d d  d d d  d d d d d d  d d d
 d d d  d d d	 d d  d d d d	 d
 d d	 d d d  d d d	 fS d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d  d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d fS d d	 d d
 d d d d d  d d d d d  d d d d d d	 d	 d	 d d	 d	 d	 d	 d  d d d	 d	 d	 d  d d d  d  d  d d	 d	 d d d d d	 d d d	 d	 d d	 d  d  d d d d	 d	 d d d d d	 d d d d d	 d d d d
 d	 d d d d	 d d d  d fS d  d d d d d d d d d	 d
 d d d	 d d	 d
 d d	 d	 d d	 d
 d d d d d	 d d d d	 d	 d  d
 d d	 d d d
 d d
 d
 d d d
 d d d d	 d d d	 d	 d d d	 d  d	 d d  d d	 d	 d d
 d d	 d d d d d
 d
 d d
 d d d d d d
 d fS d d
 d d
 d d d d	 d d d d	 d d	 d	 d	 d d d d d d	 d d	 d d	 d	 d  d d d d	 d d d
 d d  d d
 d d d
 d	 d d d	 d d	 d d d  d	 d	 d	 d d	 d d d d	 d	 d d	 d	 d	 d d d d d	 d d d
 d d d d	 d d d  d d  d	 fS d d	 d  d d d	 d d d d	 d d d	 d  d d d	 d	 d d	 d d	 d d	 d d d	 d d	 d  d
 d d d  d d d	 d
 d d d	 d
 d
 d d	 d d d	 d  d d	 d  d d d d	 d d d	 d  d d
 d	 d	 d	 d d	 d	 d	 d	 d d d d d
 d d d d	 d	 d d d	 fS d d d d	 d d  d d  d d d	 d d d d d d  d d d  d	 d	 d	 d  d d	 d  d d  d d d d  d  d	 d	 d d d	 d	 d  d d	 d	 d d	 d	 d d d d d d  d d d d d d d d d d  d d d	 d d d d  d	 d	 d	 d d d	 d d d	 d  d d	 d	 fS d d d d d d	 d d	 d d d d d	 d	 d	 d	 d	 d	 d d	 d d d d	 d d	 d	 d d d	 d d
 d d  d d
 d	 d
 d d
 d	 d
 d d d	 d
 d
 d	 d  d	 d	 d d d	 d d	 d d  d	 d	 d d d	 d	 d	 d d d d d	 d d d
 d d d
 d	 d d d  d d	 d fS d d d d	 d d	 d d d d d d d  d d  d d d d	 d d	 d d	 d d  d	 d  d d	 d  d	 d	 d	 d  d	 d	 d	 d d  d	 d  d	 d d d d	 d  d  d d	 d d d d d d  d	 d d  d d d	 d	 d d d	 d d d d d d	 d d	 d d	 d	 d d	 d d d d	 fS d d	 d d	 d d d d  d d	 d	 d d	 d  d	 d  d  d  d	 d  d d	 d d	 d	 d	 d d d	 d  d
 d d	 d  d d	 d d
 d
 d d d d d	 d	 d d d d d d  d  d	 d d d  d d d d  d d d  d	 d	 d	 d d	 d d  d d d d d
 d
 d	 d d d d d d fS d d d d  d d	 d  d	 d d d	 d	 d	 d d	 d  d d d	 d d	 d d	 d  d	 d d  d  d d d d d  d d d	 d  d d	 d d d d d	 d  d	 d  d	 d d  d d d  d d d d  d d d d d d  d  d  d d d	 d d d d	 d d d d	 d d d  d d d	 d	 fS d d  d d d d
 d d d d d d d d	 d	 d d	 d	 d
 d	 d	 d	 d d	 d d d	 d d d	 d	 d	 d d  d d	 d d  d
 d
 d	 d d
 d  d	 d
 d d d d	 d	 d d  d	 d d d d d  d	 d  d d	 d	 d	 d	 d d	 d d  d d	 d d d d
 d
 d d	 d d  d d
 fS d d d d	 d d	 d d d d d	 d  d	 d d d d  d  d	 d d	 d d	 d d	 d  d d	 d	 d d	 d  d	 d d d	 d d d  d d  d d d d d	 d	 d d d d d d d  d d d d d d d d	 d d  d	 d	 d d d d d d d	 d	 d  d d d d	 d d d d	 fS d d d d
 d d d d d d d d d d	 d d	 d	 d	 d  d d d	 d d	 d d d
 d d	 d	 d	 d	 d d d d	 d  d d	 d d  d d d	 d	 d d d	 d  d d	 d d d d d d  d d	 d	 d d d	 d	 d	 d d d d d d d	 d
 d	 d d
 d d d	 d d d d
 fS d d	 d d d d  d d  d d  d	 d d d  d	 d d	 d d d d d d	 d d d d d d  d d  d  d d d	 d  d d d d d d	 d  d d d  d	 d d d d d d d	 d d d d d d d d d d d	 d  d d	 d d d d  d d d d	 d d d d d d  d fS d  d d  d
 d d	 d d	 d d d
 d d d	 d
 d	 d	 d d d	 d d  d	 d	 d	 d	 d d  d d  d
 d d	 d  d d d	 d
 d d d	 d
 d d	 d	 d d d d d	 d	 d  d d	 d d	 d  d d	 d	 d d
 d d d d d d d	 d	 d
 d d d	 d	 d
 d d d	 d d d d fS d d d d	 d d  d d d d  d	 d	 d	 d d d  d	 d d	 d  d	 d d d d  d  d d d d d d	 d  d d d	 d d d d d  d d	 d  d  d	 d	 d  d d d d d  d	 d d d d d d d d d	 d d d	 d
 d d	 d	 d	 d d	 d	 d d	 d	 d d d  d d	 d	 fS d d d d d d	 d d d d d
 d
 d	 d d d d d  d d	 d	 d d d	 d d	 d  d	 d	 d d d	 d d	 d d	 d d	 d d d d d d d d
 d	 d	 d d d  d  d  d d d  d
 d d	 d	 d d d	 d	 d	 d d d	 d d d d d d	 d
 d
 d d d	 d d d	 d	 fS d d	 d d d d	 d d  d d	 d d	 d	 d  d	 d	 d	 d d	 d  d	 d d d	 d	 d  d  d d	 d d	 d	 d d d d d d  d
 d d	 d	 d
 d d	 d	 d d	 d d d d  d  d  d d  d	 d d  d d  d	 d	 d d	 d	 d d	 d d  d d  d	 d	 d d d  d d  d d d  d	 fS d d  d d d d d d	 d d  d	 d	 d	 d d	 d  d  d d	 d d	 d	 d d	 d d d d d  d d d	 d d d d	 d d
 d	 d	 d d d d d	 d	 d	 d d d  d	 d d d  d d d  d d d d d d d	 d	 d	 d d	 d d d d d d d
 d	 d d d	 d	 d d	 d
 fS d d d d	 d d d d	 d d  d	 d d d d d d  d d	 d  d  d	 d	 d d d	 d d d	 d d d	 d  d d	 d  d d	 d	 d d d d d d d d d d d d d d d d d d d d d d d d  d d d  d d  d d d d  d	 d  d d d d d  d d d  d fS d d	 d d	 d d
 d d  d d d d	 d  d	 d	 d d  d  d
 d d  d d
 d  d d d d d	 d	 d d d	 d d d	 d d d	 d	 d  d	 d	 d d d
 d	 d d d	 d	 d d  d d d d d d	 d d d d d	 d	 d	 d d d d  d d	 d d d d
 d d d	 d d d	 d
 fS d d	 d d	 d d	 d d  d d	 d	 d	 d	 d d	 d d d d d  d  d d d d  d d d d d  d d d  d d	 d d d d	 d	 d  d d	 d  d d	 d	 d d d  d d d d d d d d d d d d d	 d  d d	 d d	 d d  d d	 d d  d d d	 d d  d  d d	 d	 fS d d d d
 d d	 d d	 d d d
 d
 d d	 d
 d	 d d	 d
 d	 d	 d d
 d	 d d d d	 d d	 d d
 d
 d	 d d d	 d d d
 d d d d	 d d
 d
 d d d	 d d d	 d d d	 d	 d  d d	 d d d	 d	 d
 d
 d d	 d d	 d d
 d
 d
 d
 d d d d d d  d d fS d d d d d d	 d d	 d d	 d
 d d d d	 d d
 d  d	 d d
 d  d d d	 d d	 d	 d d	 d	 d	 d	 d d
 d d  d	 d	 d
 d	 d d d d d d	 d  d  d	 d  d d d	 d d d	 d d	 d d d d	 d  d	 d d d	 d d d d d d d	 d d
 d d d d d	 d fS d d	 d d	 d d	 d  d d d	 d d d	 d	 d	 d d d d d	 d	 d  d	 d	 d	 d  d  d d	 d  d d	 d d	 d d d d d d d	 d d d	 d d d d	 d  d	 d	 d  d	 d	 d d d  d d d d  d d	 d d	 d	 d
 d d	 d	 d
 d d d	 d	 d d d d	 d d d d fS d d d d  d d d d d d  d d  d	 d d d d d d d d  d d  d d d  d d d d d	 d d d  d d  d  d	 d  d d d d  d  d d  d  d d d d d d d d d d d d d d d  d  d d d d	 d d d d d  d  d d d  d d d d d d  d  fS d d  d d d d  d d d d d d d d  d d d	 d d d d	 d d d d	 d d	 d d d  d
 d  d d d d	 d d
 d d
 d d d  d d d d d  d d d  d	 d d d	 d d d	 d  d  d d  d d d d d d d d d d d d d  d d d d d d d d fS d  d d d
 d d	 d d d d	 d
 d d d	 d d	 d
 d	 d d	 d	 d d d	 d	 d	 d	 d	 d	 d d d d	 d  d	 d d d
 d d d	 d d d  d	 d
 d d	 d	 d	 d  d d d	 d	 d  d	 d  d	 d	 d	 d
 d	 d	 d d
 d d	 d d	 d d	 d d	 d d d	 d d	 d d d d	 fS d d  d d d d d d d d  d d d d  d d d d d	 d d  d d  d d d d d d d d	 d  d  d  d d	 d d d d  d d  d d d  d  d  d  d d  d d d d  d d d	 d d d d d	 d d d d d d  d d d d d	 d d	 d	 d d d d d d  d fS d d
 d  d
 d d	 d d	 d d
 d d d
 d  d
 d	 d	 d d d	 d d	 d
 d	 d d	 d	 d d d	 d d	 d	 d d	 d	 d  d d d	 d d d d	 d d
 d
 d	 d d	 d  d  d	 d	 d  d	 d  d  d	 d	 d d d
 d	 d	 d
 d d d d	 d d d d	 d
 d	 d	 d d	 d d d d	 fS d d
 d d
 d d	 d d d d d d	 d
 d d d	 d	 d	 d d d d	 d
 d	 d
 d	 d	 d  d d d d	 d	 d d	 d	 d d d d d d
 d d	 d	 d
 d
 d	 d d	 d  d d	 d d d  d d d	 d d d d d	 d  d
 d d d d	 d d d	 d  d	 d d  d d	 d	 d d	 d	 fS d d d d
 d d
 d d d d d
 d
 d
 d	 d d	 d	 d d
 d d d	 d
 d	 d
 d	 d d d d	 d d d	 d d d d	 d d
 d d d
 d
 d d	 d
 d
 d d  d	 d	 d d	 d	 d  d	 d  d d d	 d  d d d	 d d
 d d d d d d d	 d d d	 d	 d d d d d
 d
 fS d d d d d d
 d d  d  d	 d	 d d d	 d d  d	 d d
 d  d	 d d	 d  d	 d  d  d d	 d d	 d	 d d d d	 d d d d d	 d d d d	 d
 d d  d d	 d d d d	 d d	 d  d d	 d  d d	 d d  d	 d
 d d	 d d  d d	 d d	 d	 d d d d d d d d fS d d d d
 d d d d	 d d d
 d
 d d	 d
 d	 d
 d	 d
 d	 d
 d d
 d	 d d	 d	 d d	 d d
 d	 d d  d
 d d	 d d	 d d
 d	 d d  d d
 d d	 d d	 d	 d d	 d d d d	 d d d  d d	 d d	 d	 d
 d d	 d d  d d d
 d
 d
 d d	 d d d d d	 d
 fS d d
 d d d d d d d d
 d d	 d d	 d d	 d	 d	 d d	 d d d
 d	 d
 d	 d d  d d	 d d d d d	 d
 d d d d d d
 d	 d  d	 d d
 d	 d	 d	 d	 d	 d	 d	 d d d d d	 d	 d d d	 d	 d	 d
 d	 d d  d	 d	 d
 d	 d d d d d d d	 d  d	 d	 fS d d  d d	 d d	 d d  d d  d	 d	 d	 d d	 d	 d	 d d	 d d d d	 d  d	 d d d d d d d	 d d d	 d d d  d d d  d	 d	 d d d	 d	 d	 d d  d d d d  d d d	 d d	 d  d d	 d d d  d	 d d d d  d d	 d	 d  d	 d	 d d d  d  d d	 d	 fS d d d d	 d d d  d d d d d	 d  d  d	 d  d  d d d d	 d  d d	 d  d	 d d d  d d d	 d d	 d	 d	 d  d d d	 d	 d	 d	 d  d d	 d  d d d  d  d d  d d d  d  d d  d  d d	 d  d	 d d d d  d d d d d	 d	 d	 d  d d d d d d d	 fS d d
 d d d d
 d d d d d
 d
 d	 d	 d d	 d	 d  d
 d d d d d d d	 d d d d	 d
 d
 d d	 d	 d d	 d	 d
 d
 d d
 d
 d  d	 d d
 d	 d  d d	 d  d	 d	 d d	 d	 d  d d	 d  d d
 d	 d	 d
 d d d d	 d d
 d	 d	 d  d d	 d d d d  d
 d	 fS d d
 d d
 d d d d d d d d	 d d	 d	 d	 d	 d	 d
 d d d d d d d
 d	 d	 d
 d d d d d	 d d d	 d	 d d d
 d
 d	 d	 d d	 d d	 d	 d d	 d	 d	 d	 d  d d d  d d	 d	 d
 d d d	 d d d d d	 d d d d d d d  d d d d d d fS d d d d d d	 d d  d d	 d
 d d	 d d	 d d d  d d d	 d	 d d  d d	 d	 d d d  d	 d	 d	 d d	 d	 d d d	 d	 d	 d
 d	 d	 d	 d	 d	 d d d d d d d d d d d d  d d d	 d  d d d	 d d	 d d d d d d	 d	 d d  d d	 d d d d fS d d d d d d d d d d d  d d  d d d d d d d d  d d d d  d d d d d d	 d  d	 d d	 d d d d d  d d	 d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d	 d d d d d d d d d d fS d d d  d	 d d d d d d	 d	 d	 d	 d  d	 d  d	 d	 d	 d	 d	 d	 d d d d  d d  d d d d	 d  d	 d	 d	 d d d	 d
 d d	 d	 d	 d	 d	 d	 d	 d d  d	 d d d d d  d d d  d d d d d d d	 d d	 d	 d d	 d	 d d d	 d  d d d  d d d d	 fS d d	 d d	 d d  d d	 d d d	 d	 d	 d d	 d  d d d	 d	 d d	 d	 d d	 d d	 d  d	 d d d	 d d d	 d	 d  d d	 d	 d d	 d d	 d  d	 d	 d  d  d d  d  d d  d d  d d  d d d d d  d  d d	 d d	 d  d d d	 d	 d	 d	 d	 d  d d d d d	 d	 fS d d d d d d d d d d d	 d d d d	 d d d d d d d d	 d d d d d d d d	 d d	 d d	 d  d d  d d  d d d  d d d d d d d d d d d d d d d d d d d d d d d d d d	 d d d d d	 d d d d d d d d d	 fS d d d d	 d  d	 d d	 d d d	 d	 d	 d  d	 d  d	 d  d	 d  d	 d	 d	 d  d	 d d d	 d  d  d d	 d	 d d	 d	 d  d d d d  d	 d	 d d  d d d	 d d  d	 d d	 d d d  d	 d d d d d	 d	 d d  d	 d d	 d d d d	 d d d d	 d  d d	 d d d	 d	 fS d d d d  d d d d d d  d	 d d d  d	 d d  d  d	 d d	 d d	 d  d d d d d  d  d	 d	 d	 d d	 d	 d  d  d d	 d d	 d	 d  d d	 d d d d  d d d d d d d	 d d  d d d d  d d  d	 d d	 d d d d	 d d d d	 d d d d d d d fS d d d d  d d  d d d d d  d d d d  d d d d d d d d  d  d  d d d d d d d d d d d d d d d  d d d d d d d d d d d d d d d d d d d d d d d d d d d d  d d d d d  d	 d  d d d d d d d d	 fS d d	 d d	 d d d d	 d d	 d	 d	 d d	 d d d d d	 d  d	 d	 d	 d d	 d	 d d d	 d d	 d d d d d	 d  d d	 d d	 d	 d d	 d  d
 d d d d	 d  d d  d	 d d	 d  d  d d d d	 d  d	 d  d	 d d	 d d  d d	 d	 d d d d  d d d  d d d fS d d  d d	 d d  d d d d  d d d
 d  d d d d d d  d	 d  d d d d  d d d d  d d  d  d d	 d	 d d
 d  d	 d d	 d	 d  d d	 d d	 d d  d d d d d d d  d d d d d d d  d d	 d d d d  d d	 d	 d	 d d	 d	 d d d d d d	 fS d d d d  d d d d d d d d d  d d d d d d  d d d d d d d d d d d d	 d d d d d d d  d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d  d d d  d d d d d d	 fS d d  d d	 d d d d	 d d d d	 d  d d	 d d d  d	 d  d d d	 d  d  d  d d  d	 d d  d d d  d	 d d  d	 d d
 d
 d  d d d  d	 d d  d d	 d d d  d d d d d d	 d d d  d  d  d	 d d d d d  d d d	 d	 d  d d	 d d  d d  d d fS d d d d  d d	 d d	 d d d d  d d d d d	 d d	 d  d	 d d	 d d	 d d  d d	 d d	 d  d	 d d	 d	 d d d  d d  d  d  d d  d d d d d  d d d  d d d d d d d d d d d  d d d d d d d d d d	 d	 d	 d	 d d d d d  d fS d d d d	 d d	 d d d d d	 d  d  d d	 d d  d d d d  d d d d d d d d  d d	 d d d d d	 d d d d d	 d  d d d d  d d d d d d d d d d  d d d d d d d d d d d d d d d d d d	 d d d d d d d d d	 fS d d d d
 d d
 d d d d	 d d	 d	 d	 d d	 d	 d	 d d	 d d d
 d d
 d
 d
 d d	 d d
 d
 d d  d
 d d	 d  d
 d d	 d d d	 d	 d d	 d	 d d	 d d d d	 d d	 d d d	 d	 d d
 d	 d d	 d	 d d	 d d	 d d	 d d
 d d
 d	 d d d	 d d	 d fS d d	 d d	 d d	 d d	 d d	 d	 d d	 d d	 d d	 d d d	 d	 d	 d	 d	 d	 d	 d	 d d	 d d d	 d	 d  d	 d d	 d d d d	 d d d	 d d d d  d d d d d  d  d d d d d	 d  d d
 d	 d d  d	 d d	 d d  d d d	 d d d	 d	 d d	 d d d d fS d d	 d d	 d d  d d d d  d d	 d	 d d	 d  d	 d  d d d	 d d d d	 d d	 d d d d	 d	 d	 d d	 d	 d	 d d	 d d  d	 d	 d d	 d d	 d	 d d  d  d d  d d d d d d	 d d d	 d  d d  d	 d d d d  d d d	 d	 d d	 d	 d d d d d	 d	 fS d d	 d d d d  d d	 d d	 d d	 d	 d d	 d	 d	 d  d	 d  d	 d	 d d	 d	 d	 d d d	 d  d
 d	 d	 d  d	 d	 d d
 d d	 d	 d d
 d	 d d
 d	 d d d  d d d d d d d d d  d  d d d d d  d	 d d	 d d d d d d	 d
 d	 d d d  d  d d	 d fS d d
 d d d d
 d d d d d d	 d	 d d	 d	 d	 d  d d	 d d  d
 d	 d d	 d d d d d d	 d d  d
 d d d d d d d
 d d  d	 d
 d d d  d d  d  d	 d d d	 d  d d	 d d  d d	 d	 d	 d d d d d	 d d d d d	 d	 d	 d d d d d	 d fS d  d d d d d	 d d  d d	 d	 d	 d  d  d	 d	 d d d	 d	 d  d d	 d d d  d d d	 d  d d  d d d	 d d d d d	 d	 d d	 d d	 d	 d  d d d  d  d	 d  d d d d	 d d  d  d d	 d d d	 d	 d d	 d d d d d	 d	 d d	 d	 d d  d d d  d fS d d d d d d d d d d	 d d d	 d  d d d	 d d	 d	 d	 d  d d	 d d d	 d d d d	 d	 d d d
 d d d  d	 d d	 d d	 d  d	 d	 d d d d d  d d	 d	 d d d d d	 d  d d d d	 d d	 d d d d  d d d d d d d d d	 d d d	 d	 fS d d d d  d d d d d d d d d  d  d  d d d d d d d d d d  d d d d d d d d  d d	 d d d d  d d d d  d d d d d d d  d d d d d d d d d d d d d d d d d d d d d d d d d d d  d d d d d d fS d d d d	 d d d d d d  d	 d	 d	 d d d d d  d d  d  d  d d d	 d  d  d d  d d	 d  d d d	 d	 d d d  d  d d d d d d  d d d d d d d	 d  d d d  d d  d  d d  d d d	 d d d d d  d d d	 d	 d d	 d  d d  d d	 d d fS d d d d	 d d
 d d d d d  d d d d	 d  d d  d	 d d d d d d d d  d d d d  d  d d d d d d d d	 d d  d d  d d d d d d d d d d d d d d d d	 d d d d d d  d d d d d d d d d d d	 d d d d d d	 fS d d d d
 d d
 d d  d d d d	 d	 d d
 d  d	 d d	 d	 d	 d d d  d d d	 d d d d d d  d  d
 d	 d d d  d d d	 d d d	 d	 d	 d d d d d  d  d d d  d  d d	 d  d d  d	 d  d d	 d d d d d d  d	 d
 d d d d d	 d d d  d	 fS d d d d
 d d d d d d d
 d d	 d	 d d	 d	 d	 d d	 d d d
 d	 d d
 d d d d d	 d d	 d  d d d  d	 d
 d d d
 d
 d d d
 d
 d
 d d	 d	 d  d d	 d  d	 d	 d d	 d	 d  d d	 d d d d d	 d d d d	 d	 d d d
 d d d d	 d d d
 fS d d d d d d	 d d	 d d	 d d d d	 d	 d d d	 d d	 d d	 d
 d	 d d	 d d  d d d d d	 d  d	 d d d d
 d
 d	 d d
 d d  d
 d d	 d d	 d d d	 d d  d	 d  d d	 d	 d	 d
 d	 d	 d	 d
 d d d d	 d	 d d	 d	 d	 d d  d d	 d d  d d	 fS d d d d
 d d d d	 d d	 d
 d
 d	 d d d	 d d d
 d d d  d d d d	 d	 d	 d d	 d
 d
 d d	 d	 d d  d d
 d
 d	 d
 d
 d d	 d
 d
 d d d	 d d d	 d	 d  d  d
 d  d d  d d d	 d d	 d
 d d d d	 d d
 d d	 d d	 d d d d  d d d fS d  d	 d d d d d d d d d
 d
 d	 d	 d	 d	 d	 d d d d	 d d d d	 d d d d	 d d
 d d	 d	 d	 d	 d d
 d
 d d
 d
 d
 d d	 d
 d
 d
 d  d	 d  d d  d d d	 d d d d d d
 d d	 d d d  d	 d d	 d d d
 d d
 d d	 d d d d d
 d fS d d	 d d d d
 d d	 d d	 d d d	 d d	 d d	 d	 d	 d	 d	 d d d	 d	 d d d d	 d	 d	 d	 d	 d  d	 d	 d	 d d d d	 d d d  d  d d d d d	 d  d d  d  d d d  d d d	 d  d	 d	 d  d	 d d d	 d d  d d	 d  d	 d d d  d d d d d d fS d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d fS d d	 d d	 d d d d	 d d  d
 d d	 d	 d	 d  d d d  d d	 d d d d d d
 d d	 d  d d	 d d d d	 d	 d	 d d	 d d
 d	 d d	 d d d	 d d d	 d d d  d d  d d d d d d d  d  d	 d  d d d d d d	 d d d d
 d d d d d d  d	 fS d d d d d d d d d d d d d d d  d d d d d d  d  d  d d d  d  d d d d d d  d  d d  d d	 d d d d	 d  d  d  d d d d d d d d d d d d d d d d d	 d d  d d d d d d d d  d d d d d  d d d d d d  fS d d d d d d d d d d  d d  d d d d d  d d d d d d d  d d  d d d d d	 d  d d d d d d d  d d d  d d  d d  d  d d d	 d d d d d d d d d d d d  d	 d  d d d d d d  d d d d  d d d d d d d d d fS d d d d d d d d	 d d d d	 d d d d	 d d d d d d	 d
 d	 d
 d	 d	 d d d d d	 d d	 d  d d d d	 d d d d	 d	 d	 d d d d	 d d  d	 d d	 d d  d d  d	 d	 d	 d d d	 d	 d
 d d d d	 d d d	 d	 d	 d d  d d	 d d d	 d	 fS d d d d	 d d	 d d	 d d	 d
 d
 d	 d	 d	 d	 d d	 d d	 d	 d	 d d d d	 d	 d	 d	 d d	 d
 d	 d	 d  d	 d d d
 d
 d
 d
 d d	 d d
 d
 d	 d d d	 d	 d	 d	 d d	 d	 d  d d	 d d d	 d	 d	 d d d d d d d d	 d d d  d d d	 d d d d  fS fS Z d f  d Ñ  É  YZ d e f d Ñ  É  YZ	 d e f d Ñ  É  YZ
 d S(   i   (   t   wrap_ordi   iˇˇˇˇid   iË  i   i    i   i   i   t   JapaneseContextAnalysisc           B   s>   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s   |  j  É  d  S(   N(   t   reset(   t   self(    (    s2   /usr/lib/python2.7/dist-packages/chardet/jpcntx.pyt   __init__|   s    c         C   s8   d |  _  d g t |  _ d |  _ d |  _ t |  _ d  S(   Ni    iˇˇˇˇ(   t
   _mTotalRelt   NUM_OF_CATEGORYt   _mRelSamplet   _mNeedToSkipCharNumt   _mLastCharOrdert   Falset   _mDone(   R   (    (    s2   /usr/lib/python2.7/dist-packages/chardet/jpcntx.pyR      s
    			c         C   sÏ   |  j  r d  S|  j } xœ | | k  rÁ |  j | | | d !É \ } } | | 7} | | k rt | | |  _ d |  _ q | d k r€ |  j d k r€ |  j d 7_ |  j t k r∫ t |  _  Pn  |  j t |  j | c d 7<n  | |  _ q Wd  S(   Ni   iˇˇˇˇi   (	   R   R   t	   get_orderR	   R   t   MAX_REL_THRESHOLDt   TrueR   t   jp2CharContext(   R   t   aBuft   aLent   it   ordert   charLen(    (    s2   /usr/lib/python2.7/dist-packages/chardet/jpcntx.pyt   feedã   s     			 
	!c         C   s   |  j  t k S(   N(   R   t   ENOUGH_REL_THRESHOLD(   R   (    (    s2   /usr/lib/python2.7/dist-packages/chardet/jpcntx.pyt   got_enough_data¶   s    c         C   s0   |  j  t k r( |  j  |  j d |  j  St Sd  S(   Ni    (   R   t   MINIMUM_DATA_THRESHOLDR   t	   DONT_KNOW(   R   (    (    s2   /usr/lib/python2.7/dist-packages/chardet/jpcntx.pyt   get_confidence©   s    c         C   s   d S(   Niˇˇˇˇi   (   iˇˇˇˇi   (    (   R   R   (    (    s2   /usr/lib/python2.7/dist-packages/chardet/jpcntx.pyR   ∞   s    (   t   __name__t
   __module__R   R   R   R   R   R   (    (    (    s2   /usr/lib/python2.7/dist-packages/chardet/jpcntx.pyR   {   s   					t   SJISContextAnalysisc           B   s#   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s   d |  _  d  S(   Nt	   SHIFT_JIS(   t   charset_name(   R   (    (    s2   /usr/lib/python2.7/dist-packages/chardet/jpcntx.pyR   ¥   s    c         C   s   |  j  S(   N(   R   (   R   (    (    s2   /usr/lib/python2.7/dist-packages/chardet/jpcntx.pyt   get_charset_name∑   s    c         C   s˙   | s
 d St  | d É } d | k o1 d k n sR d | k oM d k n rè d } | d	 k sÄ d
 | k o{ d k n rï d |  _ qï n d } t | É d k r t  | d É } | d k r d | k o⁄ d k n r | d | f Sn  d | f S(   Niˇˇˇˇi   i    iÅ   iü   i‡   i¸   i   iá   i˙   t   CP932i    iÒ   (   iˇˇˇˇi   (   R    R   t   len(   R   R   t
   first_charR   t   second_char(    (    s2   /usr/lib/python2.7/dist-packages/chardet/jpcntx.pyR   ∫   s    8(((   R   R   R   R    R   (    (    (    s2   /usr/lib/python2.7/dist-packages/chardet/jpcntx.pyR   ≥   s   		t   EUCJPContextAnalysisc           B   s   e  Z d  Ñ  Z RS(   c         C   sÀ   | s
 d St  | d É } | d k sB d | k o= d k n rK d } n | d k r` d	 } n d } t | É d k r¡ t  | d É } | d
 k r¡ d | k o´ d k n r¡ | d | f Sn  d | f S(   Niˇˇˇˇi   i    ié   i°   i˛   i   iè   i   i§   iÛ   (   iˇˇˇˇi   (   R    R"   (   R   R   R#   R   R$   (    (    s2   /usr/lib/python2.7/dist-packages/chardet/jpcntx.pyR   œ   s    (		((   R   R   R   (    (    (    s2   /usr/lib/python2.7/dist-packages/chardet/jpcntx.pyR%   Œ   s   N(   t   compatR    R   R   R   R   R   R   R   R   R%   (    (    (    s2   /usr/lib/python2.7/dist-packages/chardet/jpcntx.pyt   <module>   s∏   ¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸ˇ 8
filename:/usr/lib/python2.7/dist-packages/chardet/chardetect.py
__doc__
#!/usr/bin/env python
"""

filename:/usr/lib/python2.7/dist-packages/deluge/__init__.py
__doc__
"""Deluge"""

filename:/usr/lib/python2.7/dist-packages/deluge/pluginmanagerbase.pyc
__doc__
Û
K›ıUc        	   @   sç   d  Z  d d l Z d d l Z d d l Z d d l Z d d l m Z	 d d l
 j Z d d d d d d	 d
 d d g	 Z d  d d Ñ  É  YZ d S(   t   PluginManagerBaseiˇˇˇˇN(   t   LOGt   Namet   Licenset   Authors	   Home-paget   Summaryt   Platformt   Versions   Author-emailt   Descriptionc           B   sh   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z RS(   s?   PluginManagerBase is a base class for PluginManagers to inheritc         C   sî   t  j d É t j j | É |  _ t j j t j j	 t j j
 É  d É É st t j t j j	 t j j
 É  d É É n  | |  _ i  |  _ |  j É  d  S(   Ns   Plugin manager init..t   plugins(   t   logt   debugt   deluget   configmanagert   ConfigManagert   configt   ost   patht   existst   joint   get_config_dirt   mkdirt
   entry_nameR	   t   scan_for_plugins(   t   selft   config_fileR   (    (    s<   /usr/lib/python2.7/dist-packages/deluge/pluginmanagerbase.pyt   __init__@   s    *(		c         C   s)   x" |  j  d D] } |  j | É q Wd  S(   Nt   enabled_plugins(   R   t   enable_plugin(   R   t   name(    (    s<   /usr/lib/python2.7/dist-packages/deluge/pluginmanagerbase.pyt   enable_pluginsR   s    c         C   s+   x$ |  j  j É  D] } |  j | É q Wd  S(   N(   R	   t   keyst   disable_plugin(   R   t   key(    (    s<   /usr/lib/python2.7/dist-packages/deluge/pluginmanagerbase.pyt   disable_pluginsW   s    c         C   s   |  j  | S(   N(   R	   (   R   R!   (    (    s<   /usr/lib/python2.7/dist-packages/deluge/pluginmanagerbase.pyt   __getitem__\   s    c         C   s   |  j  S(   s,   Returns a list of the available plugins name(   t   available_plugins(   R   (    (    s<   /usr/lib/python2.7/dist-packages/deluge/pluginmanagerbase.pyt   get_available_plugins_   s    c         C   s   |  j  j É  S(   s!   Returns a list of enabled plugins(   R	   R   (   R   (    (    s<   /usr/lib/python2.7/dist-packages/deluge/pluginmanagerbase.pyt   get_enabled_pluginsc   s    c         C   sR  t  j j t  j j t É d É } t j j | É t  j j t j	 j
 É  d É } | g } xI t  j | É D]8 } t  j j | | É } t j j | É | j | É qh Wt j j | É | j | É t j | É |  _ g  |  _ xo |  j D]d } t j d |  j | d j |  j | d j |  j | d j É |  j j |  j | d j É qÊ Wd S(   s   Scans for available pluginsR	   s   Found plugin: %s %s at %si    N(   R   R   R   t   dirnamet   __file__t   pkg_resourcest   working_sett	   add_entryR   R   R   t   listdirt   appendt   Environmentt   pkg_envR$   R
   R   t   project_namet   versiont   location(   R   t   base_plugin_dirt   user_plugin_dirt   plugins_dirsR'   t
   plugin_dirR   (    (    s<   /usr/lib/python2.7/dist-packages/deluge/pluginmanagerbase.pyR   g   s$    !			c         C   sü  | |  j  k r# t j d | É d S| |  j k rF t j d | É d S| j d d É } |  j | d } | j É  x%| j |  j É D]} | j	 |  j | É } y( | j
 É  } | | j d d É É } Wn0 t k
 r˚ } t j d É t j | É qÜ n X| j É  |  j d	 k r.t j | j j g É n  | j d d É } | |  j | <| |  j d
 k rát j d | É |  j d
 j | É n  t j d | É qÜ Wd S(   s   Enables a plugins$   Cannot enable non-existant plugin %sNs'   Cannot enable already enabled plugin %st    t   -i    t   _s   Unable to instantiate plugin!t   StartedR   s+   Adding %s to enabled_plugins list in configs   Plugin %s enabled..(   R$   R
   t   warningR	   t   replaceR/   t   activatet   get_entry_mapR   t   get_entry_infot   loadt	   Exceptiont   errort	   exceptiont   enablet   _component_statet	   componentt   startt   plugint   _component_nameR   R   R-   t   info(   R   t   plugin_namet   eggR   t   entry_pointt   clst   instancet   e(    (    s<   /usr/lib/python2.7/dist-packages/deluge/pluginmanagerbase.pyR      s8    

	c         C   sÖ   yM |  j  | j É  t j |  j  | j j É |  j  | =|  j d j | É Wn! t k
 rp t	 j
 d | É n Xt	 j d | É d S(   s   Disables a pluginR   s   Plugin %s is not enabled..s   Plugin %s disabled..N(   R	   t   disableRF   t
   deregisterRH   RI   R   t   removet   KeyErrorR
   R;   RJ   (   R   R   (    (    s<   /usr/lib/python2.7/dist-packages/deluge/pluginmanagerbase.pyR    †   s    
c         C   sÇ  i  j  t É } d } g  } |  j | s^ t j d | É x | D] } t d É | | <q@ W| Sx|  j | d j d É j É  D]˚ } | së q n  | d d k r˜ t | j	 d d É É d k s· | j	 d d É d | j
 É  k r˜ | j | j É  É q | rd	 j | É j É  | | <g  } n  | j	 d d É d | j
 É  k r | j	 d d É d } | j	 d d É d j É  | | <q q W| S(
   s5   Returns a dictionary of plugin info from the metadatat    s&   Failed to retrive info for plugin '%s's   Not availablei    s   PKG-INFOs    	t   :i   s   
(   t   fromkeyst   METADATA_KEYSR/   R
   t   warnR9   t   get_metadatat
   splitlinest   lent   splitR   R-   t   stripR   (   R   R   RJ   t   last_headert
   cont_linest   kt   line(    (    s<   /usr/lib/python2.7/dist-packages/deluge/pluginmanagerbase.pyt   get_plugin_info¨   s(    'P	"'(   t   __name__t
   __module__t   __doc__R   R   R"   R#   R%   R&   R   R   R    Rc   (    (    (    s<   /usr/lib/python2.7/dist-packages/deluge/pluginmanagerbase.pyR    =   s   								!	(    (   Rf   t   os.pathR   R)   t   deluge.commonR   t   deluge.configmanagert
   deluge.logR   R
   t   deluge.componentRF   RX   R    (    (    (    s<   /usr/lib/python2.7/dist-packages/deluge/pluginmanagerbase.pyt   <module>%   s    	
filename:/usr/lib/python2.7/dist-packages/deluge/__rpcapi.py
__doc__
from new import classobj
from deluge.core.core import Core
from deluge.core.daemon import Daemon

class RpcApi:
    pass

def scan_for_methods(obj):
    methods = {
        '__doc__': 'Methods available in %s' % obj.__name__.lower()
    }
    for d in dir(obj):
        if not hasattr(getattr(obj,d), '_rpcserver_export'):
            continue
        methods[d] = getattr(obj, d)
    cobj = classobj(obj.__name__.lower(), (object,), methods)
    setattr(RpcApi, obj.__name__.lower(), cobj)

scan_for_methods(Core)
scan_for_methods(Daemon)
filename:/usr/lib/python2.7/dist-packages/deluge/log.pyc
__doc__
Û
K›ıUc           @   sx   d  Z  d d l Z i e j d 6e j d 6e j d 6e j d 6e j d 6Z d d d d	 Ñ Z	 d
 Ñ  Z
 e j d É a d S(   s   Logging functionsiˇˇˇˇNt   infot   warningt   errort   nonet   debugt   wc         C   sL   |  s |  t  k r d }  n  t j d t  |  d d d d d | d | É d	 S(
   sŒ   
    Sets up the basic logger and if `:param:filename` is set, then it will log
    to that file instead of stdout.

    :param level: str, the level to log
    :param filename: str, the file to log to
    R   t   levelt   formats?   [%(levelname)-8s] %(asctime)s %(module)s:%(lineno)d %(message)st   datefmts   %H:%M:%St   filenamet   filemodeN(   t   levelst   loggingt   basicConfig(   R   R	   R
   (    (    s.   /usr/lib/python2.7/dist-packages/deluge/log.pyt   setupLogger0   s    			
c         C   s%   |  t  k r d St j t  |  É d S(   sa   
    Sets the logger level.

    :param level: str, a string representing the desired level

    N(   R   t   LOGt   setLevel(   R   (    (    s.   /usr/lib/python2.7/dist-packages/deluge/log.pyt   setLoggerLevelD   s    t   deluge(   t   __doc__R   t   INFOt   WARNINGt   ERRORt   CRITICALt   DEBUGR   t   NoneR   R   t	   getLoggerR   (    (    (    s.   /usr/lib/python2.7/dist-packages/deluge/log.pyt   <module>%   s   



	
filename:/usr/lib/python2.7/dist-packages/deluge/metafile.py
__doc__
# Taken from http://download.bittorrent.com/dl/BitTorrent-5.3-GPL.tar.gz
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Written by Bram Cohen
# Modifications for use in Deluge by Andrew Resch 2008

import os
import os.path
import sys
import time
from hashlib import sha1 as sha

from deluge.bencode import bencode
from deluge.log import LOG as log

ignore = ['core', 'CVS', 'Thumbs.db', 'desktop.ini']

noncharacter_translate = {}
for i in xrange(0xD800, 0xE000):
    noncharacter_translate[i] = ord('-')
for i in xrange(0xFDD0, 0xFDF0):
    noncharacter_translate[i] = ord('-')
for i in (0xFFFE, 0xFFFF):
    noncharacter_translate[i] = ord('-')

def gmtime():
    return time.mktime(time.gmtime())

def get_filesystem_encoding():
    return sys.getfilesystemencoding()

def decode_from_filesystem(path):
    encoding = get_filesystem_encoding()
    if encoding == None:
        assert isinstance(path, unicode), "Path should be unicode not %s" % type(path)
        decoded_path = path
    else:
        assert isinstance(path, str), "Path should be str not %s" % type(path)
        decoded_path = path.decode(encoding)

    return decoded_path

def dummy(*v):
    pass

def make_meta_file(path, url, piece_length, progress=dummy,
                   title=None, comment=None, safe=None, content_type=None,
                   target=None, webseeds=None, name=None, private=False,
                   created_by=None, trackers=None):
    data = {'creation date': int(gmtime())}
    if url:
        data['announce'] = url.strip()
    a, b = os.path.split(path)
    if not target:
        if b == '':
            f = a + '.torrent'
        else:
            f = os.path.join(a, b + '.torrent')
    else:
        f = target
    info = makeinfo(path, piece_length, progress, name, content_type, private)

    #check_info(info)
    h = file(f, 'wb')

    data['info'] = info
    if title:
        data['title'] = title.encode("utf8")
    if comment:
        data['comment'] = comment.encode("utf8")
    if safe:
        data['safe'] = safe.encode("utf8")

    httpseeds = []
    url_list = []

    if webseeds:
        for webseed in webseeds:
            if webseed.endswith(".php"):
                httpseeds.append(webseed)
            else:
                url_list.append(webseed)

    if url_list:
        data['url-list'] = url_list
    if httpseeds:
        data['httpseeds'] = httpseeds
    if created_by:
        data['created by'] = created_by.encode("utf8")

    if trackers and (len(trackers[0]) > 1 or len(trackers) > 1):
        data['announce-list'] = trackers

    data["encoding"] = "UTF-8"

    h.write(bencode(data))
    h.close()

def calcsize(path):
    total = 0
    for s in subfiles(os.path.abspath(path)):
        total += os.path.getsize(s[1])
    return total

def makeinfo(path, piece_length, progress, name = None,
             content_type = None, private=False):  # HEREDAVE. If path is directory,
                                    # how do we assign content type?
    def to_utf8(name):
        if isinstance(name, unicode):
            u = name
        else:
            try:
                u = decode_from_filesystem(name)
            except Exception, e:
                raise Exception('Could not convert file/directory name %r to '
                                  'Unicode. Either the assumed filesystem '
                                  'encoding "%s" is wrong or the filename contains '
                                  'illegal bytes.' % (name, get_filesystem_encoding()))

        if u.translate(noncharacter_translate) != u:
            raise Exception('File/directory name "%s" contains reserved '
                              'unicode values that do not correspond to '
                              'characters.' % name)
        return u.encode('utf-8')
    path = os.path.abspath(path)
    piece_count = 0
    if os.path.isdir(path):
        subs = subfiles(path)
        subs.sort()
        pieces = []
        sh = sha()
        done = 0
        fs = []
        totalsize = 0.0
        totalhashed = 0
        for p, f in subs:
            totalsize += os.path.getsize(f)
        if totalsize >= piece_length:
            import math
            num_pieces = math.ceil(float(totalsize) / float(piece_length))
        else:
            num_pieces = 1

        for p, f in subs:
            pos = 0
            size = os.path.getsize(f)
            p2 = [to_utf8(n) for n in p]
            if content_type:
                fs.append({'length': size, 'path': p2,
                           'content_type' : content_type}) # HEREDAVE. bad for batch!
            else:
                fs.append({'length': size, 'path': p2})
            h = file(f, 'rb')
            while pos < size:
                a = min(size - pos, piece_length - done)
                sh.update(h.read(a))
                done += a
                pos += a
                totalhashed += a

                if done == piece_length:
                    pieces.append(sh.digest())
                    piece_count += 1
                    done = 0
                    sh = sha()
                    progress(piece_count, num_pieces)
            h.close()
        if done > 0:
            pieces.append(sh.digest())
            progress(piece_count, num_pieces)
            
        if name is not None:
            assert isinstance(name, unicode)
            name = to_utf8(name)
        else:
            name = to_utf8(os.path.split(path)[1])

        return {'pieces': ''.join(pieces),
            'piece length': piece_length, 'files': fs,
            'name': name,
            'private': private}
    else:
        size = os.path.getsize(path)
        if size >= piece_length:
            num_pieces = size / piece_length
        else:
            num_pieces = 1

        pieces = []
        p = 0
        h = file(path, 'rb')
        while p < size:
            x = h.read(min(piece_length, size - p))
            pieces.append(sha(x).digest())
            piece_count += 1
            p += piece_length
            if p > size:
                p = size
            progress(piece_count, num_pieces)
        h.close()
        if content_type is not None:
            return {'pieces': ''.join(pieces),
                'piece length': piece_length, 'length': size,
                'name': to_utf8(os.path.split(path)[1]),
                'content_type' : content_type,
                'private': private }
        return {'pieces': ''.join(pieces),
            'piece length': piece_length, 'length': size,
            'name': to_utf8(os.path.split(path)[1]),
            'private': private}

def subfiles(d):
    r = []
    stack = [([], d)]
    while stack:
        p, n = stack.pop()
        if os.path.isdir(n):
            for s in os.listdir(n):
                if s not in ignore and not s.startswith('.'):
                    stack.append((p + [s], os.path.join(n, s)))
        else:
            r.append((p, n))
    return r

filename:/usr/lib/python2.7/dist-packages/deluge/configmanager.py
__doc__
#
# configmanager.py
#
# Copyright (C) 2007 Andrew Resch <andrewresch@gmail.com>
#
# Deluge is free software.
#
# You may redistribute it and/or modify it under the terms of the
# GNU General Public License, as published by the Free Software
# Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# deluge is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with deluge.    If not, write to:
# 	The Free Software Foundation, Inc.,
# 	51 Franklin Street, Fifth Floor
# 	Boston, MA  02110-1301, USA.
#
#    In addition, as a special exception, the copyright holders give
#    permission to link the code of portions of this program with the OpenSSL
#    library.
#    You must obey the GNU General Public License in all respects for all of
#    the code used other than OpenSSL. If you modify file(s) with this
#    exception, you may extend this exception to your version of the file(s),
#    but you are not obligated to do so. If you do not wish to do so, delete
#    this exception statement from your version. If you delete this exception
#    statement from all source files in the program, then also delete it here.
#
#

import os

import deluge.common
from deluge.log import LOG as log
from deluge.config import Config

class _ConfigManager:
    def __init__(self):
        log.debug("ConfigManager started..")
        self.config_files = {}
        self.__config_directory = None

    @property
    def config_directory(self):
        if self.__config_directory is None:
            self.__config_directory = deluge.common.get_default_config_dir()
        return self.__config_directory

    def __del__(self):
        log.debug("ConfigManager stopping..")
        del self.config_files

    def set_config_dir(self, directory):
        """
        Sets the config directory.

        :param directory: str, the directory where the config info should be

        :returns bool: True if successfully changed directory, False if not
        """

        if not directory:
            return False

        log.info("Setting config directory to: %s", directory)
        if not os.path.exists(directory):
            # Try to create the config folder if it doesn't exist
            try:
                os.makedirs(directory)
            except Exception, e:
                log.error("Unable to make config directory: %s", e)
                return False
        elif not os.path.isdir(directory):
            log.error("Config directory needs to be a directory!")
            return False

        self.__config_directory = directory

        # Reset the config_files so we don't get config from old config folder
        # XXX: Probably should have it go through the config_files dict and try
        # to reload based on the new config directory
        self.save()
        self.config_files = {}

        return True

    def get_config_dir(self):
        return self.config_directory

    def close(self, config):
        """Closes a config file."""
        try:
            del self.config_files[config]
        except KeyError:
            pass

    def save(self):
        """Saves all the configs to disk."""
        for value in self.config_files.values():
            value.save()
        # We need to return True to keep the timer active
        return True

    def get_config(self, config_file, defaults=None):
        """Get a reference to the Config object for this filename"""
        log.debug("Getting config '%s'", config_file)
        # Create the config object if not already created
        if config_file not in self.config_files.keys():
            self.config_files[config_file] = Config(config_file, defaults, self.config_directory)

        return self.config_files[config_file]

# Singleton functions
_configmanager = _ConfigManager()

def ConfigManager(config, defaults=None):
    return _configmanager.get_config(config, defaults)

def set_config_dir(directory):
    """Sets the config directory, else just uses default"""
    return _configmanager.set_config_dir(directory)

def get_config_dir(filename=None):
    if filename != None:
        return os.path.join(_configmanager.get_config_dir(), filename)
    else:
        return _configmanager.get_config_dir()

def close(config):
    return _configmanager.close(config)

filename:/usr/lib/python2.7/dist-packages/deluge/metafile.pyc
__doc__
Û
K›ıUc           @   sc  d  d l  Z  d  d l Z  d  d l Z d  d l Z d  d l m Z d  d l m Z d  d l	 m
 Z d d d d g Z i  Z x' e d	 d
 É D] Z e d É e e <qà Wx' e d d É D] Z e d É e e <q≤ Wx d D] Z e d É e e <q” Wd Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e d d d d d d d e d d d Ñ Z d Ñ  Z d d e d Ñ Z d Ñ  Z d S(   iˇˇˇˇN(   t   sha1(   t   bencode(   t   LOGt   coret   CVSs	   Thumbs.dbs   desktop.inii ÿ  i ‡  t   -i–˝  i˝  i˛ˇ  iˇˇ  c           C   s   t  j t  j É  É S(   N(   t   timet   mktimet   gmtime(    (    (    s3   /usr/lib/python2.7/dist-packages/deluge/metafile.pyR   &   s    c           C   s
   t  j É  S(   N(   t   syst   getfilesystemencoding(    (    (    s3   /usr/lib/python2.7/dist-packages/deluge/metafile.pyt   get_filesystem_encoding)   s    c         C   s{   t  É  } | d  k rC t |  t É s: t d t |  É É Ç |  } n4 t |  t É sh t d t |  É É Ç |  j | É } | S(   Ns   Path should be unicode not %ss   Path should be str not %s(   R   t   Nonet
   isinstancet   unicodet   AssertionErrort   typet   strt   decode(   t   patht   encodingt   decoded_path(    (    s3   /usr/lib/python2.7/dist-packages/deluge/metafile.pyt   decode_from_filesystem,   s    	%	%c          G   s   d  S(   N(    (   t   v(    (    s3   /usr/lib/python2.7/dist-packages/deluge/metafile.pyt   dummy7   s    c         C   s
  i t  t É  É d 6} | r/ | j É  | d <n  t j j |  É \ } } | sÇ | d k rf | d } qà t j j | | d É } n | } t |  | | |
 | | É } t | d É } | | d <| rÿ | j	 d É | d <n  | rÙ | j	 d É | d	 <n  | r| j	 d É | d
 <n  g  } g  } |	 rbx= |	 D]2 } | j
 d É rN| j | É q)| j | É q)Wn  | ru| | d <n  | rà| | d <n  | r§| j	 d É | d <n  | rﬂt | d É d k s“t | É d k rﬂ| | d <n  d | d <| j t | É É | j É  d  S(   Ns   creation datet   announcet    s   .torrentt   wbt   infot   utf8t   titlet   commentt   safes   .phps   url-listt	   httpseedss
   created byi    i   s   announce-lists   UTF-8R   (   t   intR   t   stript   osR   t   splitt   joint   makeinfot   filet   encodet   endswitht   appendt   lent   writeR   t   close(   R   t   urlt   piece_lengtht   progressR   R   R    t   content_typet   targett   webseedst   namet   privatet
   created_byt   trackerst   datat   at   bt   fR   t   hR!   t   url_listt   webseed(    (    s3   /usr/lib/python2.7/dist-packages/deluge/metafile.pyt   make_meta_file:   sH    
.
c         C   sG   d } x: t  t j j |  É É D]  } | t j j | d É 7} q W| S(   Ni    i   (   t   subfilesR$   R   t   abspatht   getsize(   R   t   totalt   s(    (    s3   /usr/lib/python2.7/dist-packages/deluge/metafile.pyt   calcsizeo   s    c         C   sR  d Ñ  } t  j j |  É }  d } t  j j |  É r€t |  É } | j É  g  }	 t É  }
 d } g  } d } d } x* | D]" \ } } | t  j j | É 7} qw W| | k r◊ d d  l } | j	 t
 | É t
 | É É } n d } xP| D]H\ } } d } t  j j | É } g  | D] } | | É ^ q} | rR| j i | d 6| d 6| d 6É n | j i | d 6| d 6É t | d	 É } x£ | | k  r!t | | | | É } |
 j | j | É É | | 7} | | 7} | | 7} | | k r|	 j |
 j É  É | d 7} d } t É  }
 | | | É qqW| j É  q‰ W| d k r_|	 j |
 j É  É | | | É n  | d  k	 rèt | t É sÄt Ç | | É } n | t  j j |  É d É } i d
 j |	 É d 6| d 6| d 6| d 6| d 6St  j j |  É } | | k r| | } n d } g  }	 d } t |  d	 É } x{ | | k  r§| j t | | | É É } |	 j t | É j É  É | d 7} | | 7} | | k rî| } n  | | | É q*W| j É  | d  k	 ri d
 j |	 É d 6| d 6| d 6| t  j j |  É d É d 6| d 6| d 6Si d
 j |	 É d 6| d 6| d 6| t  j j |  É d É d 6| d 6Sd  S(   Nc         S   så   t  |  t É r |  } n? y t |  É } Wn, t k
 rV } t d |  t É  f É Ç n X| j t É | k r t d |  É Ç n  | j d É S(   Nsë   Could not convert file/directory name %r to Unicode. Either the assumed filesystem encoding "%s" is wrong or the filename contains illegal bytes.s_   File/directory name "%s" contains reserved unicode values that do not correspond to characters.s   utf-8(   R   R   R   t	   ExceptionR   t	   translatet   noncharacter_translateR)   (   R5   t   ut   e(    (    s3   /usr/lib/python2.7/dist-packages/deluge/metafile.pyt   to_utf8x   s    	i    g        iˇˇˇˇi   t   lengthR   R2   t   rbR   t   piecess   piece lengtht   filesR5   R6   (   R$   R   RB   t   isdirRA   t   sortt   shaRC   t   matht   ceilt   floatR+   R(   t   mint   updatet   readt   digestR.   R   R   R   R   R%   R&   (   R   R0   R1   R5   R2   R6   RL   t   piece_countt   subsRO   t   sht   donet   fst	   totalsizet   totalhashedt   pR<   RT   t
   num_piecest   post   sizet   nt   p2R=   R:   t   x(    (    s3   /usr/lib/python2.7/dist-packages/deluge/metafile.pyR'   u   sö    	
	"



	

	
c         C   s¬   g  } g  |  f g } x¶ | rΩ | j  É  \ } } t j j | É rß xu t j | É D]N } | t k rR | j d É rR | j | | g t j j | | É f É qR qR Wq | j | | f É q W| S(   Nt   .(	   t   popR$   R   RQ   t   listdirt   ignoret
   startswithR+   R&   (   t   dt   rt   stackRb   Rf   RE   (    (    s3   /usr/lib/python2.7/dist-packages/deluge/metafile.pyRA   ‡   s    	3(   i˛ˇ  iˇˇ  (   R$   t   os.pathR	   R   t   hashlibR    RS   t   deluge.bencodeR   t
   deluge.logR   t   logRl   RI   t   xranget   it   ordR   R   R   R   R   t   FalseR@   RF   R'   RA   (    (    (    s3   /usr/lib/python2.7/dist-packages/deluge/metafile.pyt   <module>   s4   				2	j
filename:/usr/lib/python2.7/dist-packages/deluge/maketorrent.py
__doc__
#
# maketorrent.py
#
# Copyright (C) 2009 Andrew Resch <andrewresch@gmail.com>
#
# Deluge is free software.
#
# You may redistribute it and/or modify it under the terms of the
# GNU General Public License, as published by the Free Software
# Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# deluge is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with deluge.    If not, write to:
# 	The Free Software Foundation, Inc.,
# 	51 Franklin Street, Fifth Floor
# 	Boston, MA  02110-1301, USA.
#
#    In addition, as a special exception, the copyright holders give
#    permission to link the code of portions of this program with the OpenSSL
#    library.
#    You must obey the GNU General Public License in all respects for all of
#    the code used other than OpenSSL. If you modify file(s) with this
#    exception, you may extend this exception to your version of the file(s),
#    but you are not obligated to do so. If you do not wish to do so, delete
#    this exception statement from your version. If you delete this exception
#    statement from all source files in the program, then also delete it here.
#
#

import sys
import os
from hashlib import sha1 as sha

from deluge.common import get_path_size
from deluge.bencode import bencode, bdecode

class InvalidPath(Exception):
    """
    Raised when an invalid path is supplied
    """
    pass

class InvalidPieceSize(Exception):
    """
    Raised when an invalid piece size is set.  Piece sizes must be multiples of
    16KiB.
    """
    pass

class TorrentMetadata(object):
    """
    This class is used to create .torrent files.

    ** Usage **

    >>> t = TorrentMetadata()
    >>> t.data_path = "/tmp/torrent"
    >>> t.comment = "My Test Torrent"
    >>> t.trackers = [["http://tracker.openbittorent.com"]]
    >>> t.save("/tmp/test.torrent")

    """
    def __init__(self):
        self.__data_path = None
        self.__piece_size = 0
        self.__comment = ""
        self.__private = False
        self.__trackers = []
        self.__webseeds = []
        self.__pad_files = False

    def save(self, torrent_path, progress=None):
        """
        Creates and saves the torrent file to `path`.

        :param torrent_path: where to save the torrent file
        :type torrent_path: string

        :param progress: a function to be called when a piece is hashed
        :type progress: function(num_completed, num_pieces)

        :raises InvalidPath: if the data_path has not been set

        """
        if not self.data_path:
            raise InvalidPath("Need to set a data_path!")

        torrent = {
            "info": {}
            }

        if self.comment:
            torrent["comment"] = self.comment.encode("UTF-8")

        if self.private:
            torrent["info"]["private"] = True

        if self.trackers:
            torrent["announce"] = self.trackers[0][0]
            torrent["announce-list"] = self.trackers
        else:
            torrent["announce"] = ""

        if self.webseeds:
            httpseeds = []
            webseeds = []
            for w in self.webseeds:
                if w.endswith(".php"):
                    httpseeds.append(w)
                else:
                    webseeds.append(w)

            if httpseeds:
                torrent["httpseeds"] = httpseeds
            if webseeds:
                torrent["url-list"] = webseeds

        datasize = get_path_size(self.data_path)

        if self.piece_size:
            piece_size = piece_size * 1024
        else:
            # We need to calculate a piece size
            piece_size = 16384
            while (datasize / piece_size) > 1024 and piece_size < (8192 * 1024):
                piece_size *= 2

        # Calculate the number of pieces we will require for the data
        num_pieces = datasize / piece_size
        if datasize % piece_size:
            num_pieces += 1

        torrent["info"]["piece length"] = piece_size

        # Create the info
        if os.path.isdir(self.data_path):
            torrent["info"]["name"] = os.path.split(self.data_path)[1]
            files = []
            padding_count = 0
            # Collect a list of file paths and add padding files if necessary
            for (dirpath, dirnames, filenames) in os.walk(self.data_path):
                for index, filename in enumerate(filenames):
                    size = get_path_size(os.path.join(self.data_path, dirpath, filename))
                    p = dirpath[len(self.data_path):]
                    p = p.lstrip("/")
                    p = p.split("/")
                    if p[0]:
                        p += [filename]
                    else:
                        p = [filename]
                    files.append((size, p))
                    # Add a padding file if necessary
                    if self.pad_files and (index + 1) < len(filenames):
                        left = size % piece_size
                        if left:
                            p = list(p)
                            p[-1] = "_____padding_file_" + str(padding_count)
                            files.append((piece_size - left, p))
                            padding_count += 1

            # Run the progress function with 0 completed pieces
            if progress:
                progress(0, num_pieces)

            fs = []
            pieces = []
            # Create the piece hashes
            buf = ""
            for size, path in files:
                path = [s.decode(sys.getfilesystemencoding()).encode("UTF-8") for s in path]
                fs.append({"length": size, "path": path})
                if path[-1].startswith("_____padding_file_"):
                    buf += "\0" * size
                    pieces.append(sha(buf).digest())
                    buf = ""
                    fs[-1]["attr"] = "p"
                else:
                    fd = open(os.path.join(self.data_path, *path), "rb")
                    r = fd.read(piece_size - len(buf))
                    while r:
                        buf += r
                        if len(buf) == piece_size:
                            pieces.append(sha(buf).digest())
                            # Run the progress function if necessary
                            if progress:
                                progress(len(pieces), num_pieces)
                            buf = ""
                        else:
                            break
                        r = fd.read(piece_size - len(buf))
                    fd.close()

            if buf:
                pieces.append(sha(buf).digest())
                if progress:
                    progress(len(pieces), num_pieces)
                buf = ""

            torrent["info"]["pieces"] = "".join(pieces)
            torrent["info"]["files"] = fs

        elif os.path.isfile(self.data_path):
            torrent["info"]["name"] = os.path.split(self.data_path)[1]
            torrent["info"]["length"] = get_path_size(self.data_path)
            pieces = []

            fd = open(self.data_path, "rb")
            r = fd.read(piece_size)
            while r:
                pieces.append(sha(r).digest())
                if progress:
                    progress(len(pieces), num_pieces)

                r = fd.read(piece_size)

            torrent["info"]["pieces"] = "".join(pieces)

        # Write out the torrent file
        open(torrent_path, "wb").write(bencode(torrent))

    def get_data_path(self):
        """
        The path to the files that the torrent will contain.  It can be either
        a file or a folder.  This property needs to be set before the torrent
        file can be created and saved.
        """
        return self.__data_path

    def set_data_path(self, path):
        """
        :param path: the path to the data
        :type path: string

        :raises InvalidPath: if the path is not found

        """
        if os.path.exists(path) and (os.path.isdir(path) or os.path.isfile(path)):
            self.__data_path = os.path.abspath(path)
        else:
            raise InvalidPath("No such file or directory: %s" % path)

    def get_piece_size(self):
        """
        The size of pieces in bytes.  The size must be a multiple of 16KiB.
        If you don't set a piece size, one will be automatically selected to
        produce a torrent with less than 1024 pieces or the smallest possible
        with a 8192KiB piece size.

        """
        return self.__piece_size

    def set_piece_size(self, size):
        """
        :param size: the desired piece size in KiBs
        :type size: int

        :raises InvalidPieceSize: if the piece size is not a multiple of 16 KiB

        """
        if size % 16 and size:
            raise InvalidPieceSize("Piece size must be a multiple of 16 KiB")
        self.__piece_size = size

    def get_comment(self):
        """
        Comment is some extra info to be stored in the torrent.  This is
        typically an informational string.
        """
        return self.__comment

    def set_comment(self, comment):
        """
        :param comment: an informational string
        :type comment: string
        """
        self.__comment = comment

    def get_private(self):
        """
        Private torrents only announce to the tracker and will not use DHT or
        Peer Exchange.

        See: http://bittorrent.org/beps/bep_0027.html

        """
        return self.__private

    def set_private(self, private):
        """
        :param private: True if the torrent is to be private
        :type private: bool
        """
        self.__private = private

    def get_trackers(self):
        """
        The announce trackers is a list of lists.

        See: http://bittorrent.org/beps/bep_0012.html

        """
        return self.__trackers

    def set_trackers(self, trackers):
        """
        :param trackers: a list of lists of trackers, each list is a tier
        :type trackers: list of list of strings
        """
        self.__trackers = trackers

    def get_webseeds(self):
        """
        The web seeds can either be:
        Hoffman-style: http://bittorrent.org/beps/bep_0017.html
        or,
        GetRight-style: http://bittorrent.org/beps/bep_0019.html

        If the url ends in '.php' then it will be considered Hoffman-style, if
        not it will be considered GetRight-style.
        """
        return self.__webseeds

    def set_webseeds(self, webseeds):
        """
        :param webseeds: the webseeds which can be either Hoffman or GetRight style
        :type webseeds: list of urls
        """
        self.__webseeds = webseeds

    def get_pad_files(self):
        """
        If this is True, padding files will be added to align files on piece
        boundaries.
        """
        return self.__pad_files

    def set_pad_files(self, pad):
        """
        :param pad: set True to align files on piece boundaries
        :type pad: bool
        """
        self.__pad_files = pad

    data_path = property(get_data_path, set_data_path)
    piece_size = property(get_piece_size, set_piece_size)
    comment = property(get_comment, set_comment)
    private = property(get_private, set_private)
    trackers = property(get_trackers, set_trackers)
    webseeds = property(get_webseeds, set_webseeds)
    pad_files = property(get_pad_files, set_pad_files)

filename:/usr/lib/python2.7/dist-packages/deluge/error.py
__doc__
#
# error.py
#
# Copyright (C) 2008 Andrew Resch <andrewresch@gmail.com>
#
# Deluge is free software.
#
# You may redistribute it and/or modify it under the terms of the
# GNU General Public License, as published by the Free Software
# Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# deluge is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with deluge.    If not, write to:
# 	The Free Software Foundation, Inc.,
# 	51 Franklin Street, Fifth Floor
# 	Boston, MA  02110-1301, USA.
#
#    In addition, as a special exception, the copyright holders give
#    permission to link the code of portions of this program with the OpenSSL
#    library.
#    You must obey the GNU General Public License in all respects for all of
#    the code used other than OpenSSL. If you modify file(s) with this
#    exception, you may extend this exception to your version of the file(s),
#    but you are not obligated to do so. If you do not wish to do so, delete
#    this exception statement from your version. If you delete this exception
#    statement from all source files in the program, then also delete it here.
#
#


class DelugeError(Exception):
    pass

class NoCoreError(DelugeError):
    pass

class DaemonRunningError(DelugeError):
    pass

class InvalidTorrentError(DelugeError):
    pass

class InvalidPathError(DelugeError):
    pass

filename:/usr/lib/python2.7/dist-packages/deluge/component.py
__doc__
#
# component.py
#
# Copyright (C) 2007-2010 Andrew Resch <andrewresch@gmail.com>
#
# Deluge is free software.
#
# You may redistribute it and/or modify it under the terms of the
# GNU General Public License, as published by the Free Software
# Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# deluge is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with deluge.    If not, write to:
# 	The Free Software Foundation, Inc.,
# 	51 Franklin Street, Fifth Floor
# 	Boston, MA  02110-1301, USA.
#
#    In addition, as a special exception, the copyright holders give
#    permission to link the code of portions of this program with the OpenSSL
#    library.
#    You must obey the GNU General Public License in all respects for all of
#    the code used other than OpenSSL. If you modify file(s) with this
#    exception, you may extend this exception to your version of the file(s),
#    but you are not obligated to do so. If you do not wish to do so, delete
#    this exception statement from your version. If you delete this exception
#    statement from all source files in the program, then also delete it here.
#
#

from twisted.internet.defer import maybeDeferred, succeed, DeferredList, fail
from twisted.internet.task import LoopingCall
from deluge.log import LOG as log

class ComponentAlreadyRegistered(Exception):
    pass

class Component(object):
    """
    Component objects are singletons managed by the :class:`ComponentRegistry`.
    When a new Component object is instantiated, it will be automatically
    registered with the :class:`ComponentRegistry`.

    The ComponentRegistry has the ability to start, stop, pause and shutdown the
    components registered with it.

    **Events:**

        **start()** - This method is called when the client has connected to a
                  Deluge core.

        **stop()** - This method is called when the client has disconnected from a
                 Deluge core.

        **update()** - This method is called every 1 second by default while the
                   Componented is in a *Started* state.  The interval can be
                   specified during instantiation.  The update() timer can be
                   paused by instructing the :class:`ComponentRegistry` to pause
                   this Component.

        **shutdown()** - This method is called when the client is exiting.  If the
                     Component is in a "Started" state when this is called, a
                     call to stop() will be issued prior to shutdown().

    **States:**

        A Component can be in one of these 5 states.

        **Started** - The Component has been started by the :class:`ComponentRegistry`
                    and will have it's update timer started.

        **Starting** - The Component has had it's start method called, but it hasn't
                    fully started yet.

        **Stopped** - The Component has either been stopped or has yet to be started.

        **Stopping** - The Component has had it's stop method called, but it hasn't
                    fully stopped yet.

        **Paused** - The Component has had it's update timer stopped, but will
                    still be considered in a Started state.

    """
    def __init__(self, name, interval=1, depend=None):
        self._component_name = name
        self._component_interval = interval
        self._component_depend = depend
        self._component_state = "Stopped"
        self._component_timer = None
        self._component_starting_deferred = None
        self._component_stopping_deferred = None
        _ComponentRegistry.register(self)

    def __del__(self):
        if _ComponentRegistry:
            _ComponentRegistry.deregister(self._component_name)

    def _component_start_timer(self):
        if hasattr(self, "update"):
            self._component_timer = LoopingCall(self.update)
            self._component_timer.start(self._component_interval)

    def _component_start(self):
        def on_start(result):
            self._component_state = "Started"
            self._component_starting_deferred = None
            self._component_start_timer()
            return True

        def on_start_fail(result):
            self._component_state = "Stopped"
            self._component_starting_deferred = None
            log.error(result)
            return result

        if self._component_state == "Stopped":
            if hasattr(self, "start"):
                self._component_state = "Starting"
                d = maybeDeferred(self.start)
                d.addCallback(on_start)
                d.addErrback(on_start_fail)
                self._component_starting_deferred = d
            else:
                d = maybeDeferred(on_start, None)
        elif self._component_state == "Starting":
            return self._component_starting_deferred
        elif self._component_state == "Started":
            d = succeed(True)
        else:
            d = fail("Cannot start a component not in a Stopped state!")

        return d

    def _component_stop(self):
        def on_stop(result):
            self._component_state = "Stopped"
            if self._component_timer and self._component_timer.running:
                self._component_timer.stop()
            return True

        def on_stop_fail(result):
            self._component_state = "Started"
            self._component_stopping_deferred = None
            log.error(result)
            return result

        if self._component_state != "Stopped" and self._component_state != "Stopping":
            if hasattr(self, "stop"):
                self._component_state = "Stopping"
                d = maybeDeferred(self.stop)
                d.addCallback(on_stop)
                d.addErrback(on_stop_fail)
                self._component_stopping_deferred = d
            else:
                d = maybeDeferred(on_stop, None)

        if self._component_state == "Stopping":
            return self._component_stopping_deferred

        return succeed(None)

    def _component_pause(self):
        def on_pause(result):
            self._component_state = "Paused"

        if self._component_state == "Started":
            if self._component_timer and self._component_timer.running:
                d = maybeDeferred(self._component_timer.stop)
                d.addCallback(on_pause)
            else:
                d = succeed(None)
        elif self._component_state == "Paused":
            d = succeed(None)
        else:
            d = fail("Cannot pause a component in a non-Started state!")

        return d

    def _component_resume(self):
        def on_resume(result):
            self._component_state = "Started"

        if self._component_state == "Paused":
            d = maybeDeferred(self._component_start_timer)
            d.addCallback(on_resume)
        else:
            d = fail("Component cannot be resumed from a non-Paused state!")

        return d

    def _component_shutdown(self):
        def on_stop(result):
            if hasattr(self, "shutdown"):
                return maybeDeferred(self.shutdown)
            return succeed(None)

        d = self._component_stop()
        d.addCallback(on_stop)
        return d

    def start(self):
        pass

    def stop(self):
        pass

    def update(self):
        pass

    def shutdown(self):
        pass

class ComponentRegistry(object):
    """
    The ComponentRegistry holds a list of currently registered
    :class:`Component` objects.  It is used to manage the Components by
    starting, stopping, pausing and shutting them down.
    """
    def __init__(self):
        self.components = {}

    def register(self, obj):
        """
        Registers a component object with the registry.  This is done
        automatically when a Component object is instantiated.

        :param obj: the Component object
        :type obj: object

        :raises ComponentAlreadyRegistered: if a component with the same name is already registered.

        """
        name = obj._component_name
        if name in self.components:
            raise ComponentAlreadyRegistered(
                "Component already registered with name %s" % name)

        self.components[obj._component_name] = obj

    def deregister(self, name):
        """
        Deregisters a component from the registry.  A stop will be
        issued to the component prior to deregistering it.

        :param name: the name of the component
        :type name: string

        """

        if name in self.components:
            log.debug("Deregistering Component: %s", name)
            d = self.stop([name])
            def on_stop(result, name):
                del self.components[name]
            return d.addCallback(on_stop, name)
        else:
            return succeed(None)

    def start(self, names=[]):
        """
        Starts Components that are currently in a Stopped state and their
        dependencies.  If *names* is specified, will only start those
        Components and their dependencies and if not it will start all
        registered components.

        :param names: a list of Components to start
        :type names: list

        :returns: a Deferred object that will fire once all Components have been sucessfully started
        :rtype: twisted.internet.defer.Deferred

        """
        # Start all the components if names is empty
        if not names:
            names = self.components.keys()
        elif isinstance(names, str):
            names = [names]

        def on_depends_started(result, name):
            return self.components[name]._component_start()

        deferreds = []

        for name in names:
            if self.components[name]._component_depend:
                # This component has depends, so we need to start them first.
                d = self.start(self.components[name]._component_depend)
                d.addCallback(on_depends_started, name)
                deferreds.append(d)
            else:
                deferreds.append(self.components[name]._component_start())

        return DeferredList(deferreds)

    def stop(self, names=[]):
        """
        Stops Components that are currently not in a Stopped state.  If
        *names* is specified, then it will only stop those Components,
        and if not it will stop all the registered Components.

        :param names: a list of Components to start
        :type names: list

        :returns: a Deferred object that will fire once all Components have been sucessfully stopped
        :rtype: twisted.internet.defer.Deferred

        """
        if not names:
            names = self.components.keys()
        elif isinstance(names, str):
            names = [names]

        deferreds = []

        for name in names:
            if name in self.components:
                deferreds.append(self.components[name]._component_stop())

        return DeferredList(deferreds)

    def pause(self, names=[]):
        """
        Pauses Components that are currently in a Started state.  If
        *names* is specified, then it will only pause those Components,
        and if not it will pause all the registered Components.

        :param names: a list of Components to pause
        :type names: list

        :returns: a Deferred object that will fire once all Components have been sucessfully paused
        :rtype: twisted.internet.defer.Deferred

        """
        if not names:
            names = self.components.keys()
        elif isinstance(names, str):
            names = [names]

        deferreds = []

        for name in names:
            if self.components[name]._component_state == "Started":
                deferreds.append(self.components[name]._component_pause())

        return DeferredList(deferreds)

    def resume(self, names=[]):
        """
        Resumes Components that are currently in a Paused state.  If
        *names* is specified, then it will only resume those Components,
        and if not it will resume all the registered Components.

        :param names: a list of Components to resume
        :type names: list

        :returns: a Deferred object that will fire once all Components have been sucessfully resumed
        :rtype: twisted.internet.defer.Deferred

        """
        if not names:
            names = self.components.keys()
        elif isinstance(names, str):
            names = [names]

        deferreds = []

        for name in names:
            if self.components[name]._component_state == "Paused":
                deferreds.append(self.components[name]._component_resume())

        return DeferredList(deferreds)

    def shutdown(self):
        """
        Shutdowns all Components regardless of state.  This will call
        :meth:`stop` on call the components prior to shutting down.  This should
        be called when the program is exiting to ensure all Components have a
        chance to properly shutdown.

        :returns: a Deferred object that will fire once all Components have been sucessfully resumed
        :rtype: twisted.internet.defer.Deferred

        """
        deferreds = []

        for component in self.components.values():
            deferreds.append(component._component_shutdown())

        return DeferredList(deferreds)

    def update(self):
        """
        Updates all Components that are in a Started state.

        """
        for component in self.components.items():
            component.update()

_ComponentRegistry = ComponentRegistry()

deregister = _ComponentRegistry.deregister
start = _ComponentRegistry.start
stop = _ComponentRegistry.stop
pause = _ComponentRegistry.pause
resume = _ComponentRegistry.resume
update = _ComponentRegistry.update
shutdown = _ComponentRegistry.shutdown

def get(name):
    """
    Return a reference to a component.

    :param name: the Component name to get
    :type name: string

    :returns: the Component object
    :rtype: object

    :raises KeyError: if the Component does not exist

    """
    return _ComponentRegistry.components[name]

filename:/usr/lib/python2.7/dist-packages/deluge/common.pyc
__doc__
Û
K›ıUc           @   sË  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l	 Z	 y d d l
 Z
 Wn e k
 r° d d l Z
 n Xd d l Td d l m Z e e
 d É s
e
 j e
 _ e
 j e
 _ d Ñ  Z d Ñ  Z e e
 _ e e
 _ n  ys e e	 d É r;e	 j d	 e j d	 d
 É É n  e e	 d É rZe	 j d	 É n  e j d	 e j d	 d
 É d e ÉWnI e k
 r»Z e j d É e j  e É d d l! Z! d Ñ  e! j" d <n Xi d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6Z# d d d d d  d! d g Z$ i d" d 6d# d 6d$ d 6d$ d 6d$ d 6d$ d 6d$ d 6d% d 6d d" 6d d# 6d d$ 6d d% 6Z% d& Ñ  Z& d d' Ñ Z( d( Ñ  Z) d) Ñ  Z* d* Ñ  Z+ d+ Ñ  Z, d, Ñ  Z- d d- Ñ Z. d. Ñ  Z/ d/ Ñ  Z0 d0 Ñ  Z1 d1 Ñ  Z2 d2 Ñ  Z3 d3 Ñ  Z4 d4 Ñ  Z5 d5 Ñ  Z6 d6 Ñ  Z7 d7 Ñ  Z8 d g  d8 Ñ Z9 d9 Ñ  Z: d: Ñ  Z; d; Ñ  Z< d< Ñ  Z= dN dO dP dQ dR f Z> dG Ñ  Z? dH Ñ  Z@ dI dJ Ñ ZA dI dK Ñ ZB dL eC f dM Ñ  É  YZD d S(S   s4   Common functions for various parts of Deluge to use.iˇˇˇˇN(   t   *(   t   LOGt   dumpsc         K   s   | j  t j |  É É d  S(   N(   t   writet   jsonR   (   t   objt   fpt   kw(    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   dump?   s    c         K   s   t  j |  j É  É S(   N(   R   t   loadst   read(   R   R   (    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   loadB   s    t   bindtextdomaint   deluget   i18nt
   textdomaint   unicodes$   Unable to initialize gettext/locale!c         C   s   |  S(   N(    (   t   x(    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   <lambda>S   s    t   _i    t   Queuedi   t   Checkingi   s   Downloading Metadatai   t   Downloadingi   t   Finishedi   t   Seedingi   t
   Allocatingi   s   Checking Resume Datat   Pausedt   Errors   Do Not Downloads   Normal Prioritys   High Prioritys   Highest Priorityc           C   s   t  j d É d j S(   st   
    Returns the program version from the egg metadata

    :returns: the version of Deluge
    :rtype: string

    t   Delugei    (   t   pkg_resourcest   requiret   version(    (    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   get_versionÅ   s    c         C   s  t  É  r† t j j d É } | sn d d l } | j | j d É } | j | d É } | d } | j | É n  |  rä t j	 j
 | d |  É St j	 j
 | d É Snp d d l m } y- |  r“ t j	 j
 | d É |  É S| d É SWn0 t k
 r} t j d	 | É t j d
 É n Xd S(   s¯   
    :param filename: if None, only the config path is returned, if provided, a path including the filename will be returned
    :type filename: string
    :returns: a file path to the config directory and optional filename
    :rtype: string

    t   APPDATAiˇˇˇˇNs@   Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folderst   AppDatai    R   (   t   save_config_paths7   Unable to use default config directory, exiting... (%s)i   (   t   windows_checkt   ost   environt   gett   _winregt   OpenKeyt   HKEY_CURRENT_USERt   QueryValueExt   CloseKeyt   patht   joint   xdg.BaseDirectoryR#   t   OSErrort   logt   errort   syst   exit(   t   filenamet   appDataPathR(   t   hkeyt
   appDataRegR#   t   e(    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   get_default_config_dirã   s&    	
c          C   s‚   d }  t  É  s¥ d d l m } y~ xw t t j j | d É d É D]W } | j d É rA | j d É rA t j j | j	 d É d	 j
 É  j d
 É É }  PqA qA WWq¥ t k
 r∞ q¥ Xn  |  sﬁ t j j t j j d É d É }  n  |  S(   sF   
    :returns: the default download directory
    :rtype: string

    t    iˇˇˇˇ(   t   xdg_config_homes   user-dirs.dirst   rt   #t   XDG_DOWNLOAD_DIRt   =i   t   "t   ~t	   Downloads(   R$   R/   R<   t   openR%   R-   R.   t
   startswitht
   expandvarst	   partitiont   rstript   stript   IOErrort
   expanduser(   t   download_dirR<   t   line(    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   get_default_download_dir™   s    	%.$c           C   s   t  j É  d k S(   sb   
    Checks if the current platform is Windows

    :returns: True or False
    :rtype: bool

    t   Windowst	   Microsoft(   RO   RP   (   t   platformt   system(    (    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyR$   ø   s    c           C   s   t  j É  d k S(   sh   
    Checks if the current platform is Windows Vista

    :returns: True or False
    :rtype: bool

    t   Vista(   RQ   t   release(    (    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   vista_check…   s    c           C   s   t  j É  d k S(   sc   
    Checks if the current platform is Mac OS X

    :returns: True or False
    :rtype: bool

    t   Darwin(   RQ   RR   (    (    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt	   osx_check”   s    c         C   s"   t  j d t j j d d |  É É S(   sÚ   
    Provides easy access to files in the deluge/data/pixmaps folder within the Deluge egg

    :param fname: the filename to look for
    :type fname: string
    :returns: a path to a pixmap file included with Deluge
    :rtype: string

    R   t   datat   pixmaps(   R   t   resource_filenameR%   R-   R.   (   t   fname(    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt
   get_pixmap›   s    
c         C   s”   t  É  r" t j |  j d É É n≠ t É  rE t j d d |  g É nä | d
 k rf t t	 j	 É  É } n  t j
 j É  } d t j j t j d É t j É  t j É  d | f | d <t j d d |  g d	 | Éd
 S(   sˆ   
    Opens a file or folder using the system configured program

    :param path: the path to the file or folder to open
    :type path: string
    :param timestamp: the timestamp of the event that requested to open
    :type timestamp: int

    t   utf8RD   s   %ss   %s-%u-%s-xdg_open_TIME%di    i   t   DESKTOP_STARTUP_IDs   xdg-opent   envN(   R$   R%   t	   startfilet   decodeRW   t
   subprocesst   Popent   Nonet   intt   timeR&   t   copyR-   t   basenameR3   t   argvt   getpidt   uname(   R-   t	   timestampR_   (    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt	   open_fileÍ   s    
		:c         C   s   d d l  } | j |  É d S(   sn   
    Opens a url in the desktop's default browser

    :param url: the url to open
    :type url: string

    iˇˇˇˇN(   t
   webbrowserRD   (   t   urlRn   (    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   open_url_in_browser   s    c         C   sr   |  d } | d k  r* d | t  d É f S| d } | d k  rT d | t  d É f S| d } d | t  d É f S(   s  
    Formats the bytes value into a string with KiB, MiB or GiB units

    :param fsize_b: the filesize in bytes
    :type fsize_b: int
    :returns: formatted string in KiB, MiB or GiB units
    :rtype: string

    **Usage**

    >>> fsize(112245)
    '109.6 KiB'

    g      ê@i   s   %.1f %st   KiBt   MiBt   GiB(   R   (   t   fsize_bt   fsize_kbt   fsize_mbt   fsize_gb(    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   fsize  s    


c         C   sr   |  d } | d k  r* d | t  d É f S| d } | d k  rT d | t  d É f S| d } d | t  d É f S(   s   
    Formats the bytes value into a string with K, M or G units

    :param fsize_b: the filesize in bytes
    :type fsize_b: int
    :returns: formatted string in K, M or G units
    :rtype: string

    **Usage**

    >>> fsize(112245)
    '109.6 K'

    g      ê@i   s   %.1f %st   Kt   Mt   G(   R   (   Rt   Ru   Rv   Rw   (    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   fsize_short%  s    


c         C   s   d |  d S(   s  
    Formats a string to display a percentage with two decimal places

    :param dec: the ratio in the range [0.0, 1.0]
    :type dec: float
    :returns: a formatted string representing a percentage
    :rtype: string

    **Usage**

    >>> fpcnt(0.9311)
    '93.11%'

    s   %.2f%%id   (    (   t   dec(    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   fpcnt=  s    c         C   sr   |  d } | d k  r* d | t  d É f S| d } | d k  rT d | t  d É f S| d } d | t  d É f S(   s  
    Formats a string to display a transfer speed utilizing :func:`fsize`

    :param bps: bytes per second
    :type bps: int
    :returns: a formatted string representing transfer speed
    :rtype: string

    **Usage**

    >>> fspeed(43134)
    '42.1 KiB/s'

    g      ê@i   s   %.1f %ss   KiB/ss   MiB/ss   GiB/s(   R   (   t   bpst	   fspeed_kbt	   fspeed_mbt	   fspeed_gb(    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   fspeedN  s    


c         C   s&   | d k r d |  | f Sd |  Sd S(   s©  
    Formats a string to show 'num_peers' ('total_peers')

    :param num_peers: the number of connected peers
    :type num_peers: int
    :param total_peers: the total number of peers
    :type total_peers: int
    :returns: a formatted string: num_peers (total_peers), if total_peers < 0, then it will not be shown
    :rtype: string

    **Usage**

    >>> fpeer(10, 20)
    '10 (20)'
    >>> fpeer(10, -1)
    '10'

    iˇˇˇˇs   %d (%d)s   %dN(    (   t	   num_peerst   total_peers(    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   fpeerf  s    c         C   s˛   |  d k r d S|  d k  r$ d |  S|  d } | d k  rR |  d }  d | |  f S| d } | d k  rÄ | d } d | | f S| d } | d k  rÆ | d } d	 | | f S| d } | d
 k  r‹ | d } d | | f S| d
 } | d
 } d | | f S(   s  
    Formats a string to show time in a human readable form

    :param seconds: the number of seconds
    :type seconds: int
    :returns: a formatted time string, will return '' if seconds == 0
    :rtype: string

    **Usage**

    >>> ftime(23011)
    '6h 23m'

    i    R;   i<   s   %dss   %dm %dsi   s   %dh %dmi   s   %dd %dhi4   s   %dw %dds   %dy %dw(    (   t   secondst   minutest   hourst   dayst   weekst   years(    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   ftime~  s.    









c         C   s)   |  d k  r d St  j d t  j |  É É S(   s  
    Formats a date time string in the locale's date representation based on the systems timezone

    :param seconds: time in seconds since the Epoch
    :type seconds: float
    :returns: a string in the locale's datetime representation or "" if seconds < 0
    :rtype: string

    i    R;   s   %x %X(   Rf   t   strftimet	   localtime(   Rá   (    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   fdate•  s    
c         C   s   |  j  d É d d k S(   sﬁ   
    A simple test to check if the URL is valid

    :param url: the url to test
    :type url: string
    :returns: True or False
    :rtype: bool

    **Usage**

    >>> is_url("http://deluge-torrent.org")
    True

    s   ://i    t   httpt   httpst   ftpt   udp(   Rë   Rí   Rì   Rî   (   RG   (   Ro   (    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   is_url≥  s    c         C   s/   d } d } |  j  | É r+ | |  k r+ t St S(   s  
    A check to determine if a uri is a valid bittorrent magnet uri

    :param uri: the uri to check
    :type uri: string
    :returns: True or False
    :rtype: bool

    **Usage**

    >>> is_magnet("magnet:?xt=urn:btih:SU5225URMTUEQLDXQWRB2EQWN6KLTYKN")
    True

    s   magnet:?s   xt=urn:btih:(   RE   t   Truet   False(   t   urit   magnet_schemet   xt_param(    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt	   is_magnetƒ  s
    c         C   sl   d d l  m } d | |  j d É É } | r@ | d | } n  | rh x | D] } | d | } qM Wn  | S(   sN  
    Creates a magnet uri

    :param infohash: the info-hash of the torrent
    :type infohash: string
    :param name: the name of the torrent (optional)
    :type name: string
    :param trackers: the trackers to announce to (optional)
    :type trackers: list of strings

    :returns: a magnet uri string
    :rtype: string

    iˇˇˇˇ(   t	   b32encodes   magnet:?xt=urn:btih:t   hexs   &dn=s   &tr=(   t   base64Rú   Ra   (   t   infohasht   namet   trackersRú   Rò   t   t(    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   create_magnet_uriŸ  s    c         C   s°   t  j j |  É s d St  j j |  É r8 t  j j |  É Sd } x\ t  j |  É D]K \ } } } x9 | D]1 } t  j j | | É } | t  j j | É 7} qd WqN W| S(   sÃ   
    Gets the size in bytes of 'path'

    :param path: the path to check for size
    :type path: string
    :returns: the size in bytes of the path or -1 if the path does not exist
    :rtype: int

    iˇˇˇˇi    (   R%   R-   t   existst   isfilet   getsizet   walkR.   (   R-   t   dir_sizet   pt   dirst   filest   fileR5   (    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   get_path_sizeÚ  s    
c         C   sÑ   |  s t  j j |  É r- t d |  É Ç n  t É  rT d d l m } | |  É d St  j |  j d É É } | j	 } | j
 | Sd S(   s„   
    Gets the free space available at 'path'

    :param path: the path to check
    :type path: string
    :returns: the free space at path in bytes
    :rtype: int

    :raises InvalidPathError: if the path is not valid

    s   %s is not a valid pathiˇˇˇˇ(   t   GetDiskFreeSpaceExi    R]   N(   R%   R-   R§   t   InvalidPathErrorR$   t	   win32fileRÆ   t   statvfst   encodet   f_frsizet   f_bavail(   R-   RÆ   t	   disk_datat
   block_size(    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt
   free_space	  s    		c         C   sÀ   d d l  } yD t É  r2 | j d |  É rO t Sn | j | j d |  É rO t SWn! | j k
 rs | j st t Sn Xy; t É  rë t	 j
 d É t S| j | j d |  É rÆ t SWn | j k
 r∆ t SXd S(   s»   
    A simple test to see if 'ip' is valid

    :param ip: the ip to check
    :type ip: string
    :returns: True or False
    :rtype: bool

    ** Usage **

    >>> is_ip("127.0.0.1")
    True

    iˇˇˇˇNs   %ss!   ipv6 check unavailable on windows(   t   socketR$   t	   inet_atonRñ   t	   inet_ptont   AF_INETR2   t   has_ipv6Ró   R1   t   warningt   AF_INET6(   t   ipR∏   (    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   is_ip   s$    			c          G   s]   d } xP |  D]H } | s q q | d d k r8 | } q | sG | } q | d | 7} q W| S(   s≥   
    An implementation of os.path.join that always uses / for the separator
    to ensure that the correct paths are produced when working with internal
    paths on Windows.
    R;   i    t   /(    (   t   partsR-   t   part(    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt	   path_joinF  s    		t   &s   &amp;t   <s   &lt;t   >s   &gt;RA   s   &quot;t   's   &apos;c         C   s-   x& t  D] \ } } |  j | | É }  q W|  S(   s”   
    Unescape a string that was previously encoded for use within xml.

    :param string: The string to escape
    :type string: string
    :returns: The unescaped version of the string.
    :rtype: string
    (   t   XML_ESCAPESt   replace(   t   stringt   chart   escape(    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt
   xml_decode`  s    	c         C   s-   x& t  D] \ } } |  j | | É }  q W|  S(   s    
    Escape a string for use within an xml element or attribute.

    :param string: The string to escape
    :type string: string
    :returns: An escaped version of the string.
    :rtype: string
    (   R…   R    (   RÀ   RÃ   RÕ   (    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt
   xml_encodem  s    	R]   c            s¨   à s
 d St  à t É r à Sd Ñ  d Ñ  á f d Ü  á  f d Ü  g } à  d k	 ro | j d á  f d Ü  É n  x6 | D]. } y à j | É  å  SWqv t k
 r£ qv Xqv Wd S(	   sú  
    Decodes a string and return unicode. If it cannot decode using
    `:param:encoding` then it will try latin1, and if that fails,
    try to detect the string encoding. If that fails, decode with
    ignore.

    :param s: string to decode
    :type s: string
    :keyword encoding: the encoding to use in the decoding
    :type encoding: string
    :returns: s converted to unicode
    :rtype: unicode

    u    c           S   s   d S(   NR]   t   strict(   s   utf8s   strict(    (    (    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyR   é  s    c           S   s   d S(   Ns
   iso-8859-1R–   (   s
   iso-8859-1s   strict(    (    (    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyR   è  s    c              s   t  j à  É d d f S(   Nt   encodingR–   (   t   chardett   detect(    (   t   s(    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyR   ê  s    c              s
   à  d f S(   Nt   ignore(    (    (   R—   (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyR   ë  s    R]   i    c              s
   à  d f S(   NR–   (    (    (   R—   (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyR   î  s    (   t
   isinstanceR   t   insertRa   t   UnicodeDecodeError(   R‘   R—   t	   encodingst   l(    (   R—   R‘   s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   decode_stringz  s     c         C   sO   t  |  t É r* t |  | É j d É }  n! t  |  t É rK |  j d É }  n  |  S(   s  
    Returns a utf8 encoded string of s

    :param s: (unicode) string to (re-)encode
    :type s: basestring
    :keyword encoding: the encoding to use in the decoding
    :type encoding: string
    :returns: a utf8 encoded string of s
    :rtype: str

    R]   (   R÷   t   strR€   R≤   R   (   R‘   R—   (    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   utf8_encodedù  s
    t   VersionSplitc           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   sa   
    Used for comparing version numbers.

    :param ver: the version
    :type ver: string

    c         C   sÃ   | j  É  } | j d d É j d É } g  | d j d É D] } | j É  r; t | É ^ q; |  _ d  |  _ t |  _	 t
 | É d k r» | d j d É r© | d |  _ n  | d	 d
 k r» t |  _	 q» n  d  S(   NR   t   -i    t   .i   t   rct   alphat   betaiˇˇˇˇt   dev(   s   rcR‚   R„   (   t   lowerR    t   splitt   isdigitRe   R   Rd   t   suffixRó   R‰   t   lenRE   Rñ   (   t   selft   vert   vsR   (    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   __init__∑  s    ;		c         C   sI   |  j  |  j p d |  j g } | j  | j p0 d | j g } t | | É S(   sz   
        The comparison method.

        :param ver: the version to compare with
        :type ver: VersionSplit

        t   z(   R   RË   R‰   t   cmp(   RÍ   RÎ   t   v1t   v2(    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   __cmp__√  s    (   t   __name__t
   __module__t   __doc__RÌ   RÚ   (    (    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyRﬁ   Ø  s   	(   R≈   s   &amp;(   R∆   s   &lt;(   R«   s   &gt;(   RA   s   &quot;(   R»   s   &apos;(E   Rı   R%   Rf   Rb   RQ   R3   R“   R   t   gettextt   localeR   t   ImportErrort
   simplejsont   deluge.errort
   deluge.logR   R1   t   hasattrR   R   R
   R	   R   R   R   RZ   R   t   installRñ   t	   ExceptionR9   R2   t	   exceptiont   __builtin__t   __dict__t   LT_TORRENT_STATEt   TORRENT_STATEt   FILE_PRIORITYR    Rd   R:   RN   R$   RU   RW   R\   Rm   Rp   Rx   R|   R~   RÉ   RÜ   Rç   Rê   Rï   Rõ   R£   R≠   R∑   R¿   Rƒ   R…   RŒ   Rœ   R€   R›   t   objectRﬁ   (    (    (    s1   /usr/lib/python2.7/dist-packages/deluge/common.pyt   <module>%   sŒ   
			&
	
	
		
	
	
								'						&				#
filename:/usr/lib/python2.7/dist-packages/deluge/rencode.pyc
__doc__
Û
K›ıUc           @   s`  d  Z  d Z d d g Z d d l Z d d l Z d d l m Z d Z d Z e	 d	 É Z
 e	 d
 É Z e	 d É Z e	 d É Z e	 d É Z e	 d É Z e	 d É Z e	 d É Z e	 d É Z e	 d É Z e	 d É Z e	 d É Z e	 d É Z d Z d Z d Z d Z d Z d Z d Z d Z e e Z d Z  d Ñ  Z! d Ñ  Z" d Ñ  Z# d Ñ  Z$ d Ñ  Z% d Ñ  Z& d  Ñ  Z' d! Ñ  Z( d" Ñ  Z) d# Ñ  Z* d$ Ñ  Z+ d% Ñ  Z, d& Ñ  Z- i  Z. e( e. d' <e( e. d( <e( e. d) <e( e. d* <e( e. d+ <e( e. d, <e( e. d- <e( e. d. <e( e. d/ <e( e. d0 <e) e. e
 <e* e. e <e! e. e <e" e. e <e# e. e <e$ e. e <e% e. e <e& e. e <e' e. e <e+ e. e <e, e. e <e- e. e <d1 Ñ  Z/ e/ É  d2 Ñ  Z0 e0 É  d3 Ñ  Z1 e1 É  d4 Ñ  Z2 e2 É  d5 Ñ  Z3 d6 Ñ  Z4 d d7 l5 m6 Z6 m7 Z7 m8 Z8 m9 Z9 m: Z: m; Z; m< Z< m= Z= m> Z> d8 Ñ  Z? d9 Ñ  Z@ d: Ñ  ZA d; Ñ  ZB d< Ñ  ZC d= Ñ  ZD d> Ñ  ZE d? Ñ  ZF d@ Ñ  Z3 i  ZG e? eG e7 <e? eG e8 <eD eG e6 <eF eG e: <eF eG e; <e3 eG e9 <eC eG e= <eE eG e> <e É  ZH y d dA l5 mI ZI eB eG eI <Wn eJ k
 rÚn Xe dB Ñ ZK dC Ñ  ZL y* d d lM ZM eM jN eK É eM jN e4 É Wn eJ k
 rEn XeO dD k r\eL É  n  d S(E   s_  
rencode -- Web safe object pickling/unpickling.

Public domain, Connelly Barnes 2006-2007.

The rencode module is a modified version of bencode from the
BitTorrent project.  For complex, heterogeneous data structures with
many small elements, r-encodings take up significantly less space than
b-encodings:

 >>> len(rencode.dumps({'a':0, 'b':[1,2], 'c':99}))
 13
 >>> len(bencode.bencode({'a':0, 'b':[1,2], 'c':99}))
 26

The rencode format is not standardized, and may change with different
rencode module versions, so you should check that you are using the
same rencode version throughout your project.
s   1.0.1t   dumpst   loadsiˇˇˇˇN(   t   Locki    i@   i;   i<   i=   i>   i?   iA   iB   i,   iC   iD   iE   i   i    if   i   iF   iÄ   c         C   sÊ   | d 7} |  j  t | É } | | t k r; t d É Ç n  y t |  | | !É } Wn* t t f k
 r~ t |  | | !É } n X|  | d k rØ |  | d d k rÿ t Ç qÿ n) |  | d k rÿ | | d k rÿ t Ç n  | | d f S(   Ni   t   overflowt   -t   0(   t   indext   CHR_TERMt   MAX_INT_LENGTHt
   ValueErrort   intt   OverflowErrort   long(   t   xt   ft   newft   n(    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt
   decode_into   s    
 	c         C   s3   | d 7} t  j d |  | | d !É d | d f S(   Ni   s   !bi    (   t   structt   unpack(   R   R   (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   decode_intb   s    
c         C   s3   | d 7} t  j d |  | | d !É d | d f S(   Ni   s   !hi   i    (   R   R   (   R   R   (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   decode_inthÉ   s    
c         C   s3   | d 7} t  j d |  | | d !É d | d f S(   Ni   s   !li   i    (   R   R   (   R   R   (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   decode_intlá   s    
c         C   s3   | d 7} t  j d |  | | d !É d | d f S(   Ni   s   !qi   i    (   R   R   (   R   R   (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   decode_intqã   s    
c         C   s9   | d 7} t  j d |  | | d !É d } | | d f S(   Ni   s   !fi   i    (   R   R   (   R   R   R   (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   decode_float32è   s    
!c         C   s9   | d 7} t  j d |  | | d !É d } | | d f S(   Ni   s   !di   i    (   R   R   (   R   R   R   (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   decode_float64î   s    
!c         C   s   |  j  d | É } y t |  | | !É } Wn* t t f k
 rU t |  | | !É } n X|  | d k r | | d k r t Ç n  | d 7} |  | | | !} y4 | j d É } t | É t | É k rÕ | } n  Wn t k
 r· n X| | | f S(   Nt   :R   i   t   utf8(   R   R
   R   R	   R   t   decodet   lent   UnicodeDecodeError(   R   R   t   colonR   t   st   t(    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   decode_stringô   s      	
c         C   sf   g  | d } } x> |  | t  k rQ t |  | |  | É \ } } | j | É q Wt | É | d f S(   Ni   (   R   t   decode_funct   appendt   tuple(   R   R   t   rt   v(    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   decode_list´   s
    c         C   st   i  | d } } xR |  | t  k re t |  | |  | É \ } } t |  | |  | É \ | | <} q W| | d f S(   Ni   (   R   R#   (   R   R   R&   t   k(    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   decode_dict≤   s
    %c         C   s   t  | d f S(   Ni   (   t   True(   R   R   (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   decode_trueπ   s    c         C   s   t  | d f S(   Ni   (   t   False(   R   R   (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   decode_falseº   s    c         C   s   d  | d f S(   Ni   (   t   None(   R   R   (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   decode_noneø   s    R   t   1t   2t   3t   4t   5t   6t   7t   8t   9c          C   s>   d Ñ  }  x. t  t É D]  } |  | É t t t | É <q Wd  S(   Nc            s   á  f d Ü  } | S(   Nc            ss   |  | d | d à  !} y4 | j  d É } t | É t | É k rL | } n  Wn t k
 r` n X| | d à  f S(   Ni   R   (   R   R   R   (   R   R   R    R!   (   t   slen(    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyR   ‹   s    (    (   R:   R   (    (   R:   s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   make_decoder€   s    	(   t   ranget   STR_FIXED_COUNTR#   t   chrt   STR_FIXED_START(   R;   t   i(    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt!   make_fixed_length_string_decoders⁄   s    	c          C   s>   d Ñ  }  x. t  t É D]  } |  | É t t t | É <q Wd  S(   Nc            s   á  f d Ü  } | S(   Nc            sb   g  | d } } x> t  à  É D]0 } t |  | |  | É \ } } | j | É q Wt | É | f S(   Ni   (   R<   R#   R$   R%   (   R   R   R&   R@   R'   (   R:   (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyR   Ì   s
    (    (   R:   R   (    (   R:   s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyR;   Ï   s    (   R<   t   LIST_FIXED_COUNTR#   R>   t   LIST_FIXED_START(   R;   R@   (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   make_fixed_length_list_decodersÎ   s    	c          C   ss   d Ñ  }  x. t  t É D]  } |  | É t t t | É <q Wx2 t  t É D]$ } |  d | É t t t | É <qG Wd  S(   Nc            s   á  f d Ü  } | S(   Nc            s   à  | d f S(   Ni   (    (   R   R   (   t   j(    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyR   ˚   s    (    (   RE   R   (    (   RE   s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyR;   ˙   s    iˇˇˇˇ(   R<   t   INT_POS_FIXED_COUNTR#   R>   t   INT_POS_FIXED_STARTt   INT_NEG_FIXED_COUNTt   INT_NEG_FIXED_START(   R;   R@   (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   make_fixed_length_int_decoders˘   s
    	c          C   s>   d Ñ  }  x. t  t É D]  } |  | É t t t | É <q Wd  S(   Nc            s   á  f d Ü  } | S(   Nc            sp   i  | d } } xR t  à  É D]D } t |  | |  | É \ } } t |  | |  | É \ | | <} q W| | f S(   Ni   (   R<   R#   (   R   R   R&   RE   R)   (   R:   (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyR     s
    %(    (   R:   R   (    (   R:   s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyR;     s    (   R<   t   DICT_FIXED_COUNTR#   R>   t   DICT_FIXED_START(   R;   R@   (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   make_fixed_length_dict_decoders  s    	c         C   si   | j  t É xH |  j É  D]: \ } } t t | É | | É t t | É | | É q W| j  t É d  S(   N(   R$   t   CHR_DICTt   itemst   encode_funct   typeR   (   R   R&   R)   R'   (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   encode_dict  s
    c         C   s`   y! t  |  d |  d É \ } } Wn t t f k
 r@ t Ç n X| t |  É k r\ t Ç n  | S(   Ni    (   R#   t
   IndexErrort   KeyErrorR	   R   (   R   R&   t   l(    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyR     s    !
	(	   t
   StringTypet   IntTypet   LongTypet   DictTypet   ListTypet	   TupleTypet	   FloatTypet   NoneTypet   UnicodeTypec         C   s∞  d |  k o t  k  n r6 | j t t |  É É nvt |  k oN d k  n rq | j t t d |  É É n;d |  k oà d k  n rØ | j t t j	 d |  É f É n˝ d |  k o∆ d k  n rÌ | j t
 t j	 d |  É f É nø d	 |  k od
 k  n r+| j t t j	 d |  É f É nÅ d |  k oBd k  n ri| j t t j	 d |  É f É nC t |  É } t | É t k rñt d É Ç n  | j t | t f É d  S(   Ni    i   iÄˇˇˇiÄ   s   !bi Äˇˇi Ä  s   !hi   ÄI   Ä    s   !lI       Äl            s   !qR   (   RF   R$   R>   RG   RH   RI   t   extendt   CHR_INT1R   t   packt   CHR_INT2t   CHR_INT4t   CHR_INT8t   strR   R   R	   t   CHR_INTR   (   R   R&   R    (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt
   encode_int&  s     """"c         C   s#   | j  t t j d |  É f É d  S(   Ns   !f(   R_   t   CHR_FLOAT32R   Ra   (   R   R&   (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   encode_float329  s    c         C   s#   | j  t t j d |  É f É d  S(   Ns   !d(   R_   t   CHR_FLOAT64R   Ra   (   R   R&   (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   encode_float64<  s    c         C   s)   | j  i t t 6t t 6t |  É É d  S(   N(   R_   t	   CHR_FALSER-   t   CHR_TRUER+   t   bool(   R   R&   (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   encode_bool?  s    c         C   s   | j  t É d  S(   N(   R_   t   CHR_NONE(   R   R&   (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   encode_noneB  s    c         C   s^   t  |  É t k  r8 | j t t t  |  É É |  f É n" | j t t  |  É É d |  f É d  S(   NR   (   R   R=   R_   R>   R?   Re   (   R   R&   (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   encode_stringE  s    &c         C   s   t  |  j d É | É d  S(   NR   (   Rr   t   encode(   R   R&   (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   encode_unicodeK  s    c         C   s†   t  |  É t k  rZ | j t t t  |  É É É xj |  D] } t t | É | | É q6 WnB | j t É x% |  D] } t t | É | | É qn W| j t É d  S(   N(	   R   RB   R$   R>   RC   RP   RQ   t   CHR_LISTR   (   R   R&   R@   (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   encode_listN  s    c         C   sÊ   t  |  É t k  r} | j t t t  |  É É É x∞ |  j É  D]: \ } } t t | É | | É t t | É | | É q< Wne | j t É xH |  j É  D]: \ } } t t | É | | É t t | É | | É qó W| j t	 É d  S(   N(
   R   RK   R$   R>   RL   RO   RP   RQ   RN   R   (   R   R&   R)   R'   (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyRR   Y  s    (   t   BooleanTypec         C   sà   t  j É  zc | d k r& t t t <n) | d k r? t t t <n t d | É Ç g  } t t |  É |  | É Wd t  j É  Xd j	 | É S(   sN   
    Dump data structure to str.

    Here float_bits is either 32 or 64.
    i    i@   s   Float bits (%d) is not 32 or 64Nt    (
   t   lockt   acquireRi   RP   R\   Rk   R	   RQ   t   releaset   join(   R   t
   float_bitsR&   (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyR    x  s    
c          C   s˜  t  j d t  j d d É É d }  t  j d t  j d d É É d } t  j d t  j d d É É d } i d d 6|  d 6| d	 6| d. t t d
 f d
 6d d/ f t t d d É É d d d d d d d0 d1 d2 d3 d4 d5 d6 d7 t t t d d d f f } t t | É É | k st	 Ç t
 t t d d É t d d É É É } | j i d d 6d d 6d d 6| |  6| | 6t | 6t t 6t t 6É | i  i d d 6i d d 6d t 6i d d 6d d 6d  d! 6d
 d" 6f } t t | É É | k sÂt	 Ç d
 d8 d d# d d$ d d% d d d d& d d' f } t t | É É | k s9t	 Ç t g  t d# É D]' } t
 t t | É t | É É É ^ qIÉ d9 } t t | É É | k sõt	 Ç t g  t d# É D]+ } t
 t t | É t | d É É É ^ q´É d: } t t | É É | k st	 Ç t g  t d# É D] } t t | É É ^ qÉ d; } t t | É É | k sTt	 Ç t g  t d$ É D] } d | ^ qdÉ d< } t t | É É | k süt	 Ç t g  t d$ É D] } d | ^ qØÉ d  t d  f } t t | É É | k sÛt	 Ç t t d  É É d  k st	 Ç t t i d  d  6É É i d  d  6k s=t	 Ç d( t t t d) É É d) É k  ojd* k  n sut	 Ç d( t t t d) d+ É É d) É k  o•d* k  n s∞t	 Ç t t t d) d É É d) É d, k  s€t	 Ç t t d- É É sÛt	 Ç d  S(=   Ns   !fg     Ä9@i    gÕÃÃÃÃL=@g333333„øi   t   at   bbt   cccRx   i
   i   i`y˛ˇi†Ü t   bi   i>   i@   i   i   i!   iˇˇˇˇi(   i)   i   i   i   i   i	   i'   i   i2   i1   i,   id   iË  i'  i@B iÄñò gªΩ◊Ÿﬂ|€=göôôôôôÒ?gçÌµ†˜∆∞>i    gÍ-Åôóq=u   Hello World!!(    l      Fµx:^V i   @I       I       @l            i   @I       I       @l            t
   aaaaaaaaaa(   RÅ   (   RÅ   (   RÅ   (   RÅ   (   R   R   Ra   R-   R+   R%   R<   R   R    t   AssertionErrort   dictt   zipt   updateR/   t   abs(   t   f1t   f2t   f3t   Lt   dR   (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   testå  s6    """ë'EF6DH5-6,8;+t   __main__(P   t   __doc__t   __version__t   __all__R   t   stringt	   threadingR   t   DEFAULT_FLOAT_BITSR   R>   Ru   RN   Rf   R`   Rb   Rc   Rd   Rh   Rj   Rm   Rl   Rp   R   RG   RF   RL   RK   RI   RH   R?   R=   RC   RB   R   R   R   R   R   R   R   R"   R(   R*   R,   R.   R0   R#   RA   RD   RJ   RM   RR   R   t   typesRV   RW   RX   RY   RZ   R[   R\   R]   R^   Rg   Ri   Rk   Ro   Rq   Rr   Rt   Rv   RP   Ry   Rw   t   ImportErrorR    Rç   t   psycot   bindt   __name__(    (    (    s2   /usr/lib/python2.7/dist-packages/deluge/rencode.pyt   <module>   sﬁ   *
													





















			
				@									







		
filename:/usr/lib/python2.7/dist-packages/deluge/config.pyc
__doc__
Û
K›ıUc           @   s~   d  Z  d d l Z d d l Z d d l Z d d l Z d d l m Z	 e j
 j Z d Ñ  Z d Ñ  Z d e f d Ñ  É  YZ d S(   ss  
Deluge Config Module

This module is used for loading and saving of configuration files.. or anything
really.

The format of the config file is two json encoded dicts:

<version dict>
<content dict>

The version dict contains two keys: file and format.  The format version is
controlled by the Config class.  It should only be changed when anything below
it is changed directly by the Config class.  An example of this would be if we
changed the serializer for the content to something different.

The config file version is changed by the 'owner' of the config file.  This is
to signify that there is a change in the naming of some config keys or something
similar along those lines.

The content is simply the dict to be saved and will be serialized before being
written.

Converting

Since the format of the config could change, there needs to be a way to have
the Config object convert to newer formats.  To do this, you will need to
register conversion functions for various versions of the config file. Note that
this can only be done for the 'config file version' and not for the 'format'
version as this will be done internally.

iˇˇˇˇN(   t   LOGc         C   s   t  d |  j |  É  ç S(   sÿ  Function decorator for defining property attributes

    The decorated function is expected to return a dictionary
    containing one or more of the following pairs:
        fget - function for getting attribute value
        fset - function for setting attribute value
        fdel - function for deleting attribute
    This can be conveniently constructed by the locals() builtin
    function; see:
    http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/205183
    t   doc(   t   propertyt   __doc__(   t   func(    (    s1   /usr/lib/python2.7/dist-packages/deluge/config.pyt   propO   s    c         C   s¿   g  } d } |  j  d É } | } | d k  r1 g  Sxà t |  | É D]v \ } } | d k rg | d 7} qB | d k rB | d 8} | d k r∏ | j | | | d f É | | d } q∏ qB qB W| S(   sÙ   
    Find json objects in a string.

    :param s: the string to find json objects in
    :type s: string

    :returns: a list of tuples containing start and end locations of json objects in the string `s`
    :rtype: [(start, end), ...]

    i    t   {i   t   }(   t   findt	   enumeratet   append(   t   st   objectst   openst   startt   offsett   indext   c(    (    s1   /usr/lib/python2.7/dist-packages/deluge/config.pyt   find_json_objects]   s    
t   Configc           B   s∞   e  Z d  Z d d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 e d Ñ Z d	 Ñ  Z d
 Ñ  Z d d Ñ Z d d Ñ Z d Ñ  Z e d Ñ  É Z e d Ñ  É Z RS(   sﬁ   
    This class is used to access/create/modify config files

    :param filename: the name of the config file
    :param defaults: dictionary of default values
    :param config_dir: the path to the config directory

    c         C   sµ   i  |  _  i  |  _ g  |  _ i d d 6d d 6|  _ d  |  _ | rq x- | j É  D] \ } } |  j | | É qN Wn  | rí t j	 j
 | | É |  _ n t j j | É |  _ |  j É  d  S(   Ni   t   formatt   file(   t   _Config__configt   _Config__set_functionst   _Config__change_callbackst   _Config__versiont   Nonet   _save_timert	   iteritemst   set_itemt   ost   patht   joint   _Config__config_filet   deluget   commont   get_default_config_dirt   load(   t   selft   filenamet   defaultst
   config_dirt   keyt   value(    (    s1   /usr/lib/python2.7/dist-packages/deluge/config.pyt   __init__Ö   s    				c         C   s   | |  j  k S(   N(   R   (   R&   t   item(    (    s1   /usr/lib/python2.7/dist-packages/deluge/config.pyt   __contains__†   s    c         C   s   |  j  | | É S(   s.   
        See
        :meth:`set_item`
        (   R   (   R&   R*   R+   (    (    s1   /usr/lib/python2.7/dist-packages/deluge/config.pyt   __setitem__£   s    c            s
  t  | t É r$ t j j | É } n  à  j j | É sc | à  j | <t j d | | t	 | É É d Sà  j | | k rz d St	 à  j | É t	 | É } } | d k	 r| t	 d É k r| | k ry. | t k rÂ | | d É } n | | É } Wqt k
 rt j d | | É Ç  qXn  t j d | | t	 | É É | à  j | <d d l m } y2 x+ à  j | D] } | j d | | | É qiWWn t k
 rùn Xy) á  f d Ü  } | j d | | | É Wn n Xà  j sÎà  j j É  r| j d	 à  j É à  _ n  d S(
   s¨  
        Sets item 'key' to 'value' in the config dictionary, but does not allow
        changing the item's type unless it is None.  If the types do not match,
        it will attempt to convert it to the set type before raising a ValueError.

        :param key: string, item to change to change
        :param value: the value to change item to, must be same type as what is currently in the config

        :raises ValueError: raised when the type of value is not the same aswhat is currently in the config and it could not convert the value

        **Usage**

        >>> config = Config("test.conf")
        >>> config["test"] = 5
        >>> config["test"]
        5

        s   Setting '%s' to %s of %sNt   utf8s   Type '%s' invalid for '%s'iˇˇˇˇ(   t   reactori    c            s%   x à  j  D] } | |  | É q
 Wd  S(   N(   R   (   R*   R+   R   (   R&   (    s1   /usr/lib/python2.7/dist-packages/deluge/config.pyt   do_change_callbacks„   s    i   (   t
   isinstancet
   basestringR"   R#   t   utf8_encodedR   t   has_keyt   logt   debugt   typeR   t   unicodet
   ValueErrort   warningt   twisted.internetR1   R   t	   callLatert   KeyErrorR   t   activet   save(   R&   R*   R+   t   oldtypet   newtypeR1   R   R2   (    (   R&   s1   /usr/lib/python2.7/dist-packages/deluge/config.pyR   ´   s@     *
c         C   s   |  j  | É S(   s.   
        See
        :meth:`get_item`
        (   t   get_item(   R&   R*   (    (    s1   /usr/lib/python2.7/dist-packages/deluge/config.pyt   __getitem__Ó   s    c         C   s\   t  |  j | t É rM y |  j | j d É SWqX t k
 rI |  j | SXn |  j | Sd S(   sP  
        Gets the value of item 'key'

        :param key: the item for which you want it's value
        :return: the value of item 'key'

        :raises KeyError: if 'key' is not in the config dictionary

        **Usage**

        >>> config = Config("test.conf", defaults={"test": 5})
        >>> config["test"]
        5

        R0   N(   R3   R   t   strt   decodet   UnicodeDecodeError(   R&   R*   (    (    s1   /usr/lib/python2.7/dist-packages/deluge/config.pyRD   ı   s    c         C   s   |  j  j | É d S(   sÇ  
        Registers a callback function that will be called when a value is changed in the config dictionary

        :param callback: the function, callback(key, value)

        **Usage**

        >>> config = Config("test.conf", defaults={"test": 5})
        >>> def cb(key, value):
        ...     print key, value
        ...
        >>> config.register_change_callback(cb)

        N(   R   R
   (   R&   t   callback(    (    s1   /usr/lib/python2.7/dist-packages/deluge/config.pyt   register_change_callback  s    c         C   sd   t  j d | É | |  j k r/ g  |  j | <n  |  j | j | É | r` | | |  j | É n  d S(   s"  
        Register a function to be called when a config value changes

        :param key: the item to monitor for change
        :param function: the function to call when the value changes, f(key, value)
        :keyword apply_now: if True, the function will be called after it's registered

        **Usage**

        >>> config = Config("test.conf", defaults={"test": 5})
        >>> def cb(key, value):
        ...     print key, value
        ...
        >>> config.register_set_function("test", cb, apply_now=True)
        test 5

        s!   Registering function for %s key..N(   R7   R8   R   R
   R   (   R&   R*   t   functiont	   apply_now(    (    s1   /usr/lib/python2.7/dist-packages/deluge/config.pyt   register_set_function  s    c         C   sV   t  j d É xB |  j j É  D]1 \ } } x" | D] } | | |  j | É q0 Wq Wd S(   s>  
        Calls all set functions

        **Usage**

        >>> config = Config("test.conf", defaults={"test": 5})
        >>> def cb(key, value):
        ...     print key, value
        ...
        >>> config.register_set_function("test", cb, apply_now=False)
        >>> config.apply_all()
        test 5

        s   Calling all set functions..N(   R7   R8   R   R   R   (   R&   R*   R+   R   (    (    s1   /usr/lib/python2.7/dist-packages/deluge/config.pyt	   apply_all;  s    c         C   sR   t  j d | É | |  j k rN x, |  j | D] } | | |  j | É q- Wn  d S(   sa   
        Calls set functions for `:param:key`.

        :param key: str, the config key

        s"   Calling set functions for key %s..N(   R7   R8   R   R   (   R&   R*   R   (    (    s1   /usr/lib/python2.7/dist-packages/deluge/config.pyt   apply_set_functionsO  s    c         C   s  | s |  j  } n  y t | d É j É  } Wn' t k
 rT } t j d | | É d SXt | É } t | É s¿ y |  j j	 t
 j | É É WqËt k
 rº } t j | É t j d | É qËXn(t | É d k r<| d \ } } y$ |  j j	 t j | | | !É É WqËt k
 r8} t j | É t j d | É qËXn¨ t | É d k rËyd | d \ } } |  j j	 t j | | | !É É | d \ } } |  j j	 t j | | | !É É WqËt k
 r‰} t j | É t j d | É qËXn  t j d | |  j d	 |  j d
 |  j É d S(   st   
        Load a config file

        :param filename: if None, uses filename set in object initialization


        t   rbs!   Unable to open config file %s: %sNs   Unable to load config file: %si   i    i   s#   Config %s version: %s.%s loaded: %sR   R   (   R!   t   opent   readt   IOErrorR7   R<   R   t   lenR   t   updatet   picklet   loadst	   Exceptiont	   exceptiont   jsonR   R8   (   R&   R'   t   datat   eR   R   t   end(    (    s1   /usr/lib/python2.7/dist-packages/deluge/config.pyR%   [  s@    $ $c   
      C   sÄ  | s |  j  } n  yª t | d É j É  } t | É } | d \ } } t j | | | !É } | d \ } } t j | | | !É } |  j | k rÃ |  j | k rÃ |  j r» |  j j	 É  r» |  j j
 É  n  t SWn, t t f k
 r˚ } t j d | | É n XyÑ t j d | d É t | d d É }	 t j |  j |	 d d	 Ét j |  j |	 d d	 É|	 j É  t j |	 j É  É |	 j É  Wn$ t k
 r¶} t j d
 | É t SXy( t j d | É t j | | d É Wn  t k
 rÒ} t j d É n Xz^ y/ t j d | d | É t j | d | É Wn$ t k
 rJ} t j d | É t SXt SWd |  j r{|  j j	 É  r{|  j j
 É  n  Xd S(   sƒ   
        Save configuration to disk

        :param filename: if None, uses filename set in object initiliazation
        :rtype bool:
        :return: whether or not the save succeeded.

        RP   i    i   s*   Unable to open config file: %s because: %ss   Saving new config file %ss   .newt   wbt   indenti   s!   Error writing new config file: %ss!   Backing up old config file to %s~t   ~s   Unable to backup old config...s!   Moving new config file %s to %s..s    Error moving new config file: %sN(   R!   RQ   RR   R   RZ   RW   R   R   R   R@   t   cancelt   TrueRS   t
   IndexErrorR7   R<   R8   t   dumpt   flushR   t   fsynct   filenot   closet   errort   Falset   shutilt   moveRX   (
   R&   R'   R[   R   R   R]   t   versiont   loaded_dataR\   t   f(    (    s1   /usr/lib/python2.7/dist-packages/deluge/config.pyRA   â  sR    	
 c         C   sÿ   | | k s | t  | É k r- t d É Ç n  |  j d | k r^ t j d |  j d | É d Sy | |  j É |  _ WnF t k
 rº } t j | É t j d |  j	 |  j d | É | Ç n X| |  j d <|  j
 É  d S(   s,  
        Runs a function that will convert file versions in the `:param:input_range`
        to the `:param:output_version`.

        :param input_range: tuple, (int, int) the range of input versions this
            function will accept
        :param output_version: int, the version this function will return
        :param func: func, the function that will do the conversion, it will take
            the config dict as an argument and return the augmented dict

        :raises ValueError: if the output_version is less than the input_range

        s3   output_version needs to be greater than input_rangeR   sG   File version %s is not in input_range %s, ignoring converter function..Ns=   There was an exception try to convert config file %s %s to %s(   t   maxR;   R   R7   R8   R   RX   RY   Ri   R!   RA   (   R&   t   input_ranget   output_versionR   R\   (    (    s1   /usr/lib/python2.7/dist-packages/deluge/config.pyt   run_converter«  s    		
c         C   s   |  j  S(   N(   R!   (   R&   (    (    s1   /usr/lib/python2.7/dist-packages/deluge/config.pyt   config_fileË  s    c          C   s   d Ñ  }  d Ñ  } t  É  S(   s   The config dictionaryc         S   s   |  j  S(   N(   R   (   R&   (    (    s1   /usr/lib/python2.7/dist-packages/deluge/config.pyt   fgetÔ  s    c         S   s
   |  j  É  S(   N(   RA   (   R&   (    (    s1   /usr/lib/python2.7/dist-packages/deluge/config.pyt   fdelÒ  s    (   t   locals(   Ru   Rv   (    (    s1   /usr/lib/python2.7/dist-packages/deluge/config.pyt   configÏ  s    		N(   t   __name__t
   __module__R   R   R,   R.   R/   R   RE   RD   RJ   Rb   RM   RN   RO   R%   RA   Rs   R   Rt   R   Rx   (    (    (    s1   /usr/lib/python2.7/dist-packages/deluge/config.pyR   |   s    			C					.>	!(   R   t   cPickleRV   Rk   R   t   deluge.commonR"   t
   deluge.logR    R7   R#   RZ   R   R   t   objectR   (    (    (    s1   /usr/lib/python2.7/dist-packages/deluge/config.pyt   <module>D   s   		
filename:/usr/lib/python2.7/dist-packages/deluge/httpdownloader.py
__doc__
#
# httpdownloader.py
#
# Copyright (C) 2009 Andrew Resch <andrewresch@gmail.com>
#
# Deluge is free software.
#
# You may redistribute it and/or modify it under the terms of the
# GNU General Public License, as published by the Free Software
# Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# deluge is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with deluge.    If not, write to:
# 	The Free Software Foundation, Inc.,
# 	51 Franklin Street, Fifth Floor
# 	Boston, MA  02110-1301, USA.
#
#    In addition, as a special exception, the copyright holders give
#    permission to link the code of portions of this program with the OpenSSL
#    library.
#    You must obey the GNU General Public License in all respects for all of
#    the code used other than OpenSSL. If you modify file(s) with this
#    exception, you may extend this exception to your version of the file(s),
#    but you are not obligated to do so. If you do not wish to do so, delete
#    this exception statement from your version. If you delete this exception
#    statement from all source files in the program, then also delete it here.
#

from twisted.web import client, http
from twisted.web.error import PageRedirect
from twisted.python.failure import Failure
from twisted.internet import reactor
from deluge.log import setupLogger, LOG as log
from common import get_version
import os.path
import zlib

class HTTPDownloader(client.HTTPDownloader):
    """
    Factory class for downloading files and keeping track of progress.
    """
    def __init__(self, url, filename, part_callback=None, headers=None, force_filename=False, allow_compression=True):
        """
        :param url: the url to download from
        :type url: string
        :param filename: the filename to save the file as
        :type filename: string
        :param force_filename: forces use of the supplied filename, regardless of header content
        :type force_filename: bool
        :param part_callback: a function to be called when a part of data
            is received, it's signature should be: func(data, current_length, total_length)
        :type part_callback: function
        :param headers: any optional headers to send
        :type headers: dictionary
        """
        self.part_callback = part_callback
        self.current_length = 0
        self.decoder = None
        self.value = filename
        self.force_filename = force_filename
        self.allow_compression = allow_compression
        agent = "Deluge/%s (http://deluge-torrent.org)" % get_version()
        client.HTTPDownloader.__init__(self, url, filename, headers=headers, agent=agent)

    def gotStatus(self, version, status, message):
        self.code = int(status)
        client.HTTPDownloader.gotStatus(self, version, status, message)

    def gotHeaders(self, headers):
        if self.code == http.OK:
            if "content-length" in headers:
                self.total_length = int(headers["content-length"][0])
            else:
                self.total_length = 0

            if self.allow_compression and "content-encoding" in headers and \
               headers["content-encoding"][0] in ("gzip", "x-gzip", "deflate"):
                # Adding 32 to the wbits enables gzip & zlib decoding (with automatic header detection)
                # Adding 16 just enables gzip decoding (no zlib)
                self.decoder = zlib.decompressobj(zlib.MAX_WBITS + 32)

            if "content-disposition" in headers and not self.force_filename:
                new_file_name = str(headers["content-disposition"][0]).split(";")[1].split("=")[1]
                new_file_name = sanitise_filename(new_file_name)
                new_file_name = os.path.join(os.path.split(self.fileName)[0], new_file_name)

                count = 1
                fileroot = os.path.splitext(new_file_name)[0]
                fileext = os.path.splitext(new_file_name)[1]
                while os.path.isfile(new_file_name):
                    # Increment filename if already exists
                    new_file_name = "%s-%s%s" % (fileroot, count, fileext)
                    count += 1

                self.fileName = new_file_name
                self.value = new_file_name

        elif self.code in (http.MOVED_PERMANENTLY, http.FOUND, http.SEE_OTHER, http.TEMPORARY_REDIRECT):
            location = headers["location"][0]
            error = PageRedirect(self.code, location=location)
            self.noPage(Failure(error))

        return client.HTTPDownloader.gotHeaders(self, headers)

    def pagePart(self, data):
        if self.code == http.OK:
            self.current_length += len(data)
            if self.decoder:
                data = self.decoder.decompress(data)
            if self.part_callback:
                self.part_callback(data, self.current_length, self.total_length)

        return client.HTTPDownloader.pagePart(self, data)

    def pageEnd(self):
        if self.decoder:
            data = self.decoder.flush()
            self.current_length -= len(data)
            self.decoder = None
            self.pagePart(data)

        return client.HTTPDownloader.pageEnd(self)

def sanitise_filename(filename):
    """
    Sanitises a filename to use as a download destination file.
    Logs any filenames that could be considered malicious.

    :param filename: the filename to sanitise
    :type filename: string
    :returns: the sanitised filename
    :rtype: string
    """

    # Remove any quotes
    filename = filename.strip("'\"")

    if os.path.basename(filename) != filename:
        # Dodgy server, log it
        log.warning("Potentially malicious server: trying to write to file '%s'" % filename)
        # Only use the basename
        filename = os.path.basename(filename)

    filename = filename.strip()
    if filename.startswith(".") or ";" in filename or "|" in filename:
        # Dodgy server, log it
        log.warning("Potentially malicious server: trying to write to file '%s'" % filename)

    return filename

def download_file(url, filename, callback=None, headers=None, force_filename=False, allow_compression=True):
    """
    Downloads a file from a specific URL and returns a Deferred.  You can also
    specify a callback function to be called as parts are received.

    :param url: the url to download from
    :type url: string
    :param filename: the filename to save the file as
    :type filename: string
    :param callback: a function to be called when a part of data is received,
         it's signature should be: func(data, current_length, total_length)
    :type callback: function
    :param headers: any optional headers to send
    :type headers: dictionary
    :param force_filename: force us to use the filename specified rather than
                           one the server may suggest
    :type force_filename: boolean
    :param allow_compression: allows gzip & deflate decoding
    :type allow_compression: boolean

    :returns: the filename of the downloaded file
    :rtype: Deferred

    :raises t.w.e.PageRedirect: when server responds with a temporary redirect
         or permanently moved.
    :raises t.w.e.Error: for all other HTTP response errors (besides OK)
    """
    url = str(url)
    filename = str(filename)
    if headers:
        for key, value in headers.items():
            headers[str(key)] = str(value)

    if allow_compression:
        if not headers:
            headers = {}
        headers["accept-encoding"] = "deflate, gzip, x-gzip"

    # In Twisted 13.1.0 _parse() function replaced by _URI class.
    # In Twisted 15.0.0 _URI class renamed to URI.
    if hasattr(client, "_parse"):
        scheme, host, port, path = client._parse(url)
    else:
        try:
            from twisted.web.client import _URI as URI
        except ImportError:
            from twisted.web.client import URI

        uri = URI.fromBytes(url)
        scheme = uri.scheme
        host = uri.host
        port = uri.port
        path = uri.path

    factory = HTTPDownloader(url, filename, callback, headers, force_filename, allow_compression)
    if scheme == "https":
        from twisted.internet import ssl
        reactor.connectSSL(host, port, factory, ssl.ClientContextFactory())
    else:
        reactor.connectTCP(host, port, factory)

    return factory.deferred

filename:/usr/lib/python2.7/dist-packages/deluge/plugins/pluginbase.pyc
__doc__
Û
K›ıUc           @   s~   d  d l  j Z d  d l m Z d e j f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d	 e f d
 Ñ  É  YZ	 d S(   iˇˇˇˇN(   t   LOGt
   PluginBasec           B   s)   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   i   c         C   s    t  t |  É j | |  j É d  S(   N(   t   superR   t   __init__t   update_interval(   t   selft   name(    (    s=   /usr/lib/python2.7/dist-packages/deluge/plugins/pluginbase.pyR   +   s    c         C   s   t  d É Ç d  S(   Ns    Need to define an enable method!(   t   NotImplementedError(   R   (    (    s=   /usr/lib/python2.7/dist-packages/deluge/plugins/pluginbase.pyt   enable.   s    c         C   s   t  d É Ç d  S(   Ns    Need to define a disable method!(   R   (   R   (    (    s=   /usr/lib/python2.7/dist-packages/deluge/plugins/pluginbase.pyt   disable1   s    (   t   __name__t
   __module__R   R   R   R	   (    (    (    s=   /usr/lib/python2.7/dist-packages/deluge/plugins/pluginbase.pyR   '   s   		t   CorePluginBasec           B   s   e  Z d  Ñ  Z RS(   c         C   sJ   t  t |  É j d | É t j d É j |  | j É  É t j d É d  S(   Ns   CorePlugin.t	   RPCServers   CorePlugin initialized..(	   R   R   R   t	   componentt   gett   register_objectt   lowert   logt   debug(   R   t   plugin_name(    (    s=   /usr/lib/python2.7/dist-packages/deluge/plugins/pluginbase.pyR   5   s    (   R
   R   R   (    (    (    s=   /usr/lib/python2.7/dist-packages/deluge/plugins/pluginbase.pyR   4   s   t   GtkPluginBasec           B   s   e  Z d  Ñ  Z RS(   c         C   s+   t  t |  É j d | É t j d É d  S(   Ns
   GtkPlugin.s   GtkPlugin initialized..(   R   R   R   R   R   (   R   R   (    (    s=   /usr/lib/python2.7/dist-packages/deluge/plugins/pluginbase.pyR   <   s    (   R
   R   R   (    (    (    s=   /usr/lib/python2.7/dist-packages/deluge/plugins/pluginbase.pyR   ;   s   t   WebPluginBasec           B   s;   e  Z g  Z g  Z g  Z g  Z d  Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   sJ   t  t |  É j d | É t j d É j |  | j É  É t j d É d  S(   Ns
   WebPlugin.t   JSONs   WebPlugin initialized..(	   R   R   R   R   R   R   R   R   R   (   R   R   (    (    s=   /usr/lib/python2.7/dist-packages/deluge/plugins/pluginbase.pyR   H   s    c         C   s   d  S(   N(    (   R   (    (    s=   /usr/lib/python2.7/dist-packages/deluge/plugins/pluginbase.pyR   O   s    c         C   s   d  S(   N(    (   R   (    (    s=   /usr/lib/python2.7/dist-packages/deluge/plugins/pluginbase.pyR	   R   s    (	   R
   R   t   scriptst   debug_scriptst   stylesheetst   debug_stylesheetsR   R   R	   (    (    (    s=   /usr/lib/python2.7/dist-packages/deluge/plugins/pluginbase.pyR   @   s   		(
   t   deluge.componentR   t
   deluge.logR    R   t	   ComponentR   R   R   R   (    (    (    s=   /usr/lib/python2.7/dist-packages/deluge/plugins/pluginbase.pyt   <module>$   s
   
filename:/usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/data/config.glade
__doc__
<?xml version="1.0"?>
<glade-interface>
  <!-- interface-requires gtk+ 2.16 -->
  <!-- interface-naming-policy toplevel-contextual -->
  <widget class="GtkWindow" id="window1">
    <child>
      <widget class="GtkVBox" id="prefs_box">
        <property name="visible">True</property>
        <child>
          <widget class="GtkFrame" id="settings_frame">
            <property name="visible">True</property>
            <property name="label_xalign">0</property>
            <property name="shadow_type">none</property>
            <child>
              <widget class="GtkAlignment" id="settings_alignment">
                <property name="visible">True</property>
                <property name="top_padding">10</property>
                <property name="left_padding">12</property>
                <child>
                  <widget class="GtkVBox" id="settings_vbox">
                    <property name="visible">True</property>
                    <property name="spacing">5</property>
                    <child>
                      <widget class="GtkCheckButton" id="enabled_checkbutton">
                        <property name="label" translatable="yes">Enable web interface</property>
                        <property name="visible">True</property>
                        <property name="can_focus">True</property>
                        <property name="receives_default">False</property>
                        <property name="draw_indicator">True</property>
                      </widget>
                      <packing>
                        <property name="expand">False</property>
                        <property name="fill">False</property>
                        <property name="position">0</property>
                      </packing>
                    </child>
                    <child>
                      <widget class="GtkCheckButton" id="ssl_checkbutton">
                        <property name="label" translatable="yes">Enable SSL</property>
                        <property name="visible">True</property>
                        <property name="can_focus">True</property>
                        <property name="receives_default">False</property>
                        <property name="draw_indicator">True</property>
                      </widget>
                      <packing>
                        <property name="expand">False</property>
                        <property name="fill">False</property>
                        <property name="position">1</property>
                      </packing>
                    </child>
                    <child>
                      <widget class="GtkHBox" id="port_hbox">
                        <property name="visible">True</property>
                        <property name="spacing">5</property>
                        <child>
                          <widget class="GtkLabel" id="port_label">
                            <property name="visible">True</property>
                            <property name="label" translatable="yes">Listening port:</property>
                          </widget>
                          <packing>
                            <property name="expand">False</property>
                            <property name="fill">False</property>
                            <property name="position">0</property>
                          </packing>
                        </child>
                        <child>
                          <widget class="GtkSpinButton" id="port_spinbutton">
                            <property name="visible">True</property>
                            <property name="can_focus">True</property>
                            <property name="invisible_char">&#x25CF;</property>
                            <property name="adjustment">8112 0 99999 1 10 0</property>
                            <property name="numeric">True</property>
                          </widget>
                          <packing>
                            <property name="position">1</property>
                          </packing>
                        </child>
                      </widget>
                      <packing>
                        <property name="expand">False</property>
                        <property name="fill">False</property>
                        <property name="position">2</property>
                      </packing>
                    </child>
                  </widget>
                </child>
              </widget>
            </child>
            <child>
              <widget class="GtkLabel" id="settings_label">
                <property name="visible">True</property>
                <property name="label" translatable="yes">&lt;b&gt;Settings&lt;/b&gt;</property>
                <property name="use_markup">True</property>
              </widget>
              <packing>
                <property name="type">label_item</property>
              </packing>
            </child>
          </widget>
          <packing>
            <property name="position">0</property>
          </packing>
        </child>
      </widget>
    </child>
  </widget>
</glade-interface>

filename:/usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/__init__.py
__doc__
#
# __init__.py
#
# Copyright (C) 2009 Damien Churchill <damoxc@gmail.com>
#
# Basic plugin template created by:
# Copyright (C) 2008 Martijn Voncken <mvoncken@gmail.com>
# Copyright (C) 2007-2009 Andrew Resch <andrewresch@gmail.com>
#
# Deluge is free software.
#
# You may redistribute it and/or modify it under the terms of the
# GNU General Public License, as published by the Free Software
# Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# deluge is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with deluge.    If not, write to:
# 	The Free Software Foundation, Inc.,
# 	51 Franklin Street, Fifth Floor
# 	Boston, MA  02110-1301, USA.
#
#    In addition, as a special exception, the copyright holders give
#    permission to link the code of portions of this program with the OpenSSL
#    library.
#    You must obey the GNU General Public License in all respects for all of
#    the code used other than OpenSSL. If you modify file(s) with this
#    exception, you may extend this exception to your version of the file(s),
#    but you are not obligated to do so. If you do not wish to do so, delete
#    this exception statement from your version. If you delete this exception
#    statement from all source files in the program, then also delete it here.
#

from deluge.plugins.init import PluginInitBase

class CorePlugin(PluginInitBase):
    def __init__(self, plugin_name):
        from core import Core as _plugin_cls
        self._plugin_cls = _plugin_cls
        super(CorePlugin, self).__init__(plugin_name)

class GtkUIPlugin(PluginInitBase):
    def __init__(self, plugin_name):
        from gtkui import GtkUI as _plugin_cls
        self._plugin_cls = _plugin_cls
        super(GtkUIPlugin, self).__init__(plugin_name)

class WebUIPlugin(PluginInitBase):
    def __init__(self, plugin_name):
        from webui import WebUI as _plugin_cls
        self._plugin_cls = _plugin_cls
        super(WebUIPlugin, self).__init__(plugin_name)

filename:/usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/common.pyc
__doc__
Û
J›ıUc           @   s   d  Ñ  Z  d S(   c         C   s7   d d  l  } d d  l } | j d | j j d |  É É S(   Niˇˇˇˇt   webuit   data(   t   pkg_resourcest   ost   resource_filenamet   patht   join(   t   filenameR   R   (    (    sM   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/common.pyt   get_resource'   s    N(   R   (    (    (    sM   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/common.pyt   <module>'   s    
filename:/usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/gtkui.py
__doc__
#
# gtkui.py
#
# Copyright (C) 2009 Damien Churchill <damoxc@gmail.com>
#
# Basic plugin template created by:
# Copyright (C) 2008 Martijn Voncken <mvoncken@gmail.com>
# Copyright (C) 2007-2009 Andrew Resch <andrewresch@gmail.com>
#
# Deluge is free software.
#
# You may redistribute it and/or modify it under the terms of the
# GNU General Public License, as published by the Free Software
# Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# deluge is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with deluge.    If not, write to:
# 	The Free Software Foundation, Inc.,
# 	51 Franklin Street, Fifth Floor
# 	Boston, MA  02110-1301, USA.
#
#    In addition, as a special exception, the copyright holders give
#    permission to link the code of portions of this program with the OpenSSL
#    library.
#    You must obey the GNU General Public License in all respects for all of
#    the code used other than OpenSSL. If you modify file(s) with this
#    exception, you may extend this exception to your version of the file(s),
#    but you are not obligated to do so. If you do not wish to do so, delete
#    this exception statement from your version. If you delete this exception
#    statement from all source files in the program, then also delete it here.
#

import gtk

from deluge.log import LOG as log
from deluge.ui.client import client
from deluge.plugins.pluginbase import GtkPluginBase
import deluge.component as component
import deluge.common

from common import get_resource

class GtkUI(GtkPluginBase):
    def enable(self):
        self.glade = gtk.glade.XML(get_resource("config.glade"))

        component.get("Preferences").add_page(_("WebUi"), self.glade.get_widget("prefs_box"))
        component.get("PluginManager").register_hook("on_apply_prefs", self.on_apply_prefs)
        component.get("PluginManager").register_hook("on_show_prefs", self.on_show_prefs)
        client.webui.get_config().addCallback(self.cb_get_config)
        client.webui.got_deluge_web().addCallback(self.cb_chk_deluge_web)

    def disable(self):
        component.get("Preferences").remove_page(_("WebUi"))
        component.get("PluginManager").deregister_hook("on_apply_prefs", self.on_apply_prefs)
        component.get("PluginManager").deregister_hook("on_show_prefs", self.on_show_prefs)

    def on_apply_prefs(self):
        if not self.have_web:
            return
        log.debug("applying prefs for WebUi")
        config = {
            "enabled": self.glade.get_widget("enabled_checkbutton").get_active(),
            "ssl": self.glade.get_widget("ssl_checkbutton").get_active(),
            "port": self.glade.get_widget("port_spinbutton").get_value_as_int()
        }
        client.webui.set_config(config)

    def on_show_prefs(self):
        client.webui.get_config().addCallback(self.cb_get_config)

    def cb_get_config(self, config):
        "callback for on show_prefs"
        self.glade.get_widget("enabled_checkbutton").set_active(config["enabled"])
        self.glade.get_widget("ssl_checkbutton").set_active(config["ssl"])
        self.glade.get_widget("port_spinbutton").set_value(config["port"])

    def cb_chk_deluge_web(self, have_web):
        self.have_web = have_web
        if have_web:
            return
        self.glade.get_widget("settings_vbox").set_sensitive(False)

        vbox = self.glade.get_widget("prefs_box")

        hbox = gtk.HBox()
        icon = gtk.image_new_from_stock(gtk.STOCK_DIALOG_ERROR, gtk.ICON_SIZE_SMALL_TOOLBAR)
        icon.set_padding(5, 5)
        hbox.pack_start(icon, False, False)

        label = gtk.Label(_("The Deluge web interface is not installed, "
            "please install the\ninterface and try again"))
        label.set_alignment(0, 0.5)
        label.set_padding(5, 5)
        hbox.pack_start(label)

        vbox.pack_start(hbox, False, False, 10)
        vbox.reorder_child(hbox, 0)
        vbox.show_all()

filename:/usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/core.pyc
__doc__
Û
J›ıUc           @   sç   d  d l  Z  d  d l m Z m Z m Z d  d l m Z d  d l m	 Z	 d  d l
 m Z i e d 6e d 6d d	 6Z d
 e	 f d Ñ  É  YZ d S(   iˇˇˇˇN(   t   commont	   componentt   configmanager(   t   LOG(   t   CorePluginBase(   t   exportt   enabledt   ssli∞  t   portt   Corec           B   sÄ   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e d Ñ  É Z e d Ñ  É Z	 e d Ñ  É Z
 e d Ñ  É Z e d	 Ñ  É Z RS(
   c         C   s<   t  j d t É |  _ d  |  _ |  j d r8 |  j É  n  d  S(   Ns   web_plugin.confR   (   R   t   ConfigManagert   DEFAULT_PREFSt   configt   Nonet   servert   start(   t   self(    (    sK   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/core.pyt   enable7   s    	c         C   s   |  j  r |  j  j É  n  d  S(   N(   R   t   stop(   R   (    (    sK   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/core.pyt   disable=   s    	c         C   s   d  S(   N(    (   R   (    (    sK   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/core.pyt   updateA   s    c         C   s3   |  j  r% |  j  j É  j |  j É n
 |  j É  d  S(   N(   R   R   t   addCallbackt   on_stopR   (   R   (    (    sK   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/core.pyt   restartD   s    	c         G   s   |  j  É  d  S(   N(   R   (   R   t   args(    (    sK   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/core.pyR   J   s    c         C   s1   y d d l  m } t SWn t k
 r, t SXd  S(   Niˇˇˇˇ(   R   (   t   deluge.ui.webR   t   Truet   ImportErrort   False(   R   R   (    (    sK   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/core.pyt   got_deluge_webM   s
    c         C   s~   |  j  sD y d d l m  } Wn t k
 r1 t SX| j É  |  _  n  |  j d |  j  _ |  j d |  j  _ |  j  j t É t	 S(   Niˇˇˇˇ(   R   R   R   (
   R   R   R   R   t	   DelugeWebR   R   t   httpsR   R   (   R   R   (    (    sK   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/core.pyR   U   s    	c         C   s   |  j  r |  j  j É  n  d  S(   N(   R   R   (   R   (    (    sK   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/core.pyR   d   s    	c         C   sﬁ   d } d | k rE | d |  j d k rE | d r9 d p< d } qE n  d | k rc | sc d } qc n  x% | j É  D] } | | |  j | <qp W|  j j É  | d k rÆ |  j É  S| d k rƒ |  j É  S| d k r⁄ |  j É  Sd S(   s   sets the config dictionaryR   R   R   R   R   N(   R   R   t   keyst   saveR   R   R   (   R   R   t   actiont   key(    (    sK   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/core.pyt
   set_configi   s     

c         C   s
   |  j  j  S(   s   returns the config dictionary(   R   (   R   (    (    sK   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/core.pyt
   get_configÅ   s    (   t   __name__t
   __module__R   R   R   R   R   R   R   R   R   R$   R%   (    (    (    sK   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/core.pyR	   4   s   					(   t   ost   delugeR    R   R   t
   deluge.logR   t   logt   deluge.plugins.pluginbaseR   t   deluge.core.rpcserverR   R   R   R	   (    (    (    sK   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/core.pyt   <module>'   s   

filename:/usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/core.py
__doc__
#
# core.py
#
# Copyright (C) 2009 Damien Churchill <damoxc@gmail.com>
#
# Basic plugin template created by:
# Copyright (C) 2008 Martijn Voncken <mvoncken@gmail.com>
# Copyright (C) 2007-2009 Andrew Resch <andrewresch@gmail.com>
#
# Deluge is free software.
#
# You may redistribute it and/or modify it under the terms of the
# GNU General Public License, as published by the Free Software
# Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# deluge is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with deluge.    If not, write to:
# 	The Free Software Foundation, Inc.,
# 	51 Franklin Street, Fifth Floor
# 	Boston, MA  02110-1301, USA.
#
#    In addition, as a special exception, the copyright holders give
#    permission to link the code of portions of this program with the OpenSSL
#    library.
#    You must obey the GNU General Public License in all respects for all of
#    the code used other than OpenSSL. If you modify file(s) with this
#    exception, you may extend this exception to your version of the file(s),
#    but you are not obligated to do so. If you do not wish to do so, delete
#    this exception statement from your version. If you delete this exception
#    statement from all source files in the program, then also delete it here.
#

import os

from deluge import common, component, configmanager
from deluge.log import LOG as log
from deluge.plugins.pluginbase import CorePluginBase
from deluge.core.rpcserver import export

DEFAULT_PREFS = {
    "enabled": False,
    "ssl": False,
    "port": 8112
}

class Core(CorePluginBase):
    
    
    def enable(self):
        self.config = configmanager.ConfigManager("web_plugin.conf", DEFAULT_PREFS)
        self.server = None
        if self.config['enabled']:
            self.start()

    def disable(self):
        if self.server:
            self.server.stop()

    def update(self):
        pass
    
    def restart(self):
        if self.server:
            self.server.stop().addCallback(self.on_stop)
        else:
            self.start()
        
    def on_stop(self, *args):
        self.start()

    @export
    def got_deluge_web(self):
        try:
            from deluge.ui.web import server
            return True
        except ImportError:
            return False
    
    @export
    def start(self):
        if not self.server:
            try:
                from deluge.ui.web import server
            except ImportError:
                return False

            self.server = server.DelugeWeb()

        self.server.port = self.config["port"]
        self.server.https = self.config["ssl"]
        self.server.start(False)
        return True
    
    @export
    def stop(self):
        if self.server:
            self.server.stop()

    @export
    def set_config(self, config):
        "sets the config dictionary"

        action = None
        if "enabled" in config:
            if config["enabled"] != self.config["enabled"]:
                action = config["enabled"] and 'start' or 'stop'
        
        if "ssl" in config:
            if not action:
                action = 'restart'

        for key in config.keys():
            self.config[key] = config[key]
        self.config.save()
        
        if action == 'start':
            return self.start()
        elif action == 'stop':
            return self.stop()
        elif action == 'restart':
            return self.restart()

    @export
    def get_config(self):
        "returns the config dictionary"
        return self.config.config

filename:/usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/gtkui.pyc
__doc__
Û
J›ıUc           @   sÅ   d  d l  Z  d  d l m Z d  d l m Z d  d l m Z d  d l j	 Z	 d  d l
 Z d  d l m Z d e f d Ñ  É  YZ d S(   iˇˇˇˇN(   t   LOG(   t   client(   t   GtkPluginBase(   t   get_resourcet   GtkUIc           B   s>   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s¥   t  j j t d É É |  _ t j d É j t d É |  j j d É É t j d É j	 d |  j
 É t j d É j	 d |  j É t j j É  j |  j É t j j É  j |  j É d  S(   Ns   config.gladet   Preferencest   WebUit	   prefs_boxt   PluginManagert   on_apply_prefst   on_show_prefs(   t   gtkt   gladet   XMLR   t	   componentt   gett   add_paget   _t
   get_widgett   register_hookR	   R
   R   t   webuit
   get_configt   addCallbackt   cb_get_configt   got_deluge_webt   cb_chk_deluge_web(   t   self(    (    sL   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/gtkui.pyt   enable2   s    +c         C   sX   t  j d É j t d É É t  j d É j d |  j É t  j d É j d |  j É d  S(   NR   R   R   R	   R
   (   R   R   t   remove_pageR   t   deregister_hookR	   R
   (   R   (    (    sL   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/gtkui.pyt   disable;   s    c         C   s   |  j  s d  St j d É i |  j j d É j É  d 6|  j j d É j É  d 6|  j j d É j É  d 6} t j j	 | É d  S(   Ns   applying prefs for WebUit   enabled_checkbuttont   enabledt   ssl_checkbuttont   sslt   port_spinbuttont   port(
   t   have_webt   logt   debugR   R   t
   get_activet   get_value_as_intR   R   t
   set_config(   R   t   config(    (    sL   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/gtkui.pyR	   @   s    	c         C   s   t  j j É  j |  j É d  S(   N(   R   R   R   R   R   (   R   (    (    sL   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/gtkui.pyR
   K   s    c         C   s[   |  j  j d É j | d É |  j  j d É j | d É |  j  j d É j | d É d S(   s   callback for on show_prefsR   R    R!   R"   R#   R$   N(   R   R   t
   set_activet	   set_value(   R   R+   (    (    sL   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/gtkui.pyR   N   s    c         C   s˚   | |  _  | r d  S|  j j d É j t É |  j j d É } t j É  } t j t j t j	 É } | j
 d d É | j | t t É t j t d É É } | j d d É | j
 d d É | j | É | j | t t d É | j | d É | j É  d  S(   Nt   settings_vboxR   i   sU   The Deluge web interface is not installed, please install the
interface and try againi    g      ‡?i
   (   R%   R   R   t   set_sensitivet   FalseR   t   HBoxt   image_new_from_stockt   STOCK_DIALOG_ERRORt   ICON_SIZE_SMALL_TOOLBARt   set_paddingt
   pack_startt   LabelR   t   set_alignmentt   reorder_childt   show_all(   R   R%   t   vboxt   hboxt   icont   label(    (    sL   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/gtkui.pyR   T   s     	(   t   __name__t
   __module__R   R   R	   R
   R   R   (    (    (    sL   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/gtkui.pyR   1   s   						(   R   t
   deluge.logR    R&   t   deluge.ui.clientR   t   deluge.plugins.pluginbaseR   t   deluge.componentR   t   deluge.commont   deluget   commonR   R   (    (    (    sL   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/gtkui.pyt   <module>'   s   
filename:/usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/__init__.pyc
__doc__
Û
J›ıUc           @   sV   d  d l  m Z d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d S(	   iˇˇˇˇ(   t   PluginInitBaset
   CorePluginc           B   s   e  Z d  Ñ  Z RS(   c         C   s3   d d l  m } | |  _ t t |  É j | É d  S(   Niˇˇˇˇ(   t   Core(   t   coreR   t   _plugin_clst   superR   t   __init__(   t   selft   plugin_nameR   (    (    sO   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/__init__.pyR   *   s    	(   t   __name__t
   __module__R   (    (    (    sO   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/__init__.pyR   )   s   t   GtkUIPluginc           B   s   e  Z d  Ñ  Z RS(   c         C   s3   d d l  m } | |  _ t t |  É j | É d  S(   Niˇˇˇˇ(   t   GtkUI(   t   gtkuiR   R   R   R   R   (   R   R   R   (    (    sO   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/__init__.pyR   0   s    	(   R	   R
   R   (    (    (    sO   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/__init__.pyR   /   s   t   WebUIPluginc           B   s   e  Z d  Ñ  Z RS(   c         C   s3   d d l  m } | |  _ t t |  É j | É d  S(   Niˇˇˇˇ(   t   WebUI(   t   webuiR   R   R   R   R   (   R   R   R   (    (    sO   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/__init__.pyR   6   s    	(   R	   R
   R   (    (    (    sO   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/__init__.pyR   5   s   N(   t   deluge.plugins.initR    R   R   R   (    (    (    sO   /usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/__init__.pyt   <module>'   s   
filename:/usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/webui/common.py
__doc__
#
# common.py
#
# Copyright (C) 2009 Damien Churchill <damoxc@gmail.com>
#
# Basic plugin template created by:
# Copyright (C) 2008 Martijn Voncken <mvoncken@gmail.com>
# Copyright (C) 2007-2009 Andrew Resch <andrewresch@gmail.com>
#
# Deluge is free software.
#
# You may redistribute it and/or modify it under the terms of the
# GNU General Public License, as published by the Free Software
# Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# deluge is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with deluge.    If not, write to:
# 	The Free Software Foundation, Inc.,
# 	51 Franklin Street, Fifth Floor
# 	Boston, MA  02110-1301, USA.
#
#    In addition, as a special exception, the copyright holders give
#    permission to link the code of portions of this program with the OpenSSL
#    library.
#    You must obey the GNU General Public License in all respects for all of
#    the code used other than OpenSSL. If you modify file(s) with this
#    exception, you may extend this exception to your version of the file(s),
#    but you are not obligated to do so. If you do not wish to do so, delete
#    this exception statement from your version. If you delete this exception
#    statement from all source files in the program, then also delete it here.
#

def get_resource(filename):
    import pkg_resources, os
    return pkg_resources.resource_filename("webui", os.path.join("data", filename))

filename:/usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/EGG-INFO/dependency_links.txt
__doc__


filename:/usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/EGG-INFO/zip-safe
__doc__


filename:/usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/EGG-INFO/SOURCES.txt
__doc__
setup.py
WebUi.egg-info/PKG-INFO
WebUi.egg-info/SOURCES.txt
WebUi.egg-info/dependency_links.txt
WebUi.egg-info/entry_points.txt
WebUi.egg-info/top_level.txt
webui/__init__.py
webui/common.py
webui/core.py
webui/gtkui.py
webui/data/config.glade
filename:/usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/EGG-INFO/entry_points.txt
__doc__

    [deluge.plugin.core]
    WebUi = webui:CorePlugin
    [deluge.plugin.gtkui]
    WebUi = webui:GtkUIPlugin
    
filename:/usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/EGG-INFO/top_level.txt
__doc__
webui

filename:/usr/lib/python2.7/dist-packages/deluge/plugins/WebUi-0.1.egg/EGG-INFO/PKG-INFO
__doc__
Metadata-Version: 1.0
Name: WebUi
Version: 0.1
Summary: Allows starting the web interface within the daemon.
Home-page: http://deluge-torrent.org
Author: Damien Churchill
Author-email: damoxc@gmail.com
License: GPLv3
Description: Allows starting the web interface within the daemon.
Platform: UNKNOWN

filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/detect.py
__doc__
#
# detect.py
#
# Copyright (C) 2009-2010 John Garland <johnnybg+deluge@gmail.com>
#
# Deluge is free software.
#
# You may redistribute it and/or modify it under the terms of the
# GNU General Public License, as published by the Free Software
# Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# deluge is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with deluge.    If not, write to:
# 	The Free Software Foundation, Inc.,
# 	51 Franklin Street, Fifth Floor
# 	Boston, MA  02110-1301, USA.
#
#    In addition, as a special exception, the copyright holders give
#    permission to link the code of portions of this program with the OpenSSL
#    library.
#    You must obey the GNU General Public License in all respects for all of
#    the code used other than OpenSSL. If you modify file(s) with this
#    exception, you may extend this exception to your version of the file(s),
#    but you are not obligated to do so. If you do not wish to do so, delete
#    this exception statement from your version. If you delete this exception
#    statement from all source files in the program, then also delete it here.
#
#

from decompressers import Zipped, GZipped, BZipped2
from readers import EmuleReader, SafePeerReader, PeerGuardianReader

COMPRESSION_TYPES = {
    "PK" : "Zip",
    "\x1f\x8b" : "GZip",
    "BZ" : "BZip2"
}

DECOMPRESSERS = {
    "Zip" : Zipped,
    "GZip" : GZipped,
    "BZip2" : BZipped2
}

READERS = {
    "Emule" : EmuleReader,
    "SafePeer" : SafePeerReader,
    "PeerGuardian" : PeerGuardianReader
}

class UnknownFormatError(Exception):
    pass

def detect_compression(filename):
    f = open(filename, "rb")
    magic_number = f.read(2)
    f.close()
    return COMPRESSION_TYPES.get(magic_number, "")

def detect_format(filename, compression=""):
    format = ""
    for reader in READERS:
        if create_reader(reader, compression)(filename).is_valid():
            format = reader
            break
    return format

def create_reader(format, compression=""):
    reader = READERS.get(format)
    if reader and compression:
        decompressor = DECOMPRESSERS.get(compression)
        if decompressor:
            reader = decompressor(reader)
    return reader

filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/peerguardian.py
__doc__
##
# Copyright 2007 Steve 'Tarka' Smith (tarka@internode.on.net)
# Distributed under the same terms as Deluge
##

from exceptions import Exception
from struct import unpack
import gzip, socket

from deluge.log import LOG as log

class PGException(Exception):
    pass

# Incrementally reads PeerGuardian blocklists v1 and v2.
# See http://wiki.phoenixlabs.org/wiki/P2B_Format
class PGReader:

    def __init__(self, filename):
        log.debug("PGReader loading: %s", filename)

        try:
            self.fd = gzip.open(filename, "rb")
        except IOError, e:
           log.debug("Blocklist: PGReader: Incorrect file type or list is corrupt")

        # 4 bytes, should be 0xffffffff
        buf = self.fd.read(4)
        hdr = unpack("l", buf)[0]
        if hdr != -1:
            raise PGException(_("Invalid leader") + " %d"%hdr)

        magic = self.fd.read(3)
        if magic != "P2B":
            raise PGException(_("Invalid magic code"))

        buf = self.fd.read(1)
        ver = ord(buf)
        if ver != 1 and ver != 2:
            raise PGException(_("Invalid version") + " %d" % ver)


    def next(self):

        # Skip over the string
        buf = -1
        while buf != 0:
            buf = self.fd.read(1)
            if buf == "":  # EOF
                return False
            buf = ord(buf)

        buf = self.fd.read(4)
        start = socket.inet_ntoa(buf)

        buf = self.fd.read(4)
        end = socket.inet_ntoa(buf)

        return (start, end)

    def close(self):
        self.fd.close()

filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/data/blocklist_pref.glade
__doc__
<?xml version="1.0"?>
<glade-interface>
  <!-- interface-requires gtk+ 2.12 -->
  <!-- interface-naming-policy toplevel-contextual -->
  <widget class="GtkWindow" id="window1">
    <child>
      <widget class="GtkVBox" id="blocklist_prefs_box">
        <property name="visible">True</property>
        <property name="spacing">5</property>
        <child>
          <widget class="GtkFrame" id="frame1">
            <property name="visible">True</property>
            <property name="label_xalign">0</property>
            <property name="shadow_type">none</property>
            <child>
              <widget class="GtkAlignment" id="alignment1">
                <property name="visible">True</property>
                <property name="left_padding">12</property>
                <child>
                  <widget class="GtkHBox" id="hbox2">
                    <property name="visible">True</property>
                    <property name="spacing">5</property>
                    <child>
                      <widget class="GtkLabel" id="label3">
                        <property name="visible">True</property>
                        <property name="label" translatable="yes">URL:</property>
                      </widget>
                      <packing>
                        <property name="expand">False</property>
                        <property name="fill">False</property>
                        <property name="position">0</property>
                      </packing>
                    </child>
                    <child>
                      <widget class="GtkEntry" id="entry_url">
                        <property name="visible">True</property>
                        <property name="can_focus">True</property>
                        <property name="invisible_char">&#x25CF;</property>
                      </widget>
                      <packing>
                        <property name="position">1</property>
                      </packing>
                    </child>
                  </widget>
                </child>
              </widget>
            </child>
            <child>
              <widget class="GtkLabel" id="label1">
                <property name="visible">True</property>
                <property name="ypad">5</property>
                <property name="label" translatable="yes">&lt;b&gt;General&lt;/b&gt;</property>
                <property name="use_markup">True</property>
              </widget>
              <packing>
                <property name="type">label_item</property>
              </packing>
            </child>
          </widget>
          <packing>
            <property name="expand">False</property>
            <property name="fill">False</property>
            <property name="position">0</property>
          </packing>
        </child>
        <child>
          <widget class="GtkFrame" id="frame2">
            <property name="visible">True</property>
            <property name="label_xalign">0</property>
            <property name="shadow_type">none</property>
            <child>
              <widget class="GtkAlignment" id="alignment2">
                <property name="visible">True</property>
                <property name="left_padding">12</property>
                <child>
                  <widget class="GtkVBox" id="vbox1">
                    <property name="visible">True</property>
                    <property name="spacing">5</property>
                    <child>
                      <widget class="GtkTable" id="table1">
                        <property name="visible">True</property>
                        <property name="n_columns">3</property>
                        <property name="column_spacing">5</property>
                        <property name="row_spacing">5</property>
                        <child>
                          <widget class="GtkLabel" id="label8">
                            <property name="visible">True</property>
                            <property name="xalign">0</property>
                            <property name="label" translatable="yes">Days</property>
                          </widget>
                          <packing>
                            <property name="left_attach">2</property>
                            <property name="right_attach">3</property>
                            <property name="x_options">GTK_FILL</property>
                            <property name="y_options"></property>
                          </packing>
                        </child>
                        <child>
                          <widget class="GtkSpinButton" id="spin_check_days">
                            <property name="visible">True</property>
                            <property name="can_focus">True</property>
                            <property name="adjustment">2 0 100 1 10 0</property>
                          </widget>
                          <packing>
                            <property name="left_attach">1</property>
                            <property name="right_attach">2</property>
                            <property name="x_options">GTK_FILL</property>
                            <property name="y_options"></property>
                          </packing>
                        </child>
                        <child>
                          <widget class="GtkLabel" id="label4">
                            <property name="visible">True</property>
                            <property name="xalign">0</property>
                            <property name="label" translatable="yes">Check for new list every:</property>
                          </widget>
                          <packing>
                            <property name="x_options">GTK_FILL</property>
                            <property name="y_options"></property>
                          </packing>
                        </child>
                      </widget>
                      <packing>
                        <property name="expand">False</property>
                        <property name="fill">False</property>
                        <property name="position">0</property>
                      </packing>
                    </child>
                    <child>
                      <widget class="GtkCheckButton" id="chk_import_on_start">
                        <property name="label" translatable="yes">Import blocklist on startup</property>
                        <property name="visible">True</property>
                        <property name="can_focus">True</property>
                        <property name="receives_default">False</property>
                        <property name="draw_indicator">True</property>
                      </widget>
                      <packing>
                        <property name="expand">False</property>
                        <property name="fill">False</property>
                        <property name="position">1</property>
                      </packing>
                    </child>
                  </widget>
                </child>
              </widget>
            </child>
            <child>
              <widget class="GtkLabel" id="label10">
                <property name="visible">True</property>
                <property name="ypad">5</property>
                <property name="label" translatable="yes">&lt;b&gt;Settings&lt;/b&gt;</property>
                <property name="use_markup">True</property>
              </widget>
              <packing>
                <property name="type">label_item</property>
              </packing>
            </child>
          </widget>
          <packing>
            <property name="expand">False</property>
            <property name="fill">False</property>
            <property name="position">1</property>
          </packing>
        </child>
        <child>
          <widget class="GtkFrame" id="frame3">
            <property name="visible">True</property>
            <property name="label_xalign">0</property>
            <property name="shadow_type">none</property>
            <child>
              <widget class="GtkAlignment" id="alignment3">
                <property name="visible">True</property>
                <property name="xalign">0</property>
                <property name="xscale">0</property>
                <property name="left_padding">12</property>
                <child>
                  <widget class="GtkHBox" id="hbox3">
                    <property name="visible">True</property>
                    <child>
                      <widget class="GtkVBox" id="vbox3">
                        <property name="visible">True</property>
                        <child>
                          <widget class="GtkButton" id="button_check_download">
                            <property name="visible">True</property>
                            <property name="can_focus">True</property>
                            <property name="receives_default">True</property>
                            <property name="tooltip" translatable="yes">Download the blocklist file if necessary and import the file.</property>
                            <signal name="clicked" handler="on_button_check_download_clicked"/>
                            <child>
                              <widget class="GtkHBox" id="hbox4">
                                <property name="visible">True</property>
                                <property name="spacing">5</property>
                                <child>
                                  <widget class="GtkImage" id="image_download">
                                    <property name="visible">True</property>
                                    <property name="stock">gtk-missing-image</property>
                                  </widget>
                                  <packing>
                                    <property name="expand">False</property>
                                    <property name="fill">False</property>
                                    <property name="position">0</property>
                                  </packing>
                                </child>
                                <child>
                                  <widget class="GtkLabel" id="label12">
                                    <property name="visible">True</property>
                                    <property name="label" translatable="yes">Check Download and Import</property>
                                  </widget>
                                  <packing>
                                    <property name="expand">False</property>
                                    <property name="fill">False</property>
                                    <property name="position">1</property>
                                  </packing>
                                </child>
                              </widget>
                            </child>
                          </widget>
                          <packing>
                            <property name="expand">False</property>
                            <property name="fill">False</property>
                            <property name="position">0</property>
                          </packing>
                        </child>
                        <child>
                          <widget class="GtkButton" id="button_force_download">
                            <property name="visible">True</property>
                            <property name="can_focus">True</property>
                            <property name="receives_default">True</property>
                            <property name="tooltip" translatable="yes">Download a new blocklist file and import it.</property>
                            <signal name="clicked" handler="on_button_force_download_clicked"/>
                            <child>
                              <widget class="GtkHBox" id="hbox5">
                                <property name="visible">True</property>
                                <property name="spacing">5</property>
                                <child>
                                  <widget class="GtkImage" id="image_import">
                                    <property name="visible">True</property>
                                    <property name="stock">gtk-missing-image</property>
                                  </widget>
                                  <packing>
                                    <property name="expand">False</property>
                                    <property name="fill">False</property>
                                    <property name="position">0</property>
                                  </packing>
                                </child>
                                <child>
                                  <widget class="GtkLabel" id="label7">
                                    <property name="visible">True</property>
                                    <property name="label" translatable="yes">Force Download and Import</property>
                                  </widget>
                                  <packing>
                                    <property name="expand">False</property>
                                    <property name="fill">False</property>
                                    <property name="position">1</property>
                                  </packing>
                                </child>
                              </widget>
                            </child>
                          </widget>
                          <packing>
                            <property name="expand">False</property>
                            <property name="fill">False</property>
                            <property name="position">1</property>
                          </packing>
                        </child>
                      </widget>
                      <packing>
                        <property name="position">0</property>
                      </packing>
                    </child>
                    <child>
                      <widget class="GtkImage" id="image_up_to_date">
                        <property name="tooltip" translatable="yes">Blocklist is up to date</property>
                        <property name="yalign">0.15000000596046448</property>
                        <property name="xpad">2</property>
                        <property name="stock">gtk-yes</property>
                      </widget>
                      <packing>
                        <property name="position">1</property>
                      </packing>
                    </child>
                  </widget>
                </child>
              </widget>
            </child>
            <child>
              <widget class="GtkLabel" id="label11">
                <property name="visible">True</property>
                <property name="ypad">5</property>
                <property name="label" translatable="yes">&lt;b&gt;Options&lt;/b&gt;</property>
                <property name="use_markup">True</property>
              </widget>
              <packing>
                <property name="type">label_item</property>
              </packing>
            </child>
          </widget>
          <packing>
            <property name="expand">False</property>
            <property name="fill">False</property>
            <property name="position">2</property>
          </packing>
        </child>
        <child>
          <widget class="GtkFrame" id="frame4">
            <property name="visible">True</property>
            <property name="label_xalign">0</property>
            <property name="shadow_type">none</property>
            <child>
              <widget class="GtkAlignment" id="alignment4">
                <property name="visible">True</property>
                <property name="top_padding">5</property>
                <property name="left_padding">12</property>
                <child>
                  <widget class="GtkVBox" id="vbox4">
                    <property name="visible">True</property>
                    <child>
                      <widget class="GtkProgressBar" id="progressbar">
                        <property name="visible">True</property>
                      </widget>
                      <packing>
                        <property name="position">0</property>
                      </packing>
                    </child>
                    <child>
                      <widget class="GtkTable" id="table_info">
                        <property name="visible">True</property>
                        <property name="n_rows">4</property>
                        <property name="n_columns">2</property>
                        <property name="column_spacing">5</property>
                        <child>
                          <widget class="GtkLabel" id="label_url">
                            <property name="visible">True</property>
                            <property name="xalign">0</property>
                          </widget>
                          <packing>
                            <property name="left_attach">1</property>
                            <property name="right_attach">2</property>
                            <property name="top_attach">3</property>
                            <property name="bottom_attach">4</property>
                          </packing>
                        </child>
                        <child>
                          <widget class="GtkLabel" id="label_type">
                            <property name="visible">True</property>
                            <property name="xalign">0</property>
                          </widget>
                          <packing>
                            <property name="left_attach">1</property>
                            <property name="right_attach">2</property>
                            <property name="top_attach">2</property>
                            <property name="bottom_attach">3</property>
                          </packing>
                        </child>
                        <child>
                          <widget class="GtkLabel" id="label_modified">
                            <property name="visible">True</property>
                            <property name="xalign">0</property>
                          </widget>
                          <packing>
                            <property name="left_attach">1</property>
                            <property name="right_attach">2</property>
                            <property name="top_attach">1</property>
                            <property name="bottom_attach">2</property>
                          </packing>
                        </child>
                        <child>
                          <widget class="GtkLabel" id="label_filesize">
                            <property name="visible">True</property>
                            <property name="xalign">0</property>
                          </widget>
                          <packing>
                            <property name="left_attach">1</property>
                            <property name="right_attach">2</property>
                          </packing>
                        </child>
                        <child>
                          <widget class="GtkLabel" id="label17">
                            <property name="visible">True</property>
                            <property name="xalign">0</property>
                            <property name="label" translatable="yes">URL:</property>
                          </widget>
                          <packing>
                            <property name="top_attach">3</property>
                            <property name="bottom_attach">4</property>
                            <property name="x_options">GTK_FILL</property>
                          </packing>
                        </child>
                        <child>
                          <widget class="GtkLabel" id="label16">
                            <property name="visible">True</property>
                            <property name="xalign">0</property>
                            <property name="label" translatable="yes">Type:</property>
                          </widget>
                          <packing>
                            <property name="top_attach">2</property>
                            <property name="bottom_attach">3</property>
                            <property name="x_options">GTK_FILL</property>
                          </packing>
                        </child>
                        <child>
                          <widget class="GtkLabel" id="label15">
                            <property name="visible">True</property>
                            <property name="xalign">0</property>
                            <property name="label" translatable="yes">Date:</property>
                          </widget>
                          <packing>
                            <property name="top_attach">1</property>
                            <property name="bottom_attach">2</property>
                            <property name="x_options">GTK_FILL</property>
                          </packing>
                        </child>
                        <child>
                          <widget class="GtkLabel" id="label14">
                            <property name="visible">True</property>
                            <property name="xalign">0</property>
                            <property name="label" translatable="yes">File Size:</property>
                          </widget>
                          <packing>
                            <property name="x_options">GTK_FILL</property>
                          </packing>
                        </child>
                      </widget>
                      <packing>
                        <property name="expand">False</property>
                        <property name="fill">False</property>
                        <property name="position">1</property>
                      </packing>
                    </child>
                  </widget>
                </child>
              </widget>
            </child>
            <child>
              <widget class="GtkLabel" id="label13">
                <property name="visible">True</property>
                <property name="label" translatable="yes">&lt;b&gt;Info&lt;/b&gt;</property>
                <property name="use_markup">True</property>
              </widget>
              <packing>
                <property name="type">label_item</property>
              </packing>
            </child>
          </widget>
          <packing>
            <property name="expand">False</property>
            <property name="fill">False</property>
            <property name="position">3</property>
          </packing>
        </child>
      </widget>
    </child>
  </widget>
</glade-interface>

filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/data/blocklist.js
__doc__
/*!
 * blocklist.js
 *
 * Copyright (c) Omar Alvarez 2014 <omar.alvarez@udc.es>
 *
 * This file is part of Deluge and is licensed under GNU General Public License 3.0, or later, with
 * the additional special exception to link portions of this program with the OpenSSL library.
 * See LICENSE for more details.
 *
 */

Ext.ns('Deluge.ux.preferences');

/**
 * @class Deluge.ux.preferences.BlocklistPage
 * @extends Ext.Panel
 */
Deluge.ux.preferences.BlocklistPage = Ext.extend(Ext.Panel, {

    title: _('Blocklist'),
    layout: 'fit',
    border: false,
    autoScroll: true,

    initComponent: function() {
        Deluge.ux.preferences.BlocklistPage.superclass.initComponent.call(this);

        this.URLFset = this.add({
            xtype: 'fieldset',
            border: false,
            title: _('General'),
            autoHeight: true,
            defaultType: 'textfield',
            style: 'margin-top: 3px; margin-bottom: 0px; padding-bottom: 0px;',
            autoWidth: true,
            labelWidth: 40
        });

        this.URL = this.URLFset.add({
            fieldLabel: _('URL:'),
            labelSeparator: '',
            name: 'url',
            width: '80%'
        });

        this.SettingsFset = this.add({
            xtype: 'fieldset',
            border: false,
            title: _('Settings'),
            autoHeight: true,
            defaultType: 'spinnerfield',
            style: 'margin-top: 3px; margin-bottom: 0px; padding-bottom: 0px;',
            autoWidth: true,
            labelWidth: 160
        });

        this.checkListDays = this.SettingsFset.add({
            fieldLabel: _('Check for new list every:'),
            labelSeparator: '',
            name: 'check_list_days',
            value: 4,
            decimalPrecision: 0,
            width: 80
        });

        this.chkImportOnStart = this.SettingsFset.add({
            xtype: 'checkbox',
            fieldLabel: _('Import blocklist on startup'),
            name: 'check_import_startup'
        });

        this.OptionsFset = this.add({
            xtype: 'fieldset',
            border: false,
            title: _('Options'),
            autoHeight: true,
            defaultType: 'button',
            style: 'margin-top: 3px; margin-bottom: 0px; padding-bottom: 0px;',
            autoWidth: false,
            width: '80%',
            labelWidth: 0
        });

        this.checkDownload = this.OptionsFset.add({
            fieldLabel: _(''),
            name: 'check_download',
            xtype: 'container',
            layout: 'hbox',
            margins: '4 0 0 5',
            items: [{
                    xtype: 'button',
                    text: ' Check Download and Import ',
                    scale: 'medium'
                }, {
                    xtype: 'box',
                    autoEl: {
                        tag: 'img',
                        src: '../icons/ok.png'
                    },
                    margins: '4 0 0 3'
                }]
        });

        this.forceDownload = this.OptionsFset.add({
            fieldLabel: _(''),
            name: 'force_download',
            text: ' Force Download and Import ',
            margins: '2 0 0 0',
            //icon: '../icons/blocklist_import24.png',
            scale: 'medium'
        });

        this.ProgressFset = this.add({
            xtype: 'fieldset',
            border: false,
            title: _('Info'),
            autoHeight: true,
            defaultType: 'progress',
            style: 'margin-top: 1px; margin-bottom: 0px; padding-bottom: 0px;',
            autoWidth: true,
            labelWidth: 0,
            hidden: true
        });

        this.downProgBar = this.ProgressFset.add({
            fieldLabel: _(''),
            name: 'progress_bar',
            width: '90%'
        });

        this.InfoFset = this.add({
            xtype: 'fieldset',
            border: false,
            title: _('Info'),
            autoHeight: true,
            defaultType: 'label',
            style: 'margin-top: 0px; margin-bottom: 0px; padding-bottom: 0px;',
            labelWidth: 60
        });

        this.lblFileSize = this.InfoFset.add({
            fieldLabel: _('File Size:'),
            labelSeparator: '',
            name: 'file_size'
        });

        this.lblDate = this.InfoFset.add({
            fieldLabel: _('Date:'),
            labelSeparator: '',
            name: 'date'
        });

        this.lblType = this.InfoFset.add({
            fieldLabel: _('Type:'),
            labelSeparator: '',
            name: 'type'
        });

        this.lblURL = this.InfoFset.add({
            fieldLabel: _('URL:'),
            labelSeparator: '',
            name: 'lbl_URL'
        });

        this.updateTask = Ext.TaskMgr.start({
            interval: 2000,
            run: this.onUpdate,
            scope: this
        });

        this.on('show', this.updateConfig, this);

        this.checkDownload.getComponent(0).setHandler(this.checkDown, this);
        this.forceDownload.setHandler(this.forceDown, this);
    },

    onApply: function() {
        var config = {};

        config['url'] = this.URL.getValue();
        config['check_after_days'] = this.checkListDays.getValue();
        config['load_on_start'] = this.chkImportOnStart.getValue();

        deluge.client.blocklist.set_config(config);
    },

    onOk: function() {
        this.onApply();
    },

    onUpdate: function() {
        deluge.client.blocklist.get_status({
            success: function(status) {
                if (status['state'] == 'Downloading') {
                    this.InfoFset.hide();
                    this.checkDownload.getComponent(0).setDisabled(true);
                    this.checkDownload.getComponent(1).hide();
                    this.forceDownload.setDisabled(true);

                    this.ProgressFset.show();
                    this.downProgBar.updateProgress(status['file_progress'],'Downloading '.concat((status['file_progress'] * 100).toFixed(2)).concat('%'),true);

                } else if (status['state'] == 'Importing') {
                    this.InfoFset.hide();
                    this.checkDownload.getComponent(0).setDisabled(true);
                    this.checkDownload.getComponent(1).hide();
                    this.forceDownload.setDisabled(true);

                    this.ProgressFset.show();
                    this.downProgBar.updateText('Importing '.concat(status['num_blocked']));

                } else if (status['state'] == 'Idle') {
                    this.ProgressFset.hide();
                    this.checkDownload.getComponent(0).setDisabled(false);
                    this.forceDownload.setDisabled(false);
                    if (status['up_to_date']) {
                        this.checkDownload.getComponent(1).show();
                        this.checkDownload.doLayout();
                    } else {
                        this.checkDownload.getComponent(1).hide();
                    }
                    this.InfoFset.show();
                    this.lblFileSize.setText(fsize(status['file_size']));
                    this.lblDate.setText(fdate(status['file_date']));
                    this.lblType.setText(status['file_type']);
                    this.lblURL.setText(status['file_url'].substr(0,40).concat('...'));
                }
            },
            scope: this
        });
    },

    checkDown: function() {
        this.onApply();
        deluge.client.blocklist.check_import();
    },

    forceDown: function() {
        this.onApply();
        deluge.client.blocklist.check_import(force = true);
    },

    updateConfig: function() {
        deluge.client.blocklist.get_config({
            success: function(config) {
                this.URL.setValue(config['url']);
                this.checkListDays.setValue(config['check_after_days']);
                this.chkImportOnStart.setValue(config['load_on_start']);
            },
            scope: this
        });

        deluge.client.blocklist.get_status({
            success: function(status) {
                this.lblFileSize.setText(fsize(status['file_size']));
                this.lblDate.setText(fdate(status['file_date']));
                this.lblType.setText(status['file_type']);
                this.lblURL.setText(status['file_url'].substr(0,40).concat('...'));
            },
            scope: this
        });
    },

    onDestroy: function() {
        Ext.TaskMgr.stop(this.updateTask);

        deluge.preferences.un('show', this.updateConfig, this);

        Deluge.ux.preferences.BlocklistPage.superclass.onDestroy.call(this);
    }
});

Deluge.plugins.BlocklistPlugin = Ext.extend(Deluge.Plugin, {

    name: 'Blocklist',

    onDisable: function() {
        deluge.preferences.removePage(this.prefsPage);
    },

    onEnable: function() {
        this.prefsPage = deluge.preferences.addPage(new Deluge.ux.preferences.BlocklistPage());
    }
});
Deluge.registerPlugin('Blocklist', Deluge.plugins.BlocklistPlugin);

filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/data/blocklist_import24.png
__doc__
âPNG

   IHDR         ‡w=¯   bKGD ˇ ˇ ˇ†Ωßì   	pHYs     öú   tIME◊35ì›Iî  eIDATH«≈ïÎãUU∆kÌ}Œúπ8u≈¸°¯$}ã,2
*À˙Pƒ¸ÅDÅ!1Fˆ9(*aBK“¿ÓêXÇ Ñ:Ÿ–åŒ≠qÊÃôsÊú}Y∑∑Á®S£8}à<∞Y{Û¸÷Û≤◊˚¬º‘ù>xwot*é£M!Ñ~ÈA£Z©,ë◊>ÒÎVPCO≥3éÙÓH«Áv Ï~‚ô£Ìtì§)≈B√&ä¢\+ÆÅåÿ†N~l-˜åØ?ºˇ\¸∆{∞o}ﬂÜ∂ªÔŸﬁ—øiãnÔ‡ËáÔ–””KyÏ…íkh§ÜŒ{w∞Á˘¡∂§±∏•V´o˘Ó‰ëÜˆFCà0¯iP ˙:¿¯˙cœÆ€ıËì]wÙÍˆ|úR±…üa“IöÄxú≥H h≠àŒ≥ÆQ\‰ë=Øiï≠HiU/D“ï^˘ëF}âR1¶ËM^ÑZ›–›—úµ≠∫zÇYBº°£w#≈»É∫	–7ÎØyRAEEDÁkMÎ•#¯@íYr„–ë¬∂ ŒÊXXöπ»Æ]ìÁàZ\ë è7ñ÷Ë∆ºxä&CÍçÎÑj›–Ÿ7ç k∆™ïÀËêR5x•/¨H`Ωú´îÁÒ™Ñ‹xºÕÒ¢®÷S÷oﬁ ˙Õ€®÷sî“$ô¡’J p)óÀŒıÀ
Äq·Á…Èô∫è:åìDìe9•Œ>J]}4rã˜‡ú√ã∆òºiQ%&¶Æ5¨®ÔW¢¬∑W'¶#ØK¥oÿÅn¿Ê9A±V$K4j£à‘ZT¯†±π¡∫@ &50øP)l#=≥∞ˇH2Ì|òù∏zÖ/ø9•^Ú<√ã¢T‘Lçè05>B©-¶ëyDnYÇ∏‘«‰ÃTËcO„W  ¨Sá:{kŒÊ‰y≥DZDÅRP,»m¿˚Äìg8Ø†–…ÔÃ‘S-˜¸@¢Ë à¬òoõ%Ú. 
qåÛ‡ù«;”L`∫òü_î4À«|^=w[¿˛·⁄¬õ«Í ã∆§Ü‡õ k-ËHc]¿z¡8èMpUË‡“ÿµ$uÒæ6;}´(¢åNñ†ıßÇDéàB©ßy˘Dº·∑±πÃY{‚‡Ò ÈU⁄ä≈∑f Kçr5k%†JiJk®Âö‡ Ssı01[´ÿXø|+Ø[ˆœ’ΩWèüˇm.	¢ÒƒQ‘∫Òä_/OB≥U\+◊	Ó˛∑á+’U ØúŒ≈Ω–à‚b·F„≥!æë wÚ‡Å„µ—€˘D∑Ÿ/=gF≤©˚∂∑øîÂÜç˝kc≠5JGåN.re∫öeÜcáNV>
ÕyÖ[† t∂‘56ÎæËñ≠ñìM›]•xæöÖ˘≈T=€xÊ´Ûç≠©(-y ‹	ñçS©g!?;ö}›€°.ìÌú]H¶∏òºxa¬å Y&Ûoáæj%*¥s˝@æ%€í≠ø  ÒΩüit∑    IENDÆB`Ç
filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/data/blocklist_download24.png
__doc__
âPNG

   IHDR         ‡w=¯  ﬁIDATx⁄’îkHSa«è]†>ï
¢¿ÔI∂¢/%)h4ƒkK+ª±†¢∂.Å)€º} ¡¬LGMw¶$$Ió/!äTÍÀmÓÊ.ÁÃhÁú	·ûﬁÁùêÂ÷ë z‡«9Œ˚ˇ=œª≥ó˘g’‹l:—‘jå‚J¡u∏>µ†’Ê∏0ƒ„qPR¯~8\üRÄùêÇ≈E"NÜÁ√2éKÊÇﬁS	ÆO+ Ä’°IÅÑ0ÄB Îèróâ@:Q4˙¢Ö<s$°î†EÏâ,Úà∏ø`0’Cc≥ÅB"D¥! 86Ü`xSãë™O¬æπ‰™ÜéŒv∞XÕ àQ/x	Eyl“%Ücp√#C ä¯¸nDë@[ÇºÇ„IPÅ$Ä◊7ÇÅ<6t>ÈÄ≤ä`{ãW]Q ≈Dx]‡ˆ:	‰±%IÑ·◊/1,âë∑Ø ∂$¡º«Å§Tü9m/Ø,ÅÚ “$ÍÍ ìH É•ÙsvπÁêÙÇ™≥ö¿Ãå∞∆'Far˙ù@"¡(°ù∫r†”˝úÛø¯íVêIˆık≥“µÎÈc¸Ti¯î˝3
0√d$‘·BfQñÚ®» l#Ç8œs0~
,#ìÄ˜£„¿ÈöCA⁄√ŒÁ˜@cãÅˇù`#aGYEi¸N˚Pﬂ≥¡ë´fî–mbm,úøTÜ∫î«5˘á”Îoj÷lÕ ª`Ñ‚⁄Ahöı]ºõ€†uYSu*òùù}åº∑á∞kv∂60…u?SuπÎyëæo√ãt@NTU≠q‰‰‰Ï«-§[©º „∞÷‹]®g/ºÕäπ;˚fÀÓïŒ≤V¬3◊Æ“>kÀª—Á5YÌc∑˙˘C⁄ûÜŸªô!¬&:ÚzÎ‡sMæé}Q€˝±._gWi{¢î˘[uÙ∫•‰⁄£±‹˚@•Ì=G˜¯©üﬂ‘6Ê&°˜    IENDÆB`Ç
filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/data/blocklist16.png
__doc__
âPNG

   IHDR         Ûˇa  /IDATxïœ]HS∆ÒGS˙»ÇY±∫XB%£å‘£aÃ’ÕAŸ,ó“îà¢“Qkπ,gCë∫˙»¬÷AíÜe£ Cã®Ã°B∞XuïSÊ>∂ßÌ\œ≠˛◊/?ﬁ⁄†P(*ÛÛÛ´ (ÒÂjµ⁄.õÕÈÏÏdkk+EQ(ïJ˛°lΩ^?‡rπhµZŸ‘‘D≥ŸÃ∫∫:˘ê)ïJU%I-KKK«kkk√F£1	¿F§´∫∫z(ë|\XX8†VoÌvÎú…d¢F£Ij§´••e¢∑∑óÇ∞áœü60ÀŒÔ>Iû°ØÿEKÛN	ãUo*n{‘ﬂq:ù‹W^¬xdååç“3ÿÕ∆∆FÓ∂rÊ≥H €ë"≈»ê¿WÓÀt8,+—2zFF%˛ò¥q¯~ø∏uÙJÍ$  EÎ\◊÷””ßc˚ÈÉºeØ`4xõÒ`7ìG˘sP√èrËπÑ≈˜ù˛~Ωä≥^#Á¶j8˚~3}Éπºy|◊ìEo;8÷ûNØe,Úêú?Œ®‘ÉπK¿ãGÚ8„«Ä–t6I 'd¿|‹¢Z O˜÷–€æΩíæõ@Ü$ÄS2Õä¬2˙˚s¯Ê$¯≤Mv#E+ﬂ»[MÅˆ$Ä≥20ˇ¸˙$ã`ˇ9,‘î„:Äl§jÔF˚˘ˆ◊œËÓB¯j=^îlÉ9˘%2µr9‘ïeh>v Î|Åá ¨Fö˛:àË•˘Ó    IENDÆB`Ç
filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/__init__.py
__doc__
#
# blocklist/__init__.py
#
# Copyright (C) 2007-2009 Andrew Resch <andrewresch@gmail.com>
#
#
# Deluge is free software.
#
# You may redistribute it and/or modify it under the terms of the
# GNU General Public License, as published by the Free Software
# Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# deluge is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with deluge.    If not, write to:
#     The Free Software Foundation, Inc.,
#     51 Franklin Street, Fifth Floor
#     Boston, MA  02110-1301, USA.
#
#    In addition, as a special exception, the copyright holders give
#    permission to link the code of portions of this program with the OpenSSL
#    library.
#    You must obey the GNU General Public License in all respects for all of
#    the code used other than OpenSSL. If you modify file(s) with this
#    exception, you may extend this exception to your version of the file(s),
#    but you are not obligated to do so. If you do not wish to do so, delete
#    this exception statement from your version. If you delete this exception
#    statement from all source files in the program, then also delete it here.
#
#

from deluge.plugins.init import PluginInitBase

class CorePlugin(PluginInitBase):
    def __init__(self, plugin_name):
        from core import Core as _plugin_cls
        self._plugin_cls = _plugin_cls
        super(CorePlugin, self).__init__(plugin_name)

class GtkUIPlugin(PluginInitBase):
    def __init__(self, plugin_name):
        from gtkui import GtkUI as _plugin_cls
        self._plugin_cls = _plugin_cls
        super(GtkUIPlugin, self).__init__(plugin_name)

class WebUIPlugin(PluginInitBase):
    def __init__(self, plugin_name):
        from webui import WebUI as _plugin_cls
        self._plugin_cls = _plugin_cls
        super(WebUIPlugin, self).__init__(plugin_name)

filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/decompressers.pyc
__doc__
Û
J›ıUc           @   sC   d  d l  Z  d  d l Z d  d l Z d Ñ  Z d Ñ  Z d Ñ  Z d S(   iˇˇˇˇNc         C   s   d Ñ  } | |  _  |  S(   s&   Blocklist reader for zipped blocklistsc         S   so   t  j |  j É } t | d É r= | j | j É  d É } n. d d  l } | j | j | j É  d É É } | S(   Nt   openi    iˇˇˇˇ(	   t   zipfilet   ZipFilet   filet   hasattrR    t   namelistt	   cStringIOt   StringIOt   read(   t   selft   zt   fR   (    (    s\   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/decompressers.pyR    (   s    "(   R    (   t   readerR    (    (    s\   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/decompressers.pyt   Zipped&   s    			c         C   s   d Ñ  } | |  _  |  S(   s'   Blocklist reader for gzipped blocklistsc         S   s   t  j |  j É S(   N(   t   gzipR    R   (   R	   (    (    s\   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/decompressers.pyR    6   s    (   R    (   R   R    (    (    s\   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/decompressers.pyt   GZipped4   s    		c         C   s   d Ñ  } | |  _  |  S(   s(   Blocklist reader for bzipped2 blocklistsc         S   s   t  j |  j É S(   N(   t   bz2t   BZ2FileR   (   R	   (    (    s\   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/decompressers.pyR    =   s    (   R    (   R   R    (    (    s\   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/decompressers.pyt   BZipped2;   s    		(   R   R   R   R   R   R   (    (    (    s\   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/decompressers.pyt   <module>$   s   $		
filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/readers.pyc
__doc__
Û
J›ıUc           @   sî   d  d l  m Z m Z d  d l Z d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d	 e f d
 Ñ  É  YZ	 d e	 f d Ñ  É  YZ
 d S(   iˇˇˇˇ(   t   raisesErrorsAst   remove_zerosNt   ReaderParseErrorc           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    sV   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/readers.pyR   '   s   t
   BaseReaderc           B   sY   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e	 e
 É d Ñ  É Z RS(   s   Base reader for blocklist filesc         C   s   | |  _  d S(   s%   Creates a new BaseReader given a fileN(   t   file(   t   selfR   (    (    sV   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/readers.pyt   __init__,   s    c         C   s   t  |  j É S(   s%   Opens the associated file for reading(   t   openR   (   R   (    (    sV   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/readers.pyR	   0   s    c         C   s
   t  Ç d S(   s!   Extracts ip range from given lineN(   t   NotYetImplemented(   R   t   line(    (    sV   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/readers.pyt   parse4   s    c         C   s=   x3 |  j  É  D]% \ } } | t | É t | É É q W|  j S(   s+   Calls callback on each ip range in the file(   t
   readrangesR   R   (   R   t   callbackt   startt   end(    (    sV   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/readers.pyt   read8   s    c         C   s    | j  É  } | j d É p | S(   s&   Ignore commented lines and blank linest   #(   t   stript
   startswith(   R   R   (    (    sV   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/readers.pyt
   is_ignored>   s    c         C   s¨   |  j  É  } t } xâ | D]Å } |  j | É s zd yP |  j | É \ } } t j d | d É sw t j d | d É rÄ t } n  Wn t } n XWd PXq q W| j É  | S(   s0   Determines whether file is valid for this readers   ^(\d{1,3}\.){4}$t   .N(   R	   t   TrueR   R   t   ret   matcht   Falset   close(   R   t	   blocklistt   validR   R   R   (    (    sV   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/readers.pyt   is_validC   s     	
c         c   sK   |  j  É  } x. | D]& } |  j | É s |  j | É Vq q W| j É  d S(   s"   Yields each ip range from the fileN(   R	   R   R   R   (   R   R   R   (    (    sV   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/readers.pyR   U   s
    (   R   R   t   __doc__R   R	   R   R   R   R   R    R   R   (    (    (    sV   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/readers.pyR   *   s   						t   EmuleReaderc           B   s   e  Z d  Z d Ñ  Z RS(   s+   Blocklist reader for emule style blocklistsc         C   s    | j  É  j d É d j d É S(   Ns    , i    s    - (   R   t   split(   R   R   (    (    sV   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/readers.pyR   `   s    (   R   R   R   R   (    (    (    sV   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/readers.pyR    ^   s   t   SafePeerReaderc           B   s   e  Z d  Z d Ñ  Z RS(   s.   Blocklist reader for SafePeer style blocklistsc         C   s    | j  É  j d É d j d É S(   Nt   :iˇˇˇˇt   -(   R   R!   (   R   R   (    (    sV   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/readers.pyR   e   s    (   R   R   R   R   (    (    (    sV   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/readers.pyR"   c   s   t   PeerGuardianReaderc           B   s   e  Z d  Z RS(   s2   Blocklist reader for PeerGuardian style blocklists(   R   R   R   (    (    (    sV   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/readers.pyR%   h   s   (   t   commonR    R   R   t	   ExceptionR   t   objectR   R    R"   R%   (    (    (    sV   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/readers.pyt   <module>$   s   4
filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/readers.py
__doc__
#
# readers.py
#
# Copyright (C) 2009-2010 John Garland <johnnybg+deluge@gmail.com>
#
# Deluge is free software.
#
# You may redistribute it and/or modify it under the terms of the
# GNU General Public License, as published by the Free Software
# Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# deluge is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with deluge.    If not, write to:
# 	The Free Software Foundation, Inc.,
# 	51 Franklin Street, Fifth Floor
# 	Boston, MA  02110-1301, USA.
#
#    In addition, as a special exception, the copyright holders give
#    permission to link the code of portions of this program with the OpenSSL
#    library.
#    You must obey the GNU General Public License in all respects for all of
#    the code used other than OpenSSL. If you modify file(s) with this
#    exception, you may extend this exception to your version of the file(s),
#    but you are not obligated to do so. If you do not wish to do so, delete
#    this exception statement from your version. If you delete this exception
#    statement from all source files in the program, then also delete it here.
#
#

from common import raisesErrorsAs, remove_zeros
import re

class ReaderParseError(Exception):
    pass

class BaseReader(object):
    """Base reader for blocklist files"""
    def __init__(self, file):
        """Creates a new BaseReader given a file"""
        self.file = file

    def open(self):
        """Opens the associated file for reading"""
        return open(self.file)

    def parse(self, line):
        """Extracts ip range from given line"""
        raise NotYetImplemented

    def read(self, callback):
        """Calls callback on each ip range in the file"""
        for start, end in self.readranges():
            callback(remove_zeros(start), remove_zeros(end))
        return self.file

    def is_ignored(self, line):
        """Ignore commented lines and blank lines"""
        line = line.strip()
        return line.startswith('#') or not line

    def is_valid(self):
        """Determines whether file is valid for this reader"""
        blocklist = self.open()
        valid = True
        for line in blocklist:
            if not self.is_ignored(line):
                try:
                    (start, end) = self.parse(line)
                    if not re.match("^(\d{1,3}\.){4}$", start + ".") or \
                       not re.match("^(\d{1,3}\.){4}$", end + "."):
                        valid = False
                except:
                    valid = False
                finally:
                    break
        blocklist.close()
        return valid

    @raisesErrorsAs(ReaderParseError)
    def readranges(self):
        """Yields each ip range from the file"""
        blocklist = self.open()
        for line in blocklist:
            if not self.is_ignored(line):
                yield self.parse(line)
        blocklist.close()

class EmuleReader(BaseReader):
    """Blocklist reader for emule style blocklists"""
    def parse(self, line):
        return line.strip().split(" , ")[0].split(" - ")

class SafePeerReader(BaseReader):
    """Blocklist reader for SafePeer style blocklists"""
    def parse(self, line):
        return line.strip().split(":")[-1].split("-")

class PeerGuardianReader(SafePeerReader):
    """Blocklist reader for PeerGuardian style blocklists"""
    pass

filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/common.pyc
__doc__
Û
J›ıUc           @   sW   d  d l  Z  d  d l Z d  d l m Z d  d l m Z d Ñ  Z d Ñ  Z d Ñ  Z	 d S(   iˇˇˇˇN(   t   wraps(   t   exc_infoc         C   s   t  j d t j j d |  É É S(   Nt	   blocklistt   data(   t   pkg_resourcest   resource_filenamet   ost   patht   join(   t   filename(    (    sU   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/common.pyt   get_resource*   s    c            s   á  f d Ü  } | S(   sè   
    Factory class that returns a decorator which wraps
    the decorated function to raise all exceptions as
    the specified error type
    c            s"   t  à  É á á  f d Ü  É } | S(   sh   
        Returns a function which wraps the given func
        to raise all exceptions as error
        c            sA   y à |  | | é SWn& t  É  d \ } } à  | | Ç n Xd S(   s—   
            Wraps the function in a try..except block
            and calls it with the specified args

            Raises any exceptions as error preserving the
            message and traceback
            i   N(   R   (   t   selft   argst   kwargst   valuet   tb(   t   errort   func(    sU   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/common.pyt   wrapper8   s
    	(   R    (   R   R   (   R   (   R   sU   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/common.pyt	   decorator3   s    (    (   R   R   (    (   R   sU   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/common.pyt   raisesErrorsAs-   s    c         C   s;   d j  g  |  j d É D] } | j d É j d É ^ q É S(   sÌ   
    Removes unneeded zeros from ip addresses.
    
    Example: 000.000.000.003 -> 0.0.0.3
    
    :param ip: the ip address
    :type ip: string
    
    :returns: the ip address without the unneeded zeros
    :rtype: string
    
    t   .t   0i   (   R   t   splitt   lstript   zfill(   t   ipt   part(    (    sU   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/common.pyt   remove_zerosI   s    (
   R   t   os.pathR   t	   functoolsR    t   sysR   R
   R   R   (    (    (    sU   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/common.pyt   <module>%   s   		
filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/webui.pyc
__doc__
Û
J›ıUc           @   s∏   d  d l  Z  d  d l m Z d  d l m Z d  d l m Z d  d l m	 Z	 d  d l
 m Z d e d É f d	 e d
 É f d e d É f d e d É f g Z d e	 f d Ñ  É  YZ d S(   iˇˇˇˇN(   t   LOG(   t   client(   t	   component(   t   WebPluginBase(   t   get_resourcet   gzmules   Emule IP list (GZip)t   spzips   SafePeer Text (Zipped)t   pgtexts    PeerGuardian Text (Uncompressed)t   p2bgzs   PeerGuardian P2B (GZip)t   WebUIc           B   s/   e  Z d  Ñ  Z d Ñ  Z e d É g Z e Z RS(   c         C   s   d  S(   N(    (   t   self(    (    sT   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/webui.pyt   enable:   s    c         C   s   d  S(   N(    (   R
   (    (    sT   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/webui.pyt   disable>   s    s   blocklist.js(   t   __name__t
   __module__R   R   R   t   scriptst   debug_scripts(    (    (    sT   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/webui.pyR	   9   s   		(   t   ost
   deluge.logR    t   logt   deluge.ui.clientR   t   delugeR   t   deluge.plugins.pluginbaseR   t   commonR   t   _t   FORMAT_LISTR	   (    (    (    sT   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/webui.pyt   <module>&   s   
filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/detect.pyc
__doc__
Û
J›ıUc           @   sƒ   d  d l  m Z m Z m Z d  d l m Z m Z m Z i d d 6d d 6d d 6Z i e d 6e d 6e d 6Z	 i e d	 6e d
 6e d 6Z
 d e f d Ñ  É  YZ d Ñ  Z d d Ñ Z d d Ñ Z d S(   iˇˇˇˇ(   t   Zippedt   GZippedt   BZipped2(   t   EmuleReadert   SafePeerReadert   PeerGuardianReadert   Zipt   PKt   GZips   ãt   BZip2t   BZt   Emulet   SafePeert   PeerGuardiant   UnknownFormatErrorc           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    sU   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/detect.pyR   9   s   c         C   s8   t  |  d É } | j d É } | j É  t j | d É S(   Nt   rbi   t    (   t   opent   readt   closet   COMPRESSION_TYPESt   get(   t   filenamet   ft   magic_number(    (    sU   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/detect.pyt   detect_compression<   s    
R   c         C   s@   d } x3 t  D]+ } t | | É |  É j É  r | } Pq q W| S(   NR   (   t   READERSt   create_readert   is_valid(   R   t   compressiont   formatt   reader(    (    sU   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/detect.pyt   detect_formatB   s    c         C   sF   t  j |  É } | rB | rB t j | É } | rB | | É } qB n  | S(   N(   R   R   t   DECOMPRESSERS(   R    R   R!   t   decompressor(    (    sU   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/detect.pyR   J   s    N(   t   decompressersR    R   R   t   readersR   R   R   R   R#   R   t	   ExceptionR   R   R"   R   (    (    (    sU   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/detect.pyt   <module>$   s"   


	
filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/webui.py
__doc__
#
# blocklist/webui.py
#
# Copyright (C) 2008 Martijn Voncken <mvoncken@gmail.com>

#
# Deluge is free software.
#
# You may redistribute it and/or modify it under the terms of the
# GNU General Public License, as published by the Free Software
# Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# deluge is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with deluge.    If not, write to:
# 	The Free Software Foundation, Inc.,
# 	51 Franklin Street, Fifth Floor
# 	Boston, MA  02110-1301, USA.
#
#    In addition, as a special exception, the copyright holders give
#    permission to link the code of portions of this program with the OpenSSL
#    library.
#    You must obey the GNU General Public License in all respects for all of
#    the code used other than OpenSSL. If you modify file(s) with this
#    exception, you may extend this exception to your version of the file(s),
#    but you are not obligated to do so. If you do not wish to do so, delete
#    this exception statement from your version. If you delete this exception
#    statement from all source files in the program, then also delete it here.
#
#


import os
from deluge.log import LOG as log
from deluge.ui.client import client
from deluge import component
from deluge.plugins.pluginbase import WebPluginBase

from common import get_resource

#import deluge.ui.webui.lib.newforms_plus as forms

#config_page_manager = component.get("ConfigPageManager")

FORMAT_LIST =  [
       ('gzmule',_("Emule IP list (GZip)")),
       ('spzip',_("SafePeer Text (Zipped)")),
       ('pgtext',_("PeerGuardian Text (Uncompressed)")),
       ('p2bgz',_("PeerGuardian P2B (GZip)"))
]

class WebUI(WebPluginBase):
    def enable(self):
        #config_page_manager.register('plugins','blocklist',BlockListCfgForm)
        pass

    def disable(self):
        #config_page_manager.deregister('blocklist')
        pass

    scripts = [get_resource("blocklist.js")]
    debug_scripts = scripts

filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/peerguardian.pyc
__doc__
Û
J›ıUc           @   su   d  d l  m Z d  d l m Z d  d l Z d  d l Z d  d l m Z d e f d Ñ  É  YZ	 d d	 d Ñ  É  YZ
 d S(
   iˇˇˇˇ(   t	   Exception(   t   unpackN(   t   LOGt   PGExceptionc           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s[   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/peerguardian.pyR      s   t   PGReaderc           B   s#   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s$  t  j d | É y t j | d É |  _ Wn  t k
 rK } t  j d É n X|  j j d É } t d | É d } | d k rö t t	 d É d	 | É Ç n  |  j j d
 É } | d k rÕ t t	 d É É Ç n  |  j j d É } t
 | É } | d k r | d k r t t	 d É d	 | É Ç n  d  S(   Ns   PGReader loading: %st   rbs;   Blocklist: PGReader: Incorrect file type or list is corrupti   t   li    iˇˇˇˇs   Invalid leaders    %di   t   P2Bs   Invalid magic codei   i   s   Invalid version(   t   logt   debugt   gzipt   opent   fdt   IOErrort   readR   R   t   _t   ord(   t   selft   filenamet   et   buft   hdrt   magict   ver(    (    s[   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/peerguardian.pyt   __init__   s     c         C   sì   d } x> | d k rF |  j  j d É } | d k r7 t St | É } q	 W|  j  j d É } t j | É } |  j  j d É } t j | É } | | f S(   Niˇˇˇˇi    i   t    i   (   R   R   t   FalseR   t   sockett	   inet_ntoa(   R   R   t   startt   end(    (    s[   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/peerguardian.pyt   next+   s    c         C   s   |  j  j É  d  S(   N(   R   t   close(   R   (    (    s[   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/peerguardian.pyR"   =   s    (   R   R   R   R!   R"   (    (    (    s[   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/peerguardian.pyR      s   		(    (   t
   exceptionsR    t   structR   R   R   t
   deluge.logR   R
   R   R   (    (    (    s[   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/peerguardian.pyt   <module>   s
   
filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/gtkui.py
__doc__
#
# gtkui.py
#
# Copyright (C) 2008 Andrew Resch <andrewresch@gmail.com>
#
# Deluge is free software.
#
# You may redistribute it and/or modify it under the terms of the
# GNU General Public License, as published by the Free Software
# Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# deluge is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with deluge.    If not, write to:
# 	The Free Software Foundation, Inc.,
# 	51 Franklin Street, Fifth Floor
# 	Boston, MA  02110-1301, USA.
#
#    In addition, as a special exception, the copyright holders give
#    permission to link the code of portions of this program with the OpenSSL
#    library.
#    You must obey the GNU General Public License in all respects for all of
#    the code used other than OpenSSL. If you modify file(s) with this
#    exception, you may extend this exception to your version of the file(s),
#    but you are not obligated to do so. If you do not wish to do so, delete
#    this exception statement from your version. If you delete this exception
#    statement from all source files in the program, then also delete it here.
#
#

from datetime import datetime
import gtk

from deluge.log import LOG as log
from deluge.ui.client import client
import deluge.component as component
import deluge.common
from deluge.plugins.pluginbase import GtkPluginBase
import common

class GtkUI(GtkPluginBase):
    def enable(self):
        log.debug("Blocklist GtkUI enable..")
        self.plugin = component.get("PluginManager")

        self.load_preferences_page()

        self.status_item = component.get("StatusBar").add_item(
            image=common.get_resource("blocklist16.png"),
            text="",
            callback=self._on_status_item_clicked,
            tooltip="Blocked IP Ranges")

        # Register some hooks
        self.plugin.register_hook("on_apply_prefs", self._on_apply_prefs)
        self.plugin.register_hook("on_show_prefs", self._on_show_prefs)

    def disable(self):
        log.debug("Blocklist GtkUI disable..")

        # Remove the preferences page
        self.plugin.remove_preferences_page(_("Blocklist"))

        # Remove status item
        component.get("StatusBar").remove_item(self.status_item)
        del self.status_item

        # Deregister the hooks
        self.plugin.deregister_hook("on_apply_prefs", self._on_apply_prefs)
        self.plugin.deregister_hook("on_show_prefs", self._on_show_prefs)

        del self.glade

    def update(self):
        def _on_get_status(status):
            if status["state"] == "Downloading":
                self.table_info.hide()
                self.glade.get_widget("button_check_download").set_sensitive(False)
                self.glade.get_widget("button_force_download").set_sensitive(False)
                self.glade.get_widget("image_up_to_date").hide()

                self.status_item.set_text(
                    "Downloading %.2f%%" % (status["file_progress"] * 100))
                self.progress_bar.set_text("Downloading %.2f%%" % (status["file_progress"] * 100))
                self.progress_bar.set_fraction(status["file_progress"])
                self.progress_bar.show()

            elif status["state"] == "Importing":
                self.table_info.hide()
                self.glade.get_widget("button_check_download").set_sensitive(False)
                self.glade.get_widget("button_force_download").set_sensitive(False)
                self.glade.get_widget("image_up_to_date").hide()

                self.status_item.set_text(
                    "Importing " + str(status["num_blocked"]))
                self.progress_bar.set_text("Importing %s" % (status["num_blocked"]))
                self.progress_bar.pulse()
                self.progress_bar.show()

            elif status["state"] == "Idle":
                self.progress_bar.hide()
                self.glade.get_widget("button_check_download").set_sensitive(True)
                self.glade.get_widget("button_force_download").set_sensitive(True)
                if status["up_to_date"]:
                    self.glade.get_widget("image_up_to_date").show()
                else:
                    self.glade.get_widget("image_up_to_date").hide()

                self.table_info.show()
                self.status_item.set_text(str(status["num_blocked"]))
                self.glade.get_widget("label_filesize").set_text(
                    deluge.common.fsize(status["file_size"]))
                self.glade.get_widget("label_modified").set_text(
                    datetime.fromtimestamp(status["file_date"]).strftime("%c"))
                self.glade.get_widget("label_type").set_text(status["file_type"])
                self.glade.get_widget("label_url").set_text(
                    status["file_url"])

        client.blocklist.get_status().addCallback(_on_get_status)

    def _on_show_prefs(self):
        def _on_get_config(config):
            self.glade.get_widget("entry_url").set_text(
                config["url"])

            self.glade.get_widget("spin_check_days").set_value(
                config["check_after_days"])

            self.glade.get_widget("chk_import_on_start").set_active(
                config["load_on_start"])

        client.blocklist.get_config().addCallback(_on_get_config)

    def _on_apply_prefs(self):
        config = {}
        config["url"] = self.glade.get_widget("entry_url").get_text()
        config["check_after_days"] = self.glade.get_widget("spin_check_days").get_value_as_int()
        config["load_on_start"] = self.glade.get_widget("chk_import_on_start").get_active()
        client.blocklist.set_config(config)

    def _on_button_check_download_clicked(self, widget):
        self._on_apply_prefs()
        client.blocklist.check_import()

    def _on_button_force_download_clicked(self, widget):
        self._on_apply_prefs()
        client.blocklist.check_import(force=True)

    def _on_status_item_clicked(self, widget, event):
        component.get("Preferences").show(_("Blocklist"))

    def load_preferences_page(self):
        """Initializes the preferences page and adds it to the preferences dialog"""
        # Load the preferences page
        self.glade = gtk.glade.XML(common.get_resource("blocklist_pref.glade"))

        self.progress_bar = self.glade.get_widget("progressbar")
        self.table_info = self.glade.get_widget("table_info")

        # Hide the progress bar initially
        self.progress_bar.hide()
        self.table_info.show()

        self.glade.signal_autoconnect({
            "on_button_check_download_clicked": self._on_button_check_download_clicked,
            "on_button_force_download_clicked": self._on_button_force_download_clicked
        })

        # Set button icons
        self.glade.get_widget("image_download").set_from_file(
            common.get_resource("blocklist_download24.png"))

        self.glade.get_widget("image_import").set_from_file(
            common.get_resource("blocklist_import24.png"))

        # Update the preferences page with config values from the core
        self._on_show_prefs()

        # Add the page to the preferences dialog
        self.plugin.add_preferences_page(
            _("Blocklist"),
            self.glade.get_widget("blocklist_prefs_box"))

filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.pyc
__doc__
Û
J›ıUc           @   sí  d  d l  Z  d  d l Z d  d l m Z m Z d  d l m Z d  d l m Z d  d l Z d  d l	 m
 Z
 d  d l m Z m Z d  d l m Z d  d l m Z d  d	 l m Z d  d l j Z d  d l Z d  d
 l m Z d  d l m Z d  d l m Z d  d l m  Z  m! Z! m" Z" m# Z# d  d l$ m% Z% i	 d d 6e& d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6Z' d Z( d e f d  Ñ  É  YZ) d S(!   iˇˇˇˇN(   t   datetimet	   timedelta(   t
   formatdate(   t   urljoin(   t   LoopingCall(   t   threadst   defer(   t   error(   t   LOG(   t   CorePluginBase(   t   is_url(   t   export(   t   download_file(   t   detect_compressiont   detect_formatt   create_readert   UnknownFormatError(   t   ReaderParseErrort    t   urlt   load_on_starti   t   check_after_dayst   list_compressiont	   list_typeg        t   last_updatei    t	   list_sizei¥   t   timeouti   t	   try_timesi   t   Corec           B   sø   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z e e d Ñ É Z e d Ñ  É Z e d Ñ  É Z	 e d Ñ  É Z
 d Ñ  Z d d Ñ Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s  t  j d É t |  _ t |  _ t |  _ t |  _ t |  _ t |  _	 d |  _
 d |  _ t j d É |  _ t j j d t É |  _ t |  j d |  j d É |  _ t |  j d É t k	 rÀ d |  j j d <n  t } |  j d	 r¿|  j É  |  j d
 d k rg|  j d r7t j |  j d É } t d |  j d
 É } n  |  j d s[| | t j É  k  rgt } qgn  | s¿|  j t j j d É É } | j |  j  |  j! É |  j	 rΩ| j" |  j# É qΩq¿n  |  j d
 d k rt$ |  j% É |  _& |  j& j' |  j d
 d d d | É n  d  S(   Ns   Blocklist: Plugin enabled..i    g        R   s   blocklist.confR   R   R   R   R   t   dayss   blocklist.cachei   i<   ((   t   logt   debugt   TrueR
   t   Falset   is_downloadingt   is_importingt   has_importedt
   up_to_datet   need_to_resume_sessiont   num_blockedt   file_progresst	   componentt   gett   coret   deluget   configmanagert   ConfigManagert   DEFAULT_PREFSt   configR   t   readert   typet   floatt   pause_sessionR    t   fromtimestampR   t   nowt   import_listt   get_config_dirt   addCallbackst   on_import_completet   on_import_errort   addBotht   resume_sessionR   t   check_importt   update_timert   start(   t   selft
   update_nowR   t   check_periodt   d(    (    sS   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.pyt   enableM   s>    								 
$	c         C   s   |  j  j É  t j d É d  S(   Ns   Blocklist: Plugin disabled(   R0   t   saveR   R   (   RA   (    (    sS   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.pyt   disablev   s    c         C   s   d  S(   N(    (   RA   (    (    sS   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.pyt   updatez   s    c         C   sﬂ   d |  _ | |  _ d |  _ t |  _ t |  _ | r? d |  _ n  t |  j	 d É |  _ |  j rì |  j
 É  } | j |  j |  j É | j |  j É n |  j |  j	 d É } | j |  j |  j É |  j r€ | j |  j É n  | S(   sA  
        Imports latest blocklist specified by blocklist url
        Only downloads/imports if necessary or forced

        :param force: optional argument to force download/import
        :type force: boolean
        :returns: a Deferred which fires when the blocklist has been imported
        :rtype: Deferred
        i    R   N(   t   Nonet   filenamet   force_downloadt   failed_attemptsR!   t   auto_detectedR%   R1   R
   R0   t   download_listR9   t   on_download_completet   on_download_errort   addCallbackR7   R:   R;   R&   R<   R=   (   RA   t   forceRD   (    (    sS   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.pyR>   ~   s"    							c         C   s
   |  j  j  S(   sm   
        Returns the config dictionary

        :returns: the config dictionary
        :rtype: dict
        (   R0   (   RA   (    (    sS   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.pyt
   get_config¢   s    c         C   s,   x% | j  É  D] } | | |  j | <q Wd S(   sÑ   
        Sets the config based on values in 'config'

        :param config: config to set
        :type config: dictionary
        N(   t   keysR0   (   RA   R0   t   key(    (    sS   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.pyt
   set_config¨   s    c         C   s÷   i  } |  j  r d | d <n  |  j r2 d | d <n
 d | d <|  j | d <|  j | d <|  j | d <|  j d | d	 <|  j d
 | d <|  j d | d <|  j d | d <|  j d r“ | d c d |  j d 7<n  | S(   sx   
        Returns the status of the plugin

        :returns: the status dict of the plugin
        :rtype: dict
        t   Downloadingt   statet	   Importingt   IdleR%   R'   R(   R   t   file_urlR   t	   file_sizeR   t	   file_dateR   t	   file_typeR   s    (%s)(   R"   R#   R%   R'   R(   R0   (   RA   t   status(    (    sS   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.pyt
   get_status∑   s     		
c         C   sI   t  j d | É t j É  |  j d <t j j | É |  j d <| |  _ | S(   s∞   
        Updates blocklist info

        :param blocklist: path of blocklist
        :type blocklist: string
        :returns: path of blocklist
        :rtype: string
        s   Updating blocklist info: %sR   R   (   R   R   t   timeR0   t   ost   patht   getsizeRJ   (   RA   t	   blocklist(    (    sS   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.pyt   update_info’   s
    		c            s    á  f d Ü  } d d l  } | j à  j d É | sE à  j d } n  i  } à  j d rÇ à  j rÇ t à  j d d t É| d <n  t j d	 | É t j d
 | É t à  _ t	 | t
 j j d É | | É S(   s  
        Downloads the blocklist specified by 'url' in the config

        :param url: optional url to download from, defaults to config value
        :type url: string
        :returns: a Deferred which fires once the blocklist has been downloaded
        :rtype: Deferred
        c            sA   | r. t  | É | } | d k r4 d } q4 n d } | à  _ d  S(   Ng      ?g        (   R3   R(   (   t   datat   current_lengtht   total_lengtht   fp(   RA   (    sS   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.pyt   on_retrieve_dataÌ   s    iˇˇˇˇNR   R   R   t   usegmts   If-Modified-Sinces#   Attempting to download blocklist %ss   Sending headers: %ss   blocklist.download(   t   sockett   setdefaulttimeoutR0   RK   R   R    R   R   R"   R   R,   R-   R8   (   RA   R   Rk   Rm   t   headers(    (   RA   sS   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.pyRN   ‰   s    	
 	c         C   s,   t  j d | É t |  _ t j |  j | É S(   s€   
        Runs any download clean up functions

        :param blocklist: path of blocklist
        :type blocklist: string
        :returns: a Deferred which fires when clean up is done
        :rtype: Deferred
        s   Blocklist download complete: %s(   R   R   R!   R"   R   t   deferToThreadRf   (   RA   Re   (    (    sS   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.pyRO     s    		c         C   s[  t  |  _ | j É  } | } | j t j É r§ t |  j d | j d É d É } d | k r| t	 j
 d | É | |  j d <n  |  j | É } | j |  j |  j É n≥ d | k r t	 j
 d É t |  _ t j j d É } t j |  j | É } ng t	 j d	 | É |  j |  j d
 k  rWt	 j
 d É |  j d 7_ |  j É  } | j |  j |  j É n  | S(   sˆ   
        Recovers from download error

        :param f: failure that occurred
        :type f: Failure
        :returns: a Deferred if recovery was possible
                  else the original failure
        :rtype: Deferred or Failure
        R   s    to i   s   Moved Permanentlys   Setting blocklist url to %ss   Not Modifieds   Blocklist is up-to-date!s   blocklist.caches   Blocklist download failed: %sR   s   Let's try again(   R!   R"   t   getErrorMessaget   checkR   t   PageRedirectR   R0   t   splitR   R   RN   R9   RO   RP   R    R%   R,   R-   R8   R   Rp   Rf   t   warningRL   (   RA   t   ft	   error_msgRD   t   locationRe   (    (    sS   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.pyRP     s,    
	#	c            s  á  f d Ü  } á  f d Ü  } à  j  rJ à  j rJ t j d É t j | É St à  _ d à  _ à  j	 j
 j É  à  _ | sÉ à  j } n  à  j s• à  j | É t à  _ n  t j d à  j É t j d à  j d à  j d É t j à  j | É j | É } | j | É | S(	   sˆ   
        Imports the downloaded blocklist into the session

        :param blocklist: path of blocklist
        :type blocklist: string
        :returns: a Deferred that fires when the blocklist has been imported
        :rtype: Deferred
        c            s)   à  j  j |  | t É à  j d 7_ d S(   s   Add ip range to blocklisti   N(   Re   t   add_rulet   BLOCK_RANGER'   (   R@   t   end(   RA   (    sS   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.pyt   on_read_ip_range@  s    c            s   à  j  j j à  j É |  S(   s   Add blocklist to session(   R+   t   sessiont   set_ip_filterRe   (   t   result(   RA   (    sS   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.pyt   on_finish_readE  s    s$   Latest blocklist is already importedi    s   Importing using reader: %ss   Reader type: %s compression: %sR   R   (   R%   R$   R   R   R   t   succeedR    R#   R'   R+   R}   t   get_ip_filterRe   RJ   R1   t   auto_detectRM   R0   R   Rp   t   readRQ   (   RA   Re   R|   RÄ   RD   (    (   RA   sS   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.pyR7   7  s$    				!c         C   s¨   | } t  |  _ t |  _ t j d É t j j d É } | | k r® |  j	 rz t j d | | É t
 j t j | | É } q® t j d | | É t
 j t j | | É } n  | S(   sÿ   
        Runs any import clean up functions

        :param blocklist: path of blocklist
        :type blocklist: string
        :returns: a Deferred that fires when clean up is done
        :rtype: Deferred
        s   Blocklist import complete!s   blocklist.caches   Moving %s to %ss   Copying %s to %s(   R!   R#   R    R$   R   R   R,   R-   R8   R
   R   Rp   t   shutilt   movet   copy(   RA   Re   RD   t   cache(    (    sS   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.pyR:   a  s    				c         C   s›   | } t  |  _ t  } t j j d É } | j t É re |  j re t j	 d É d |  _ d } t } nF |  j | k r´ t j j | É r´ t j	 d | j É  É | } t } n  | rŸ |  j | É } | j |  j |  j É n  | S(   sÙ   
        Recovers from import error

        :param f: failure that occurred
        :type f: Failure
        :returns: a Deferred if recovery was possible
                  else the original failure
        :rtype: Deferred or Failure
        s   blocklist.caches   Invalid / corrupt blocklists   Error reading blocklist: %sN(   R!   R#   R,   R-   R8   Rr   R   RM   R   Ru   RI   R1   R    RJ   Rb   Rc   t   existsRq   R7   R9   R:   R;   (   RA   Rv   RD   t	   try_againRà   Re   (    (    sS   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.pyR;   x  s"    
			!	c         C   sò   t  | É |  j d <t | |  j d É |  j d <t j d |  j d |  j d É |  j d st d |  j d <t Ç n  t |  j d |  j d É |  _ d S(   s⁄   
        Tries to auto-detect the blocklist type

        :param blocklist: path of blocklist to auto-detect
        :type blocklist: string
        :raises UnknownFormatError: if the format cannot be detected
        R   R   s&   Auto-detected type: %s compression: %sR   N(   R   R0   R   R   R   R   R   R1   (   RA   Re   (    (    sS   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.pyRÉ   ô  s    !	c         C   s;   |  j  j j É  s. |  j  j j É  t |  _ n	 t |  _ d  S(   N(   R+   R}   t	   is_pausedt   pauseR    R&   R!   (   RA   (    (    sS   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.pyR4   ™  s    c         C   s   |  j  j j É  t |  _ | S(   N(   R+   R}   t   resumeR!   R&   (   RA   R   (    (    sS   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.pyR=   ±  s    	N(   t   __name__t
   __module__RE   RG   RH   R   R!   R>   RS   RV   R`   Rf   RI   RN   RO   RP   R7   R:   R;   RÉ   R4   R=   (    (    (    sS   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.pyR   L   s$   	)		#
	"		$	*		!		(*   Rb   Ra   R    R   t   email.utilsR   t   urlparseR   RÖ   t   twisted.internet.taskR   t   twisted.internetR   R   t   twisted.webR   t
   deluge.logR   R   t   deluge.plugins.pluginbaseR	   t   deluge.componentR)   t   deluge.configmanagerR,   t   deluge.commonR
   t   deluge.core.rpcserverR   t   deluge.httpdownloaderR   t   detectR   R   R   R   t   readersR   R!   R/   Rz   R   (    (    (    sS   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.pyt   <module>%   s:   "

filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/decompressers.py
__doc__
#
# decompressers.py
#
# Copyright (C) 2009-2010 John Garland <johnnybg+deluge@gmail.com>
#
# Deluge is free software.
#
# You may redistribute it and/or modify it under the terms of the
# GNU General Public License, as published by the Free Software
# Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# deluge is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with deluge.    If not, write to:
# 	The Free Software Foundation, Inc.,
# 	51 Franklin Street, Fifth Floor
# 	Boston, MA  02110-1301, USA.
#
#    In addition, as a special exception, the copyright holders give
#    permission to link the code of portions of this program with the OpenSSL
#    library.
#    You must obey the GNU General Public License in all respects for all of
#    the code used other than OpenSSL. If you modify file(s) with this
#    exception, you may extend this exception to your version of the file(s),
#    but you are not obligated to do so. If you do not wish to do so, delete
#    this exception statement from your version. If you delete this exception
#    statement from all source files in the program, then also delete it here.
#
#

import gzip, zipfile, bz2

def Zipped(reader):
    """Blocklist reader for zipped blocklists"""
    def open(self):
        z = zipfile.ZipFile(self.file)
        if hasattr(z, 'open'):
            f = z.open(z.namelist()[0])
        else:
            # Handle python 2.5
            import cStringIO
            f = cStringIO.StringIO(z.read(z.namelist()[0]))
        return f
    reader.open = open
    return reader

def GZipped(reader):
    """Blocklist reader for gzipped blocklists"""
    def open(self):
        return gzip.open(self.file)
    reader.open = open
    return reader

def BZipped2(reader):
    """Blocklist reader for bzipped2 blocklists"""
    def open(self):
        return bz2.BZ2File(self.file)
    reader.open = open
    return reader

filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/core.py
__doc__
#
# core.py
#
# Copyright (C) 2008 Andrew Resch <andrewresch@gmail.com>
# Copyright (C) 2009-2010 John Garland <johnnybg+deluge@gmail.com>
#
# Deluge is free software.
#
# You may redistribute it and/or modify it under the terms of the
# GNU General Public License, as published by the Free Software
# Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# deluge is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with deluge.    If not, write to:
# 	The Free Software Foundation, Inc.,
# 	51 Franklin Street, Fifth Floor
# 	Boston, MA  02110-1301, USA.
#
#    In addition, as a special exception, the copyright holders give
#    permission to link the code of portions of this program with the OpenSSL
#    library.
#    You must obey the GNU General Public License in all respects for all of
#    the code used other than OpenSSL. If you modify file(s) with this
#    exception, you may extend this exception to your version of the file(s),
#    but you are not obligated to do so. If you do not wish to do so, delete
#    this exception statement from your version. If you delete this exception
#    statement from all source files in the program, then also delete it here.
#
#

import os
import time
from datetime import datetime, timedelta
from email.utils import formatdate
from urlparse import urljoin
import shutil

from twisted.internet.task import LoopingCall
from twisted.internet import threads, defer
from twisted.web import error

from deluge.log import LOG as log
from deluge.plugins.pluginbase import CorePluginBase
import deluge.component as component
import deluge.configmanager
from deluge.common import is_url
from deluge.core.rpcserver import export
from deluge.httpdownloader import download_file
from detect import detect_compression, detect_format, create_reader, UnknownFormatError
from readers import ReaderParseError

# TODO: check return values for deferred callbacks
# TODO: review class attributes for redundancy

DEFAULT_PREFS = {
    "url": "",
    "load_on_start": False,
    "check_after_days": 4,
    "list_compression": "",
    "list_type": "",
    "last_update": 0.0,
    "list_size": 0,
    "timeout": 180,
    "try_times": 3,
}

# Constants
BLOCK_RANGE = 1

class Core(CorePluginBase):
    def enable(self):
        log.debug('Blocklist: Plugin enabled..')

        self.is_url = True
        self.is_downloading = False
        self.is_importing = False
        self.has_imported = False
        self.up_to_date = False
        self.need_to_resume_session = False
        self.num_blocked = 0
        self.file_progress = 0.0

        self.core = component.get("Core")
        self.config = deluge.configmanager.ConfigManager("blocklist.conf", DEFAULT_PREFS)

        self.reader = create_reader(self.config["list_type"], self.config["list_compression"])

        if type(self.config["last_update"]) is not float:
            self.config.config["last_update"] = 0.0

        update_now = False
        if self.config["load_on_start"]:
            self.pause_session()
            if self.config["check_after_days"] > 0:
                if self.config["last_update"]:
                    last_update = datetime.fromtimestamp(self.config["last_update"])
                    check_period = timedelta(days=self.config["check_after_days"])
                if not self.config["last_update"] or last_update + check_period < datetime.now():
                    update_now = True
            if not update_now:
                d = self.import_list(deluge.configmanager.get_config_dir("blocklist.cache"))
                d.addCallbacks(self.on_import_complete, self.on_import_error)
                if self.need_to_resume_session:
                    d.addBoth(self.resume_session)

        # This function is called every 'check_after_days' days, to download
        # and import a new list if needed.
        if self.config["check_after_days"] > 0:
            self.update_timer = LoopingCall(self.check_import)
            self.update_timer.start(self.config["check_after_days"] * 24 * 60 * 60, update_now)

    def disable(self):
        self.config.save()
        log.debug('Blocklist: Plugin disabled')

    def update(self):
        pass

    ## Exported RPC methods ###
    @export
    def check_import(self, force=False):
        """
        Imports latest blocklist specified by blocklist url
        Only downloads/imports if necessary or forced

        :param force: optional argument to force download/import
        :type force: boolean
        :returns: a Deferred which fires when the blocklist has been imported
        :rtype: Deferred
        """


        # Reset variables
        self.filename = None
        self.force_download = force
        self.failed_attempts = 0
        self.auto_detected = False
        self.up_to_date = False
        if force:
            self.reader = None
        self.is_url = is_url(self.config["url"])

        # Start callback chain
        if self.is_url:
            d = self.download_list()
            d.addCallbacks(self.on_download_complete, self.on_download_error)
            d.addCallback(self.import_list)
        else:
            d = self.import_list(self.config["url"])
        d.addCallbacks(self.on_import_complete, self.on_import_error)
        if self.need_to_resume_session:
            d.addBoth(self.resume_session)

        return d

    @export
    def get_config(self):
        """
        Returns the config dictionary

        :returns: the config dictionary
        :rtype: dict
        """
        return self.config.config

    @export
    def set_config(self, config):
        """
        Sets the config based on values in 'config'

        :param config: config to set
        :type config: dictionary
        """
        for key in config.keys():
            self.config[key] = config[key]

    @export
    def get_status(self):
        """
        Returns the status of the plugin

        :returns: the status dict of the plugin
        :rtype: dict
        """
        status = {}
        if self.is_downloading:
            status["state"] = "Downloading"
        elif self.is_importing:
            status["state"] = "Importing"
        else:
            status["state"] = "Idle"

        status["up_to_date"] = self.up_to_date
        status["num_blocked"] = self.num_blocked
        status["file_progress"] = self.file_progress
        status["file_url"] = self.config["url"]
        status["file_size"] = self.config["list_size"]
        status["file_date"] = self.config["last_update"]
        status["file_type"] = self.config["list_type"]
        if self.config["list_compression"]:
            status["file_type"] += " (%s)" % self.config["list_compression"]

        return status

    ####

    def update_info(self, blocklist):
        """
        Updates blocklist info

        :param blocklist: path of blocklist
        :type blocklist: string
        :returns: path of blocklist
        :rtype: string
        """
        log.debug("Updating blocklist info: %s", blocklist)
        self.config["last_update"] = time.time()
        self.config["list_size"] = os.path.getsize(blocklist)
        self.filename = blocklist
        return blocklist

    def download_list(self, url=None):
        """
        Downloads the blocklist specified by 'url' in the config

        :param url: optional url to download from, defaults to config value
        :type url: string
        :returns: a Deferred which fires once the blocklist has been downloaded
        :rtype: Deferred
        """
        def on_retrieve_data(data, current_length, total_length):
            if total_length:
                fp = float(current_length) / total_length
                if fp > 1.0:
                    fp = 1.0
            else:
                fp = 0.0

            self.file_progress = fp

        import socket
        socket.setdefaulttimeout(self.config["timeout"])

        if not url:
            url = self.config["url"]

        headers = {}
        if self.config["last_update"] and not self.force_download:
            headers['If-Modified-Since'] = formatdate(self.config["last_update"], usegmt=True)

        log.debug("Attempting to download blocklist %s", url)
        log.debug("Sending headers: %s", headers)
        self.is_downloading = True
        return download_file(url, deluge.configmanager.get_config_dir("blocklist.download"), on_retrieve_data, headers)

    def on_download_complete(self, blocklist):
        """
        Runs any download clean up functions

        :param blocklist: path of blocklist
        :type blocklist: string
        :returns: a Deferred which fires when clean up is done
        :rtype: Deferred
        """
        log.debug("Blocklist download complete: %s", blocklist)
        self.is_downloading = False
        return threads.deferToThread(self.update_info, blocklist)

    def on_download_error(self, f):
        """
        Recovers from download error

        :param f: failure that occurred
        :type f: Failure
        :returns: a Deferred if recovery was possible
                  else the original failure
        :rtype: Deferred or Failure
        """
        self.is_downloading = False
        error_msg = f.getErrorMessage()
        d = f
        if f.check(error.PageRedirect):
            # Handle redirect errors
            location = urljoin(self.config["url"], error_msg.split(" to ")[1])
            if "Moved Permanently" in error_msg:
                log.debug("Setting blocklist url to %s", location)
                self.config["url"] = location
            d = self.download_list(location)
            d.addCallbacks(self.on_download_complete, self.on_download_error)
        else:
            if "Not Modified" in error_msg:
                log.debug("Blocklist is up-to-date!")
                self.up_to_date = True
                blocklist = deluge.configmanager.get_config_dir("blocklist.cache")
                d = threads.deferToThread(self.update_info, blocklist)
            else:
                log.warning("Blocklist download failed: %s", error_msg)
                if self.failed_attempts < self.config["try_times"]:
                    log.debug("Let's try again")
                    self.failed_attempts += 1
                    d = self.download_list()
                    d.addCallbacks(self.on_download_complete, self.on_download_error)
        return d

    def import_list(self, blocklist):
        """
        Imports the downloaded blocklist into the session

        :param blocklist: path of blocklist
        :type blocklist: string
        :returns: a Deferred that fires when the blocklist has been imported
        :rtype: Deferred
        """
        def on_read_ip_range(start, end):
            """Add ip range to blocklist"""
            self.blocklist.add_rule(start, end, BLOCK_RANGE)
            self.num_blocked += 1

        def on_finish_read(result):
            """Add blocklist to session"""
            self.core.session.set_ip_filter(self.blocklist)
            return result

        # TODO: double check logic
        if self.up_to_date and self.has_imported:
            log.debug("Latest blocklist is already imported")
            return defer.succeed(blocklist)

        self.is_importing = True
        self.num_blocked = 0
        self.blocklist = self.core.session.get_ip_filter()

        if not blocklist:
            blocklist = self.filename

        if not self.reader:
            self.auto_detect(blocklist)
            self.auto_detected = True

        log.debug("Importing using reader: %s", self.reader)
        log.debug("Reader type: %s compression: %s", self.config["list_type"], self.config["list_compression"])
        d = threads.deferToThread(self.reader(blocklist).read, on_read_ip_range)
        d.addCallback(on_finish_read)

        return d

    def on_import_complete(self, blocklist):
        """
        Runs any import clean up functions

        :param blocklist: path of blocklist
        :type blocklist: string
        :returns: a Deferred that fires when clean up is done
        :rtype: Deferred
        """
        d = blocklist
        self.is_importing = False
        self.has_imported = True
        log.debug("Blocklist import complete!")
        cache = deluge.configmanager.get_config_dir("blocklist.cache")
        if blocklist != cache:
            if self.is_url:
                log.debug("Moving %s to %s", blocklist, cache)
                d = threads.deferToThread(shutil.move, blocklist, cache)
            else:
                log.debug("Copying %s to %s", blocklist, cache)
                d = threads.deferToThread(shutil.copy, blocklist, cache)
        return d

    def on_import_error(self, f):
        """
        Recovers from import error

        :param f: failure that occurred
        :type f: Failure
        :returns: a Deferred if recovery was possible
                  else the original failure
        :rtype: Deferred or Failure
        """
        d = f
        self.is_importing = False
        try_again = False
        cache = deluge.configmanager.get_config_dir("blocklist.cache")

        if f.check(ReaderParseError) and not self.auto_detected:
            # Invalid / corrupt list, let's detect it
            log.warning("Invalid / corrupt blocklist")
            self.reader = None
            blocklist = None
            try_again = True
        elif self.filename != cache and os.path.exists(cache):
            # If we have a backup and we haven't already used it
            log.warning("Error reading blocklist: %s", f.getErrorMessage())
            blocklist = cache
            try_again = True

        if try_again:
            d = self.import_list(blocklist)
            d.addCallbacks(self.on_import_complete, self.on_import_error)

        return d

    def auto_detect(self, blocklist):
        """
        Tries to auto-detect the blocklist type

        :param blocklist: path of blocklist to auto-detect
        :type blocklist: string
        :raises UnknownFormatError: if the format cannot be detected
        """
        self.config["list_compression"] = detect_compression(blocklist)
        self.config["list_type"] = detect_format(blocklist, self.config["list_compression"])
        log.debug("Auto-detected type: %s compression: %s", self.config["list_type"], self.config["list_compression"])
        if not self.config["list_type"]:
            self.config["list_compression"] = ""
            raise UnknownFormatError
        else:
            self.reader = create_reader(self.config["list_type"], self.config["list_compression"])

    def pause_session(self):
        if not self.core.session.is_paused():
            self.core.session.pause()
            self.need_to_resume_session = True
        else:
            self.need_to_resume_session = False

    def resume_session(self, result):
        self.core.session.resume()
        self.need_to_resume_session = False
        return result

filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/gtkui.pyc
__doc__
Û
J›ıUc           @   sç   d  d l  m  Z  d  d l Z d  d l m Z d  d l m Z d  d l j Z d  d l	 Z
 d  d l m Z d  d l Z d e f d Ñ  É  YZ d S(   iˇˇˇˇ(   t   datetimeN(   t   LOG(   t   client(   t   GtkPluginBaset   GtkUIc           B   sY   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 RS(	   c      	   C   sï   t  j d É t j d É |  _ |  j É  t j d É j d t j d É d d d |  j	 d	 d
 É |  _
 |  j j d |  j É |  j j d |  j É d  S(   Ns   Blocklist GtkUI enable..t   PluginManagert	   StatusBart   images   blocklist16.pngt   textt    t   callbackt   tooltips   Blocked IP Rangest   on_apply_prefst   on_show_prefs(   t   logt   debugt	   componentt   gett   plugint   load_preferences_paget   add_itemt   commont   get_resourcet   _on_status_item_clickedt   status_itemt   register_hookt   _on_apply_prefst   _on_show_prefs(   t   self(    (    sT   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/gtkui.pyt   enable/   s    
	c         C   sx   t  j d É |  j j t d É É t j d É j |  j É |  ` |  j j	 d |  j
 É |  j j	 d |  j É |  ` d  S(   Ns   Blocklist GtkUI disable..t	   BlocklistR   R   R   (   R   R   R   t   remove_preferences_paget   _R   R   t   remove_itemR   t   deregister_hookR   R   t   glade(   R   (    (    sT   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/gtkui.pyt   disable?   s    c            s)   á  f d Ü  } t  j j É  j | É d  S(   Nc            s¡  |  d d k r¡ à  j  j É  à  j j d É j t É à  j j d É j t É à  j j d É j É  à  j j d |  d d É à  j j d |  d d É à  j j	 |  d É à  j j
 É  n¸|  d d	 k ryà  j  j É  à  j j d É j t É à  j j d É j t É à  j j d É j É  à  j j d
 t |  d É É à  j j d |  d É à  j j É  à  j j
 É  nD|  d d k rΩà  j j É  à  j j d É j t É à  j j d É j t É |  d rÎà  j j d É j
 É  n à  j j d É j É  à  j  j
 É  à  j j t |  d É É à  j j d É j t j j |  d É É à  j j d É j t j |  d É j d É É à  j j d É j |  d É à  j j d É j |  d É n  d  S(   Nt   statet   Downloadingt   button_check_downloadt   button_force_downloadt   image_up_to_dates   Downloading %.2f%%t   file_progressid   t	   Importings
   Importing t   num_blockeds   Importing %st   Idlet
   up_to_datet   label_filesizet	   file_sizet   label_modifiedt	   file_dates   %ct
   label_typet	   file_typet	   label_urlt   file_url(   t
   table_infot   hideR#   t
   get_widgett   set_sensitivet   FalseR   t   set_textt   progress_bart   set_fractiont   showt   strt   pulset   Truet   delugeR   t   fsizeR    t   fromtimestampt   strftime(   t   status(   R   (    sT   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/gtkui.pyt   _on_get_statusP   sH    		
(   R   t	   blocklistt
   get_statust   addCallback(   R   RH   (    (   R   sT   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/gtkui.pyt   updateO   s    ,c            s)   á  f d Ü  } t  j j É  j | É d  S(   Nc            s[   à  j  j d É j |  d É à  j  j d É j |  d É à  j  j d É j |  d É d  S(   Nt	   entry_urlt   urlt   spin_check_dayst   check_after_dayst   chk_import_on_startt   load_on_start(   R#   R9   R<   t	   set_valuet
   set_active(   t   config(   R   (    sT   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/gtkui.pyt   _on_get_config   s    (   R   RI   t
   get_configRK   (   R   RV   (    (   R   sT   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/gtkui.pyR   ~   s    
c         C   sn   i  } |  j  j d É j É  | d <|  j  j d É j É  | d <|  j  j d É j É  | d <t j j | É d  S(   NRM   RN   RO   RP   RQ   RR   (   R#   R9   t   get_textt   get_value_as_intt
   get_activeR   RI   t
   set_config(   R   RU   (    (    sT   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/gtkui.pyR   ã   s
    c         C   s   |  j  É  t j j É  d  S(   N(   R   R   RI   t   check_import(   R   t   widget(    (    sT   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/gtkui.pyt!   _on_button_check_download_clickedí   s    
c         C   s!   |  j  É  t j j d t É d  S(   Nt   force(   R   R   RI   R\   RB   (   R   R]   (    (    sT   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/gtkui.pyt!   _on_button_force_download_clickedñ   s    
c         C   s    t  j d É j t d É É d  S(   Nt   PreferencesR   (   R   R   R?   R    (   R   R]   t   event(    (    sT   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/gtkui.pyR   ö   s    c         C   s˝   t  j j t j d É É |  _ |  j j d É |  _ |  j j d É |  _ |  j j É  |  j j	 É  |  j j
 i |  j d 6|  j d 6É |  j j d É j t j d É É |  j j d É j t j d	 É É |  j É  |  j j t d
 É |  j j d É É d S(   sF   Initializes the preferences page and adds it to the preferences dialogs   blocklist_pref.gladet   progressbarR7   t    on_button_check_download_clickedt    on_button_force_download_clickedt   image_downloads   blocklist_download24.pngt   image_imports   blocklist_import24.pngR   t   blocklist_prefs_boxN(   t   gtkR#   t   XMLR   R   R9   R=   R7   R8   R?   t   signal_autoconnectR^   R`   t   set_from_fileR   R   t   add_preferences_pageR    (   R   (    (    sT   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/gtkui.pyR   ù   s     

		(   t   __name__t
   __module__R   R$   RL   R   R   R^   R`   R   R   (    (    (    sT   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/gtkui.pyR   .   s   			/					(   R    Ri   t
   deluge.logR   R   t   deluge.ui.clientR   t   deluge.componentR   t   deluge.commonRC   t   deluge.plugins.pluginbaseR   R   R   (    (    (    sT   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/gtkui.pyt   <module>$   s   
filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/__init__.pyc
__doc__
Û
J›ıUc           @   sV   d  d l  m Z d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d S(	   iˇˇˇˇ(   t   PluginInitBaset
   CorePluginc           B   s   e  Z d  Ñ  Z RS(   c         C   s3   d d l  m } | |  _ t t |  É j | É d  S(   Niˇˇˇˇ(   t   Core(   t   coreR   t   _plugin_clst   superR   t   __init__(   t   selft   plugin_nameR   (    (    sW   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/__init__.pyR   (   s    	(   t   __name__t
   __module__R   (    (    (    sW   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/__init__.pyR   '   s   t   GtkUIPluginc           B   s   e  Z d  Ñ  Z RS(   c         C   s3   d d l  m } | |  _ t t |  É j | É d  S(   Niˇˇˇˇ(   t   GtkUI(   t   gtkuiR   R   R   R   R   (   R   R   R   (    (    sW   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/__init__.pyR   .   s    	(   R	   R
   R   (    (    (    sW   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/__init__.pyR   -   s   t   WebUIPluginc           B   s   e  Z d  Ñ  Z RS(   c         C   s3   d d l  m } | |  _ t t |  É j | É d  S(   Niˇˇˇˇ(   t   WebUI(   t   webuiR   R   R   R   R   (   R   R   R   (    (    sW   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/__init__.pyR   4   s    	(   R	   R
   R   (    (    (    sW   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/__init__.pyR   3   s   N(   t   deluge.plugins.initR    R   R   R   (    (    (    sW   /usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/__init__.pyt   <module>%   s   
filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/blocklist/common.py
__doc__
#
# common.py
#
# Copyright (C) 2009 Andrew Resch <andrewresch@gmail.com>
#
# Deluge is free software.
#
# You may redistribute it and/or modify it under the terms of the
# GNU General Public License, as published by the Free Software
# Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# deluge is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with deluge.    If not, write to:
# 	The Free Software Foundation, Inc.,
# 	51 Franklin Street, Fifth Floor
# 	Boston, MA  02110-1301, USA.
#
#    In addition, as a special exception, the copyright holders give
#    permission to link the code of portions of this program with the OpenSSL
#    library.
#    You must obey the GNU General Public License in all respects for all of
#    the code used other than OpenSSL. If you modify file(s) with this
#    exception, you may extend this exception to your version of the file(s),
#    but you are not obligated to do so. If you do not wish to do so, delete
#    this exception statement from your version. If you delete this exception
#    statement from all source files in the program, then also delete it here.
#
#


import pkg_resources
import os.path
from functools import wraps
from sys import exc_info

def get_resource(filename):
    return pkg_resources.resource_filename("blocklist", os.path.join("data", filename))

def raisesErrorsAs(error):
    """
    Factory class that returns a decorator which wraps
    the decorated function to raise all exceptions as
    the specified error type
    """
    def decorator(func):
        """
        Returns a function which wraps the given func
        to raise all exceptions as error
        """
        @wraps(func)
        def wrapper(self, *args, **kwargs):
            """
            Wraps the function in a try..except block
            and calls it with the specified args

            Raises any exceptions as error preserving the
            message and traceback
            """
            try:
                return func(self, *args, **kwargs)
            except:
                (value, tb) = exc_info()[1:]
                raise error, value, tb
        return wrapper
    return decorator

def remove_zeros(ip):
    """
    Removes unneeded zeros from ip addresses.
    
    Example: 000.000.000.003 -> 0.0.0.3
    
    :param ip: the ip address
    :type ip: string
    
    :returns: the ip address without the unneeded zeros
    :rtype: string
    
    """
    return ".".join([part.lstrip("0").zfill(1) for part in ip.split(".")])

filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/EGG-INFO/dependency_links.txt
__doc__


filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/EGG-INFO/zip-safe
__doc__


filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/EGG-INFO/SOURCES.txt
__doc__
setup.py
Blocklist.egg-info/PKG-INFO
Blocklist.egg-info/SOURCES.txt
Blocklist.egg-info/dependency_links.txt
Blocklist.egg-info/entry_points.txt
Blocklist.egg-info/top_level.txt
blocklist/__init__.py
blocklist/common.py
blocklist/core.py
blocklist/decompressers.py
blocklist/detect.py
blocklist/gtkui.py
blocklist/peerguardian.py
blocklist/readers.py
blocklist/webui.py
blocklist/data/blocklist.js
blocklist/data/blocklist16.png
blocklist/data/blocklist_download24.png
blocklist/data/blocklist_import24.png
blocklist/data/blocklist_pref.glade
filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/EGG-INFO/entry_points.txt
__doc__

    [deluge.plugin.core]
    Blocklist = blocklist:CorePlugin
    [deluge.plugin.gtkui]
    Blocklist = blocklist:GtkUIPlugin
    [deluge.plugin.web]
    Blocklist = blocklist:WebUIPlugin
    
filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/EGG-INFO/top_level.txt
__doc__
blocklist

filename:/usr/lib/python2.7/dist-packages/deluge/plugins/Blocklist-1.3.egg/EGG-INFO/PKG-INFO
__doc__
Metadata-Version: 1.0
Name: Blocklist
Version: 1.3
Summary: Download and import IP blocklists
Home-page: http://deluge-torrent.org
Author: John Garland
Author-email: johnnybg+deluge@gmail.com
License: GPLv3
Description: Download and import IP blocklists
Platform: UNKNOWN

filename:/usr/lib/python2.7/dist-packages/deluge/plugins/init.py
__doc__
#
# init.py
#
# Copyright (C) 2007 Andrew Resch <andrewresch@gmail.com>
#
# Deluge is free software.
#
# You may redistribute it and/or modify it under the terms of the
# GNU General Public License, as published by the Free Software
# Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# deluge is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with deluge.    If not, write to:
# 	The Free Software Foundation, Inc.,
# 	51 Franklin Street, Fifth Floor
# 	Boston, MA  02110-1301, USA.
#
#    In addition, as a special exception, the copyright holders give
#    permission to link the code of portions of this program with the OpenSSL
#    library.
#    You must obey the GNU General Public License in all respects for all of
#    the code used other than OpenSSL. If you modify file(s) with this
#    exception, you may extend this exception to your version of the file(s),
#    but you are not obligated to do so. If you do not wish to do so, delete
#    this exception statement from your version. If you delete this exception
#    statement from all source files in the program, then also delete it here.
#
#

"""

filename:/usr/lib/python2.7/dist-packages/attr/validators.py
__doc__
"""
Commonly useful validators.
"""

filename:/usr/lib/python2.7/dist-packages/attr/filters.py
__doc__
"""
Commonly useful filters for :func:`attr.asdict`.
"""

filename:/usr/lib/python2.7/dist-packages/numpy/__init__.py
__doc__
"""
NumPy
=====

Provides
  1. An array object of arbitrary homogeneous items
  2. Fast mathematical operations over arrays
  3. Linear Algebra, Fourier Transforms, Random Number Generation

How to use the documentation
----------------------------
Documentation is available in two forms: docstrings provided
with the code, and a loose standing reference guide, available from
`the NumPy homepage <http://www.scipy.org>`_.

We recommend exploring the docstrings using
`IPython <http://ipython.scipy.org>`_, an advanced Python shell with
TAB-completion and introspection capabilities.  See below for further
instructions.

The docstring examples assume that `numpy` has been imported as `np`::

  >>> import numpy as np

Code snippets are indicated by three greater-than signs::

  >>> x = 42
  >>> x = x + 1

Use the built-in ``help`` function to view a function's docstring::

  >>> help(np.sort)
  ... # doctest: +SKIP

For some objects, ``np.info(obj)`` may provide additional help.  This is
particularly true if you see the line "Help on ufunc object:" at the top
of the help() page.  Ufuncs are implemented in C, not Python, for speed.
The native Python help() does not know how to view their help, but our
np.info() function does.

To search for documents containing a keyword, do::

  >>> np.lookfor('keyword')
  ... # doctest: +SKIP

General-purpose documents like a glossary and help on the basic concepts
of numpy are available under the ``doc`` sub-module::

  >>> from numpy import doc
  >>> help(doc)
  ... # doctest: +SKIP

Available subpackages
---------------------
doc
    Topical documentation on broadcasting, indexing, etc.
lib
    Basic functions used by several sub-packages.
random
    Core Random Tools
linalg
    Core Linear Algebra Tools
fft
    Core FFT routines
polynomial
    Polynomial tools
testing
    Numpy testing tools
f2py
    Fortran to Python Interface Generator.
distutils
    Enhancements to distutils with support for
    Fortran compilers support and more.

Utilities
---------
test
    Run numpy unittests
show_config
    Show numpy build configuration
dual
    Overwrite certain functions with high-performance Scipy tools
matlib
    Make everything matrices.
__version__
    Numpy version string

Viewing documentation using IPython
-----------------------------------
Start IPython with the NumPy profile (``ipython -p numpy``), which will
import `numpy` under the alias `np`.  Then, use the ``cpaste`` command to
paste examples into the shell.  To see which functions are available in
`numpy`, type ``np.<TAB>`` (where ``<TAB>`` refers to the TAB key), or use
``np.*cos*?<ENTER>`` (where ``<ENTER>`` refers to the ENTER key) to narrow
down the list.  To view the docstring for a function, use
``np.cos?<ENTER>`` (to view the docstring) and ``np.cos??<ENTER>`` (to view
the source code).

Copies vs. in-place operation
-----------------------------
Most of the functions in `numpy` return a copy of the array argument
(e.g., `np.sort`).  In-place versions of these functions are often
available as array methods, i.e. ``x = np.array([1,2,3]); x.sort()``.
Exceptions to this rule are documented.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/ma/__init__.py
__doc__
"""
=============
Masked Arrays
=============

Arrays sometimes contain invalid or missing data.  When doing operations
on such arrays, we wish to suppress invalid values, which is the purpose masked
arrays fulfill (an example of typical use is given below).

For example, examine the following array:

>>> x = np.array([2, 1, 3, np.nan, 5, 2, 3, np.nan])

When we try to calculate the mean of the data, the result is undetermined:

>>> np.mean(x)
nan

The mean is calculated using roughly ``np.sum(x)/len(x)``, but since
any number added to ``NaN`` [1]_ produces ``NaN``, this doesn't work.  Enter
masked arrays:

>>> m = np.ma.masked_array(x, np.isnan(x))
>>> m
masked_array(data = [2.0 1.0 3.0 -- 5.0 2.0 3.0 --],
      mask = [False False False  True False False False  True],
      fill_value=1e+20)

Here, we construct a masked array that suppress all ``NaN`` values.  We
may now proceed to calculate the mean of the other values:

>>> np.mean(m)
2.6666666666666665

.. [1] Not-a-Number, a floating point value that is the result of an
       invalid operation.

.. moduleauthor:: Pierre Gerard-Marchant
.. moduleauthor:: Jarrod Millman

"""

filename:/usr/lib/python2.7/dist-packages/numpy/ma/extras.py
__doc__
"""
Masked arrays add-ons.

A collection of utilities for `numpy.ma`.

:author: Pierre Gerard-Marchant
:contact: pierregm_at_uga_dot_edu
:version: $Id: extras.py 3473 2007-10-29 15:18:13Z jarrod.millman $

"""

filename:/usr/lib/python2.7/dist-packages/numpy/ma/version.py
__doc__
"""Version number

"""

filename:/usr/lib/python2.7/dist-packages/numpy/ma/mrecords.py
__doc__
""":mod:`numpy.ma..mrecords`

Defines the equivalent of :class:`numpy.recarrays` for masked arrays,
where fields can be accessed as attributes.
Note that :class:`numpy.ma.MaskedArray` already supports structured datatypes
and the masking of individual fields.

.. moduleauthor:: Pierre Gerard-Marchant

"""

filename:/usr/lib/python2.7/dist-packages/numpy/ma/core.py
__doc__
"""
numpy.ma : a package to handle missing or invalid values.

This package was initially written for numarray by Paul F. Dubois
at Lawrence Livermore National Laboratory.
In 2006, the package was completely rewritten by Pierre Gerard-Marchant
(University of Georgia) to make the MaskedArray class a subclass of ndarray,
and to improve support of structured arrays.


Copyright 1999, 2000, 2001 Regents of the University of California.
Released for unlimited redistribution.

* Adapted for numpy_core 2005 by Travis Oliphant and (mainly) Paul Dubois.
* Subclassing of the base `ndarray` 2006 by Pierre Gerard-Marchant
  (pgmdevlist_AT_gmail_DOT_com)
* Improvements suggested by Reggie Dugard (reggie_AT_merfinllc_DOT_com)

.. moduleauthor:: Pierre Gerard-Marchant

"""

filename:/usr/lib/python2.7/dist-packages/numpy/ma/testutils.py
__doc__
"""Miscellaneous functions for testing masked arrays and subclasses

:author: Pierre Gerard-Marchant
:contact: pierregm_at_uga_dot_edu
:version: $Id: testutils.py 3529 2007-11-13 08:01:14Z jarrod.millman $

"""

filename:/usr/lib/python2.7/dist-packages/numpy/f2py/info.py
__doc__
"""Fortran to Python Interface Generator.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/polynomial/__init__.py
__doc__
"""
A sub-package for efficiently dealing with polynomials.

Within the documentation for this sub-package, a "finite power series,"
i.e., a polynomial (also referred to simply as a "series") is represented
by a 1-D numpy array of the polynomial's coefficients, ordered from lowest
order term to highest.  For example, array([1,2,3]) represents
``P_0 + 2*P_1 + 3*P_2``, where P_n is the n-th order basis polynomial
applicable to the specific module in question, e.g., `polynomial` (which
"wraps" the "standard" basis) or `chebyshev`.  For optimal performance,
all operations on polynomials, including evaluation at an argument, are
implemented as operations on the coefficients.  Additional (module-specific)
information can be found in the docstring for the module of interest.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/polynomial/hermite_e.py
__doc__
"""
Objects for dealing with Hermite_e series.

This module provides a number of objects (mostly functions) useful for
dealing with Hermite_e series, including a `HermiteE` class that
encapsulates the usual arithmetic operations.  (General information
on how this module represents and works with such polynomials is in the
docstring for its "parent" sub-package, `numpy.polynomial`).

Constants
---------
- `hermedomain` -- Hermite_e series default domain, [-1,1].
- `hermezero` -- Hermite_e series that evaluates identically to 0.
- `hermeone` -- Hermite_e series that evaluates identically to 1.
- `hermex` -- Hermite_e series for the identity map, ``f(x) = x``.

Arithmetic
----------
- `hermemulx` -- multiply a Hermite_e series in ``P_i(x)`` by ``x``.
- `hermeadd` -- add two Hermite_e series.
- `hermesub` -- subtract one Hermite_e series from another.
- `hermemul` -- multiply two Hermite_e series.
- `hermediv` -- divide one Hermite_e series by another.
- `hermeval` -- evaluate a Hermite_e series at given points.
- `hermeval2d` -- evaluate a 2D Hermite_e series at given points.
- `hermeval3d` -- evaluate a 3D Hermite_e series at given points.
- `hermegrid2d` -- evaluate a 2D Hermite_e series on a Cartesian product.
- `hermegrid3d` -- evaluate a 3D Hermite_e series on a Cartesian product.

Calculus
--------
- `hermeder` -- differentiate a Hermite_e series.
- `hermeint` -- integrate a Hermite_e series.

Misc Functions
--------------
- `hermefromroots` -- create a Hermite_e series with specified roots.
- `hermeroots` -- find the roots of a Hermite_e series.
- `hermevander` -- Vandermonde-like matrix for Hermite_e polynomials.
- `hermevander2d` -- Vandermonde-like matrix for 2D power series.
- `hermevander3d` -- Vandermonde-like matrix for 3D power series.
- `hermegauss` -- Gauss-Hermite_e quadrature, points and weights.
- `hermeweight` -- Hermite_e weight function.
- `hermecompanion` -- symmetrized companion matrix in Hermite_e form.
- `hermefit` -- least-squares fit returning a Hermite_e series.
- `hermetrim` -- trim leading coefficients from a Hermite_e series.
- `hermeline` -- Hermite_e series of given straight line.
- `herme2poly` -- convert a Hermite_e series to a polynomial.
- `poly2herme` -- convert a polynomial to a Hermite_e series.

Classes
-------
- `HermiteE` -- A Hermite_e series class.

See also
--------
`numpy.polynomial`

"""

filename:/usr/lib/python2.7/dist-packages/numpy/polynomial/chebyshev.py
__doc__
"""
Objects for dealing with Chebyshev series.

This module provides a number of objects (mostly functions) useful for
dealing with Chebyshev series, including a `Chebyshev` class that
encapsulates the usual arithmetic operations.  (General information
on how this module represents and works with such polynomials is in the
docstring for its "parent" sub-package, `numpy.polynomial`).

Constants
---------
- `chebdomain` -- Chebyshev series default domain, [-1,1].
- `chebzero` -- (Coefficients of the) Chebyshev series that evaluates
  identically to 0.
- `chebone` -- (Coefficients of the) Chebyshev series that evaluates
  identically to 1.
- `chebx` -- (Coefficients of the) Chebyshev series for the identity map,
  ``f(x) = x``.

Arithmetic
----------
- `chebadd` -- add two Chebyshev series.
- `chebsub` -- subtract one Chebyshev series from another.
- `chebmul` -- multiply two Chebyshev series.
- `chebdiv` -- divide one Chebyshev series by another.
- `chebpow` -- raise a Chebyshev series to an positive integer power
- `chebval` -- evaluate a Chebyshev series at given points.
- `chebval2d` -- evaluate a 2D Chebyshev series at given points.
- `chebval3d` -- evaluate a 3D Chebyshev series at given points.
- `chebgrid2d` -- evaluate a 2D Chebyshev series on a Cartesian product.
- `chebgrid3d` -- evaluate a 3D Chebyshev series on a Cartesian product.

Calculus
--------
- `chebder` -- differentiate a Chebyshev series.
- `chebint` -- integrate a Chebyshev series.

Misc Functions
--------------
- `chebfromroots` -- create a Chebyshev series with specified roots.
- `chebroots` -- find the roots of a Chebyshev series.
- `chebvander` -- Vandermonde-like matrix for Chebyshev polynomials.
- `chebvander2d` -- Vandermonde-like matrix for 2D power series.
- `chebvander3d` -- Vandermonde-like matrix for 3D power series.
- `chebgauss` -- Gauss-Chebyshev quadrature, points and weights.
- `chebweight` -- Chebyshev weight function.
- `chebcompanion` -- symmetrized companion matrix in Chebyshev form.
- `chebfit` -- least-squares fit returning a Chebyshev series.
- `chebpts1` -- Chebyshev points of the first kind.
- `chebpts2` -- Chebyshev points of the second kind.
- `chebtrim` -- trim leading coefficients from a Chebyshev series.
- `chebline` -- Chebyshev series representing given straight line.
- `cheb2poly` -- convert a Chebyshev series to a polynomial.
- `poly2cheb` -- convert a polynomial to a Chebyshev series.

Classes
-------
- `Chebyshev` -- A Chebyshev series class.

See also
--------
`numpy.polynomial`

Notes
-----
The implementations of multiplication, division, integration, and
differentiation use the algebraic identities [1]_:

.. math ::
    T_n(x) = \\frac{z^n + z^{-n}}{2} \\\\
    z\\frac{dx}{dz} = \\frac{z - z^{-1}}{2}.

where

.. math :: x = \\frac{z + z^{-1}}{2}.

These identities allow a Chebyshev series to be expressed as a finite,
symmetric Laurent series.  In this module, this sort of Laurent series
is referred to as a "z-series."

References
----------
.. [1] A. T. Benjamin, et al., "Combinatorial Trigonometry with Chebyshev
  Polynomials," *Journal of Statistical Planning and Inference 14*, 2008
  (preprint: http://www.math.hmc.edu/~benjamin/papers/CombTrig.pdf, pg. 4)

"""

filename:/usr/lib/python2.7/dist-packages/numpy/polynomial/_polybase.py
__doc__
"""
Abstract base class for the various polynomial Classes.

The ABCPolyBase class provides the methods needed to implement the common API
for the various polynomial classes. It operates as a mixin, but uses the
abc module from the stdlib, hence it is only available for Python >= 2.6.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/polynomial/laguerre.py
__doc__
"""
Objects for dealing with Laguerre series.

This module provides a number of objects (mostly functions) useful for
dealing with Laguerre series, including a `Laguerre` class that
encapsulates the usual arithmetic operations.  (General information
on how this module represents and works with such polynomials is in the
docstring for its "parent" sub-package, `numpy.polynomial`).

Constants
---------
- `lagdomain` -- Laguerre series default domain, [-1,1].
- `lagzero` -- Laguerre series that evaluates identically to 0.
- `lagone` -- Laguerre series that evaluates identically to 1.
- `lagx` -- Laguerre series for the identity map, ``f(x) = x``.

Arithmetic
----------
- `lagmulx` -- multiply a Laguerre series in ``P_i(x)`` by ``x``.
- `lagadd` -- add two Laguerre series.
- `lagsub` -- subtract one Laguerre series from another.
- `lagmul` -- multiply two Laguerre series.
- `lagdiv` -- divide one Laguerre series by another.
- `lagval` -- evaluate a Laguerre series at given points.
- `lagval2d` -- evaluate a 2D Laguerre series at given points.
- `lagval3d` -- evaluate a 3D Laguerre series at given points.
- `laggrid2d` -- evaluate a 2D Laguerre series on a Cartesian product.
- `laggrid3d` -- evaluate a 3D Laguerre series on a Cartesian product.

Calculus
--------
- `lagder` -- differentiate a Laguerre series.
- `lagint` -- integrate a Laguerre series.

Misc Functions
--------------
- `lagfromroots` -- create a Laguerre series with specified roots.
- `lagroots` -- find the roots of a Laguerre series.
- `lagvander` -- Vandermonde-like matrix for Laguerre polynomials.
- `lagvander2d` -- Vandermonde-like matrix for 2D power series.
- `lagvander3d` -- Vandermonde-like matrix for 3D power series.
- `laggauss` -- Gauss-Laguerre quadrature, points and weights.
- `lagweight` -- Laguerre weight function.
- `lagcompanion` -- symmetrized companion matrix in Laguerre form.
- `lagfit` -- least-squares fit returning a Laguerre series.
- `lagtrim` -- trim leading coefficients from a Laguerre series.
- `lagline` -- Laguerre series of given straight line.
- `lag2poly` -- convert a Laguerre series to a polynomial.
- `poly2lag` -- convert a polynomial to a Laguerre series.

Classes
-------
- `Laguerre` -- A Laguerre series class.

See also
--------
`numpy.polynomial`

"""

filename:/usr/lib/python2.7/dist-packages/numpy/polynomial/legendre.py
__doc__
"""
Legendre Series (:mod: `numpy.polynomial.legendre`)
===================================================

.. currentmodule:: numpy.polynomial.polynomial

This module provides a number of objects (mostly functions) useful for
dealing with Legendre series, including a `Legendre` class that
encapsulates the usual arithmetic operations.  (General information
on how this module represents and works with such polynomials is in the
docstring for its "parent" sub-package, `numpy.polynomial`).

Constants
---------

.. autosummary::
   :toctree: generated/

   legdomain            Legendre series default domain, [-1,1].
   legzero              Legendre series that evaluates identically to 0.
   legone               Legendre series that evaluates identically to 1.
   legx                 Legendre series for the identity map, ``f(x) = x``.

Arithmetic
----------

.. autosummary::
   :toctree: generated/

   legmulx              multiply a Legendre series in P_i(x) by x.
   legadd               add two Legendre series.
   legsub               subtract one Legendre series from another.
   legmul               multiply two Legendre series.
   legdiv               divide one Legendre series by another.
   legpow               raise a Legendre series to an positive integer power
   legval               evaluate a Legendre series at given points.
   legval2d             evaluate a 2D Legendre series at given points.
   legval3d             evaluate a 3D Legendre series at given points.
   leggrid2d            evaluate a 2D Legendre series on a Cartesian product.
   leggrid3d            evaluate a 3D Legendre series on a Cartesian product.

Calculus
--------

.. autosummary::
   :toctree: generated/

   legder               differentiate a Legendre series.
   legint               integrate a Legendre series.

Misc Functions
--------------

.. autosummary::
   :toctree: generated/

   legfromroots          create a Legendre series with specified roots.
   legroots              find the roots of a Legendre series.
   legvander             Vandermonde-like matrix for Legendre polynomials.
   legvander2d           Vandermonde-like matrix for 2D power series.
   legvander3d           Vandermonde-like matrix for 3D power series.
   leggauss              Gauss-Legendre quadrature, points and weights.
   legweight             Legendre weight function.
   legcompanion          symmetrized companion matrix in Legendre form.
   legfit                least-squares fit returning a Legendre series.
   legtrim               trim leading coefficients from a Legendre series.
   legline               Legendre series representing given straight line.
   leg2poly              convert a Legendre series to a polynomial.
   poly2leg              convert a polynomial to a Legendre series.

Classes
-------
    Legendre            A Legendre series class.

See also
--------
numpy.polynomial.polynomial
numpy.polynomial.chebyshev
numpy.polynomial.laguerre
numpy.polynomial.hermite
numpy.polynomial.hermite_e

"""

filename:/usr/lib/python2.7/dist-packages/numpy/polynomial/tests/test_laguerre.py
__doc__
"""Tests for laguerre module.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/polynomial/tests/test_hermite_e.py
__doc__
"""Tests for hermite_e module.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/polynomial/tests/test_polyutils.py
__doc__
"""Tests for polyutils module.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/polynomial/tests/test_legendre.py
__doc__
"""Tests for legendre module.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/polynomial/tests/test_chebyshev.py
__doc__
"""Tests for chebyshev module.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/polynomial/tests/test_polynomial.py
__doc__
"""Tests for polynomial module.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/polynomial/tests/test_hermite.py
__doc__
"""Tests for hermite module.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/polynomial/tests/test_classes.py
__doc__
"""Test inter-conversion of different polynomial classes.

This tests the convert and cast methods of all the polynomial classes.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/polynomial/polyutils.py
__doc__
"""
Utililty classes and functions for the polynomial modules.

This module provides: error and warning objects; a polynomial base class;
and some routines used in both the `polynomial` and `chebyshev` modules.

Error objects
-------------

.. autosummary::
   :toctree: generated/

   PolyError            base class for this sub-package's errors.
   PolyDomainError      raised when domains are mismatched.

Warning objects
---------------

.. autosummary::
   :toctree: generated/

   RankWarning  raised in least-squares fit for rank-deficient matrix.

Base class
----------

.. autosummary::
   :toctree: generated/

   PolyBase Obsolete base class for the polynomial classes. Do not use.

Functions
---------

.. autosummary::
   :toctree: generated/

   as_series    convert list of array_likes into 1-D arrays of common type.
   trimseq      remove trailing zeros.
   trimcoef     remove small trailing coefficients.
   getdomain    return the domain appropriate for a given set of abscissae.
   mapdomain    maps points between domains.
   mapparms     parameters of the linear map between domains.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/polynomial/hermite.py
__doc__
"""
Objects for dealing with Hermite series.

This module provides a number of objects (mostly functions) useful for
dealing with Hermite series, including a `Hermite` class that
encapsulates the usual arithmetic operations.  (General information
on how this module represents and works with such polynomials is in the
docstring for its "parent" sub-package, `numpy.polynomial`).

Constants
---------
- `hermdomain` -- Hermite series default domain, [-1,1].
- `hermzero` -- Hermite series that evaluates identically to 0.
- `hermone` -- Hermite series that evaluates identically to 1.
- `hermx` -- Hermite series for the identity map, ``f(x) = x``.

Arithmetic
----------
- `hermmulx` -- multiply a Hermite series in ``P_i(x)`` by ``x``.
- `hermadd` -- add two Hermite series.
- `hermsub` -- subtract one Hermite series from another.
- `hermmul` -- multiply two Hermite series.
- `hermdiv` -- divide one Hermite series by another.
- `hermval` -- evaluate a Hermite series at given points.
- `hermval2d` -- evaluate a 2D Hermite series at given points.
- `hermval3d` -- evaluate a 3D Hermite series at given points.
- `hermgrid2d` -- evaluate a 2D Hermite series on a Cartesian product.
- `hermgrid3d` -- evaluate a 3D Hermite series on a Cartesian product.

Calculus
--------
- `hermder` -- differentiate a Hermite series.
- `hermint` -- integrate a Hermite series.

Misc Functions
--------------
- `hermfromroots` -- create a Hermite series with specified roots.
- `hermroots` -- find the roots of a Hermite series.
- `hermvander` -- Vandermonde-like matrix for Hermite polynomials.
- `hermvander2d` -- Vandermonde-like matrix for 2D power series.
- `hermvander3d` -- Vandermonde-like matrix for 3D power series.
- `hermgauss` -- Gauss-Hermite quadrature, points and weights.
- `hermweight` -- Hermite weight function.
- `hermcompanion` -- symmetrized companion matrix in Hermite form.
- `hermfit` -- least-squares fit returning a Hermite series.
- `hermtrim` -- trim leading coefficients from a Hermite series.
- `hermline` -- Hermite series of given straight line.
- `herm2poly` -- convert a Hermite series to a polynomial.
- `poly2herm` -- convert a polynomial to a Hermite series.

Classes
-------
- `Hermite` -- A Hermite series class.

See also
--------
`numpy.polynomial`

"""

filename:/usr/lib/python2.7/dist-packages/numpy/polynomial/polynomial.py
__doc__
"""
Objects for dealing with polynomials.

This module provides a number of objects (mostly functions) useful for
dealing with polynomials, including a `Polynomial` class that
encapsulates the usual arithmetic operations.  (General information
on how this module represents and works with polynomial objects is in
the docstring for its "parent" sub-package, `numpy.polynomial`).

Constants
---------
- `polydomain` -- Polynomial default domain, [-1,1].
- `polyzero` -- (Coefficients of the) "zero polynomial."
- `polyone` -- (Coefficients of the) constant polynomial 1.
- `polyx` -- (Coefficients of the) identity map polynomial, ``f(x) = x``.

Arithmetic
----------
- `polyadd` -- add two polynomials.
- `polysub` -- subtract one polynomial from another.
- `polymul` -- multiply two polynomials.
- `polydiv` -- divide one polynomial by another.
- `polypow` -- raise a polynomial to an positive integer power
- `polyval` -- evaluate a polynomial at given points.
- `polyval2d` -- evaluate a 2D polynomial at given points.
- `polyval3d` -- evaluate a 3D polynomial at given points.
- `polygrid2d` -- evaluate a 2D polynomial on a Cartesian product.
- `polygrid3d` -- evaluate a 3D polynomial on a Cartesian product.

Calculus
--------
- `polyder` -- differentiate a polynomial.
- `polyint` -- integrate a polynomial.

Misc Functions
--------------
- `polyfromroots` -- create a polynomial with specified roots.
- `polyroots` -- find the roots of a polynomial.
- `polyvander` -- Vandermonde-like matrix for powers.
- `polyvander2d` -- Vandermonde-like matrix for 2D power series.
- `polyvander3d` -- Vandermonde-like matrix for 3D power series.
- `polycompanion` -- companion matrix in power series form.
- `polyfit` -- least-squares fit returning a polynomial.
- `polytrim` -- trim leading coefficients from a polynomial.
- `polyline` -- polynomial representing given straight line.

Classes
-------
- `Polynomial` -- polynomial class.

See Also
--------
`numpy.polynomial`

"""

filename:/usr/lib/python2.7/dist-packages/numpy/tests/test_scripts.py
__doc__
""" Test scripts

Test that we can run executable scripts that have been installed with numpy.
"""

filename:/usr/lib/python2.7/dist-packages/numpy/distutils/compat.py
__doc__
"""Small modules to cope with python 2 vs 3 incompatibilities inside
numpy.distutils

"""

filename:/usr/lib/python2.7/dist-packages/numpy/distutils/unixccompiler.py
__doc__
"""
unixccompiler - can handle very long argument lists for ar.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/distutils/info.py
__doc__
"""
Enhanced distutils with Fortran compilers support and more.
"""

filename:/usr/lib/python2.7/dist-packages/numpy/distutils/mingw32ccompiler.py
__doc__
"""
Support code for building Python extensions on Windows.

    # NT stuff
    # 1. Make sure libpython<version>.a exists for gcc.  If not, build it.
    # 2. Force windows to use gcc (we're struggling with MSVC and g77 support)
    # 3. Force windows to use g77

"""

filename:/usr/lib/python2.7/dist-packages/numpy/distutils/command/__init__.py
__doc__
"""distutils.command

Package containing implementation of all the standard Distutils
commands.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/distutils/command/build_src.py
__doc__
""" Build swig and f2py sources.
"""

filename:/usr/lib/python2.7/dist-packages/numpy/distutils/command/build_clib.py
__doc__
""" Modified version of build_clib that handles fortran source files.
"""

filename:/usr/lib/python2.7/dist-packages/numpy/distutils/command/build_scripts.py
__doc__
""" Modified version of build_scripts that handles building scripts from functions.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/distutils/command/build_ext.py
__doc__
""" Modified version of build_ext that handles fortran source files.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/distutils/command/autodist.py
__doc__
"""This module implements additional tests ala autoconf which can be useful.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/distutils/command/develop.py
__doc__
""" Override the develop command from setuptools so we can ensure that our
generated files (from build_src or build_scripts) are properly converted to real
files with filenames.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/distutils/extension.py
__doc__
"""distutils.extension

Provides the Extension class, used to describe C/C++ extension
modules in setup scripts.

Overridden to support f2py.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/distutils/fcompiler/__init__.py
__doc__
"""numpy.distutils.fcompiler

Contains FCompiler, an abstract base class that defines the interface
for the numpy.distutils Fortran compiler abstraction model.

Terminology:

To be consistent, where the term 'executable' is used, it means the single
file, like 'gcc', that is executed, and should be a string. In contrast,
'command' means the entire command line, like ['gcc', '-c', 'file.c'], and
should be a list.

But note that FCompiler.executables is actually a dictionary of commands.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/distutils/line_endings.py
__doc__
""" Functions for converting from DOS to UNIX line endings

"""

filename:/usr/lib/python2.7/dist-packages/numpy/dual.py
__doc__
"""
Aliases for functions which may be accelerated by Scipy.

Scipy_ can be built to use accelerated or otherwise improved libraries
for FFTs, linear algebra, and special functions. This module allows
developers to transparently support these accelerated functions when
scipy is available but still support users who have only installed
Numpy.

.. _Scipy : http://www.scipy.org

"""

filename:/usr/lib/python2.7/dist-packages/numpy/testing/__init__.py
__doc__
"""Common test support for all numpy test scripts.

This single module should provide all the common functionality for numpy tests
in a single location, so that test scripts can just import it and work right
away.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/testing/utils.py
__doc__
"""
Utility function to facilitate testing.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/testing/nosetester.py
__doc__
"""
Nose test running.

This module implements ``test()`` and ``bench()`` functions for NumPy modules.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/testing/decorators.py
__doc__
"""
Decorators for labeling and modifying behavior of test objects.

Decorators that merely return a modified version of the original
function object are straightforward. Decorators that return a new
function object need to use
::

  nose.tools.make_decorator(original_function)(decorator)

in returning the decorator, in order to preserve meta-data such as
function name, setup and teardown functions and so on - see
``nose.tools`` for more information.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/testing/tests/test_doctesting.py
__doc__
""" Doctests for NumPy-specific nose/doctest modifications

"""

filename:/usr/lib/python2.7/dist-packages/numpy/fft/info.py
__doc__
"""
Discrete Fourier Transform (:mod:`numpy.fft`)
=============================================

.. currentmodule:: numpy.fft

Standard FFTs
-------------

.. autosummary::
   :toctree: generated/

   fft       Discrete Fourier transform.
   ifft      Inverse discrete Fourier transform.
   fft2      Discrete Fourier transform in two dimensions.
   ifft2     Inverse discrete Fourier transform in two dimensions.
   fftn      Discrete Fourier transform in N-dimensions.
   ifftn     Inverse discrete Fourier transform in N dimensions.

Real FFTs
---------

.. autosummary::
   :toctree: generated/

   rfft      Real discrete Fourier transform.
   irfft     Inverse real discrete Fourier transform.
   rfft2     Real discrete Fourier transform in two dimensions.
   irfft2    Inverse real discrete Fourier transform in two dimensions.
   rfftn     Real discrete Fourier transform in N dimensions.
   irfftn    Inverse real discrete Fourier transform in N dimensions.

Hermitian FFTs
--------------

.. autosummary::
   :toctree: generated/

   hfft      Hermitian discrete Fourier transform.
   ihfft     Inverse Hermitian discrete Fourier transform.

Helper routines
---------------

.. autosummary::
   :toctree: generated/

   fftfreq   Discrete Fourier Transform sample frequencies.
   rfftfreq  DFT sample frequencies (for usage with rfft, irfft).
   fftshift  Shift zero-frequency component to center of spectrum.
   ifftshift Inverse of fftshift.


Background information
----------------------

Fourier analysis is fundamentally a method for expressing a function as a
sum of periodic components, and for recovering the function from those
components.  When both the function and its Fourier transform are
replaced with discretized counterparts, it is called the discrete Fourier
transform (DFT).  The DFT has become a mainstay of numerical computing in
part because of a very fast algorithm for computing it, called the Fast
Fourier Transform (FFT), which was known to Gauss (1805) and was brought
to light in its current form by Cooley and Tukey [CT]_.  Press et al. [NR]_
provide an accessible introduction to Fourier analysis and its
applications.

Because the discrete Fourier transform separates its input into
components that contribute at discrete frequencies, it has a great number
of applications in digital signal processing, e.g., for filtering, and in
this context the discretized input to the transform is customarily
referred to as a *signal*, which exists in the *time domain*.  The output
is called a *spectrum* or *transform* and exists in the *frequency
domain*.

Implementation details
----------------------

There are many ways to define the DFT, varying in the sign of the
exponent, normalization, etc.  In this implementation, the DFT is defined
as

.. math::
   A_k =  \\sum_{m=0}^{n-1} a_m \\exp\\left\\{-2\\pi i{mk \\over n}\\right\\}
   \\qquad k = 0,\\ldots,n-1.

The DFT is in general defined for complex inputs and outputs, and a
single-frequency component at linear frequency :math:`f` is
represented by a complex exponential
:math:`a_m = \\exp\\{2\\pi i\\,f m\\Delta t\\}`, where :math:`\\Delta t`
is the sampling interval.

The values in the result follow so-called "standard" order: If ``A =
fft(a, n)``, then ``A[0]`` contains the zero-frequency term (the sum of
the signal), which is always purely real for real inputs. Then ``A[1:n/2]``
contains the positive-frequency terms, and ``A[n/2+1:]`` contains the
negative-frequency terms, in order of decreasingly negative frequency.
For an even number of input points, ``A[n/2]`` represents both positive and
negative Nyquist frequency, and is also purely real for real input.  For
an odd number of input points, ``A[(n-1)/2]`` contains the largest positive
frequency, while ``A[(n+1)/2]`` contains the largest negative frequency.
The routine ``np.fft.fftfreq(n)`` returns an array giving the frequencies
of corresponding elements in the output.  The routine
``np.fft.fftshift(A)`` shifts transforms and their frequencies to put the
zero-frequency components in the middle, and ``np.fft.ifftshift(A)`` undoes
that shift.

When the input `a` is a time-domain signal and ``A = fft(a)``, ``np.abs(A)``
is its amplitude spectrum and ``np.abs(A)**2`` is its power spectrum.
The phase spectrum is obtained by ``np.angle(A)``.

The inverse DFT is defined as

.. math::
   a_m = \\frac{1}{n}\\sum_{k=0}^{n-1}A_k\\exp\\left\\{2\\pi i{mk\\over n}\\right\\}
   \\qquad m = 0,\\ldots,n-1.

It differs from the forward transform by the sign of the exponential
argument and the default normalization by :math:`1/n`.

Normalization
-------------
The default normalization has the direct transforms unscaled and the inverse
transforms are scaled by :math:`1/n`. It is possible to obtain unitary
transforms by setting the keyword argument ``norm`` to ``"ortho"`` (default is
`None`) so that both direct and inverse transforms will be scaled by
:math:`1/\\sqrt{n}`.

Real and Hermitian transforms
-----------------------------

When the input is purely real, its transform is Hermitian, i.e., the
component at frequency :math:`f_k` is the complex conjugate of the
component at frequency :math:`-f_k`, which means that for real
inputs there is no information in the negative frequency components that
is not already available from the positive frequency components.
The family of `rfft` functions is
designed to operate on real inputs, and exploits this symmetry by
computing only the positive frequency components, up to and including the
Nyquist frequency.  Thus, ``n`` input points produce ``n/2+1`` complex
output points.  The inverses of this family assumes the same symmetry of
its input, and for an output of ``n`` points uses ``n/2+1`` input points.

Correspondingly, when the spectrum is purely real, the signal is
Hermitian.  The `hfft` family of functions exploits this symmetry by
using ``n/2+1`` complex points in the input (time) domain for ``n`` real
points in the frequency domain.

In higher dimensions, FFTs are used, e.g., for image analysis and
filtering.  The computational efficiency of the FFT means that it can
also be a faster way to compute large convolutions, using the property
that a convolution in the time domain is equivalent to a point-by-point
multiplication in the frequency domain.

Higher dimensions
-----------------

In two dimensions, the DFT is defined as

.. math::
   A_{kl} =  \\sum_{m=0}^{M-1} \\sum_{n=0}^{N-1}
   a_{mn}\\exp\\left\\{-2\\pi i \\left({mk\\over M}+{nl\\over N}\\right)\\right\\}
   \\qquad k = 0, \\ldots, M-1;\\quad l = 0, \\ldots, N-1,

which extends in the obvious way to higher dimensions, and the inverses
in higher dimensions also extend in the same way.

References
----------

.. [CT] Cooley, James W., and John W. Tukey, 1965, "An algorithm for the
        machine calculation of complex Fourier series," *Math. Comput.*
        19: 297-301.

.. [NR] Press, W., Teukolsky, S., Vetterline, W.T., and Flannery, B.P.,
        2007, *Numerical Recipes: The Art of Scientific Computing*, ch.
        12-13.  Cambridge Univ. Press, Cambridge, UK.

Examples
--------

For examples, see the various functions.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/fft/fftpack.py
__doc__
"""
Discrete Fourier Transforms

Routines in this module:

fft(a, n=None, axis=-1)
ifft(a, n=None, axis=-1)
rfft(a, n=None, axis=-1)
irfft(a, n=None, axis=-1)
hfft(a, n=None, axis=-1)
ihfft(a, n=None, axis=-1)
fftn(a, s=None, axes=None)
ifftn(a, s=None, axes=None)
rfftn(a, s=None, axes=None)
irfftn(a, s=None, axes=None)
fft2(a, s=None, axes=(-2,-1))
ifft2(a, s=None, axes=(-2, -1))
rfft2(a, s=None, axes=(-2,-1))
irfft2(a, s=None, axes=(-2, -1))

i = inverse transform
r = transform of purely real data
h = Hermite transform
n = n-dimensional transform
2 = 2-dimensional transform
(Note: 2D routines are just nD routines with different default
behavior.)

The underlying code for these functions is an f2c-translated and modified
version of the FFTPACK routines.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/fft/helper.py
__doc__
"""
Discrete Fourier Transforms - helper.py

"""

filename:/usr/lib/python2.7/dist-packages/numpy/lib/scimath.py
__doc__
"""
Wrapper functions to more user-friendly calling of certain math functions
whose output data-type is different than the input data-type in certain
domains of the input.

For example, for functions like `log` with branch cuts, the versions in this
module provide the mathematically valid answers in the complex plane::

  >>> import math
  >>> from numpy.lib import scimath
  >>> scimath.log(-math.exp(1)) == (1+1j*math.pi)
  True

Similarly, `sqrt`, other base logarithms, `power` and trig functions are
correctly handled.  See their respective docstrings for specific examples.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/lib/twodim_base.py
__doc__
""" Basic functions for manipulating 2d arrays

"""

filename:/usr/lib/python2.7/dist-packages/numpy/lib/recfunctions.py
__doc__
"""
Collection of utilities to manipulate structured arrays.

Most of these functions were initially implemented by John Hunter for
matplotlib.  They have been rewritten and extended for convenience.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/lib/arraypad.py
__doc__
"""
The arraypad module contains a group of functions to pad values onto the edges
of an n-dimensional array.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/lib/info.py
__doc__
"""
Basic functions used by several sub-packages and
useful to have in the main name-space.

Type Handling
-------------
================ ===================
iscomplexobj     Test for complex object, scalar result
isrealobj        Test for real object, scalar result
iscomplex        Test for complex elements, array result
isreal           Test for real elements, array result
imag             Imaginary part
real             Real part
real_if_close    Turns complex number with tiny imaginary part to real
isneginf         Tests for negative infinity, array result
isposinf         Tests for positive infinity, array result
isnan            Tests for nans, array result
isinf            Tests for infinity, array result
isfinite         Tests for finite numbers, array result
isscalar         True if argument is a scalar
nan_to_num       Replaces NaN's with 0 and infinities with large numbers
cast             Dictionary of functions to force cast to each type
common_type      Determine the minimum common type code for a group
                 of arrays
mintypecode      Return minimal allowed common typecode.
================ ===================

Index Tricks
------------
================ ===================
mgrid            Method which allows easy construction of N-d
                 'mesh-grids'
``r_``           Append and construct arrays: turns slice objects into
                 ranges and concatenates them, for 2d arrays appends rows.
index_exp        Konrad Hinsen's index_expression class instance which
                 can be useful for building complicated slicing syntax.
================ ===================

Useful Functions
----------------
================ ===================
select           Extension of where to multiple conditions and choices
extract          Extract 1d array from flattened array according to mask
insert           Insert 1d array of values into Nd array according to mask
linspace         Evenly spaced samples in linear space
logspace         Evenly spaced samples in logarithmic space
fix              Round x to nearest integer towards zero
mod              Modulo mod(x,y) = x % y except keeps sign of y
amax             Array maximum along axis
amin             Array minimum along axis
ptp              Array max-min along axis
cumsum           Cumulative sum along axis
prod             Product of elements along axis
cumprod          Cumluative product along axis
diff             Discrete differences along axis
angle            Returns angle of complex argument
unwrap           Unwrap phase along given axis (1-d algorithm)
sort_complex     Sort a complex-array (based on real, then imaginary)
trim_zeros       Trim the leading and trailing zeros from 1D array.
vectorize        A class that wraps a Python function taking scalar
                 arguments into a generalized function which can handle
                 arrays of arguments using the broadcast rules of
                 numerix Python.
================ ===================

Shape Manipulation
------------------
================ ===================
squeeze          Return a with length-one dimensions removed.
atleast_1d       Force arrays to be > 1D
atleast_2d       Force arrays to be > 2D
atleast_3d       Force arrays to be > 3D
vstack           Stack arrays vertically (row on row)
hstack           Stack arrays horizontally (column on column)
column_stack     Stack 1D arrays as columns into 2D array
dstack           Stack arrays depthwise (along third dimension)
stack            Stack arrays along a new axis
split            Divide array into a list of sub-arrays
hsplit           Split into columns
vsplit           Split into rows
dsplit           Split along third dimension
================ ===================

Matrix (2D Array) Manipulations
-------------------------------
================ ===================
fliplr           2D array with columns flipped
flipud           2D array with rows flipped
rot90            Rotate a 2D array a multiple of 90 degrees
eye              Return a 2D array with ones down a given diagonal
diag             Construct a 2D array from a vector, or return a given
                 diagonal from a 2D array.
mat              Construct a Matrix
bmat             Build a Matrix from blocks
================ ===================

Polynomials
-----------
================ ===================
poly1d           A one-dimensional polynomial class
poly             Return polynomial coefficients from roots
roots            Find roots of polynomial given coefficients
polyint          Integrate polynomial
polyder          Differentiate polynomial
polyadd          Add polynomials
polysub          Substract polynomials
polymul          Multiply polynomials
polydiv          Divide polynomials
polyval          Evaluate polynomial at given argument
================ ===================

Iterators
---------
================ ===================
Arrayterator     A buffered iterator for big arrays.
================ ===================

Import Tricks
-------------
================ ===================
ppimport         Postpone module import until trying to use it
ppimport_attr    Postpone module import until trying to use its attribute
ppresolve        Import postponed module and return it.
================ ===================

Machine Arithmetics
-------------------
================ ===================
machar_single    Single precision floating point arithmetic parameters
machar_double    Double precision floating point arithmetic parameters
================ ===================

Threading Tricks
----------------
================ ===================
ParallelExec     Execute commands in parallel thread.
================ ===================

1D Array Set Operations
-----------------------
Set operations for 1D numeric arrays based on sort() function.

================ ===================
ediff1d          Array difference (auxiliary function).
unique           Unique elements of an array.
intersect1d      Intersection of 1D arrays with unique elements.
setxor1d         Set exclusive-or of 1D arrays with unique elements.
in1d             Test whether elements in a 1D array are also present in
                 another array.
union1d          Union of 1D arrays with unique elements.
setdiff1d        Set difference of 1D arrays with unique elements.
================ ===================

"""

filename:/usr/lib/python2.7/dist-packages/numpy/lib/type_check.py
__doc__
"""Automatically adapted for numpy Sep 19, 2005 by convertcode.py

"""

filename:/usr/lib/python2.7/dist-packages/numpy/lib/arraysetops.py
__doc__
"""
Set operations for 1D numeric arrays based on sorting.

:Contains:
  ediff1d,
  unique,
  intersect1d,
  setxor1d,
  in1d,
  union1d,
  setdiff1d

:Notes:

For floating point arrays, inaccurate results may appear due to usual round-off
and floating point comparison issues.

Speed could be gained in some operations by an implementation of
sort(), that can provide directly the permutation vectors, avoiding
thus calls to argsort().

To do: Optionally return indices analogously to unique for all functions.

:Author: Robert Cimrman

"""

filename:/usr/lib/python2.7/dist-packages/numpy/lib/stride_tricks.py
__doc__
"""
Utilities that manipulate strides to achieve desirable effects.

An explanation of strides can be found in the "ndarray.rst" file in the
NumPy reference guide.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/lib/nanfunctions.py
__doc__
"""
Functions that ignore NaN.

Functions
---------

- `nanmin` -- minimum non-NaN value
- `nanmax` -- maximum non-NaN value
- `nanargmin` -- index of minimum non-NaN value
- `nanargmax` -- index of maximum non-NaN value
- `nansum` -- sum of non-NaN values
- `nanprod` -- product of non-NaN values
- `nanmean` -- mean of non-NaN values
- `nanvar` -- variance of non-NaN values
- `nanstd` -- standard deviation of non-NaN values
- `nanmedian` -- median of non-NaN values
- `nanpercentile` -- qth percentile of non-NaN values

"""

filename:/usr/lib/python2.7/dist-packages/numpy/lib/_version.py
__doc__
"""Utility to compare (Numpy) version strings.

The NumpyVersion class allows properly comparing numpy version strings.
The LooseVersion and StrictVersion classes that distutils provides don't
work; they don't recognize anything like alpha/beta/rc/dev versions.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/lib/financial.py
__doc__
"""Some simple financial calculations

patterned after spreadsheet computations.

There is some complexity in each function
so that the functions behave like ufuncs with
broadcasting and being able to be called with scalars
or arrays (or other sequences).

"""

filename:/usr/lib/python2.7/dist-packages/numpy/lib/format.py
__doc__
"""
Define a simple format for saving numpy arrays to disk with the full
information about them.

The ``.npy`` format is the standard binary file format in NumPy for
persisting a *single* arbitrary NumPy array on disk. The format stores all
of the shape and dtype information necessary to reconstruct the array
correctly even on another machine with a different architecture.
The format is designed to be as simple as possible while achieving
its limited goals.

The ``.npz`` format is the standard format for persisting *multiple* NumPy
arrays on disk. A ``.npz`` file is a zip file containing multiple ``.npy``
files, one for each array.

Capabilities
------------

- Can represent all NumPy arrays including nested record arrays and
  object arrays.

- Represents the data in its native binary form.

- Supports Fortran-contiguous arrays directly.

- Stores all of the necessary information to reconstruct the array
  including shape and dtype on a machine of a different
  architecture.  Both little-endian and big-endian arrays are
  supported, and a file with little-endian numbers will yield
  a little-endian array on any machine reading the file. The
  types are described in terms of their actual sizes. For example,
  if a machine with a 64-bit C "long int" writes out an array with
  "long ints", a reading machine with 32-bit C "long ints" will yield
  an array with 64-bit integers.

- Is straightforward to reverse engineer. Datasets often live longer than
  the programs that created them. A competent developer should be
  able to create a solution in their preferred programming language to
  read most ``.npy`` files that he has been given without much
  documentation.

- Allows memory-mapping of the data. See `open_memmep`.

- Can be read from a filelike stream object instead of an actual file.

- Stores object arrays, i.e. arrays containing elements that are arbitrary
  Python objects. Files with object arrays are not to be mmapable, but
  can be read and written to disk.

Limitations
-----------

- Arbitrary subclasses of numpy.ndarray are not completely preserved.
  Subclasses will be accepted for writing, but only the array data will
  be written out. A regular numpy.ndarray object will be created
  upon reading the file.

.. warning::

  Due to limitations in the interpretation of structured dtypes, dtypes
  with fields with empty names will have the names replaced by 'f0', 'f1',
  etc. Such arrays will not round-trip through the format entirely
  accurately. The data is intact; only the field names will differ. We are
  working on a fix for this. This fix will not require a change in the
  file format. The arrays with such structures can still be saved and
  restored, and the correct dtype may be restored by using the
  ``loadedarray.view(correct_dtype)`` method.

File extensions
---------------

We recommend using the ``.npy`` and ``.npz`` extensions for files saved
in this format. This is by no means a requirement; applications may wish
to use these file formats but use an extension specific to the
application. In the absence of an obvious alternative, however,
we suggest using ``.npy`` and ``.npz``.

Version numbering
-----------------

The version numbering of these formats is independent of NumPy version
numbering. If the format is upgraded, the code in `numpy.io` will still
be able to read and write Version 1.0 files.

Format Version 1.0
------------------

The first 6 bytes are a magic string: exactly ``\\x93NUMPY``.

The next 1 byte is an unsigned byte: the major version number of the file
format, e.g. ``\\x01``.

The next 1 byte is an unsigned byte: the minor version number of the file
format, e.g. ``\\x00``. Note: the version of the file format is not tied
to the version of the numpy package.

The next 2 bytes form a little-endian unsigned short int: the length of
the header data HEADER_LEN.

The next HEADER_LEN bytes form the header data describing the array's
format. It is an ASCII string which contains a Python literal expression
of a dictionary. It is terminated by a newline (``\\n``) and padded with
spaces (``\\x20``) to make the total length of
``magic string + 4 + HEADER_LEN`` be evenly divisible by 16 for alignment
purposes.

The dictionary contains three keys:

    "descr" : dtype.descr
      An object that can be passed as an argument to the `numpy.dtype`
      constructor to create the array's dtype.
    "fortran_order" : bool
      Whether the array data is Fortran-contiguous or not. Since
      Fortran-contiguous arrays are a common form of non-C-contiguity,
      we allow them to be written directly to disk for efficiency.
    "shape" : tuple of int
      The shape of the array.

For repeatability and readability, the dictionary keys are sorted in
alphabetic order. This is for convenience only. A writer SHOULD implement
this if possible. A reader MUST NOT depend on this.

Following the header comes the array data. If the dtype contains Python
objects (i.e. ``dtype.hasobject is True``), then the data is a Python
pickle of the array. Otherwise the data is the contiguous (either C-
or Fortran-, depending on ``fortran_order``) bytes of the array.
Consumers can figure out the number of bytes by multiplying the number
of elements given by the shape (noting that ``shape=()`` means there is
1 element) by ``dtype.itemsize``.

Format Version 2.0
------------------

The version 1.0 format only allowed the array header to have a total size of
65535 bytes.  This can be exceeded by structured arrays with a large number of
columns.  The version 2.0 format extends the header size to 4 GiB.
`numpy.save` will automatically save in 2.0 format if the data requires it,
else it will always use the more compatible 1.0 format.

The description of the fourth element of the header therefore has become:
"The next 4 bytes form a little-endian unsigned int: the length of the header
data HEADER_LEN."

Notes
-----
The ``.npy`` format, including reasons for creating it and a comparison of
alternatives, is described fully in the "npy-format" NEP.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/lib/arrayterator.py
__doc__
"""
A buffered iterator for big arrays.

This module solves the problem of iterating over a big file-based array
without having to read it into memory. The `Arrayterator` class wraps
an array object, and when iterated it will return sub-arrays with at most
a user-specified number of elements.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/lib/user_array.py
__doc__
"""
Standard container-class for easy multiple-inheritance.

Try to inherit from the ndarray instead of using this class as this is not
complete.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/lib/tests/test_arraypad.py
__doc__
"""Tests for the array padding functions.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/lib/tests/test_arraysetops.py
__doc__
"""Test functions for 1D array set operations.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/lib/tests/test_twodim_base.py
__doc__
"""Test functions for matrix module

"""

filename:/usr/lib/python2.7/dist-packages/numpy/lib/tests/test__version.py
__doc__
"""Tests for the NumpyVersion class.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/lib/_datasource.py
__doc__
"""A file interface for handling local and remote data files.

The goal of datasource is to abstract some of the file system operations
when dealing with data files so the researcher doesn't have to know all the
low-level details.  Through datasource, a researcher can obtain and use a
file with one function call, regardless of location of the file.

DataSource is meant to augment standard python libraries, not replace them.
It should work seemlessly with standard file IO operations and the os
module.

DataSource files can originate locally or remotely:

- local files : '/home/guido/src/local/data.txt'
- URLs (http, ftp, ...) : 'http://www.scipy.org/not/real/data.txt'

DataSource files can also be compressed or uncompressed.  Currently only
gzip and bz2 are supported.

Example::

    >>> # Create a DataSource, use os.curdir (default) for local storage.
    >>> ds = datasource.DataSource()
    >>>
    >>> # Open a remote file.
    >>> # DataSource downloads the file, stores it locally in:
    >>> #     './www.google.com/index.html'
    >>> # opens the file and returns a file object.
    >>> fp = ds.open('http://www.google.com/index.html')
    >>>
    >>> # Use the file as you normally would
    >>> fp.read()
    >>> fp.close()

"""

filename:/usr/lib/python2.7/dist-packages/numpy/lib/_iotools.py
__doc__
"""A collection of functions designed to help I/O with ascii files.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/lib/ufunclike.py
__doc__
"""
Module of functions that are like ufuncs in acting on arrays and optionally
storing results in an output array.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/lib/polynomial.py
__doc__
"""
Functions to operate on polynomials.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/core/defchararray.py
__doc__
"""
This module contains a set of functions for vectorized string
operations and methods.

.. note::
   The `chararray` class exists for backwards compatibility with
   Numarray, it is not recommended for new development. Starting from numpy
   1.4, if one needs arrays of strings, it is recommended to use arrays of
   `dtype` `object_`, `string_` or `unicode_`, and use the free functions
   in the `numpy.char` module for fast vectorized string operations.

Some methods will only be available if the corresponding string method is
available in your version of Python.

The preferred alias for `defchararray` is `numpy.char`.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/core/records.py
__doc__
"""
Record Arrays
=============
Record arrays expose the fields of structured arrays as properties.

Most commonly, ndarrays contain elements of a single type, e.g. floats,
integers, bools etc.  However, it is possible for elements to be combinations
of these using structured types, such as::

  >>> a = np.array([(1, 2.0), (1, 2.0)], dtype=[('x', int), ('y', float)])
  >>> a
  array([(1, 2.0), (1, 2.0)],
        dtype=[('x', '<i4'), ('y', '<f8')])

Here, each element consists of two fields: x (and int), and y (a float).
This is known as a structured array.  The different fields are analogous
to columns in a spread-sheet.  The different fields can be accessed as
one would a dictionary::

  >>> a['x']
  array([1, 1])

  >>> a['y']
  array([ 2.,  2.])

Record arrays allow us to access fields as properties::

  >>> ar = np.rec.array(a)

  >>> ar.x
  array([1, 1])

  >>> ar.y
  array([ 2.,  2.])

"""

filename:/usr/lib/python2.7/dist-packages/numpy/core/info.py
__doc__
"""Defines a multi-dimensional array and useful procedures for Numerical computation.

Functions

-   array                      - NumPy Array construction
-   zeros                      - Return an array of all zeros
-   empty                      - Return an unitialized array
-   shape                      - Return shape of sequence or array
-   rank                       - Return number of dimensions
-   size                       - Return number of elements in entire array or a
                                 certain dimension
-   fromstring                 - Construct array from (byte) string
-   take                       - Select sub-arrays using sequence of indices
-   put                        - Set sub-arrays using sequence of 1-D indices
-   putmask                    - Set portion of arrays using a mask
-   reshape                    - Return array with new shape
-   repeat                     - Repeat elements of array
-   choose                     - Construct new array from indexed array tuple
-   correlate                  - Correlate two 1-d arrays
-   searchsorted               - Search for element in 1-d array
-   sum                        - Total sum over a specified dimension
-   average                    - Average, possibly weighted, over axis or array.
-   cumsum                     - Cumulative sum over a specified dimension
-   product                    - Total product over a specified dimension
-   cumproduct                 - Cumulative product over a specified dimension
-   alltrue                    - Logical and over an entire axis
-   sometrue                   - Logical or over an entire axis
-   allclose                   - Tests if sequences are essentially equal

More Functions:

-   arange                     - Return regularly spaced array
-   asarray                    - Guarantee NumPy array
-   convolve                   - Convolve two 1-d arrays
-   swapaxes                   - Exchange axes
-   concatenate                - Join arrays together
-   transpose                  - Permute axes
-   sort                       - Sort elements of array
-   argsort                    - Indices of sorted array
-   argmax                     - Index of largest value
-   argmin                     - Index of smallest value
-   inner                      - Innerproduct of two arrays
-   dot                        - Dot product (matrix multiplication)
-   outer                      - Outerproduct of two arrays
-   resize                     - Return array with arbitrary new shape
-   indices                    - Tuple of indices
-   fromfunction               - Construct array from universal function
-   diagonal                   - Return diagonal array
-   trace                      - Trace of array
-   dump                       - Dump array to file object (pickle)
-   dumps                      - Return pickled string representing data
-   load                       - Return array stored in file object
-   loads                      - Return array from pickled string
-   ravel                      - Return array as 1-D
-   nonzero                    - Indices of nonzero elements for 1-D array
-   shape                      - Shape of array
-   where                      - Construct array from binary result
-   compress                   - Elements of array where condition is true
-   clip                       - Clip array between two values
-   ones                       - Array of all ones
-   identity                   - 2-D identity array (matrix)

(Universal) Math Functions

       add                    logical_or             exp
       subtract               logical_xor            log
       multiply               logical_not            log10
       divide                 maximum                sin
       divide_safe            minimum                sinh
       conjugate              bitwise_and            sqrt
       power                  bitwise_or             tan
       absolute               bitwise_xor            tanh
       negative               invert                 ceil
       greater                left_shift             fabs
       greater_equal          right_shift            floor
       less                   arccos                 arctan2
       less_equal             arcsin                 fmod
       equal                  arctan                 hypot
       not_equal              cos                    around
       logical_and            cosh                   sign
       arccosh                arcsinh                arctanh

"""

filename:/usr/lib/python2.7/dist-packages/numpy/core/getlimits.py
__doc__
"""Machine limits for Float32 and Float64 and (long double) if available...

"""

filename:/usr/lib/python2.7/dist-packages/numpy/core/_internal.py
__doc__
"""
A place for code to be called from core C-code.

Some things are more easily handled Python.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/core/machar.py
__doc__
"""
Machine arithmetics - determine the parameters of the
floating-point arithmetic system

Author: Pearu Peterson, September 2003

"""

filename:/usr/lib/python2.7/dist-packages/numpy/core/cversions.py
__doc__
"""Simple script to compute the api hash of the current API.

The API has is defined by numpy_api_order and ufunc_api_order.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/core/arrayprint.py
__doc__
"""Array printing function

$Id: arrayprint.py,v 1.9 2005/09/13 13:58:44 teoliphant Exp $

"""

filename:/usr/lib/python2.7/dist-packages/numpy/core/numerictypes.py
__doc__
"""
numerictypes: Define the numeric type objects

This module is designed so "from numerictypes import \\*" is safe.
Exported symbols include:

  Dictionary with all registered number types (including aliases):
    typeDict

  Type objects (not all will be available, depends on platform):
      see variable sctypes for which ones you have

    Bit-width names

    int8 int16 int32 int64 int128
    uint8 uint16 uint32 uint64 uint128
    float16 float32 float64 float96 float128 float256
    complex32 complex64 complex128 complex192 complex256 complex512
    datetime64 timedelta64

    c-based names

    bool_

    object_

    void, str_, unicode_

    byte, ubyte,
    short, ushort
    intc, uintc,
    intp, uintp,
    int_, uint,
    longlong, ulonglong,

    single, csingle,
    float_, complex_,
    longfloat, clongfloat,

   As part of the type-hierarchy:    xx -- is bit-width

   generic
     +-> bool_                                  (kind=b)
     +-> number                                 (kind=i)
     |     integer
     |     signedinteger   (intxx)
     |     byte
     |     short
     |     intc
     |     intp           int0
     |     int_
     |     longlong
     +-> unsignedinteger  (uintxx)              (kind=u)
     |     ubyte
     |     ushort
     |     uintc
     |     uintp          uint0
     |     uint_
     |     ulonglong
     +-> inexact
     |   +-> floating           (floatxx)       (kind=f)
     |   |     half
     |   |     single
     |   |     float_  (double)
     |   |     longfloat
     |   \\-> complexfloating    (complexxx)     (kind=c)
     |         csingle  (singlecomplex)
     |         complex_ (cfloat, cdouble)
     |         clongfloat (longcomplex)
     +-> flexible
     |     character
     |     void                                 (kind=V)
     |
     |     str_     (string_, bytes_)           (kind=S)    [Python 2]
     |     unicode_                             (kind=U)    [Python 2]
     |
     |     bytes_   (string_)                   (kind=S)    [Python 3]
     |     str_     (unicode_)                  (kind=U)    [Python 3]
     |
     \\-> object_ (not used much)                (kind=O)

"""

filename:/usr/lib/python2.7/dist-packages/numpy/core/tests/test_deprecations.py
__doc__
"""
Tests related to deprecation warnings. Also a convenient place
to document how deprecations should eventually be turned into errors.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/core/tests/test_getlimits.py
__doc__
""" Test functions for limits module.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/core/_methods.py
__doc__
"""
Array methods which are called by both the C-code for the method
and the Python code for the NumPy-namespace function

"""

filename:/usr/lib/python2.7/dist-packages/numpy/core/fromnumeric.py
__doc__
"""Module containing non-deprecated functions borrowed from Numeric.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/matrixlib/__init__.py
__doc__
"""Sub-package containing the matrix class and related functions.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/random/__init__.py
__doc__
"""
========================
Random Number Generation
========================

==================== =========================================================
Utility functions
==============================================================================
random               Uniformly distributed values of a given shape.
bytes                Uniformly distributed random bytes.
random_integers      Uniformly distributed integers in a given range.
random_sample        Uniformly distributed floats in a given range.
random               Alias for random_sample
ranf                 Alias for random_sample
sample               Alias for random_sample
choice               Generate a weighted random sample from a given array-like
permutation          Randomly permute a sequence / generate a random sequence.
shuffle              Randomly permute a sequence in place.
seed                 Seed the random number generator.
==================== =========================================================

==================== =========================================================
Compatibility functions
==============================================================================
rand                 Uniformly distributed values.
randn                Normally distributed values.
ranf                 Uniformly distributed floating point numbers.
randint              Uniformly distributed integers in a given range.
==================== =========================================================

==================== =========================================================
Univariate distributions
==============================================================================
beta                 Beta distribution over ``[0, 1]``.
binomial             Binomial distribution.
chisquare            :math:`\\chi^2` distribution.
exponential          Exponential distribution.
f                    F (Fisher-Snedecor) distribution.
gamma                Gamma distribution.
geometric            Geometric distribution.
gumbel               Gumbel distribution.
hypergeometric       Hypergeometric distribution.
laplace              Laplace distribution.
logistic             Logistic distribution.
lognormal            Log-normal distribution.
logseries            Logarithmic series distribution.
negative_binomial    Negative binomial distribution.
noncentral_chisquare Non-central chi-square distribution.
noncentral_f         Non-central F distribution.
normal               Normal / Gaussian distribution.
pareto               Pareto distribution.
poisson              Poisson distribution.
power                Power distribution.
rayleigh             Rayleigh distribution.
triangular           Triangular distribution.
uniform              Uniform distribution.
vonmises             Von Mises circular distribution.
wald                 Wald (inverse Gaussian) distribution.
weibull              Weibull distribution.
zipf                 Zipf's distribution over ranked data.
==================== =========================================================

==================== =========================================================
Multivariate distributions
==============================================================================
dirichlet            Multivariate generalization of Beta distribution.
multinomial          Multivariate generalization of the binomial distribution.
multivariate_normal  Multivariate generalization of the normal distribution.
==================== =========================================================

==================== =========================================================
Standard distributions
==============================================================================
standard_cauchy      Standard Cauchy-Lorentz distribution.
standard_exponential Standard exponential distribution.
standard_gamma       Standard Gamma distribution.
standard_normal      Standard normal distribution.
standard_t           Standard Student's t-distribution.
==================== =========================================================

==================== =========================================================
Internal functions
==============================================================================
get_state            Get tuple representing internal state of generator.
set_state            Set state of generator.
==================== =========================================================

"""

filename:/usr/lib/python2.7/dist-packages/numpy/random/info.py
__doc__
"""
========================
Random Number Generation
========================

==================== =========================================================
Utility functions
==============================================================================
random_sample        Uniformly distributed floats over ``[0, 1)``.
random               Alias for `random_sample`.
bytes                Uniformly distributed random bytes.
random_integers      Uniformly distributed integers in a given range.
permutation          Randomly permute a sequence / generate a random sequence.
shuffle              Randomly permute a sequence in place.
seed                 Seed the random number generator.
choice               Random sample from 1-D array.

==================== =========================================================

==================== =========================================================
Compatibility functions
==============================================================================
rand                 Uniformly distributed values.
randn                Normally distributed values.
ranf                 Uniformly distributed floating point numbers.
randint              Uniformly distributed integers in a given range.
==================== =========================================================

==================== =========================================================
Univariate distributions
==============================================================================
beta                 Beta distribution over ``[0, 1]``.
binomial             Binomial distribution.
chisquare            :math:`\\chi^2` distribution.
exponential          Exponential distribution.
f                    F (Fisher-Snedecor) distribution.
gamma                Gamma distribution.
geometric            Geometric distribution.
gumbel               Gumbel distribution.
hypergeometric       Hypergeometric distribution.
laplace              Laplace distribution.
logistic             Logistic distribution.
lognormal            Log-normal distribution.
logseries            Logarithmic series distribution.
negative_binomial    Negative binomial distribution.
noncentral_chisquare Non-central chi-square distribution.
noncentral_f         Non-central F distribution.
normal               Normal / Gaussian distribution.
pareto               Pareto distribution.
poisson              Poisson distribution.
power                Power distribution.
rayleigh             Rayleigh distribution.
triangular           Triangular distribution.
uniform              Uniform distribution.
vonmises             Von Mises circular distribution.
wald                 Wald (inverse Gaussian) distribution.
weibull              Weibull distribution.
zipf                 Zipf's distribution over ranked data.
==================== =========================================================

==================== =========================================================
Multivariate distributions
==============================================================================
dirichlet            Multivariate generalization of Beta distribution.
multinomial          Multivariate generalization of the binomial distribution.
multivariate_normal  Multivariate generalization of the normal distribution.
==================== =========================================================

==================== =========================================================
Standard distributions
==============================================================================
standard_cauchy      Standard Cauchy-Lorentz distribution.
standard_exponential Standard exponential distribution.
standard_gamma       Standard Gamma distribution.
standard_normal      Standard normal distribution.
standard_t           Standard Student's t-distribution.
==================== =========================================================

==================== =========================================================
Internal functions
==============================================================================
get_state            Get tuple representing internal state of generator.
set_state            Set state of generator.
==================== =========================================================

"""

filename:/usr/lib/python2.7/dist-packages/numpy/ctypeslib.py
__doc__
"""
============================
``ctypes`` Utility Functions
============================

See Also
---------
load_library : Load a C library.
ndpointer : Array restype/argtype with verification.
as_ctypes : Create a ctypes array from an ndarray.
as_array : Create an ndarray from a ctypes array.

References
----------
.. [1] "SciPy Cookbook: ctypes", http://www.scipy.org/Cookbook/Ctypes

Examples
--------
Load the C library:

>>> _lib = np.ctypeslib.load_library('libmystuff', '.')     #doctest: +SKIP

Our result type, an ndarray that must be of type double, be 1-dimensional
and is C-contiguous in memory:

>>> array_1d_double = np.ctypeslib.ndpointer(
...                          dtype=np.double,
...                          ndim=1, flags='CONTIGUOUS')    #doctest: +SKIP

Our C-function typically takes an array and updates its values
in-place.  For example::

    void foo_func(double* x, int length)
    {
        int i;
        for (i = 0; i < length; i++) {
            x[i] = i*i;
        }
    }

We wrap it using:

>>> _lib.foo_func.restype = None                      #doctest: +SKIP
>>> _lib.foo_func.argtypes = [array_1d_double, c_int] #doctest: +SKIP

Then, we're ready to call ``foo_func``:

>>> out = np.empty(15, dtype=np.double)
>>> _lib.foo_func(out, len(out))                #doctest: +SKIP

"""

filename:/usr/lib/python2.7/dist-packages/numpy/compat/__init__.py
__doc__
"""
Compatibility module.

This module contains duplicated code from Python itself or 3rd party
extensions, which may be included for the following reasons:

  * compatibility
  * we may only need a small subset of the copied library/module

"""

filename:/usr/lib/python2.7/dist-packages/numpy/compat/py3k.py
__doc__
"""
Python 3 compatibility tools.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/compat/_inspect.py
__doc__
"""Subset of inspect module from upstream python

We use this instead of upstream because upstream inspect is slow to import, and
significanly contributes to numpy import times. Importing this copy has almost
no overhead.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/add_newdocs.py
__doc__
"""
This is only meant to add docs to objects defined in C-extension modules.
The purpose is to allow easier editing of the docstrings without
requiring a re-compile.

NOTE: Many of the methods of ndarray have corresponding functions.
      If you update these docstrings, please keep also the ones in
      core/fromnumeric.py, core/defmatrix.py up-to-date.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/linalg/linalg.py
__doc__
"""Lite version of scipy.linalg.

Notes
-----
This module is a lite version of the linalg.py module in SciPy which
contains high-level Python interface to the LAPACK library.  The lite
version only accesses the following LAPACK functions: dgesv, zgesv,
dgeev, zgeev, dgesdd, zgesdd, dgelsd, zgelsd, dsyevd, zheevd, dgetrf,
zgetrf, dpotrf, zpotrf, dgeqrf, zgeqrf, zungqr, dorgqr.
"""

filename:/usr/lib/python2.7/dist-packages/numpy/linalg/__init__.py
__doc__
"""
Core Linear Algebra Tools
=========================

=============== ==========================================================
Linear algebra basics
==========================================================================
norm            Vector or matrix norm
inv             Inverse of a square matrix
solve           Solve a linear system of equations
det             Determinant of a square matrix
slogdet         Logarithm of the determinant of a square matrix
lstsq           Solve linear least-squares problem
pinv            Pseudo-inverse (Moore-Penrose) calculated using a singular
                value decomposition
matrix_power    Integer power of a square matrix
matrix_rank     Calculate matrix rank using an SVD-based method
=============== ==========================================================

=============== ==========================================================
Eigenvalues and decompositions
==========================================================================
eig             Eigenvalues and vectors of a square matrix
eigh            Eigenvalues and eigenvectors of a Hermitian matrix
eigvals         Eigenvalues of a square matrix
eigvalsh        Eigenvalues of a Hermitian matrix
qr              QR decomposition of a matrix
svd             Singular value decomposition of a matrix
cholesky        Cholesky decomposition of a matrix
=============== ==========================================================

=============== ==========================================================
Tensor operations
==========================================================================
tensorsolve     Solve a linear tensor equation
tensorinv       Calculate an inverse of a tensor
=============== ==========================================================

=============== ==========================================================
Exceptions
==========================================================================
LinAlgError     Indicates a failed linear algebra operation
=============== ==========================================================

"""

filename:/usr/lib/python2.7/dist-packages/numpy/linalg/info.py
__doc__
"""\
Core Linear Algebra Tools
-------------------------
Linear algebra basics:

- norm            Vector or matrix norm
- inv             Inverse of a square matrix
- solve           Solve a linear system of equations
- det             Determinant of a square matrix
- lstsq           Solve linear least-squares problem
- pinv            Pseudo-inverse (Moore-Penrose) calculated using a singular
                  value decomposition
- matrix_power    Integer power of a square matrix

Eigenvalues and decompositions:

- eig             Eigenvalues and vectors of a square matrix
- eigh            Eigenvalues and eigenvectors of a Hermitian matrix
- eigvals         Eigenvalues of a square matrix
- eigvalsh        Eigenvalues of a Hermitian matrix
- qr              QR decomposition of a matrix
- svd             Singular value decomposition of a matrix
- cholesky        Cholesky decomposition of a matrix

Tensor operations:

- tensorsolve     Solve a linear tensor equation
- tensorinv       Calculate an inverse of a tensor

Exceptions:

- LinAlgError     Indicates a failed linear algebra operation

"""

filename:/usr/lib/python2.7/dist-packages/numpy/linalg/tests/test_deprecations.py
__doc__
"""Test deprecation and future warnings.

"""

filename:/usr/lib/python2.7/dist-packages/numpy/linalg/tests/test_regression.py
__doc__
""" Test functions for linalg module
"""

filename:/usr/lib/python2.7/dist-packages/numpy/linalg/tests/test_linalg.py
__doc__
""" Test functions for linalg module

"""

filename:/usr/lib/python2.7/dist-packages/html5lib/__init__.py
__doc__
"""
HTML parsing library based on the WHATWG "HTML5"
specification. The parser is designed to be compatible with existing
HTML found in the wild and implements well-defined error recovery that
is largely compatible with modern desktop web browsers.

Example usage:

import html5lib
f = open("my_document.html")
tree = html5lib.parse(f)
"""

filename:/usr/lib/python2.7/dist-packages/html5lib/treebuilders/__init__.py
__doc__
"""A collection of modules for building different kinds of tree from
HTML documents.

To create a treebuilder for a new type of tree, you need to do
implement several things:

1) A set of classes for various types of elements: Document, Doctype,
Comment, Element. These must implement the interface of
_base.treebuilders.Node (although comment nodes have a different
signature for their constructor, see treebuilders.etree.Comment)
Textual content may also be implemented as another node type, or not, as
your tree implementation requires.

2) A treebuilder object (called TreeBuilder by convention) that
inherits from treebuilders._base.TreeBuilder. This has 4 required attributes:
documentClass - the class to use for the bottommost node of a document
elementClass - the class to use for HTML Elements
commentClass - the class to use for comments
doctypeClass - the class to use for doctypes
It also has one required method:
getDocument - Returns the root node of the complete document tree

3) If you wish to run the unit tests, you must also create a
testSerializer method on your treebuilder which accepts a node and
returns a string containing Node and its children serialized according
to the format used in the unittests
"""

filename:/usr/lib/python2.7/dist-packages/html5lib/treebuilders/etree_lxml.py
__doc__
"""Module for supporting the lxml.etree library. The idea here is to use as much
of the native library as possible, without using fragile hacks like custom element
names that break between releases. The downside of this is that we cannot represent
all possible trees; specifically the following are known to cause problems:

Text or comments as siblings of the root element
Docypes with no name

When any of these things occur, we emit a DataLossWarning
"""

filename:/usr/lib/python2.7/dist-packages/html5lib/treewalkers/__init__.py
__doc__
"""A collection of modules for iterating through different kinds of
tree, generating tokens identical to those produced by the tokenizer
module.

To create a tree walker for a new type of tree, you need to do
implement a tree walker object (called TreeWalker by convention) that
implements a 'serialize' method taking a tree as sole argument and
returning an iterator generating tokens.
"""

filename:/usr/lib/python2.7/dist-packages/enum/__init__.py
__doc__
"""Python Enumerations"""

import sys as _sys

__all__ = ['Enum', 'IntEnum', 'unique']

version = 1, 1, 2

pyver = float('%s.%s' % _sys.version_info[:2])

try:
    any
except NameError:
    def any(iterable):
        for element in iterable:
            if element:
                return True
        return False

try:
    from collections import OrderedDict
except ImportError:
    OrderedDict = None

try:
    basestring
except NameError:
    # In Python 2 basestring is the ancestor of both str and unicode
    # in Python 3 it's just str, but was missing in 3.1
    basestring = str

try:
    unicode
except NameError:
    # In Python 3 unicode no longer exists (it's just str)
    unicode = str

class _RouteClassAttributeToGetattr(object):
    """Route attribute access on a class to __getattr__.

    This is a descriptor, used to define attributes that act differently when
    accessed through an instance and through a class.  Instance access remains
    normal, but access to an attribute through a class will be routed to the
    class's __getattr__ method; this is done by raising AttributeError.

    """
    def __init__(self, fget=None):
        self.fget = fget

    def __get__(self, instance, ownerclass=None):
        if instance is None:
            raise AttributeError()
        return self.fget(instance)

    def __set__(self, instance, value):
        raise AttributeError("can't set attribute")

    def __delete__(self, instance):
        raise AttributeError("can't delete attribute")


def _is_descriptor(obj):
    """Returns True if obj is a descriptor, False otherwise."""
    return (
            hasattr(obj, '__get__') or
            hasattr(obj, '__set__') or
            hasattr(obj, '__delete__'))


def _is_dunder(name):
    """Returns True if a __dunder__ name, False otherwise."""
    return (name[:2] == name[-2:] == '__' and
            name[2:3] != '_' and
            name[-3:-2] != '_' and
            len(name) > 4)


def _is_sunder(name):
    """Returns True if a _sunder_ name, False otherwise."""
    return (name[0] == name[-1] == '_' and
            name[1:2] != '_' and
            name[-2:-1] != '_' and
            len(name) > 2)


def _make_class_unpicklable(cls):
    """Make the given class un-picklable."""
    def _break_on_call_reduce(self, protocol=None):
        raise TypeError('%r cannot be pickled' % self)
    cls.__reduce_ex__ = _break_on_call_reduce
    cls.__module__ = '<unknown>'


class _EnumDict(dict):
    """Track enum member order and ensure member names are not reused.

    EnumMeta will use the names found in self._member_names as the
    enumeration member names.

    """
    def __init__(self):
        super(_EnumDict, self).__init__()
        self._member_names = []

    def __setitem__(self, key, value):
        """Changes anything not dundered or not a descriptor.

        If a descriptor is added with the same name as an enum member, the name
        is removed from _member_names (this may leave a hole in the numerical
        sequence of values).

        If an enum member name is used twice, an error is raised; duplicate
        values are not checked for.

        Single underscore (sunder) names are reserved.

        Note:   in 3.x __order__ is simply discarded as a not necessary piece
                leftover from 2.x

        """
        if pyver >= 3.0 and key == '__order__':
                return
        if _is_sunder(key):
            raise ValueError('_names_ are reserved for future Enum use')
        elif _is_dunder(key):
            pass
        elif key in self._member_names:
            # descriptor overwriting an enum?
            raise TypeError('Attempted to reuse key: %r' % key)
        elif not _is_descriptor(value):
            if key in self:
                # enum overwriting a descriptor?
                raise TypeError('Key already defined as: %r' % self[key])
            self._member_names.append(key)
        super(_EnumDict, self).__setitem__(key, value)


# Dummy value for Enum as EnumMeta explicity checks for it, but of course until
# EnumMeta finishes running the first time the Enum class doesn't exist.  This
# is also why there are checks in EnumMeta like `if Enum is not None`
Enum = None


class EnumMeta(type):
    """Metaclass for Enum"""
    @classmethod
    def __prepare__(metacls, cls, bases):
        return _EnumDict()

    def __new__(metacls, cls, bases, classdict):
        # an Enum class is final once enumeration items have been defined; it
        # cannot be mixed with other types (int, float, etc.) if it has an
        # inherited __new__ unless a new __new__ is defined (or the resulting
        # class will fail).
        if type(classdict) is dict:
            original_dict = classdict
            classdict = _EnumDict()
            for k, v in original_dict.items():
                classdict[k] = v

        member_type, first_enum = metacls._get_mixins_(bases)
        __new__, save_new, use_args = metacls._find_new_(classdict, member_type,
                                                        first_enum)
        # save enum items into separate mapping so they don't get baked into
        # the new class
        members = dict((k, classdict[k]) for k in classdict._member_names)
        for name in classdict._member_names:
            del classdict[name]

        # py2 support for definition order
        __order__ = classdict.get('__order__')
        if __order__ is None:
            if pyver < 3.0:
                try:
                    __order__ = [name for (name, value) in sorted(members.items(), key=lambda item: item[1])]
                except TypeError:
                    __order__ = [name for name in sorted(members.keys())]
            else:
                __order__ = classdict._member_names
        else:
            del classdict['__order__']
            if pyver < 3.0:
                __order__ = __order__.replace(',', ' ').split()
                aliases = [name for name in members if name not in __order__]
                __order__ += aliases

        # check for illegal enum names (any others?)
        invalid_names = set(members) & set(['mro'])
        if invalid_names:
            raise ValueError('Invalid enum member name(s): %s' % (
                ', '.join(invalid_names), ))

        # save attributes from super classes so we know if we can take
        # the shortcut of storing members in the class dict
        base_attributes = set([a for b in bases for a in b.__dict__])
        # create our new Enum type
        enum_class = super(EnumMeta, metacls).__new__(metacls, cls, bases, classdict)
        enum_class._member_names_ = []               # names in random order
        if OrderedDict is not None:
            enum_class._member_map_ = OrderedDict()
        else:
            enum_class._member_map_ = {}             # name->value map
        enum_class._member_type_ = member_type

        # Reverse value->name map for hashable values.
        enum_class._value2member_map_ = {}

        # instantiate them, checking for duplicates as we go
        # we instantiate first instead of checking for duplicates first in case
        # a custom __new__ is doing something funky with the values -- such as
        # auto-numbering ;)
        if __new__ is None:
            __new__ = enum_class.__new__
        for member_name in __order__:
            value = members[member_name]
            if not isinstance(value, tuple):
                args = (value, )
            else:
                args = value
            if member_type is tuple:   # special case for tuple enums
                args = (args, )     # wrap it one more time
            if not use_args or not args:
                enum_member = __new__(enum_class)
                if not hasattr(enum_member, '_value_'):
                    enum_member._value_ = value
            else:
                enum_member = __new__(enum_class, *args)
                if not hasattr(enum_member, '_value_'):
                    enum_member._value_ = member_type(*args)
            value = enum_member._value_
            enum_member._name_ = member_name
            enum_member.__objclass__ = enum_class
            enum_member.__init__(*args)
            # If another member with the same value was already defined, the
            # new member becomes an alias to the existing one.
            for name, canonical_member in enum_class._member_map_.items():
                if canonical_member.value == enum_member._value_:
                    enum_member = canonical_member
                    break
            else:
                # Aliases don't appear in member names (only in __members__).
                enum_class._member_names_.append(member_name)
            # performance boost for any member that would not shadow
            # a DynamicClassAttribute (aka _RouteClassAttributeToGetattr)
            if member_name not in base_attributes:
                setattr(enum_class, member_name, enum_member)
            # now add to _member_map_
            enum_class._member_map_[member_name] = enum_member
            try:
                # This may fail if value is not hashable. We can't add the value
                # to the map, and by-value lookups for this value will be
                # linear.
                enum_class._value2member_map_[value] = enum_member
            except TypeError:
                pass


        # If a custom type is mixed into the Enum, and it does not know how
        # to pickle itself, pickle.dumps will succeed but pickle.loads will
        # fail.  Rather than have the error show up later and possibly far
        # from the source, sabotage the pickle protocol for this class so
        # that pickle.dumps also fails.
        #
        # However, if the new class implements its own __reduce_ex__, do not
        # sabotage -- it's on them to make sure it works correctly.  We use
        # __reduce_ex__ instead of any of the others as it is preferred by
        # pickle over __reduce__, and it handles all pickle protocols.
        unpicklable = False
        if '__reduce_ex__' not in classdict:
            if member_type is not object:
                methods = ('__getnewargs_ex__', '__getnewargs__',
                        '__reduce_ex__', '__reduce__')
                if not any(m in member_type.__dict__ for m in methods):
                    _make_class_unpicklable(enum_class)
                    unpicklable = True


        # double check that repr and friends are not the mixin's or various
        # things break (such as pickle)
        for name in ('__repr__', '__str__', '__format__', '__reduce_ex__'):
            class_method = getattr(enum_class, name)
            obj_method = getattr(member_type, name, None)
            enum_method = getattr(first_enum, name, None)
            if name not in classdict and class_method is not enum_method:
                if name == '__reduce_ex__' and unpicklable:
                    continue
                setattr(enum_class, name, enum_method)

        # method resolution and int's are not playing nice
        # Python's less than 2.6 use __cmp__

        if pyver < 2.6:

            if issubclass(enum_class, int):
                setattr(enum_class, '__cmp__', getattr(int, '__cmp__'))

        elif pyver < 3.0:

            if issubclass(enum_class, int):
                for method in (
                        '__le__',
                        '__lt__',
                        '__gt__',
                        '__ge__',
                        '__eq__',
                        '__ne__',
                        '__hash__',
                        ):
                    setattr(enum_class, method, getattr(int, method))

        # replace any other __new__ with our own (as long as Enum is not None,
        # anyway) -- again, this is to support pickle
        if Enum is not None:
            # if the user defined their own __new__, save it before it gets
            # clobbered in case they subclass later
            if save_new:
                setattr(enum_class, '__member_new__', enum_class.__dict__['__new__'])
            setattr(enum_class, '__new__', Enum.__dict__['__new__'])
        return enum_class

    def __call__(cls, value, names=None, module=None, type=None, start=1):
        """Either returns an existing member, or creates a new enum class.

        This method is used both when an enum class is given a value to match
        to an enumeration member (i.e. Color(3)) and for the functional API
        (i.e. Color = Enum('Color', names='red green blue')).

        When used for the functional API: `module`, if set, will be stored in
        the new class' __module__ attribute; `type`, if set, will be mixed in
        as the first base class.

        Note: if `module` is not set this routine will attempt to discover the
        calling module by walking the frame stack; if this is unsuccessful
        the resulting class will not be pickleable.

        """
        if names is None:  # simple value lookup
            return cls.__new__(cls, value)
        # otherwise, functional API: we're creating a new Enum type
        return cls._create_(value, names, module=module, type=type, start=start)

    def __contains__(cls, member):
        return isinstance(member, cls) and member.name in cls._member_map_

    def __delattr__(cls, attr):
        # nicer error message when someone tries to delete an attribute
        # (see issue19025).
        if attr in cls._member_map_:
            raise AttributeError(
                    "%s: cannot delete Enum member." % cls.__name__)
        super(EnumMeta, cls).__delattr__(attr)

    def __dir__(self):
        return (['__class__', '__doc__', '__members__', '__module__'] +
                self._member_names_)

    @property
    def __members__(cls):
        """Returns a mapping of member name->value.

        This mapping lists all enum members, including aliases. Note that this
        is a copy of the internal mapping.

        """
        return cls._member_map_.copy()

    def __getattr__(cls, name):
        """Return the enum member matching `name`

        We use __getattr__ instead of descriptors or inserting into the enum
        class' __dict__ in order to support `name` and `value` being both
        properties for enum members (which live in the class' __dict__) and
        enum members themselves.

        """
        if _is_dunder(name):
            raise AttributeError(name)
        try:
            return cls._member_map_[name]
        except KeyError:
            raise AttributeError(name)

    def __getitem__(cls, name):
        return cls._member_map_[name]

    def __iter__(cls):
        return (cls._member_map_[name] for name in cls._member_names_)

    def __reversed__(cls):
        return (cls._member_map_[name] for name in reversed(cls._member_names_))

    def __len__(cls):
        return len(cls._member_names_)

    def __repr__(cls):
        return "<enum %r>" % cls.__name__

    def __setattr__(cls, name, value):
        """Block attempts to reassign Enum members.

        A simple assignment to the class namespace only changes one of the
        several possible ways to get an Enum member from the Enum class,
        resulting in an inconsistent Enumeration.

        """
        member_map = cls.__dict__.get('_member_map_', {})
        if name in member_map:
            raise AttributeError('Cannot reassign members.')
        super(EnumMeta, cls).__setattr__(name, value)

    def _create_(cls, class_name, names=None, module=None, type=None, start=1):
        """Convenience method to create a new Enum class.

        `names` can be:

        * A string containing member names, separated either with spaces or
          commas.  Values are auto-numbered from 1.
        * An iterable of member names.  Values are auto-numbered from 1.
        * An iterable of (member name, value) pairs.
        * A mapping of member name -> value.

        """
        if pyver < 3.0:
            # if class_name is unicode, attempt a conversion to ASCII
            if isinstance(class_name, unicode):
                try:
                    class_name = class_name.encode('ascii')
                except UnicodeEncodeError:
                    raise TypeError('%r is not representable in ASCII' % class_name)
        metacls = cls.__class__
        if type is None:
            bases = (cls, )
        else:
            bases = (type, cls)
        classdict = metacls.__prepare__(class_name, bases)
        __order__ = []

        # special processing needed for names?
        if isinstance(names, basestring):
            names = names.replace(',', ' ').split()
        if isinstance(names, (tuple, list)) and isinstance(names[0], basestring):
            names = [(e, i+start) for (i, e) in enumerate(names)]

        # Here, names is either an iterable of (name, value) or a mapping.
        item = None  # in case names is empty
        for item in names:
            if isinstance(item, basestring):
                member_name, member_value = item, names[item]
            else:
                member_name, member_value = item
            classdict[member_name] = member_value
            __order__.append(member_name)
        # only set __order__ in classdict if name/value was not from a mapping
        if not isinstance(item, basestring):
            classdict['__order__'] = ' '.join(__order__)
        enum_class = metacls.__new__(metacls, class_name, bases, classdict)

        # TODO: replace the frame hack if a blessed way to know the calling
        # module is ever developed
        if module is None:
            try:
                module = _sys._getframe(2).f_globals['__name__']
            except (AttributeError, ValueError):
                pass
        if module is None:
            _make_class_unpicklable(enum_class)
        else:
            enum_class.__module__ = module

        return enum_class

    @staticmethod
    def _get_mixins_(bases):
        """Returns the type for creating enum members, and the first inherited
        enum class.

        bases: the tuple of bases that was given to __new__

        """
        if not bases or Enum is None:
            return object, Enum


        # double check that we are not subclassing a class with existing
        # enumeration members; while we're at it, see if any other data
        # type has been mixed in so we can use the correct __new__
        member_type = first_enum = None
        for base in bases:
            if  (base is not Enum and
                    issubclass(base, Enum) and
                    base._member_names_):
                raise TypeError("Cannot extend enumerations")
        # base is now the last base in bases
        if not issubclass(base, Enum):
            raise TypeError("new enumerations must be created as "
                    "`ClassName([mixin_type,] enum_type)`")

        # get correct mix-in type (either mix-in type of Enum subclass, or
        # first base if last base is Enum)
        if not issubclass(bases[0], Enum):
            member_type = bases[0]     # first data type
            first_enum = bases[-1]  # enum type
        else:
            for base in bases[0].__mro__:
                # most common: (IntEnum, int, Enum, object)
                # possible:    (<Enum 'AutoIntEnum'>, <Enum 'IntEnum'>,
                #               <class 'int'>, <Enum 'Enum'>,
                #               <class 'object'>)
                if issubclass(base, Enum):
                    if first_enum is None:
                        first_enum = base
                else:
                    if member_type is None:
                        member_type = base

        return member_type, first_enum

    if pyver < 3.0:
        @staticmethod
        def _find_new_(classdict, member_type, first_enum):
            """Returns the __new__ to be used for creating the enum members.

            classdict: the class dictionary given to __new__
            member_type: the data type whose __new__ will be used by default
            first_enum: enumeration to check for an overriding __new__

            """
            # now find the correct __new__, checking to see of one was defined
            # by the user; also check earlier enum classes in case a __new__ was
            # saved as __member_new__
            __new__ = classdict.get('__new__', None)
            if __new__:
                return None, True, True      # __new__, save_new, use_args

            N__new__ = getattr(None, '__new__')
            O__new__ = getattr(object, '__new__')
            if Enum is None:
                E__new__ = N__new__
            else:
                E__new__ = Enum.__dict__['__new__']
            # check all possibles for __member_new__ before falling back to
            # __new__
            for method in ('__member_new__', '__new__'):
                for possible in (member_type, first_enum):
                    try:
                        target = possible.__dict__[method]
                    except (AttributeError, KeyError):
                        target = getattr(possible, method, None)
                    if target not in [
                            None,
                            N__new__,
                            O__new__,
                            E__new__,
                            ]:
                        if method == '__member_new__':
                            classdict['__new__'] = target
                            return None, False, True
                        if isinstance(target, staticmethod):
                            target = target.__get__(member_type)
                        __new__ = target
                        break
                if __new__ is not None:
                    break
            else:
                __new__ = object.__new__

            # if a non-object.__new__ is used then whatever value/tuple was
            # assigned to the enum member name will be passed to __new__ and to the
            # new enum member's __init__
            if __new__ is object.__new__:
                use_args = False
            else:
                use_args = True

            return __new__, False, use_args
    else:
        @staticmethod
        def _find_new_(classdict, member_type, first_enum):
            """Returns the __new__ to be used for creating the enum members.

            classdict: the class dictionary given to __new__
            member_type: the data type whose __new__ will be used by default
            first_enum: enumeration to check for an overriding __new__

            """
            # now find the correct __new__, checking to see of one was defined
            # by the user; also check earlier enum classes in case a __new__ was
            # saved as __member_new__
            __new__ = classdict.get('__new__', None)

            # should __new__ be saved as __member_new__ later?
            save_new = __new__ is not None

            if __new__ is None:
                # check all possibles for __member_new__ before falling back to
                # __new__
                for method in ('__member_new__', '__new__'):
                    for possible in (member_type, first_enum):
                        target = getattr(possible, method, None)
                        if target not in (
                                None,
                                None.__new__,
                                object.__new__,
                                Enum.__new__,
                                ):
                            __new__ = target
                            break
                    if __new__ is not None:
                        break
                else:
                    __new__ = object.__new__

            # if a non-object.__new__ is used then whatever value/tuple was
            # assigned to the enum member name will be passed to __new__ and to the
            # new enum member's __init__
            if __new__ is object.__new__:
                use_args = False
            else:
                use_args = True

            return __new__, save_new, use_args


########################################################
# In order to support Python 2 and 3 with a single
# codebase we have to create the Enum methods separately
# and then use the `type(name, bases, dict)` method to
# create the class.
########################################################
temp_enum_dict = {}
temp_enum_dict['__doc__'] = "Generic enumeration.\n\n    Derive from this class to define new enumerations.\n\n"

def __new__(cls, value):
    # all enum instances are actually created during class construction
    # without calling this method; this method is called by the metaclass'
    # __call__ (i.e. Color(3) ), and by pickle
    if type(value) is cls:
        # For lookups like Color(Color.red)
        value = value.value
        #return value
    # by-value search for a matching enum member
    # see if it's in the reverse mapping (for hashable values)
    try:
        if value in cls._value2member_map_:
            return cls._value2member_map_[value]
    except TypeError:
        # not there, now do long search -- O(n) behavior
        for member in cls._member_map_.values():
            if member.value == value:
                return member
    raise ValueError("%s is not a valid %s" % (value, cls.__name__))
temp_enum_dict['__new__'] = __new__
del __new__

def __repr__(self):
    return "<%s.%s: %r>" % (
            self.__class__.__name__, self._name_, self._value_)
temp_enum_dict['__repr__'] = __repr__
del __repr__

def __str__(self):
    return "%s.%s" % (self.__class__.__name__, self._name_)
temp_enum_dict['__str__'] = __str__
del __str__

if pyver >= 3.0:
    def __dir__(self):
        added_behavior = [
                m
                for cls in self.__class__.mro()
                for m in cls.__dict__
                if m[0] != '_' and m not in self._member_map_
                ]
        return (['__class__', '__doc__', '__module__', ] + added_behavior)
    temp_enum_dict['__dir__'] = __dir__
    del __dir__

def __format__(self, format_spec):
    # mixed-in Enums should use the mixed-in type's __format__, otherwise
    # we can get strange results with the Enum name showing up instead of
    # the value

    # pure Enum branch
    if self._member_type_ is object:
        cls = str
        val = str(self)
    # mix-in branch
    else:
        cls = self._member_type_
        val = self.value
    return cls.__format__(val, format_spec)
temp_enum_dict['__format__'] = __format__
del __format__


####################################
# Python's less than 2.6 use __cmp__

if pyver < 2.6:

    def __cmp__(self, other):
        if type(other) is self.__class__:
            if self is other:
                return 0
            return -1
        return NotImplemented
        raise TypeError("unorderable types: %s() and %s()" % (self.__class__.__name__, other.__class__.__name__))
    temp_enum_dict['__cmp__'] = __cmp__
    del __cmp__

else:

    def __le__(self, other):
        raise TypeError("unorderable types: %s() <= %s()" % (self.__class__.__name__, other.__class__.__name__))
    temp_enum_dict['__le__'] = __le__
    del __le__

    def __lt__(self, other):
        raise TypeError("unorderable types: %s() < %s()" % (self.__class__.__name__, other.__class__.__name__))
    temp_enum_dict['__lt__'] = __lt__
    del __lt__

    def __ge__(self, other):
        raise TypeError("unorderable types: %s() >= %s()" % (self.__class__.__name__, other.__class__.__name__))
    temp_enum_dict['__ge__'] = __ge__
    del __ge__

    def __gt__(self, other):
        raise TypeError("unorderable types: %s() > %s()" % (self.__class__.__name__, other.__class__.__name__))
    temp_enum_dict['__gt__'] = __gt__
    del __gt__


def __eq__(self, other):
    if type(other) is self.__class__:
        return self is other
    return NotImplemented
temp_enum_dict['__eq__'] = __eq__
del __eq__

def __ne__(self, other):
    if type(other) is self.__class__:
        return self is not other
    return NotImplemented
temp_enum_dict['__ne__'] = __ne__
del __ne__

def __hash__(self):
    return hash(self._name_)
temp_enum_dict['__hash__'] = __hash__
del __hash__

# TODO: enable once Python 3.6 is released
# def __bool__(self):
#     return bool(self._value_)
# if pyver < 3.0:
#     temp_enum_dict['__nonzero__'] = __bool__
# else:
#     temp_enum_dict['__bool__'] = __bool__
#     del __bool__

def __reduce_ex__(self, proto):
    return self.__class__, (self._value_, )
temp_enum_dict['__reduce_ex__'] = __reduce_ex__
del __reduce_ex__

# _RouteClassAttributeToGetattr is used to provide access to the `name`
# and `value` properties of enum members while keeping some measure of
# protection from modification, while still allowing for an enumeration
# to have members named `name` and `value`.  This works because enumeration
# members are not set directly on the enum class -- __getattr__ is
# used to look them up.

@_RouteClassAttributeToGetattr
def name(self):
    return self._name_
temp_enum_dict['name'] = name
del name

@_RouteClassAttributeToGetattr
def value(self):
    return self._value_
temp_enum_dict['value'] = value
del value

@classmethod
def _convert(cls, name, module, filter, source=None):
    """
    Create a new Enum subclass that replaces a collection of global constants
    """
    # convert all constants from source (or module) that pass filter() to
    # a new Enum called name, and export the enum and its members back to
    # module;
    # also, replace the __reduce_ex__ method so unpickling works in
    # previous Python versions
    module_globals = vars(_sys.modules[module])
    if source:
        source = vars(source)
    else:
        source = module_globals
    members = dict((name, value) for name, value in source.items() if filter(name))
    cls = cls(name, members, module=module)
    cls.__reduce_ex__ = _reduce_ex_by_name
    module_globals.update(cls.__members__)
    module_globals[name] = cls
    return cls
temp_enum_dict['_convert'] = _convert
del _convert

Enum = EnumMeta('Enum', (object, ), temp_enum_dict)
del temp_enum_dict

# Enum has now been created
###########################

class IntEnum(int, Enum):
    """Enum where members are also (and must be) ints"""

def _reduce_ex_by_name(self, proto):
    return self.name

def unique(enumeration):
    """Class decorator that ensures only unique members exist in an enumeration."""
    duplicates = []
    for name, member in enumeration.__members__.items():
        if name != member.name:
            duplicates.append((name, member.name))
    if duplicates:
        duplicate_names = ', '.join(
                ["%s -> %s" % (alias, name) for (alias, name) in duplicates]
                )
        raise ValueError('duplicate names found in %r: %s' %
                (enumeration, duplicate_names)
                )
    return enumeration

filename:/usr/lib/python2.7/dist-packages/enum/test_enum.py
__doc__
import enum
import sys
import unittest
from enum import Enum, IntEnum, unique, EnumMeta
from pickle import dumps, loads, PicklingError, HIGHEST_PROTOCOL

pyver = float('%s.%s' % sys.version_info[:2])

try:
    any
except NameError:
    def any(iterable):
        for element in iterable:
            if element:
                return True
        return False

try:
    unicode
except NameError:
    unicode = str

try:
    from collections import OrderedDict
except ImportError:
    OrderedDict = None

# for pickle tests
try:
    class Stooges(Enum):
        LARRY = 1
        CURLY = 2
        MOE = 3
except Exception:
    Stooges = sys.exc_info()[1]

try:
    class IntStooges(int, Enum):
        LARRY = 1
        CURLY = 2
        MOE = 3
except Exception:
    IntStooges = sys.exc_info()[1]

try:
    class FloatStooges(float, Enum):
        LARRY = 1.39
        CURLY = 2.72
        MOE = 3.142596
except Exception:
    FloatStooges = sys.exc_info()[1]

# for pickle test and subclass tests
try:
    class StrEnum(str, Enum):
        'accepts only string values'
    class Name(StrEnum):
        BDFL = 'Guido van Rossum'
        FLUFL = 'Barry Warsaw'
except Exception:
    Name = sys.exc_info()[1]

try:
    Question = Enum('Question', 'who what when where why', module=__name__)
except Exception:
    Question = sys.exc_info()[1]

try:
    Answer = Enum('Answer', 'him this then there because')
except Exception:
    Answer = sys.exc_info()[1]

try:
    Theory = Enum('Theory', 'rule law supposition', qualname='spanish_inquisition')
except Exception:
    Theory = sys.exc_info()[1]

# for doctests
try:
    class Fruit(Enum):
        tomato = 1
        banana = 2
        cherry = 3
except Exception:
    pass

def test_pickle_dump_load(assertion, source, target=None,
        protocol=(0, HIGHEST_PROTOCOL)):
    start, stop = protocol
    failures = []
    for protocol in range(start, stop+1):
        try:
            if target is None:
                assertion(loads(dumps(source, protocol=protocol)) is source)
            else:
                assertion(loads(dumps(source, protocol=protocol)), target)
        except Exception:
            exc, tb = sys.exc_info()[1:]
            failures.append('%2d: %s' %(protocol, exc))
    if failures:
        raise ValueError('Failed with protocols: %s' % ', '.join(failures))

def test_pickle_exception(assertion, exception, obj,
        protocol=(0, HIGHEST_PROTOCOL)):
    start, stop = protocol
    failures = []
    for protocol in range(start, stop+1):
        try:
            assertion(exception, dumps, obj, protocol=protocol)
        except Exception:
            exc = sys.exc_info()[1]
            failures.append('%d: %s %s' % (protocol, exc.__class__.__name__, exc))
    if failures:
        raise ValueError('Failed with protocols: %s' % ', '.join(failures))


class TestHelpers(unittest.TestCase):
    # _is_descriptor, _is_sunder, _is_dunder

    def test_is_descriptor(self):
        class foo:
            pass
        for attr in ('__get__','__set__','__delete__'):
            obj = foo()
            self.assertFalse(enum._is_descriptor(obj))
            setattr(obj, attr, 1)
            self.assertTrue(enum._is_descriptor(obj))

    def test_is_sunder(self):
        for s in ('_a_', '_aa_'):
            self.assertTrue(enum._is_sunder(s))

        for s in ('a', 'a_', '_a', '__a', 'a__', '__a__', '_a__', '__a_', '_',
                '__', '___', '____', '_____',):
            self.assertFalse(enum._is_sunder(s))

    def test_is_dunder(self):
        for s in ('__a__', '__aa__'):
            self.assertTrue(enum._is_dunder(s))
        for s in ('a', 'a_', '_a', '__a', 'a__', '_a_', '_a__', '__a_', '_',
                '__', '___', '____', '_____',):
            self.assertFalse(enum._is_dunder(s))


class TestEnum(unittest.TestCase):
    def setUp(self):
        class Season(Enum):
            SPRING = 1
            SUMMER = 2
            AUTUMN = 3
            WINTER = 4
        self.Season = Season

        class Konstants(float, Enum):
            E = 2.7182818
            PI = 3.1415926
            TAU = 2 * PI
        self.Konstants = Konstants

        class Grades(IntEnum):
            A = 5
            B = 4
            C = 3
            D = 2
            F = 0
        self.Grades = Grades

        class Directional(str, Enum):
            EAST = 'east'
            WEST = 'west'
            NORTH = 'north'
            SOUTH = 'south'
        self.Directional = Directional

        from datetime import date
        class Holiday(date, Enum):
            NEW_YEAR = 2013, 1, 1
            IDES_OF_MARCH = 2013, 3, 15
        self.Holiday = Holiday

    if pyver >= 3.0:     # do not specify custom `dir` on previous versions
        def test_dir_on_class(self):
            Season = self.Season
            self.assertEqual(
                set(dir(Season)),
                set(['__class__', '__doc__', '__members__', '__module__',
                    'SPRING', 'SUMMER', 'AUTUMN', 'WINTER']),
                )

        def test_dir_on_item(self):
            Season = self.Season
            self.assertEqual(
                set(dir(Season.WINTER)),
                set(['__class__', '__doc__', '__module__', 'name', 'value']),
                )

        def test_dir_with_added_behavior(self):
            class Test(Enum):
                this = 'that'
                these = 'those'
                def wowser(self):
                    return ("Wowser! I'm %s!" % self.name)
            self.assertEqual(
                    set(dir(Test)),
                    set(['__class__', '__doc__', '__members__', '__module__', 'this', 'these']),
                    )
            self.assertEqual(
                    set(dir(Test.this)),
                    set(['__class__', '__doc__', '__module__', 'name', 'value', 'wowser']),
                    )

        def test_dir_on_sub_with_behavior_on_super(self):
            # see issue22506
            class SuperEnum(Enum):
                def invisible(self):
                    return "did you see me?"
            class SubEnum(SuperEnum):
                sample = 5
            self.assertEqual(
                    set(dir(SubEnum.sample)),
                    set(['__class__', '__doc__', '__module__', 'name', 'value', 'invisible']),
                    )

    if pyver >= 2.7:    # OrderedDict first available here
        def test_members_is_ordereddict_if_ordered(self):
            class Ordered(Enum):
                __order__ = 'first second third'
                first = 'bippity'
                second = 'boppity'
                third = 'boo'
            self.assertTrue(type(Ordered.__members__) is OrderedDict)

        def test_members_is_ordereddict_if_not_ordered(self):
            class Unordered(Enum):
                this = 'that'
                these = 'those'
            self.assertTrue(type(Unordered.__members__) is OrderedDict)

    if pyver >= 3.0:     # all objects are ordered in Python 2.x
        def test_members_is_always_ordered(self):
            class AlwaysOrdered(Enum):
                first = 1
                second = 2
                third = 3
            self.assertTrue(type(AlwaysOrdered.__members__) is OrderedDict)

        def test_comparisons(self):
            def bad_compare():
                Season.SPRING > 4
            Season = self.Season
            self.assertNotEqual(Season.SPRING, 1)
            self.assertRaises(TypeError, bad_compare)

            class Part(Enum):
                SPRING = 1
                CLIP = 2
                BARREL = 3

            self.assertNotEqual(Season.SPRING, Part.SPRING)
            def bad_compare():
                Season.SPRING < Part.CLIP
            self.assertRaises(TypeError, bad_compare)

    def test_enum_in_enum_out(self):
        Season = self.Season
        self.assertTrue(Season(Season.WINTER) is Season.WINTER)

    def test_enum_value(self):
        Season = self.Season
        self.assertEqual(Season.SPRING.value, 1)

    def test_intenum_value(self):
        self.assertEqual(IntStooges.CURLY.value, 2)

    def test_enum(self):
        Season = self.Season
        lst = list(Season)
        self.assertEqual(len(lst), len(Season))
        self.assertEqual(len(Season), 4, Season)
        self.assertEqual(
            [Season.SPRING, Season.SUMMER, Season.AUTUMN, Season.WINTER], lst)

        for i, season in enumerate('SPRING SUMMER AUTUMN WINTER'.split()):
            i += 1
            e = Season(i)
            self.assertEqual(e, getattr(Season, season))
            self.assertEqual(e.value, i)
            self.assertNotEqual(e, i)
            self.assertEqual(e.name, season)
            self.assertTrue(e in Season)
            self.assertTrue(type(e) is Season)
            self.assertTrue(isinstance(e, Season))
            self.assertEqual(str(e), 'Season.' + season)
            self.assertEqual(
                    repr(e),
                    '<Season.%s: %s>' % (season, i),
                    )

    def test_value_name(self):
        Season = self.Season
        self.assertEqual(Season.SPRING.name, 'SPRING')
        self.assertEqual(Season.SPRING.value, 1)
        def set_name(obj, new_value):
            obj.name = new_value
        def set_value(obj, new_value):
            obj.value = new_value
        self.assertRaises(AttributeError, set_name, Season.SPRING, 'invierno', )
        self.assertRaises(AttributeError, set_value, Season.SPRING, 2)

    def test_attribute_deletion(self):
        class Season(Enum):
            SPRING = 1
            SUMMER = 2
            AUTUMN = 3
            WINTER = 4

            def spam(cls):
                pass

        self.assertTrue(hasattr(Season, 'spam'))
        del Season.spam
        self.assertFalse(hasattr(Season, 'spam'))

        self.assertRaises(AttributeError, delattr, Season, 'SPRING')
        self.assertRaises(AttributeError, delattr, Season, 'DRY')
        self.assertRaises(AttributeError, delattr, Season.SPRING, 'name')

    def test_invalid_names(self):
        def create_bad_class_1():
            class Wrong(Enum):
                mro = 9
        def create_bad_class_2():
            class Wrong(Enum):
                _reserved_ = 3
        self.assertRaises(ValueError, create_bad_class_1)
        self.assertRaises(ValueError, create_bad_class_2)

    # TODO: enable when Python 3.6 is released
    # def test_bool(self):
    #     class Logic(Enum):
    #         true = True
    #         false = False
    #     self.assertTrue(Logic.true)
    #     self.assertFalse(Logic.false)

    def test_contains(self):
        Season = self.Season
        self.assertTrue(Season.AUTUMN in Season)
        self.assertTrue(3 not in Season)

        val = Season(3)
        self.assertTrue(val in Season)

        class OtherEnum(Enum):
            one = 1; two = 2
        self.assertTrue(OtherEnum.two not in Season)

    if pyver >= 2.6:     # when `format` came into being

        def test_format_enum(self):
            Season = self.Season
            self.assertEqual('{0}'.format(Season.SPRING),
                             '{0}'.format(str(Season.SPRING)))
            self.assertEqual( '{0:}'.format(Season.SPRING),
                              '{0:}'.format(str(Season.SPRING)))
            self.assertEqual('{0:20}'.format(Season.SPRING),
                             '{0:20}'.format(str(Season.SPRING)))
            self.assertEqual('{0:^20}'.format(Season.SPRING),
                             '{0:^20}'.format(str(Season.SPRING)))
            self.assertEqual('{0:>20}'.format(Season.SPRING),
                             '{0:>20}'.format(str(Season.SPRING)))
            self.assertEqual('{0:<20}'.format(Season.SPRING),
                             '{0:<20}'.format(str(Season.SPRING)))

        def test_format_enum_custom(self):
            class TestFloat(float, Enum):
                one = 1.0
                two = 2.0
                def __format__(self, spec):
                    return 'TestFloat success!'
            self.assertEqual('{0}'.format(TestFloat.one), 'TestFloat success!')

        def assertFormatIsValue(self, spec, member):
            self.assertEqual(spec.format(member), spec.format(member.value))

        def test_format_enum_date(self):
            Holiday = self.Holiday
            self.assertFormatIsValue('{0}', Holiday.IDES_OF_MARCH)
            self.assertFormatIsValue('{0:}', Holiday.IDES_OF_MARCH)
            self.assertFormatIsValue('{0:20}', Holiday.IDES_OF_MARCH)
            self.assertFormatIsValue('{0:^20}', Holiday.IDES_OF_MARCH)
            self.assertFormatIsValue('{0:>20}', Holiday.IDES_OF_MARCH)
            self.assertFormatIsValue('{0:<20}', Holiday.IDES_OF_MARCH)
            self.assertFormatIsValue('{0:%Y %m}', Holiday.IDES_OF_MARCH)
            self.assertFormatIsValue('{0:%Y %m %M:00}', Holiday.IDES_OF_MARCH)

        def test_format_enum_float(self):
            Konstants = self.Konstants
            self.assertFormatIsValue('{0}', Konstants.TAU)
            self.assertFormatIsValue('{0:}', Konstants.TAU)
            self.assertFormatIsValue('{0:20}', Konstants.TAU)
            self.assertFormatIsValue('{0:^20}', Konstants.TAU)
            self.assertFormatIsValue('{0:>20}', Konstants.TAU)
            self.assertFormatIsValue('{0:<20}', Konstants.TAU)
            self.assertFormatIsValue('{0:n}', Konstants.TAU)
            self.assertFormatIsValue('{0:5.2}', Konstants.TAU)
            self.assertFormatIsValue('{0:f}', Konstants.TAU)

        def test_format_enum_int(self):
            Grades = self.Grades
            self.assertFormatIsValue('{0}', Grades.C)
            self.assertFormatIsValue('{0:}', Grades.C)
            self.assertFormatIsValue('{0:20}', Grades.C)
            self.assertFormatIsValue('{0:^20}', Grades.C)
            self.assertFormatIsValue('{0:>20}', Grades.C)
            self.assertFormatIsValue('{0:<20}', Grades.C)
            self.assertFormatIsValue('{0:+}', Grades.C)
            self.assertFormatIsValue('{0:08X}', Grades.C)
            self.assertFormatIsValue('{0:b}', Grades.C)

        def test_format_enum_str(self):
            Directional = self.Directional
            self.assertFormatIsValue('{0}', Directional.WEST)
            self.assertFormatIsValue('{0:}', Directional.WEST)
            self.assertFormatIsValue('{0:20}', Directional.WEST)
            self.assertFormatIsValue('{0:^20}', Directional.WEST)
            self.assertFormatIsValue('{0:>20}', Directional.WEST)
            self.assertFormatIsValue('{0:<20}', Directional.WEST)

    def test_hash(self):
        Season = self.Season
        dates = {}
        dates[Season.WINTER] = '1225'
        dates[Season.SPRING] = '0315'
        dates[Season.SUMMER] = '0704'
        dates[Season.AUTUMN] = '1031'
        self.assertEqual(dates[Season.AUTUMN], '1031')

    def test_enum_duplicates(self):
        __order__ = "SPRING SUMMER AUTUMN WINTER"
        class Season(Enum):
            SPRING = 1
            SUMMER = 2
            AUTUMN = FALL = 3
            WINTER = 4
            ANOTHER_SPRING = 1
        lst = list(Season)
        self.assertEqual(
            lst,
            [Season.SPRING, Season.SUMMER,
             Season.AUTUMN, Season.WINTER,
            ])
        self.assertTrue(Season.FALL is Season.AUTUMN)
        self.assertEqual(Season.FALL.value, 3)
        self.assertEqual(Season.AUTUMN.value, 3)
        self.assertTrue(Season(3) is Season.AUTUMN)
        self.assertTrue(Season(1) is Season.SPRING)
        self.assertEqual(Season.FALL.name, 'AUTUMN')
        self.assertEqual(
                set([k for k,v in Season.__members__.items() if v.name != k]),
                set(['FALL', 'ANOTHER_SPRING']),
                )

    if pyver >= 3.0:
        cls = vars()
        result = {'Enum':Enum}
        exec("""def test_duplicate_name(self):
            with self.assertRaises(TypeError):
                class Color(Enum):
                    red = 1
                    green = 2
                    blue = 3
                    red = 4

            with self.assertRaises(TypeError):
                class Color(Enum):
                    red = 1
                    green = 2
                    blue = 3
                    def red(self):
                        return 'red'

            with self.assertRaises(TypeError):
                class Color(Enum):
                    @property

                    def red(self):
                        return 'redder'
                    red = 1
                    green = 2
                    blue = 3""",
            result)
        cls['test_duplicate_name'] = result['test_duplicate_name']

    def test_enum_with_value_name(self):
        class Huh(Enum):
            name = 1
            value = 2
        self.assertEqual(
            list(Huh),
            [Huh.name, Huh.value],
            )
        self.assertTrue(type(Huh.name) is Huh)
        self.assertEqual(Huh.name.name, 'name')
        self.assertEqual(Huh.name.value, 1)

    def test_intenum_from_scratch(self):
        class phy(int, Enum):
            pi = 3
            tau = 2 * pi
        self.assertTrue(phy.pi < phy.tau)

    def test_intenum_inherited(self):
        class IntEnum(int, Enum):
            pass
        class phy(IntEnum):
            pi = 3
            tau = 2 * pi
        self.assertTrue(phy.pi < phy.tau)

    def test_floatenum_from_scratch(self):
        class phy(float, Enum):
            pi = 3.1415926
            tau = 2 * pi
        self.assertTrue(phy.pi < phy.tau)

    def test_floatenum_inherited(self):
        class FloatEnum(float, Enum):
            pass
        class phy(FloatEnum):
            pi = 3.1415926
            tau = 2 * pi
        self.assertTrue(phy.pi < phy.tau)

    def test_strenum_from_scratch(self):
        class phy(str, Enum):
            pi = 'Pi'
            tau = 'Tau'
        self.assertTrue(phy.pi < phy.tau)

    def test_strenum_inherited(self):
        class StrEnum(str, Enum):
            pass
        class phy(StrEnum):
            pi = 'Pi'
            tau = 'Tau'
        self.assertTrue(phy.pi < phy.tau)

    def test_intenum(self):
        class WeekDay(IntEnum):
            SUNDAY = 1
            MONDAY = 2
            TUESDAY = 3
            WEDNESDAY = 4
            THURSDAY = 5
            FRIDAY = 6
            SATURDAY = 7

        self.assertEqual(['a', 'b', 'c'][WeekDay.MONDAY], 'c')
        self.assertEqual([i for i in range(WeekDay.TUESDAY)], [0, 1, 2])

        lst = list(WeekDay)
        self.assertEqual(len(lst), len(WeekDay))
        self.assertEqual(len(WeekDay), 7)
        target = 'SUNDAY MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY SATURDAY'
        target = target.split()
        for i, weekday in enumerate(target):
            i += 1
            e = WeekDay(i)
            self.assertEqual(e, i)
            self.assertEqual(int(e), i)
            self.assertEqual(e.name, weekday)
            self.assertTrue(e in WeekDay)
            self.assertEqual(lst.index(e)+1, i)
            self.assertTrue(0 < e < 8)
            self.assertTrue(type(e) is WeekDay)
            self.assertTrue(isinstance(e, int))
            self.assertTrue(isinstance(e, Enum))

    def test_intenum_duplicates(self):
        class WeekDay(IntEnum):
            __order__ = 'SUNDAY MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY SATURDAY'
            SUNDAY = 1
            MONDAY = 2
            TUESDAY = TEUSDAY = 3
            WEDNESDAY = 4
            THURSDAY = 5
            FRIDAY = 6
            SATURDAY = 7
        self.assertTrue(WeekDay.TEUSDAY is WeekDay.TUESDAY)
        self.assertEqual(WeekDay(3).name, 'TUESDAY')
        self.assertEqual([k for k,v in WeekDay.__members__.items()
                if v.name != k], ['TEUSDAY', ])

    def test_pickle_enum(self):
        if isinstance(Stooges, Exception):
            raise Stooges
        test_pickle_dump_load(self.assertTrue, Stooges.CURLY)
        test_pickle_dump_load(self.assertTrue, Stooges)

    def test_pickle_int(self):
        if isinstance(IntStooges, Exception):
            raise IntStooges
        test_pickle_dump_load(self.assertTrue, IntStooges.CURLY)
        test_pickle_dump_load(self.assertTrue, IntStooges)

    def test_pickle_float(self):
        if isinstance(FloatStooges, Exception):
            raise FloatStooges
        test_pickle_dump_load(self.assertTrue, FloatStooges.CURLY)
        test_pickle_dump_load(self.assertTrue, FloatStooges)

    def test_pickle_enum_function(self):
        if isinstance(Answer, Exception):
            raise Answer
        test_pickle_dump_load(self.assertTrue, Answer.him)
        test_pickle_dump_load(self.assertTrue, Answer)

    def test_pickle_enum_function_with_module(self):
        if isinstance(Question, Exception):
            raise Question
        test_pickle_dump_load(self.assertTrue, Question.who)
        test_pickle_dump_load(self.assertTrue, Question)

    if pyver == 3.4:
        def test_class_nested_enum_and_pickle_protocol_four(self):
            # would normally just have this directly in the class namespace
            class NestedEnum(Enum):
                twigs = 'common'
                shiny = 'rare'

            self.__class__.NestedEnum = NestedEnum
            self.NestedEnum.__qualname__ = '%s.NestedEnum' % self.__class__.__name__
            test_pickle_exception(
                    self.assertRaises, PicklingError, self.NestedEnum.twigs,
                    protocol=(0, 3))
            test_pickle_dump_load(self.assertTrue, self.NestedEnum.twigs,
                    protocol=(4, HIGHEST_PROTOCOL))

    elif pyver == 3.5:
        def test_class_nested_enum_and_pickle_protocol_four(self):
            # would normally just have this directly in the class namespace
            class NestedEnum(Enum):
                twigs = 'common'
                shiny = 'rare'

            self.__class__.NestedEnum = NestedEnum
            self.NestedEnum.__qualname__ = '%s.NestedEnum' % self.__class__.__name__
            test_pickle_dump_load(self.assertTrue, self.NestedEnum.twigs,
                    protocol=(0, HIGHEST_PROTOCOL))

    def test_exploding_pickle(self):
        BadPickle = Enum('BadPickle', 'dill sweet bread-n-butter')
        enum._make_class_unpicklable(BadPickle)
        globals()['BadPickle'] = BadPickle
        test_pickle_exception(self.assertRaises, TypeError, BadPickle.dill)
        test_pickle_exception(self.assertRaises, PicklingError, BadPickle)

    def test_string_enum(self):
        class SkillLevel(str, Enum):
            master = 'what is the sound of one hand clapping?'
            journeyman = 'why did the chicken cross the road?'
            apprentice = 'knock, knock!'
        self.assertEqual(SkillLevel.apprentice, 'knock, knock!')

    def test_getattr_getitem(self):
        class Period(Enum):
            morning = 1
            noon = 2
            evening = 3
            night = 4
        self.assertTrue(Period(2) is Period.noon)
        self.assertTrue(getattr(Period, 'night') is Period.night)
        self.assertTrue(Period['morning'] is Period.morning)

    def test_getattr_dunder(self):
        Season = self.Season
        self.assertTrue(getattr(Season, '__hash__'))

    def test_iteration_order(self):
        class Season(Enum):
            __order__ = 'SUMMER WINTER AUTUMN SPRING'
            SUMMER = 2
            WINTER = 4
            AUTUMN = 3
            SPRING = 1
        self.assertEqual(
                list(Season),
                [Season.SUMMER, Season.WINTER, Season.AUTUMN, Season.SPRING],
                )

    def test_iteration_order_reversed(self):
        self.assertEqual(
                list(reversed(self.Season)),
                [self.Season.WINTER, self.Season.AUTUMN, self.Season.SUMMER,
                 self.Season.SPRING]
                )

    def test_iteration_order_with_unorderable_values(self):
        class Complex(Enum):
            a = complex(7, 9)
            b = complex(3.14, 2)
            c = complex(1, -1)
            d = complex(-77, 32)
        self.assertEqual(
                list(Complex),
                [Complex.a, Complex.b, Complex.c, Complex.d],
                )

    def test_programatic_function_string(self):
        SummerMonth = Enum('SummerMonth', 'june july august')
        lst = list(SummerMonth)
        self.assertEqual(len(lst), len(SummerMonth))
        self.assertEqual(len(SummerMonth), 3, SummerMonth)
        self.assertEqual(
                [SummerMonth.june, SummerMonth.july, SummerMonth.august],
                lst,
                )
        for i, month in enumerate('june july august'.split()):
            i += 1
            e = SummerMonth(i)
            self.assertEqual(int(e.value), i)
            self.assertNotEqual(e, i)
            self.assertEqual(e.name, month)
            self.assertTrue(e in SummerMonth)
            self.assertTrue(type(e) is SummerMonth)

    def test_programatic_function_string_with_start(self):
        SummerMonth = Enum('SummerMonth', 'june july august', start=10)
        lst = list(SummerMonth)
        self.assertEqual(len(lst), len(SummerMonth))
        self.assertEqual(len(SummerMonth), 3, SummerMonth)
        self.assertEqual(
                [SummerMonth.june, SummerMonth.july, SummerMonth.august],
                lst,
                )
        for i, month in enumerate('june july august'.split(), 10):
            e = SummerMonth(i)
            self.assertEqual(int(e.value), i)
            self.assertNotEqual(e, i)
            self.assertEqual(e.name, month)
            self.assertTrue(e in SummerMonth)
            self.assertTrue(type(e) is SummerMonth)

    def test_programatic_function_string_list(self):
        SummerMonth = Enum('SummerMonth', ['june', 'july', 'august'])
        lst = list(SummerMonth)
        self.assertEqual(len(lst), len(SummerMonth))
        self.assertEqual(len(SummerMonth), 3, SummerMonth)
        self.assertEqual(
                [SummerMonth.june, SummerMonth.july, SummerMonth.august],
                lst,
                )
        for i, month in enumerate('june july august'.split()):
            i += 1
            e = SummerMonth(i)
            self.assertEqual(int(e.value), i)
            self.assertNotEqual(e, i)
            self.assertEqual(e.name, month)
            self.assertTrue(e in SummerMonth)
            self.assertTrue(type(e) is SummerMonth)

    def test_programatic_function_string_list_with_start(self):
        SummerMonth = Enum('SummerMonth', ['june', 'july', 'august'], start=20)
        lst = list(SummerMonth)
        self.assertEqual(len(lst), len(SummerMonth))
        self.assertEqual(len(SummerMonth), 3, SummerMonth)
        self.assertEqual(
                [SummerMonth.june, SummerMonth.july, SummerMonth.august],
                lst,
                )
        for i, month in enumerate('june july august'.split(), 20):
            e = SummerMonth(i)
            self.assertEqual(int(e.value), i)
            self.assertNotEqual(e, i)
            self.assertEqual(e.name, month)
            self.assertTrue(e in SummerMonth)
            self.assertTrue(type(e) is SummerMonth)

    def test_programatic_function_iterable(self):
        SummerMonth = Enum(
                'SummerMonth',
                (('june', 1), ('july', 2), ('august', 3))
                )
        lst = list(SummerMonth)
        self.assertEqual(len(lst), len(SummerMonth))
        self.assertEqual(len(SummerMonth), 3, SummerMonth)
        self.assertEqual(
                [SummerMonth.june, SummerMonth.july, SummerMonth.august],
                lst,
                )
        for i, month in enumerate('june july august'.split()):
            i += 1
            e = SummerMonth(i)
            self.assertEqual(int(e.value), i)
            self.assertNotEqual(e, i)
            self.assertEqual(e.name, month)
            self.assertTrue(e in SummerMonth)
            self.assertTrue(type(e) is SummerMonth)

    def test_programatic_function_from_dict(self):
        SummerMonth = Enum(
                'SummerMonth',
                dict((('june', 1), ('july', 2), ('august', 3)))
                )
        lst = list(SummerMonth)
        self.assertEqual(len(lst), len(SummerMonth))
        self.assertEqual(len(SummerMonth), 3, SummerMonth)
        if pyver < 3.0:
            self.assertEqual(
                    [SummerMonth.june, SummerMonth.july, SummerMonth.august],
                    lst,
                    )
        for i, month in enumerate('june july august'.split()):
            i += 1
            e = SummerMonth(i)
            self.assertEqual(int(e.value), i)
            self.assertNotEqual(e, i)
            self.assertEqual(e.name, month)
            self.assertTrue(e in SummerMonth)
            self.assertTrue(type(e) is SummerMonth)

    def test_programatic_function_type(self):
        SummerMonth = Enum('SummerMonth', 'june july august', type=int)
        lst = list(SummerMonth)
        self.assertEqual(len(lst), len(SummerMonth))
        self.assertEqual(len(SummerMonth), 3, SummerMonth)
        self.assertEqual(
                [SummerMonth.june, SummerMonth.july, SummerMonth.august],
                lst,
                )
        for i, month in enumerate('june july august'.split()):
            i += 1
            e = SummerMonth(i)
            self.assertEqual(e, i)
            self.assertEqual(e.name, month)
            self.assertTrue(e in SummerMonth)
            self.assertTrue(type(e) is SummerMonth)

    def test_programatic_function_type_with_start(self):
        SummerMonth = Enum('SummerMonth', 'june july august', type=int, start=30)
        lst = list(SummerMonth)
        self.assertEqual(len(lst), len(SummerMonth))
        self.assertEqual(len(SummerMonth), 3, SummerMonth)
        self.assertEqual(
                [SummerMonth.june, SummerMonth.july, SummerMonth.august],
                lst,
                )
        for i, month in enumerate('june july august'.split(), 30):
            e = SummerMonth(i)
            self.assertEqual(e, i)
            self.assertEqual(e.name, month)
            self.assertTrue(e in SummerMonth)
            self.assertTrue(type(e) is SummerMonth)

    def test_programatic_function_type_from_subclass(self):
        SummerMonth = IntEnum('SummerMonth', 'june july august')
        lst = list(SummerMonth)
        self.assertEqual(len(lst), len(SummerMonth))
        self.assertEqual(len(SummerMonth), 3, SummerMonth)
        self.assertEqual(
                [SummerMonth.june, SummerMonth.july, SummerMonth.august],
                lst,
                )
        for i, month in enumerate('june july august'.split()):
            i += 1
            e = SummerMonth(i)
            self.assertEqual(e, i)
            self.assertEqual(e.name, month)
            self.assertTrue(e in SummerMonth)
            self.assertTrue(type(e) is SummerMonth)

    def test_programatic_function_type_from_subclass_with_start(self):
        SummerMonth = IntEnum('SummerMonth', 'june july august', start=40)
        lst = list(SummerMonth)
        self.assertEqual(len(lst), len(SummerMonth))
        self.assertEqual(len(SummerMonth), 3, SummerMonth)
        self.assertEqual(
                [SummerMonth.june, SummerMonth.july, SummerMonth.august],
                lst,
                )
        for i, month in enumerate('june july august'.split(), 40):
            e = SummerMonth(i)
            self.assertEqual(e, i)
            self.assertEqual(e.name, month)
            self.assertTrue(e in SummerMonth)
            self.assertTrue(type(e) is SummerMonth)

    def test_programatic_function_unicode(self):
        SummerMonth = Enum('SummerMonth', unicode('june july august'))
        lst = list(SummerMonth)
        self.assertEqual(len(lst), len(SummerMonth))
        self.assertEqual(len(SummerMonth), 3, SummerMonth)
        self.assertEqual(
                [SummerMonth.june, SummerMonth.july, SummerMonth.august],
                lst,
                )
        for i, month in enumerate(unicode('june july august').split()):
            i += 1
            e = SummerMonth(i)
            self.assertEqual(int(e.value), i)
            self.assertNotEqual(e, i)
            self.assertEqual(e.name, month)
            self.assertTrue(e in SummerMonth)
            self.assertTrue(type(e) is SummerMonth)

    def test_programatic_function_unicode_list(self):
        SummerMonth = Enum('SummerMonth', [unicode('june'), unicode('july'), unicode('august')])
        lst = list(SummerMonth)
        self.assertEqual(len(lst), len(SummerMonth))
        self.assertEqual(len(SummerMonth), 3, SummerMonth)
        self.assertEqual(
                [SummerMonth.june, SummerMonth.july, SummerMonth.august],
                lst,
                )
        for i, month in enumerate(unicode('june july august').split()):
            i += 1
            e = SummerMonth(i)
            self.assertEqual(int(e.value), i)
            self.assertNotEqual(e, i)
            self.assertEqual(e.name, month)
            self.assertTrue(e in SummerMonth)
            self.assertTrue(type(e) is SummerMonth)

    def test_programatic_function_unicode_iterable(self):
        SummerMonth = Enum(
                'SummerMonth',
                ((unicode('june'), 1), (unicode('july'), 2), (unicode('august'), 3))
                )
        lst = list(SummerMonth)
        self.assertEqual(len(lst), len(SummerMonth))
        self.assertEqual(len(SummerMonth), 3, SummerMonth)
        self.assertEqual(
                [SummerMonth.june, SummerMonth.july, SummerMonth.august],
                lst,
                )
        for i, month in enumerate(unicode('june july august').split()):
            i += 1
            e = SummerMonth(i)
            self.assertEqual(int(e.value), i)
            self.assertNotEqual(e, i)
            self.assertEqual(e.name, month)
            self.assertTrue(e in SummerMonth)
            self.assertTrue(type(e) is SummerMonth)

    def test_programatic_function_from_unicode_dict(self):
        SummerMonth = Enum(
                'SummerMonth',
                dict(((unicode('june'), 1), (unicode('july'), 2), (unicode('august'), 3)))
                )
        lst = list(SummerMonth)
        self.assertEqual(len(lst), len(SummerMonth))
        self.assertEqual(len(SummerMonth), 3, SummerMonth)
        if pyver < 3.0:
            self.assertEqual(
                    [SummerMonth.june, SummerMonth.july, SummerMonth.august],
                    lst,
                    )
        for i, month in enumerate(unicode('june july august').split()):
            i += 1
            e = SummerMonth(i)
            self.assertEqual(int(e.value), i)
            self.assertNotEqual(e, i)
            self.assertEqual(e.name, month)
            self.assertTrue(e in SummerMonth)
            self.assertTrue(type(e) is SummerMonth)

    def test_programatic_function_unicode_type(self):
        SummerMonth = Enum('SummerMonth', unicode('june july august'), type=int)
        lst = list(SummerMonth)
        self.assertEqual(len(lst), len(SummerMonth))
        self.assertEqual(len(SummerMonth), 3, SummerMonth)
        self.assertEqual(
                [SummerMonth.june, SummerMonth.july, SummerMonth.august],
                lst,
                )
        for i, month in enumerate(unicode('june july august').split()):
            i += 1
            e = SummerMonth(i)
            self.assertEqual(e, i)
            self.assertEqual(e.name, month)
            self.assertTrue(e in SummerMonth)
            self.assertTrue(type(e) is SummerMonth)

    def test_programatic_function_unicode_type_from_subclass(self):
        SummerMonth = IntEnum('SummerMonth', unicode('june july august'))
        lst = list(SummerMonth)
        self.assertEqual(len(lst), len(SummerMonth))
        self.assertEqual(len(SummerMonth), 3, SummerMonth)
        self.assertEqual(
                [SummerMonth.june, SummerMonth.july, SummerMonth.august],
                lst,
                )
        for i, month in enumerate(unicode('june july august').split()):
            i += 1
            e = SummerMonth(i)
            self.assertEqual(e, i)
            self.assertEqual(e.name, month)
            self.assertTrue(e in SummerMonth)
            self.assertTrue(type(e) is SummerMonth)

    def test_programmatic_function_unicode_class(self):
        if pyver < 3.0:
            class_names = unicode('SummerMonth'), 'S\xfcmm\xe9rM\xf6nth'.decode('latin1')
        else:
            class_names = 'SummerMonth', 'S\xfcmm\xe9rM\xf6nth'
        for i, class_name in enumerate(class_names):
            if pyver < 3.0 and i == 1:
                self.assertRaises(TypeError, Enum, class_name, unicode('june july august'))
            else:
                SummerMonth = Enum(class_name, unicode('june july august'))
                lst = list(SummerMonth)
                self.assertEqual(len(lst), len(SummerMonth))
                self.assertEqual(len(SummerMonth), 3, SummerMonth)
                self.assertEqual(
                        [SummerMonth.june, SummerMonth.july, SummerMonth.august],
                        lst,
                        )
                for i, month in enumerate(unicode('june july august').split()):
                    i += 1
                    e = SummerMonth(i)
                    self.assertEqual(e.value, i)
                    self.assertEqual(e.name, month)
                    self.assertTrue(e in SummerMonth)
                    self.assertTrue(type(e) is SummerMonth)

    def test_subclassing(self):
        if isinstance(Name, Exception):
            raise Name
        self.assertEqual(Name.BDFL, 'Guido van Rossum')
        self.assertTrue(Name.BDFL, Name('Guido van Rossum'))
        self.assertTrue(Name.BDFL is getattr(Name, 'BDFL'))
        test_pickle_dump_load(self.assertTrue, Name.BDFL)

    def test_extending(self):
        def bad_extension():
            class Color(Enum):
                red = 1
                green = 2
                blue = 3
            class MoreColor(Color):
                cyan = 4
                magenta = 5
                yellow = 6
        self.assertRaises(TypeError, bad_extension)

    def test_exclude_methods(self):
        class whatever(Enum):
            this = 'that'
            these = 'those'
            def really(self):
                return 'no, not %s' % self.value
        self.assertFalse(type(whatever.really) is whatever)
        self.assertEqual(whatever.this.really(), 'no, not that')

    def test_wrong_inheritance_order(self):
        def wrong_inherit():
            class Wrong(Enum, str):
                NotHere = 'error before this point'
        self.assertRaises(TypeError, wrong_inherit)

    def test_intenum_transitivity(self):
        class number(IntEnum):
            one = 1
            two = 2
            three = 3
        class numero(IntEnum):
            uno = 1
            dos = 2
            tres = 3
        self.assertEqual(number.one, numero.uno)
        self.assertEqual(number.two, numero.dos)
        self.assertEqual(number.three, numero.tres)

    def test_introspection(self):
        class Number(IntEnum):
            one = 100
            two = 200
        self.assertTrue(Number.one._member_type_ is int)
        self.assertTrue(Number._member_type_ is int)
        class String(str, Enum):
            yarn = 'soft'
            rope = 'rough'
            wire = 'hard'
        self.assertTrue(String.yarn._member_type_ is str)
        self.assertTrue(String._member_type_ is str)
        class Plain(Enum):
            vanilla = 'white'
            one = 1
        self.assertTrue(Plain.vanilla._member_type_ is object)
        self.assertTrue(Plain._member_type_ is object)

    def test_wrong_enum_in_call(self):
        class Monochrome(Enum):
            black = 0
            white = 1
        class Gender(Enum):
            male = 0
            female = 1
        self.assertRaises(ValueError, Monochrome, Gender.male)

    def test_wrong_enum_in_mixed_call(self):
        class Monochrome(IntEnum):
            black = 0
            white = 1
        class Gender(Enum):
            male = 0
            female = 1
        self.assertRaises(ValueError, Monochrome, Gender.male)

    def test_mixed_enum_in_call_1(self):
        class Monochrome(IntEnum):
            black = 0
            white = 1
        class Gender(IntEnum):
            male = 0
            female = 1
        self.assertTrue(Monochrome(Gender.female) is Monochrome.white)

    def test_mixed_enum_in_call_2(self):
        class Monochrome(Enum):
            black = 0
            white = 1
        class Gender(IntEnum):
            male = 0
            female = 1
        self.assertTrue(Monochrome(Gender.male) is Monochrome.black)

    def test_flufl_enum(self):
        class Fluflnum(Enum):
            def __int__(self):
                return int(self.value)
        class MailManOptions(Fluflnum):
            option1 = 1
            option2 = 2
            option3 = 3
        self.assertEqual(int(MailManOptions.option1), 1)

    def test_no_such_enum_member(self):
        class Color(Enum):
            red = 1
            green = 2
            blue = 3
        self.assertRaises(ValueError, Color, 4)
        self.assertRaises(KeyError, Color.__getitem__, 'chartreuse')

    def test_new_repr(self):
        class Color(Enum):
            red = 1
            green = 2
            blue = 3
            def __repr__(self):
                return "don't you just love shades of %s?" % self.name
        self.assertEqual(
                repr(Color.blue),
                "don't you just love shades of blue?",
                )

    def test_inherited_repr(self):
        class MyEnum(Enum):
            def __repr__(self):
                return "My name is %s." % self.name
        class MyIntEnum(int, MyEnum):
            this = 1
            that = 2
            theother = 3
        self.assertEqual(repr(MyIntEnum.that), "My name is that.")

    def test_multiple_mixin_mro(self):
        class auto_enum(EnumMeta):
            def __new__(metacls, cls, bases, classdict):
                original_dict = classdict
                classdict = enum._EnumDict()
                for k, v in original_dict.items():
                    classdict[k] = v
                temp = type(classdict)()
                names = set(classdict._member_names)
                i = 0
                for k in classdict._member_names:
                    v = classdict[k]
                    if v == ():
                        v = i
                    else:
                        i = v
                    i += 1
                    temp[k] = v
                for k, v in classdict.items():
                    if k not in names:
                        temp[k] = v
                return super(auto_enum, metacls).__new__(
                        metacls, cls, bases, temp)

        AutoNumberedEnum = auto_enum('AutoNumberedEnum', (Enum,), {})

        AutoIntEnum = auto_enum('AutoIntEnum', (IntEnum,), {})

        class TestAutoNumber(AutoNumberedEnum):
            a = ()
            b = 3
            c = ()

        class TestAutoInt(AutoIntEnum):
            a = ()
            b = 3
            c = ()

    def test_subclasses_with_getnewargs(self):
        class NamedInt(int):
            __qualname__ = 'NamedInt'  # needed for pickle protocol 4
            def __new__(cls, *args):
                _args = args
                if len(args) < 1:
                    raise TypeError("name and value must be specified")
                name, args = args[0], args[1:]
                self = int.__new__(cls, *args)
                self._intname = name
                self._args = _args
                return self
            def __getnewargs__(self):
                return self._args
            @property
            def __name__(self):
                return self._intname
            def __repr__(self):
                # repr() is updated to include the name and type info
                return "%s(%r, %s)" % (type(self).__name__,
                                             self.__name__,
                                             int.__repr__(self))
            def __str__(self):
                # str() is unchanged, even if it relies on the repr() fallback
                base = int
                base_str = base.__str__
                if base_str.__objclass__ is object:
                    return base.__repr__(self)
                return base_str(self)
            # for simplicity, we only define one operator that
            # propagates expressions
            def __add__(self, other):
                temp = int(self) + int( other)
                if isinstance(self, NamedInt) and isinstance(other, NamedInt):
                    return NamedInt(
                        '(%s + %s)' % (self.__name__, other.__name__),
                        temp )
                else:
                    return temp

        class NEI(NamedInt, Enum):
            __qualname__ = 'NEI'  # needed for pickle protocol 4
            x = ('the-x', 1)
            y = ('the-y', 2)

        self.assertTrue(NEI.__new__ is Enum.__new__)
        self.assertEqual(repr(NEI.x + NEI.y), "NamedInt('(the-x + the-y)', 3)")
        globals()['NamedInt'] = NamedInt
        globals()['NEI'] = NEI
        NI5 = NamedInt('test', 5)
        self.assertEqual(NI5, 5)
        test_pickle_dump_load(self.assertTrue, NI5, 5)
        self.assertEqual(NEI.y.value, 2)
        test_pickle_dump_load(self.assertTrue, NEI.y)

    if pyver >= 3.4:
        def test_subclasses_with_getnewargs_ex(self):
            class NamedInt(int):
                __qualname__ = 'NamedInt'       # needed for pickle protocol 4
                def __new__(cls, *args):
                    _args = args
                    if len(args) < 2:
                        raise TypeError("name and value must be specified")
                    name, args = args[0], args[1:]
                    self = int.__new__(cls, *args)
                    self._intname = name
                    self._args = _args
                    return self
                def __getnewargs_ex__(self):
                    return self._args, {}
                @property
                def __name__(self):
                    return self._intname
                def __repr__(self):
                    # repr() is updated to include the name and type info
                    return "{}({!r}, {})".format(type(self).__name__,
                                                 self.__name__,
                                                 int.__repr__(self))
                def __str__(self):
                    # str() is unchanged, even if it relies on the repr() fallback
                    base = int
                    base_str = base.__str__
                    if base_str.__objclass__ is object:
                        return base.__repr__(self)
                    return base_str(self)
                # for simplicity, we only define one operator that
                # propagates expressions
                def __add__(self, other):
                    temp = int(self) + int( other)
                    if isinstance(self, NamedInt) and isinstance(other, NamedInt):
                        return NamedInt(
                            '({0} + {1})'.format(self.__name__, other.__name__),
                            temp )
                    else:
                        return temp

            class NEI(NamedInt, Enum):
                __qualname__ = 'NEI'      # needed for pickle protocol 4
                x = ('the-x', 1)
                y = ('the-y', 2)


            self.assertIs(NEI.__new__, Enum.__new__)
            self.assertEqual(repr(NEI.x + NEI.y), "NamedInt('(the-x + the-y)', 3)")
            globals()['NamedInt'] = NamedInt
            globals()['NEI'] = NEI
            NI5 = NamedInt('test', 5)
            self.assertEqual(NI5, 5)
            test_pickle_dump_load(self.assertEqual, NI5, 5, protocol=(4, HIGHEST_PROTOCOL))
            self.assertEqual(NEI.y.value, 2)
            test_pickle_dump_load(self.assertTrue, NEI.y, protocol=(4, HIGHEST_PROTOCOL))

    def test_subclasses_with_reduce(self):
        class NamedInt(int):
            __qualname__ = 'NamedInt'       # needed for pickle protocol 4
            def __new__(cls, *args):
                _args = args
                if len(args) < 1:
                    raise TypeError("name and value must be specified")
                name, args = args[0], args[1:]
                self = int.__new__(cls, *args)
                self._intname = name
                self._args = _args
                return self
            def __reduce__(self):
                return self.__class__, self._args
            @property
            def __name__(self):
                return self._intname
            def __repr__(self):
                # repr() is updated to include the name and type info
                return "%s(%r, %s)" % (type(self).__name__,
                                             self.__name__,
                                             int.__repr__(self))
            def __str__(self):
                # str() is unchanged, even if it relies on the repr() fallback
                base = int
                base_str = base.__str__
                if base_str.__objclass__ is object:
                    return base.__repr__(self)
                return base_str(self)
            # for simplicity, we only define one operator that
            # propagates expressions
            def __add__(self, other):
                temp = int(self) + int( other)
                if isinstance(self, NamedInt) and isinstance(other, NamedInt):
                    return NamedInt(
                        '(%s + %s)' % (self.__name__, other.__name__),
                        temp )
                else:
                    return temp

        class NEI(NamedInt, Enum):
            __qualname__ = 'NEI'      # needed for pickle protocol 4
            x = ('the-x', 1)
            y = ('the-y', 2)


        self.assertTrue(NEI.__new__ is Enum.__new__)
        self.assertEqual(repr(NEI.x + NEI.y), "NamedInt('(the-x + the-y)', 3)")
        globals()['NamedInt'] = NamedInt
        globals()['NEI'] = NEI
        NI5 = NamedInt('test', 5)
        self.assertEqual(NI5, 5)
        test_pickle_dump_load(self.assertEqual, NI5, 5)
        self.assertEqual(NEI.y.value, 2)
        test_pickle_dump_load(self.assertTrue, NEI.y)

    def test_subclasses_with_reduce_ex(self):
        class NamedInt(int):
            __qualname__ = 'NamedInt'       # needed for pickle protocol 4
            def __new__(cls, *args):
                _args = args
                if len(args) < 1:
                    raise TypeError("name and value must be specified")
                name, args = args[0], args[1:]
                self = int.__new__(cls, *args)
                self._intname = name
                self._args = _args
                return self
            def __reduce_ex__(self, proto):
                return self.__class__, self._args
            @property
            def __name__(self):
                return self._intname
            def __repr__(self):
                # repr() is updated to include the name and type info
                return "%s(%r, %s)" % (type(self).__name__,
                                             self.__name__,
                                             int.__repr__(self))
            def __str__(self):
                # str() is unchanged, even if it relies on the repr() fallback
                base = int
                base_str = base.__str__
                if base_str.__objclass__ is object:
                    return base.__repr__(self)
                return base_str(self)
            # for simplicity, we only define one operator that
            # propagates expressions
            def __add__(self, other):
                temp = int(self) + int( other)
                if isinstance(self, NamedInt) and isinstance(other, NamedInt):
                    return NamedInt(
                        '(%s + %s)' % (self.__name__, other.__name__),
                        temp )
                else:
                    return temp

        class NEI(NamedInt, Enum):
            __qualname__ = 'NEI'      # needed for pickle protocol 4
            x = ('the-x', 1)
            y = ('the-y', 2)


        self.assertTrue(NEI.__new__ is Enum.__new__)
        self.assertEqual(repr(NEI.x + NEI.y), "NamedInt('(the-x + the-y)', 3)")
        globals()['NamedInt'] = NamedInt
        globals()['NEI'] = NEI
        NI5 = NamedInt('test', 5)
        self.assertEqual(NI5, 5)
        test_pickle_dump_load(self.assertEqual, NI5, 5)
        self.assertEqual(NEI.y.value, 2)
        test_pickle_dump_load(self.assertTrue, NEI.y)

    def test_subclasses_without_direct_pickle_support(self):
        class NamedInt(int):
            __qualname__ = 'NamedInt'
            def __new__(cls, *args):
                _args = args
                name, args = args[0], args[1:]
                if len(args) == 0:
                    raise TypeError("name and value must be specified")
                self = int.__new__(cls, *args)
                self._intname = name
                self._args = _args
                return self
            @property
            def __name__(self):
                return self._intname
            def __repr__(self):
                # repr() is updated to include the name and type info
                return "%s(%r, %s)" % (type(self).__name__,
                                             self.__name__,
                                             int.__repr__(self))
            def __str__(self):
                # str() is unchanged, even if it relies on the repr() fallback
                base = int
                base_str = base.__str__
                if base_str.__objclass__ is object:
                    return base.__repr__(self)
                return base_str(self)
            # for simplicity, we only define one operator that
            # propagates expressions
            def __add__(self, other):
                temp = int(self) + int( other)
                if isinstance(self, NamedInt) and isinstance(other, NamedInt):
                    return NamedInt(
                        '(%s + %s)' % (self.__name__, other.__name__),
                        temp )
                else:
                    return temp

        class NEI(NamedInt, Enum):
            __qualname__ = 'NEI'
            x = ('the-x', 1)
            y = ('the-y', 2)

        self.assertTrue(NEI.__new__ is Enum.__new__)
        self.assertEqual(repr(NEI.x + NEI.y), "NamedInt('(the-x + the-y)', 3)")
        globals()['NamedInt'] = NamedInt
        globals()['NEI'] = NEI
        NI5 = NamedInt('test', 5)
        self.assertEqual(NI5, 5)
        self.assertEqual(NEI.y.value, 2)
        test_pickle_exception(self.assertRaises, TypeError, NEI.x)
        test_pickle_exception(self.assertRaises, PicklingError, NEI)

    def test_subclasses_without_direct_pickle_support_using_name(self):
        class NamedInt(int):
            __qualname__ = 'NamedInt'
            def __new__(cls, *args):
                _args = args
                name, args = args[0], args[1:]
                if len(args) == 0:
                    raise TypeError("name and value must be specified")
                self = int.__new__(cls, *args)
                self._intname = name
                self._args = _args
                return self
            @property
            def __name__(self):
                return self._intname
            def __repr__(self):
                # repr() is updated to include the name and type info
                return "%s(%r, %s)" % (type(self).__name__,
                                             self.__name__,
                                             int.__repr__(self))
            def __str__(self):
                # str() is unchanged, even if it relies on the repr() fallback
                base = int
                base_str = base.__str__
                if base_str.__objclass__ is object:
                    return base.__repr__(self)
                return base_str(self)
            # for simplicity, we only define one operator that
            # propagates expressions
            def __add__(self, other):
                temp = int(self) + int( other)
                if isinstance(self, NamedInt) and isinstance(other, NamedInt):
                    return NamedInt(
                        '(%s + %s)' % (self.__name__, other.__name__),
                        temp )
                else:
                    return temp

        class NEI(NamedInt, Enum):
            __qualname__ = 'NEI'
            x = ('the-x', 1)
            y = ('the-y', 2)
            def __reduce_ex__(self, proto):
                return getattr, (self.__class__, self._name_)

        self.assertTrue(NEI.__new__ is Enum.__new__)
        self.assertEqual(repr(NEI.x + NEI.y), "NamedInt('(the-x + the-y)', 3)")
        globals()['NamedInt'] = NamedInt
        globals()['NEI'] = NEI
        NI5 = NamedInt('test', 5)
        self.assertEqual(NI5, 5)
        self.assertEqual(NEI.y.value, 2)
        test_pickle_dump_load(self.assertTrue, NEI.y)
        test_pickle_dump_load(self.assertTrue, NEI)

    def test_tuple_subclass(self):
        class SomeTuple(tuple, Enum):
            __qualname__ = 'SomeTuple'
            first = (1, 'for the money')
            second = (2, 'for the show')
            third = (3, 'for the music')
        self.assertTrue(type(SomeTuple.first) is SomeTuple)
        self.assertTrue(isinstance(SomeTuple.second, tuple))
        self.assertEqual(SomeTuple.third, (3, 'for the music'))
        globals()['SomeTuple'] = SomeTuple
        test_pickle_dump_load(self.assertTrue, SomeTuple.first)

    def test_duplicate_values_give_unique_enum_items(self):
        class AutoNumber(Enum):
            __order__ = 'enum_m enum_d enum_y'
            enum_m = ()
            enum_d = ()
            enum_y = ()
            def __new__(cls):
                value = len(cls.__members__) + 1
                obj = object.__new__(cls)
                obj._value_ = value
                return obj
            def __int__(self):
                return int(self._value_)
        self.assertEqual(int(AutoNumber.enum_d), 2)
        self.assertEqual(AutoNumber.enum_y.value, 3)
        self.assertTrue(AutoNumber(1) is AutoNumber.enum_m)
        self.assertEqual(
            list(AutoNumber),
            [AutoNumber.enum_m, AutoNumber.enum_d, AutoNumber.enum_y],
            )

    def test_inherited_new_from_enhanced_enum(self):
        class AutoNumber2(Enum):
            def __new__(cls):
                value = len(cls.__members__) + 1
                obj = object.__new__(cls)
                obj._value_ = value
                return obj
            def __int__(self):
                return int(self._value_)
        class Color(AutoNumber2):
            __order__ = 'red green blue'
            red = ()
            green = ()
            blue = ()
        self.assertEqual(len(Color), 3, "wrong number of elements: %d (should be %d)" % (len(Color), 3))
        self.assertEqual(list(Color), [Color.red, Color.green, Color.blue])
        if pyver >= 3.0:
            self.assertEqual(list(map(int, Color)), [1, 2, 3])

    def test_inherited_new_from_mixed_enum(self):
        class AutoNumber3(IntEnum):
            def __new__(cls):
                value = len(cls.__members__) + 1
                obj = int.__new__(cls, value)
                obj._value_ = value
                return obj
        class Color(AutoNumber3):
            red = ()
            green = ()
            blue = ()
        self.assertEqual(len(Color), 3, "wrong number of elements: %d (should be %d)" % (len(Color), 3))
        Color.red
        Color.green
        Color.blue

    def test_equality(self):
        class AlwaysEqual:
            def __eq__(self, other):
                return True
        class OrdinaryEnum(Enum):
            a = 1
        self.assertEqual(AlwaysEqual(), OrdinaryEnum.a)
        self.assertEqual(OrdinaryEnum.a, AlwaysEqual())

    def test_ordered_mixin(self):
        class OrderedEnum(Enum):
            def __ge__(self, other):
                if self.__class__ is other.__class__:
                    return self._value_ >= other._value_
                return NotImplemented
            def __gt__(self, other):
                if self.__class__ is other.__class__:
                    return self._value_ > other._value_
                return NotImplemented
            def __le__(self, other):
                if self.__class__ is other.__class__:
                    return self._value_ <= other._value_
                return NotImplemented
            def __lt__(self, other):
                if self.__class__ is other.__class__:
                    return self._value_ < other._value_
                return NotImplemented
        class Grade(OrderedEnum):
            __order__ = 'A B C D F'
            A = 5
            B = 4
            C = 3
            D = 2
            F = 1
        self.assertEqual(list(Grade), [Grade.A, Grade.B, Grade.C, Grade.D, Grade.F])
        self.assertTrue(Grade.A > Grade.B)
        self.assertTrue(Grade.F <= Grade.C)
        self.assertTrue(Grade.D < Grade.A)
        self.assertTrue(Grade.B >= Grade.B)

    def test_extending2(self):
        def bad_extension():
            class Shade(Enum):
                def shade(self):
                    print(self.name)
            class Color(Shade):
                red = 1
                green = 2
                blue = 3
            class MoreColor(Color):
                cyan = 4
                magenta = 5
                yellow = 6
        self.assertRaises(TypeError, bad_extension)

    def test_extending3(self):
        class Shade(Enum):
            def shade(self):
                return self.name
        class Color(Shade):
            def hex(self):
                return '%s hexlified!' % self.value
        class MoreColor(Color):
            cyan = 4
            magenta = 5
            yellow = 6
        self.assertEqual(MoreColor.magenta.hex(), '5 hexlified!')

    def test_no_duplicates(self):
        def bad_duplicates():
            class UniqueEnum(Enum):
                def __init__(self, *args):
                    cls = self.__class__
                    if any(self.value == e.value for e in cls):
                        a = self.name
                        e = cls(self.value).name
                        raise ValueError(
                                "aliases not allowed in UniqueEnum:  %r --> %r"
                                % (a, e)
                                )
            class Color(UniqueEnum):
                red = 1
                green = 2
                blue = 3
            class Color(UniqueEnum):
                red = 1
                green = 2
                blue = 3
                grene = 2
        self.assertRaises(ValueError, bad_duplicates)

    def test_init(self):
        class Planet(Enum):
            MERCURY = (3.303e+23, 2.4397e6)
            VENUS   = (4.869e+24, 6.0518e6)
            EARTH   = (5.976e+24, 6.37814e6)
            MARS    = (6.421e+23, 3.3972e6)
            JUPITER = (1.9e+27,   7.1492e7)
            SATURN  = (5.688e+26, 6.0268e7)
            URANUS  = (8.686e+25, 2.5559e7)
            NEPTUNE = (1.024e+26, 2.4746e7)
            def __init__(self, mass, radius):
                self.mass = mass       # in kilograms
                self.radius = radius   # in meters
            @property
            def surface_gravity(self):
                # universal gravitational constant  (m3 kg-1 s-2)
                G = 6.67300E-11
                return G * self.mass / (self.radius * self.radius)
        self.assertEqual(round(Planet.EARTH.surface_gravity, 2), 9.80)
        self.assertEqual(Planet.EARTH.value, (5.976e+24, 6.37814e6))

    def test_nonhash_value(self):
        class AutoNumberInAList(Enum):
            def __new__(cls):
                value = [len(cls.__members__) + 1]
                obj = object.__new__(cls)
                obj._value_ = value
                return obj
        class ColorInAList(AutoNumberInAList):
            __order__ = 'red green blue'
            red = ()
            green = ()
            blue = ()
        self.assertEqual(list(ColorInAList), [ColorInAList.red, ColorInAList.green, ColorInAList.blue])
        self.assertEqual(ColorInAList.red.value, [1])
        self.assertEqual(ColorInAList([1]), ColorInAList.red)

    def test_conflicting_types_resolved_in_new(self):
        class LabelledIntEnum(int, Enum):
            def __new__(cls, *args):
                value, label = args
                obj = int.__new__(cls, value)
                obj.label = label
                obj._value_ = value
                return obj

        class LabelledList(LabelledIntEnum):
            unprocessed = (1, "Unprocessed")
            payment_complete = (2, "Payment Complete")

        self.assertEqual(list(LabelledList), [LabelledList.unprocessed, LabelledList.payment_complete])
        self.assertEqual(LabelledList.unprocessed, 1)
        self.assertEqual(LabelledList(1), LabelledList.unprocessed)

    def test_empty_with_functional_api(self):
        empty = enum.IntEnum('Foo', {})
        self.assertEqual(len(empty), 0)


class TestUnique(unittest.TestCase):
    """2.4 doesn't allow class decorators, use function syntax."""

    def test_unique_clean(self):
        class Clean(Enum):
            one = 1
            two = 'dos'
            tres = 4.0
        unique(Clean)
        class Cleaner(IntEnum):
            single = 1
            double = 2
            triple = 3
        unique(Cleaner)

    def test_unique_dirty(self):
        try:
            class Dirty(Enum):
                __order__ = 'one two tres'
                one = 1
                two = 'dos'
                tres = 1
            unique(Dirty)
        except ValueError:
            exc = sys.exc_info()[1]
            message = exc.args[0]
        self.assertTrue('tres -> one' in message)

        try:
            class Dirtier(IntEnum):
                __order__ = 'single double triple turkey'
                single = 1
                double = 1
                triple = 3
                turkey = 3
            unique(Dirtier)
        except ValueError:
            exc = sys.exc_info()[1]
            message = exc.args[0]
        self.assertTrue('double -> single' in message)
        self.assertTrue('turkey -> triple' in message)


class TestMe(unittest.TestCase):

    pass

if __name__ == '__main__':
    unittest.main()

filename:/usr/lib/python2.7/dist-packages/enum/test_enum.pyc
__doc__
Û
ö…yVc           @   sí  d  d l  Z  d  d l Z d  d l Z d  d l  m Z m Z m Z m Z d  d l m Z m	 Z	 m
 Z
 m Z e d e j d  É Z y e Wn e k
 r£ d Ñ  Z n Xy e Wn e k
 r≈ e Z n Xy d  d l m Z Wn e k
 rÛ e Z n Xy d e f d	 Ñ  É  YZ Wn! e k
 r1e j É  d
 Z n Xy d e e f d Ñ  É  YZ Wn! e k
 rre j É  d
 Z n Xy d e e f d Ñ  É  YZ Wn! e k
 r≥e j É  d
 Z n Xy3 d e e f d Ñ  É  YZ d e f d Ñ  É  YZ Wn! e k
 r
e j É  d
 Z n Xy e d d d e ÉZ  Wn! e k
 rGe j É  d
 Z  n Xy e d d É Z! Wn! e k
 r~e j É  d
 Z! n Xy e d d d d ÉZ" Wn! e k
 rªe j É  d
 Z" n Xy d e f d Ñ  É  YZ# Wn e k
 rÈn Xe d e f d Ñ Z$ d e f d  Ñ Z% d! e j& f d" Ñ  É  YZ' d# e j& f d$ Ñ  É  YZ( d% e j& f d& Ñ  É  YZ) d' e j& f d( Ñ  É  YZ* e d) k rée j+ É  n  d S(*   iˇˇˇˇN(   t   Enumt   IntEnumt   uniquet   EnumMeta(   t   dumpst   loadst   PicklingErrort   HIGHEST_PROTOCOLs   %s.%si   c         C   s   x |  D] } | r t  Sq Wt S(   N(   t   Truet   False(   t   iterablet   element(    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   any   s    (   t   OrderedDictt   Stoogesc           B   s   e  Z d  Z d Z d Z RS(   i   i   i   (   t   __name__t
   __module__t   LARRYt   CURLYt   MOE(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR      s   i   t
   IntStoogesc           B   s   e  Z d  Z d Z d Z RS(   i   i   i   (   R   R   R   R   R   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR   &   s   t   FloatStoogesc           B   s   e  Z d  Z d Z d Z RS(   g=
◊£p=ˆ?g√ı(\è¬@g∆R$_	$	@(   R   R   R   R   R   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR   .   s   t   StrEnumc           B   s   e  Z d  Z RS(   s   accepts only string values(   R   R   t   __doc__(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR   7   s   t   Namec           B   s   e  Z d  Z d Z RS(   s   Guido van Rossums   Barry Warsaw(   R   R   t   BDFLt   FLUFL(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR   9   s   t   Questions   who what when where whyt   modulet   Answers   him this then there becauset   Theorys   rule law suppositiont   qualnamet   spanish_inquisitiont   Fruitc           B   s   e  Z d  Z d Z d Z RS(   i   i   i   (   R   R   t   tomatot   bananat   cherry(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR!   P   s   i    c   	      C   sÎ   | \ } } g  } x∞ t  | | d É D]õ } yT | d  k r` |  t t | d | ÉÉ | k É n |  t t | d | ÉÉ | É Wq& t k
 r¿ t j É  d \ } } | j d | | f É q& Xq& W| rÁ t d d j	 | É É Ç n  d  S(   Ni   t   protocols   %2d: %ss   Failed with protocols: %ss   , (
   t   ranget   NoneR   R   t	   Exceptiont   syst   exc_infot   appendt
   ValueErrort   join(	   t	   assertiont   sourcet   targetR%   t   startt   stopt   failurest   exct   tb(    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_pickle_dump_loadW   s    %#c         C   s¥   | \ } } g  } xy t  | | d É D]d } y |  | t | d | ÉWq& t k
 râ t j É  d } | j d | | j j | f É q& Xq& W| r∞ t d d j	 | É É Ç n  d  S(   Ni   R%   s	   %d: %s %ss   Failed with protocols: %ss   , (
   R&   R   R(   R)   R*   R+   t	   __class__R   R,   R-   (   R.   t	   exceptiont   objR%   R1   R2   R3   R4   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_pickle_exceptiong   s    (t   TestHelpersc           B   s#   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   sm   d d d Ñ  É  Y} xS d D]K } | É  } |  j  t j | É É t | | d É |  j t j | É É q Wd  S(	   Nt   fooc           B   s   e  Z RS(    (   R   R   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR<   y   s   t   __get__t   __set__t
   __delete__i   (    (   s   __get__s   __set__s
   __delete__(   t   assertFalset   enumt   _is_descriptort   setattrt
   assertTrue(   t   selfR<   t   attrR9   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_is_descriptorx   s    	c         C   sR   x$ d D] } |  j  t j | É É q Wx$ d D] } |  j t j | É É q. Wd  S(   Nt   _a_t   _aa_t   at   a_t   _at   __at   a__t   __a__t   _a__t   __a_t   _t   __t   ___t   ____t   _____(   RH   RI   (   RJ   RK   RL   RM   RN   RO   RP   RQ   RR   s   __RT   RU   RV   (   RD   RA   t
   _is_sunderR@   (   RE   t   s(    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_is_sunderÅ   s
    
c         C   sR   x$ d D] } |  j  t j | É É q Wx$ d D] } |  j t j | É É q. Wd  S(   NRO   t   __aa__RJ   RK   RL   RM   RN   RH   RP   RQ   RR   RS   RT   RU   RV   (   s   __a__RZ   (   RJ   s   a_s   _as   __as   a__s   _a_s   _a__s   __a_RR   s   __s   ___s   ____s   _____(   RD   RA   t
   _is_dunderR@   (   RE   RX   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_is_dunderâ   s
    
(   R   R   RG   RY   R\   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR;   u   s   			t   TestEnumc           B   s0  e  Z d  Ñ  Z e d k rB d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z n  e d k rc d Ñ  Z d Ñ  Z	 n  e d k rÑ d	 Ñ  Z
 d
 Ñ  Z n  d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e d k rd Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z n  d Ñ  Z d Ñ  Z e d k rge É  Z i e d 6Z  d e  Ue  d e d <n  d  Ñ  Z! d! Ñ  Z" d" Ñ  Z# d# Ñ  Z$ d$ Ñ  Z% d% Ñ  Z& d& Ñ  Z' d' Ñ  Z( d( Ñ  Z) d) Ñ  Z* d* Ñ  Z+ d+ Ñ  Z, d, Ñ  Z- d- Ñ  Z. e d. k r˝d/ Ñ  Z/ n e d0 k rd1 Ñ  Z/ n  d2 Ñ  Z0 d3 Ñ  Z1 d4 Ñ  Z2 d5 Ñ  Z3 d6 Ñ  Z4 d7 Ñ  Z5 d8 Ñ  Z6 d9 Ñ  Z7 d: Ñ  Z8 d; Ñ  Z9 d< Ñ  Z: d= Ñ  Z; d> Ñ  Z< d? Ñ  Z= d@ Ñ  Z> dA Ñ  Z? dB Ñ  Z@ dC Ñ  ZA dD Ñ  ZB dE Ñ  ZC dF Ñ  ZD dG Ñ  ZE dH Ñ  ZF dI Ñ  ZG dJ Ñ  ZH dK Ñ  ZI dL Ñ  ZJ dM Ñ  ZK dN Ñ  ZL dO Ñ  ZM dP Ñ  ZN dQ Ñ  ZO dR Ñ  ZP dS Ñ  ZQ dT Ñ  ZR dU Ñ  ZS dV Ñ  ZT dW Ñ  ZU dX Ñ  ZV dY Ñ  ZW e d. k rïdZ Ñ  ZX n  d[ Ñ  ZY d\ Ñ  ZZ d] Ñ  Z[ d^ Ñ  Z\ d_ Ñ  Z] d` Ñ  Z^ da Ñ  Z_ db Ñ  Z` dc Ñ  Za dd Ñ  Zb de Ñ  Zc df Ñ  Zd dg Ñ  Ze dh Ñ  Zf di Ñ  Zg dj Ñ  Zh dk Ñ  Zi RS(l   c         C   s∏   d t  f d Ñ  É  Y} | |  _ d t t  f d Ñ  É  Y} | |  _ d t f d Ñ  É  Y} | |  _ d t t  f d Ñ  É  Y} | |  _ d	 d
 l m	 } d | t  f d Ñ  É  Y} | |  _
 d  S(   Nt   Seasonc           B   s    e  Z d  Z d Z d Z d Z RS(   i   i   i   i   (   R   R   t   SPRINGt   SUMMERt   AUTUMNt   WINTER(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR^   ì   s   t	   Konstantsc           B   s   e  Z d  Z d Z d e Z RS(   gBá
ø@gJÿM˚!	@i   (   R   R   t   Et   PIt   TAU(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRc   ö   s   t   Gradesc           B   s&   e  Z d  Z d Z d Z d Z d Z RS(   i   i   i   i   i    (   R   R   t   At   Bt   Ct   Dt   F(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRg   †   s
   t   Directionalc           B   s    e  Z d  Z d Z d Z d Z RS(   t   eastt   westt   northt   south(   R   R   t   EASTt   WESTt   NORTHt   SOUTH(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRm   ®   s   iˇˇˇˇ(   t   datet   Holidayc           B   s   e  Z d Z d Z RS(   i›  i   i   i   (   i›  i   i   (   i›  i   i   (   R   R   t   NEW_YEARt   IDES_OF_MARCH(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRw   ∞   s   (   R    R^   t   floatRc   R   Rg   t   strRm   t   datetimeRv   Rw   (   RE   R^   Rc   Rg   Rm   Rv   Rw   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   setUpí   s    				g      @c         C   sG   |  j  } |  j t t | É É t d d d d d d d d g É É d  S(	   NR7   R   t   __members__R   R_   R`   Ra   Rb   (   R^   t   assertEqualt   sett   dir(   RE   R^   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_dir_on_class∂   s
    	c         C   sA   |  j  } |  j t t | j É É t d d d d d g É É d  S(   NR7   R   R   t   namet   value(   R^   R   RÄ   RÅ   Rb   (   RE   R^   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_dir_on_itemæ   s    	c      	   C   sÖ   d t  f d Ñ  É  Y} |  j t t | É É t d d d d d d g É É |  j t t | j É É t d d d d	 d
 d g É É d  S(   Nt   Testc           B   s   e  Z d  Z d Z d Ñ  Z RS(   t   thatt   thosec         S   s   d |  j  S(   Ns   Wowser! I'm %s!(   RÉ   (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   wowser…   s    (   R   R   t   thist   theseRâ   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRÜ   ∆   s   R7   R   R~   R   Rä   Rã   RÉ   RÑ   Râ   (   R    R   RÄ   RÅ   Rä   (   RE   RÜ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_dir_with_added_behavior≈   s    c      	   C   sg   d t  f d Ñ  É  Y} d | f d Ñ  É  Y} |  j t t | j É É t d d d d d	 d
 g É É d  S(   Nt	   SuperEnumc           B   s   e  Z d  Ñ  Z RS(   c         S   s   d S(   Ns   did you see me?(    (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt	   invisible◊   s    (   R   R   Ré   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRç   ÷   s   t   SubEnumc           B   s   e  Z d  Z RS(   i   (   R   R   t   sample(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRè   Ÿ   s   R7   R   R   RÉ   RÑ   Ré   (   R    R   RÄ   RÅ   Rê   (   RE   Rç   Rè   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt&   test_dir_on_sub_with_behavior_on_super‘   s
    göôôôôô@c         C   s6   d t  f d Ñ  É  Y} |  j t | j É t k É d  S(   Nt   Orderedc           B   s    e  Z d  Z d Z d Z d Z RS(   s   first second thirdt   bippityt   boppityt   boo(   R   R   t	   __order__t   firstt   secondt   third(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRí   ‚   s   (   R    RD   t   typeR~   R   (   RE   Rí   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt&   test_members_is_ordereddict_if_ordered·   s    c         C   s6   d t  f d Ñ  É  Y} |  j t | j É t k É d  S(   Nt	   Unorderedc           B   s   e  Z d  Z d Z RS(   Rá   Rà   (   R   R   Rä   Rã   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRú   Í   s   (   R    RD   Rö   R~   R   (   RE   Rú   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt*   test_members_is_ordereddict_if_not_orderedÈ   s    c         C   s6   d t  f d Ñ  É  Y} |  j t | j É t k É d  S(   Nt   AlwaysOrderedc           B   s   e  Z d  Z d Z d Z RS(   i   i   i   (   R   R   Ró   Rò   Rô   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRû   Ò   s   (   R    RD   Rö   R~   R   (   RE   Rû   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_members_is_always_ordered   s    c            sç   á f d Ü  } |  j  â |  j à j d É |  j t | É d t f d Ñ  É  Yâ  |  j à j à  j É á  á f d Ü  } |  j t | É d  S(   Nc              s   à  j  d k d  S(   Ni   (   R_   (    (   R^   (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   bad_compare¯   s    i   t   Partc           B   s   e  Z d  Z d Z d Z RS(   i   i   i   (   R   R   R_   t   CLIPt   BARREL(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR°   ˛   s   c              s   à j  à  j k  d  S(   N(   R_   R¢   (    (   R°   R^   (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR†     s    (   R^   t   assertNotEqualR_   t   assertRaisest	   TypeErrorR    (   RE   R†   (    (   R°   R^   s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_comparisons˜   s    	c         C   s,   |  j  } |  j | | j É | j k É d  S(   N(   R^   RD   Rb   (   RE   R^   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_enum_in_enum_out  s    	c         C   s#   |  j  } |  j | j j d É d  S(   Ni   (   R^   R   R_   RÑ   (   RE   R^   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_enum_value  s    	c         C   s   |  j  t j j d É d  S(   Ni   (   R   R   R   RÑ   (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_intenum_value  s    c         C   sz  |  j  } t | É } |  j t | É t | É É |  j t | É d | É |  j | j | j | j | j g | É xt d j	 É  É D]Ì \ } } | d 7} | | É } |  j | t
 | | É É |  j | j | É |  j | | É |  j | j | É |  j | | k É |  j t | É | k É |  j t | | É É |  j t | É d | É |  j t | É d | | f É qÖ Wd  S(   Ni   s   SPRING SUMMER AUTUMN WINTERi   s   Season.s   <Season.%s: %s>(   R^   t   listR   t   lenR_   R`   Ra   Rb   t	   enumeratet   splitt   getattrRÑ   R§   RÉ   RD   Rö   t
   isinstanceR{   t   repr(   RE   R^   t   lstt   it   seasont   e(    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt	   test_enum  s(    	"
	c         C   s}   |  j  } |  j | j j d É |  j | j j d É d Ñ  } d Ñ  } |  j t | | j d É |  j t | | j d É d  S(   NR_   i   c         S   s   | |  _  d  S(   N(   RÉ   (   R9   t	   new_value(    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   set_name/  s    c         S   s   | |  _  d  S(   N(   RÑ   (   R9   R∑   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt	   set_value1  s    t   inviernoi   (   R^   R   R_   RÉ   RÑ   R•   t   AttributeError(   RE   R^   R∏   Rπ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_value_name+  s    			c         C   së   d t  f d Ñ  É  Y} |  j t | d É É | ` |  j t | d É É |  j t t | d É |  j t t | d É |  j t t | j d É d  S(   NR^   c           B   s)   e  Z d  Z d Z d Z d Z d Ñ  Z RS(   i   i   i   i   c         S   s   d  S(   N(    (   t   cls(    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   spam=  s    (   R   R   R_   R`   Ra   Rb   Ræ   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR^   7  s
   Ræ   R_   t   DRYRÉ   (	   R    RD   t   hasattrRæ   R@   R•   Rª   t   delattrR_   (   RE   R^   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_attribute_deletion6  s    	c         C   s6   d Ñ  } d Ñ  } |  j  t | É |  j  t | É d  S(   Nc          S   s   d t  f d Ñ  É  Y}  d  S(   Nt   Wrongc           B   s   e  Z d  Z RS(   i	   (   R   R   t   mro(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR√   J  s   (   R    (   R√   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   create_bad_class_1I  s    c          S   s   d t  f d Ñ  É  Y}  d  S(   NR√   c           B   s   e  Z d  Z RS(   i   (   R   R   t
   _reserved_(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR√   M  s   (   R    (   R√   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   create_bad_class_2L  s    (   R•   R,   (   RE   R≈   R«   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_invalid_namesH  s    		c         C   sÅ   |  j  } |  j | j | k É |  j d | k É | d É } |  j | | k É d t f d Ñ  É  Y} |  j | j | k É d  S(   Ni   t	   OtherEnumc           B   s   e  Z d  Z d Z RS(   i   i   (   R   R   t   onet   two(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR…   b  s    (   R^   RD   Ra   R    RÀ   (   RE   R^   t   valR…   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_containsZ  s    	gÕÃÃÃÃÃ@c         C   s!  |  j  } |  j d j | j É d j t | j É É É |  j d j | j É d j t | j É É É |  j d j | j É d j t | j É É É |  j d j | j É d j t | j É É É |  j d j | j É d j t | j É É É |  j d j | j É d j t | j É É É d  S(   Ns   {0}s   {0:}s   {0:20}s   {0:^20}s   {0:>20}s   {0:<20}(   R^   R   t   formatR_   R{   (   RE   R^   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_format_enumh  s    	c         C   s9   d t  t f d Ñ  É  Y} |  j d j | j É d É d  S(   Nt	   TestFloatc           B   s   e  Z d  Z d Z d Ñ  Z RS(   g      ?g       @c         S   s   d S(   Ns   TestFloat success!(    (   RE   t   spec(    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt
   __format__{  s    (   R   R   R    RÀ   R“   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR–   x  s   s   {0}s   TestFloat success!(   Rz   R    R   RŒ   R    (   RE   R–   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_format_enum_customw  s    c         C   s)   |  j  | j | É | j | j É É d  S(   N(   R   RŒ   RÑ   (   RE   R—   t   member(    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   assertFormatIsValue  s    c         C   s•   |  j  } |  j d | j É |  j d | j É |  j d | j É |  j d | j É |  j d | j É |  j d | j É |  j d | j É |  j d | j É d  S(	   Ns   {0}s   {0:}s   {0:20}s   {0:^20}s   {0:>20}s   {0:<20}s	   {0:%Y %m}s   {0:%Y %m %M:00}(   Rw   R’   Ry   (   RE   Rw   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_format_enum_dateÇ  s    	c         C   s∏   |  j  } |  j d | j É |  j d | j É |  j d | j É |  j d | j É |  j d | j É |  j d | j É |  j d | j É |  j d | j É |  j d	 | j É d  S(
   Ns   {0}s   {0:}s   {0:20}s   {0:^20}s   {0:>20}s   {0:<20}s   {0:n}s   {0:5.2}s   {0:f}(   Rc   R’   Rf   (   RE   Rc   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_format_enum_floatç  s    	c         C   s∏   |  j  } |  j d | j É |  j d | j É |  j d | j É |  j d | j É |  j d | j É |  j d | j É |  j d | j É |  j d | j É |  j d	 | j É d  S(
   Ns   {0}s   {0:}s   {0:20}s   {0:^20}s   {0:>20}s   {0:<20}s   {0:+}s   {0:08X}s   {0:b}(   Rg   R’   Rj   (   RE   Rg   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_format_enum_intô  s    	c         C   s   |  j  } |  j d | j É |  j d | j É |  j d | j É |  j d | j É |  j d | j É |  j d | j É d  S(   Ns   {0}s   {0:}s   {0:20}s   {0:^20}s   {0:>20}s   {0:<20}(   Rm   R’   Rs   (   RE   Rm   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_format_enum_str•  s    	c         C   s^   |  j  } i  } d | | j <d | | j <d | | j <d | | j <|  j | | j d É d  S(   Nt   1225t   0315t   0704t   1031(   R^   Rb   R_   R`   Ra   R   (   RE   R^   t   dates(    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt	   test_hashÆ  s    	c         C   s:  d } d t  f d Ñ  É  Y} t | É } |  j | | j | j | j | j g É |  j | j | j k É |  j | j j	 d É |  j | j j	 d É |  j | d É | j k É |  j | d É | j k É |  j | j j
 d É |  j t g  | j j É  D]! \ } } | j
 | k r¸ | ^ q¸ É t d d g É É d  S(	   Ns   SPRING SUMMER AUTUMN WINTERR^   c           B   s*   e  Z d  Z d Z d Z Z d Z d  Z RS(   i   i   i   i   (   R   R   R_   R`   Ra   t   FALLRb   t   ANOTHER_SPRING(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR^   π  s
   
i   i   Ra   R‡   R·   (   R    R´   R   R_   R`   Ra   Rb   RD   R‡   RÑ   RÉ   RÄ   R~   t   items(   RE   Rñ   R^   R≤   t   kt   v(    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_enum_duplicates∑  s     :R    sÈ  def test_duplicate_name(self):
            with self.assertRaises(TypeError):
                class Color(Enum):
                    red = 1
                    green = 2
                    blue = 3
                    red = 4

            with self.assertRaises(TypeError):
                class Color(Enum):
                    red = 1
                    green = 2
                    blue = 3
                    def red(self):
                        return 'red'

            with self.assertRaises(TypeError):
                class Color(Enum):
                    @property

                    def red(self):
                        return 'redder'
                    red = 1
                    green = 2
                    blue = 3t   test_duplicate_namec         C   sÑ   d t  f d Ñ  É  Y} |  j t | É | j | j g É |  j t | j É | k É |  j | j j d É |  j | j j d É d  S(   Nt   Huhc           B   s   e  Z d  Z d Z RS(   i   i   (   R   R   RÉ   RÑ   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRÁ     s   RÉ   i   (   R    R   R´   RÉ   RÑ   RD   Rö   (   RE   RÁ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_enum_with_value_nameÔ  s    	c         C   s6   d t  t f d Ñ  É  Y} |  j | j | j k  É d  S(   Nt   phyc           B   s   e  Z d  Z d e Z RS(   i   i   (   R   R   t   pit   tau(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRÈ   ¸  s   (   t   intR    RD   RÍ   RÎ   (   RE   RÈ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_intenum_from_scratch˚  s    c         C   sL   d t  t f d Ñ  É  Y} d | f d Ñ  É  Y} |  j | j | j k  É d  S(   NR   c           B   s   e  Z RS(    (   R   R   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR     s   RÈ   c           B   s   e  Z d  Z d e Z RS(   i   i   (   R   R   RÍ   RÎ   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRÈ     s   (   RÏ   R    RD   RÍ   RÎ   (   RE   R   RÈ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_intenum_inherited  s    c         C   s6   d t  t f d Ñ  É  Y} |  j | j | j k  É d  S(   NRÈ   c           B   s   e  Z d  Z d e Z RS(   gJÿM˚!	@i   (   R   R   RÍ   RÎ   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRÈ   
  s   (   Rz   R    RD   RÍ   RÎ   (   RE   RÈ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_floatenum_from_scratch	  s    c         C   sL   d t  t f d Ñ  É  Y} d | f d Ñ  É  Y} |  j | j | j k  É d  S(   Nt	   FloatEnumc           B   s   e  Z RS(    (   R   R   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR     s   RÈ   c           B   s   e  Z d  Z d e Z RS(   gJÿM˚!	@i   (   R   R   RÍ   RÎ   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRÈ     s   (   Rz   R    RD   RÍ   RÎ   (   RE   R   RÈ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_floatenum_inherited  s    c         C   s6   d t  t f d Ñ  É  Y} |  j | j | j k  É d  S(   NRÈ   c           B   s   e  Z d  Z d Z RS(   t   Pit   Tau(   R   R   RÍ   RÎ   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRÈ     s   (   R{   R    RD   RÍ   RÎ   (   RE   RÈ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_strenum_from_scratch  s    c         C   sL   d t  t f d Ñ  É  Y} d | f d Ñ  É  Y} |  j | j | j k  É d  S(   NR   c           B   s   e  Z RS(    (   R   R   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR     s   RÈ   c           B   s   e  Z d  Z d Z RS(   RÚ   RÛ   (   R   R   RÍ   RÎ   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRÈ      s   (   R{   R    RD   RÍ   RÎ   (   RE   R   RÈ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_strenum_inherited  s    c         C   s√  d t  f d Ñ  É  Y} |  j d d d g | j d É |  j g  t | j É D] } | ^ qL d d d g É t | É } |  j t | É t | É É |  j t | É d	 É d
 } | j É  } xt | É D]Û \ } } | d 7} | | É } |  j | | É |  j t	 | É | É |  j | j
 | É |  j | | k É |  j | j | É d | É |  j d | k  opd k  n É |  j t | É | k É |  j t | t	 É É |  j t | t É É q» Wd  S(   Nt   WeekDayc           B   s2   e  Z d  Z d Z d Z d Z d Z d Z d Z RS(   i   i   i   i   i   i   i   (	   R   R   t   SUNDAYt   MONDAYt   TUESDAYt	   WEDNESDAYt   THURSDAYt   FRIDAYt   SATURDAY(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRˆ   &  s   RJ   t   bt   ci    i   i   i   s8   SUNDAY MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY SATURDAYi   (   R   R   R¯   R&   R˘   R´   R¨   RÆ   R≠   RÏ   RÉ   RD   t   indexRö   R∞   R    (   RE   Rˆ   R≥   R≤   R0   t   weekdayRµ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_intenum%  s(    	 5
#c         C   sê   d t  f d Ñ  É  Y} |  j | j | j k É |  j | d É j d É |  j g  | j j É  D]! \ } } | j | k r^ | ^ q^ d g É d  S(   NRˆ   c           B   s<   e  Z d  Z d Z d Z d Z Z d Z d Z d Z	 d Z
 RS(   s8   SUNDAY MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY SATURDAYi   i   i   i   i   i   i   (   R   R   Rñ   R˜   R¯   R˘   t   TEUSDAYR˙   R˚   R¸   R˝   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRˆ   E  s   
i   R˘   R  (   R   RD   R  R˘   R   RÉ   R~   R‚   (   RE   Rˆ   R„   R‰   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_intenum_duplicatesD  s
    	"c         C   s?   t  t t É r t Ç n  t |  j t j É t |  j t É d  S(   N(   R∞   R   R(   R6   RD   R   (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_pickle_enumS  s    	c         C   s?   t  t t É r t Ç n  t |  j t j É t |  j t É d  S(   N(   R∞   R   R(   R6   RD   R   (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_pickle_intY  s    	c         C   s?   t  t t É r t Ç n  t |  j t j É t |  j t É d  S(   N(   R∞   R   R(   R6   RD   R   (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_pickle_float_  s    	c         C   s?   t  t t É r t Ç n  t |  j t j É t |  j t É d  S(   N(   R∞   R   R(   R6   RD   t   him(   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_pickle_enum_functione  s    	c         C   s?   t  t t É r t Ç n  t |  j t j É t |  j t É d  S(   N(   R∞   R   R(   R6   RD   t   who(   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt%   test_pickle_enum_function_with_modulek  s    	g333333@c         C   s}   d t  f d Ñ  É  Y} | |  j _ d |  j j |  j _ t |  j t |  j j d d Ét	 |  j
 |  j j d d t f Éd  S(	   Nt
   NestedEnumc           B   s   e  Z d  Z d Z RS(   t   commont   rare(   R   R   t   twigst   shiny(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR  t  s   s   %s.NestedEnumR%   i    i   i   (   i    i   (   R    R7   R  R   t   __qualname__R:   R•   R   R  R6   RD   R   (   RE   R  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt/   test_class_nested_enum_and_pickle_protocol_fourr  s    g      @c         C   s^   d t  f d Ñ  É  Y} | |  j _ d |  j j |  j _ t |  j |  j j d d t f Éd  S(   NR  c           B   s   e  Z d  Z d Z RS(   R  R  (   R   R   R  R  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR  É  s   s   %s.NestedEnumR%   i    (	   R    R7   R  R   R  R6   RD   R  R   (   RE   R  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR  Å  s
    c         C   sV   t  d d É } t j | É | t É  d <t |  j t | j É t |  j t | É d  S(   Nt	   BadPickles   dill sweet bread-n-butter(	   R    RA   t   _make_class_unpicklablet   globalsR:   R•   R¶   t   dillR   (   RE   R  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_exploding_pickleå  s
    c         C   s0   d t  t f d Ñ  É  Y} |  j | j d É d  S(   Nt
   SkillLevelc           B   s   e  Z d  Z d Z d Z RS(   s'   what is the sound of one hand clapping?s#   why did the chicken cross the road?s   knock, knock!(   R   R   t   mastert
   journeymant
   apprentice(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR  î  s   s   knock, knock!(   R{   R    R   R  (   RE   R  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_string_enumì  s    c         C   so   d t  f d Ñ  É  Y} |  j | d É | j k É |  j t | d É | j k É |  j | d | j k É d  S(   Nt   Periodc           B   s    e  Z d  Z d Z d Z d Z RS(   i   i   i   i   (   R   R   t   morningt   noont   eveningt   night(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR  õ  s   i   R!  R  (   R    RD   R  RØ   R!  R  (   RE   R  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_getattr_getitemö  s    c         C   s#   |  j  } |  j t | d É É d  S(   Nt   __hash__(   R^   RD   RØ   (   RE   R^   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_getattr_dunder§  s    	c         C   sH   d t  f d Ñ  É  Y} |  j t | É | j | j | j | j g É d  S(   NR^   c           B   s&   e  Z d  Z d Z d Z d Z d Z RS(   s   SUMMER WINTER AUTUMN SPRINGi   i   i   i   (   R   R   Rñ   R`   Rb   Ra   R_   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR^   ©  s
   (   R    R   R´   R`   Rb   Ra   R_   (   RE   R^   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_iteration_order®  s    	c         C   sG   |  j  t t |  j É É |  j j |  j j |  j j |  j j g É d  S(   N(   R   R´   t   reversedR^   Rb   Ra   R`   R_   (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_iteration_order_reversed¥  s    c         C   sH   d t  f d Ñ  É  Y} |  j t | É | j | j | j | j g É d  S(   Nt   Complexc           B   sD   e  Z e d  d É Z e d d É Z e d d É Z e d d É Z RS(   i   i	   gÖÎQ∏	@i   i   iˇˇˇˇi≥ˇˇˇi    (   R   R   t   complexRJ   R˛   Rˇ   t   d(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR(  º  s   (   R    R   R´   RJ   R˛   Rˇ   R*  (   RE   R(  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt,   test_iteration_order_with_unorderable_valuesª  s    	c         C   s  t  d d É } t | É } |  j t | É t | É É |  j t | É d | É |  j | j | j | j g | É xû t d j É  É D]ä \ } } | d 7} | | É } |  j t	 | j
 É | É |  j | | É |  j | j | É |  j | | k É |  j t | É | k É qÖ Wd  S(   Nt   SummerMonths   june july augusti   i   (   R    R´   R   R¨   t   junet   julyt   augustR≠   RÆ   RÏ   RÑ   R§   RÉ   RD   Rö   (   RE   R,  R≤   R≥   t   monthRµ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt    test_programatic_function_string∆  s    
c         C   s  t  d d d d É} t | É } |  j t | É t | É É |  j t | É d | É |  j | j | j | j g | É xó t d j É  d É D]Ä \ } } | | É } |  j t	 | j
 É | É |  j | | É |  j | j | É |  j | | k É |  j t | É | k É qé Wd  S(   NR,  s   june july augustR1   i
   i   (   R    R´   R   R¨   R-  R.  R/  R≠   RÆ   RÏ   RÑ   R§   RÉ   RD   Rö   (   RE   R,  R≤   R≥   R0  Rµ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt+   test_programatic_function_string_with_startÿ  s    "c         C   s   t  d d d d g É } t | É } |  j t | É t | É É |  j t | É d | É |  j | j | j | j g | É xû t d j É  É D]ä \ } } | d 7} | | É } |  j t	 | j
 É | É |  j | | É |  j | j | É |  j | | k É |  j t | É | k É qé Wd  S(   NR,  R-  R.  R/  i   s   june july augusti   (   R    R´   R   R¨   R-  R.  R/  R≠   RÆ   RÏ   RÑ   R§   RÉ   RD   Rö   (   RE   R,  R≤   R≥   R0  Rµ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt%   test_programatic_function_string_listÈ  s    
c         C   s  t  d d d d g d d É} t | É } |  j t | É t | É É |  j t | É d | É |  j | j | j | j g | É xó t d j É  d É D]Ä \ } } | | É } |  j t	 | j
 É | É |  j | | É |  j | j | É |  j | | k É |  j t | É | k É qó Wd  S(	   NR,  R-  R.  R/  R1   i   i   s   june july august(   R    R´   R   R¨   R-  R.  R/  R≠   RÆ   RÏ   RÑ   R§   RÉ   RD   Rö   (   RE   R,  R≤   R≥   R0  Rµ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt0   test_programatic_function_string_list_with_start˚  s    "c         C   s   t  d d	 d
 d f É } t | É } |  j t | É t | É É |  j t | É d | É |  j | j | j | j g | É xû t d j É  É D]ä \ } } | d 7} | | É } |  j t	 | j
 É | É |  j | | É |  j | j | É |  j | | k É |  j t | É | k É qé Wd  S(   NR,  R-  i   R.  i   R/  i   s   june july august(   s   junei   (   s   julyi   (   s   augusti   (   R    R´   R   R¨   R-  R.  R/  R≠   RÆ   RÏ   RÑ   R§   RÉ   RD   Rö   (   RE   R,  R≤   R≥   R0  Rµ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt"   test_programatic_function_iterable  s"    
c         C   s5  t  d t d
 d d f É É } t | É } |  j t | É t | É É |  j t | É d | É t d k  rê |  j | j | j | j g | É n  xû t	 d	 j
 É  É D]ä \ } } | d 7} | | É } |  j t | j É | É |  j | | É |  j | j | É |  j | | k É |  j t | É | k É q£ Wd  S(   NR,  R-  i   R.  i   R/  i   g      @s   june july august(   s   junei   (   s   julyi   (   s   augusti   (   R    t   dictR´   R   R¨   t   pyverR-  R.  R/  R≠   RÆ   RÏ   RÑ   R§   RÉ   RD   Rö   (   RE   R,  R≤   R≥   R0  Rµ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt#   test_programatic_function_from_dict!  s$    

c         C   s  t  d d d t É} t | É } |  j t | É t | É É |  j t | É d | É |  j | j | j | j g | É xÖ t d j	 É  É D]q \ } } | d 7} | | É } |  j | | É |  j | j
 | É |  j | | k É |  j t | É | k É qã Wd  S(   NR,  s   june july augustRö   i   i   (   R    RÏ   R´   R   R¨   R-  R.  R/  R≠   RÆ   RÉ   RD   Rö   (   RE   R,  R≤   R≥   R0  Rµ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_programatic_function_type7  s    
c         C   s  t  d d d t d d É} t | É } |  j t | É t | É É |  j t | É d | É |  j | j | j | j g | É x~ t d j	 É  d É D]g \ } } | | É } |  j | | É |  j | j
 | É |  j | | k É |  j t | É | k É qî Wd  S(   NR,  s   june july augustRö   R1   i   i   (   R    RÏ   R´   R   R¨   R-  R.  R/  R≠   RÆ   RÉ   RD   Rö   (   RE   R,  R≤   R≥   R0  Rµ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt)   test_programatic_function_type_with_startH  s    "c         C   s˛   t  d d É } t | É } |  j t | É t | É É |  j t | É d | É |  j | j | j | j g | É xÖ t d j É  É D]q \ } } | d 7} | | É } |  j | | É |  j | j	 | É |  j
 | | k É |  j
 t | É | k É qÖ Wd  S(   NR,  s   june july augusti   i   (   R   R´   R   R¨   R-  R.  R/  R≠   RÆ   RÉ   RD   Rö   (   RE   R,  R≤   R≥   R0  Rµ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt,   test_programatic_function_type_from_subclassX  s    
c         C   s˝   t  d d d d É} t | É } |  j t | É t | É É |  j t | É d | É |  j | j | j | j g | É x~ t d j É  d É D]g \ } } | | É } |  j | | É |  j | j	 | É |  j
 | | k É |  j
 t | É | k É qé Wd  S(   NR,  s   june july augustR1   i(   i   (   R   R´   R   R¨   R-  R.  R/  R≠   RÆ   RÉ   RD   Rö   (   RE   R,  R≤   R≥   R0  Rµ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt7   test_programatic_function_type_from_subclass_with_starti  s    "c         C   s#  t  d t d É É } t | É } |  j t | É t | É É |  j t | É d | É |  j | j | j | j g | É x§ t t d É j	 É  É D]ä \ } } | d 7} | | É } |  j t
 | j É | É |  j | | É |  j | j | É |  j | | k É |  j t | É | k É që Wd  S(   NR,  s   june july augusti   i   (   R    t   unicodeR´   R   R¨   R-  R.  R/  R≠   RÆ   RÏ   RÑ   R§   RÉ   RD   Rö   (   RE   R,  R≤   R≥   R0  Rµ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt!   test_programatic_function_unicodey  s    %
c         C   s8  t  d t d É t d É t d É g É } t | É } |  j t | É t | É É |  j t | É d | É |  j | j | j | j g | É x§ t t d É j	 É  É D]ä \ } } | d 7} | | É } |  j t
 | j É | É |  j | | É |  j | j | É |  j | | k É |  j t | É | k É q¶ Wd  S(   NR,  R-  R.  R/  i   s   june july augusti   (   R    R=  R´   R   R¨   R-  R.  R/  R≠   RÆ   RÏ   RÑ   R§   RÉ   RD   Rö   (   RE   R,  R≤   R≥   R0  Rµ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt&   test_programatic_function_unicode_listã  s    *%
c         C   sJ  t  d t d É d f t d É d f t d É d f f É } t | É } |  j t | É t | É É |  j t | É d | É |  j | j | j | j g | É x§ t t d É j	 É  É D]ä \ } } | d 7} | | É } |  j t
 | j É | É |  j | | É |  j | j | É |  j | | k É |  j t | É | k É q∏ Wd  S(	   NR,  R-  i   R.  i   R/  i   s   june july august(   R    R=  R´   R   R¨   R-  R.  R/  R≠   RÆ   RÏ   RÑ   R§   RÉ   RD   Rö   (   RE   R,  R≤   R≥   R0  Rµ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt*   test_programatic_function_unicode_iterableù  s"    6%
c         C   s_  t  d t t d É d f t d É d f t d É d f f É É } t | É } |  j t | É t | É É |  j t | É d | É t d k  r¥ |  j | j | j | j	 g | É n  x§ t
 t d	 É j É  É D]ä \ } } | d 7} | | É } |  j t | j É | É |  j | | É |  j | j | É |  j | | k É |  j t | É | k É qÕ Wd  S(
   NR,  R-  i   R.  i   R/  i   g      @s   june july august(   R    R6  R=  R´   R   R¨   R7  R-  R.  R/  R≠   RÆ   RÏ   RÑ   R§   RÉ   RD   Rö   (   RE   R,  R≤   R≥   R0  Rµ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt+   test_programatic_function_from_unicode_dict≤  s$    <
%
c         C   s  t  d t d É d t É} t | É } |  j t | É t | É É |  j t | É d | É |  j | j | j | j g | É xã t	 t d É j
 É  É D]q \ } } | d 7} | | É } |  j | | É |  j | j | É |  j | | k É |  j t | É | k É qó Wd  S(   NR,  s   june july augustRö   i   i   (   R    R=  RÏ   R´   R   R¨   R-  R.  R/  R≠   RÆ   RÉ   RD   Rö   (   RE   R,  R≤   R≥   R0  Rµ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt&   test_programatic_function_unicode_type»  s    %
c         C   s
  t  d t d É É } t | É } |  j t | É t | É É |  j t | É d | É |  j | j | j | j g | É xã t t d É j	 É  É D]q \ } } | d 7} | | É } |  j | | É |  j | j
 | É |  j | | k É |  j t | É | k É që Wd  S(   NR,  s   june july augusti   i   (   R   R=  R´   R   R¨   R-  R.  R/  R≠   RÆ   RÉ   RD   Rö   (   RE   R,  R≤   R≥   R0  Rµ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt4   test_programatic_function_unicode_type_from_subclassŸ  s    %
c         C   së  t  d k  r* t d É d j d É f } n d } xZt | É D]L\ } } t  d k  rÄ | d k rÄ |  j t t | t d É É q= t | t d É É } t | É } |  j t	 | É t	 | É É |  j t	 | É d | É |  j | j
 | j | j g | É xé t t d É j É  É D]t \ } } | d 7} | | É } |  j | j | É |  j | j | É |  j | | k É |  j t | É | k É qWq= Wd  S(	   Ng      @R,  s   S¸mmÈrMˆntht   latin1i   s   june july augusti   (   s   SummerMonths   S¸mmÈrMˆnth(   R7  R=  t   decodeR≠   R•   R¶   R    R´   R   R¨   R-  R.  R/  RÆ   RÑ   RÉ   RD   Rö   (   RE   t   class_namesR≥   t
   class_nameR,  R≤   R0  Rµ   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt(   test_programmatic_function_unicode_classÍ  s(    %
c         C   sz   t  t t É r t Ç n  |  j t j d É |  j t j t d É É |  j t j t t d É k É t |  j t j É d  S(   Ns   Guido van RossumR   (   R∞   R   R(   R   R   RD   RØ   R6   (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_subclassing  s    	c         C   s   d Ñ  } |  j  t | É d  S(   Nc          S   s0   d t  f d Ñ  É  Y}  d |  f d Ñ  É  Y} d  S(   Nt   Colorc           B   s   e  Z d  Z d Z d Z RS(   i   i   i   (   R   R   t   redt   greent   blue(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRJ    s   t	   MoreColorc           B   s   e  Z d  Z d Z d Z RS(   i   i   i   (   R   R   t   cyant   magentat   yellow(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRN    s   (   R    (   RJ  RN  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   bad_extension  s    (   R•   R¶   (   RE   RR  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_extending  s    		c         C   sO   d t  f d Ñ  É  Y} |  j t | j É | k É |  j | j j É  d É d  S(   Nt   whateverc           B   s   e  Z d  Z d Z d Ñ  Z RS(   Rá   Rà   c         S   s   d |  j  S(   Ns
   no, not %s(   RÑ   (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   really  s    (   R   R   Rä   Rã   RU  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRT    s   s   no, not that(   R    R@   Rö   RU  R   Rä   (   RE   RT  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_exclude_methods  s    c         C   s   d Ñ  } |  j  t | É d  S(   Nc          S   s   d t  t f d Ñ  É  Y}  d  S(   NR√   c           B   s   e  Z d  Z RS(   s   error before this point(   R   R   t   NotHere(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR√   "  s   (   R    R{   (   R√   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   wrong_inherit!  s    (   R•   R¶   (   RE   RX  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_wrong_inheritance_order   s    	c         C   sr   d t  f d Ñ  É  Y} d t  f d Ñ  É  Y} |  j | j | j É |  j | j | j É |  j | j | j É d  S(   Nt   numberc           B   s   e  Z d  Z d Z d Z RS(   i   i   i   (   R   R   R    RÀ   t   three(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRZ  '  s   t   numeroc           B   s   e  Z d  Z d Z d Z RS(   i   i   i   (   R   R   t   unot   dost   tres(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR\  +  s   (   R   R   R    R]  RÀ   R^  R[  R_  (   RE   RZ  R\  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_intenum_transitivity&  s
    c         C   s÷   d t  f d Ñ  É  Y} |  j | j j t k É |  j | j t k É d t t f d Ñ  É  Y} |  j | j j t k É |  j | j t k É d t f d Ñ  É  Y} |  j | j j t	 k É |  j | j t	 k É d  S(   Nt   Numberc           B   s   e  Z d  Z d Z RS(   id   i»   (   R   R   R    RÀ   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRa  4  s   t   Stringc           B   s   e  Z d  Z d Z d Z RS(   t   softt   rought   hard(   R   R   t   yarnt   ropet   wire(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRb  9  s   t   Plainc           B   s   e  Z d  Z d Z RS(   t   whitei   (   R   R   t   vanillaR    (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRi  ?  s   (
   R   RD   R    t   _member_type_RÏ   R{   R    Rf  Rk  t   object(   RE   Ra  Rb  Ri  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_introspection3  s    c         C   sF   d t  f d Ñ  É  Y} d t  f d Ñ  É  Y} |  j t | | j É d  S(   Nt
   Monochromec           B   s   e  Z d  Z d Z RS(   i    i   (   R   R   t   blackRj  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRo  F  s   t   Genderc           B   s   e  Z d  Z d Z RS(   i    i   (   R   R   t   malet   female(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRq  I  s   (   R    R•   R,   Rr  (   RE   Ro  Rq  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_wrong_enum_in_callE  s    c         C   sF   d t  f d Ñ  É  Y} d t f d Ñ  É  Y} |  j t | | j É d  S(   NRo  c           B   s   e  Z d  Z d Z RS(   i    i   (   R   R   Rp  Rj  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRo  O  s   Rq  c           B   s   e  Z d  Z d Z RS(   i    i   (   R   R   Rr  Rs  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRq  R  s   (   R   R    R•   R,   Rr  (   RE   Ro  Rq  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_wrong_enum_in_mixed_callN  s    c         C   sO   d t  f d Ñ  É  Y} d t  f d Ñ  É  Y} |  j | | j É | j k É d  S(   NRo  c           B   s   e  Z d  Z d Z RS(   i    i   (   R   R   Rp  Rj  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRo  X  s   Rq  c           B   s   e  Z d  Z d Z RS(   i    i   (   R   R   Rr  Rs  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRq  [  s   (   R   RD   Rs  Rj  (   RE   Ro  Rq  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_mixed_enum_in_call_1W  s    c         C   sO   d t  f d Ñ  É  Y} d t f d Ñ  É  Y} |  j | | j É | j k É d  S(   NRo  c           B   s   e  Z d  Z d Z RS(   i    i   (   R   R   Rp  Rj  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRo  a  s   Rq  c           B   s   e  Z d  Z d Z RS(   i    i   (   R   R   Rr  Rs  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRq  d  s   (   R    R   RD   Rr  Rp  (   RE   Ro  Rq  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_mixed_enum_in_call_2`  s    c         C   sI   d t  f d Ñ  É  Y} d | f d Ñ  É  Y} |  j t | j É d É d  S(   Nt   Fluflnumc           B   s   e  Z d  Ñ  Z RS(   c         S   s   t  |  j É S(   N(   RÏ   RÑ   (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   __int__k  s    (   R   R   Ry  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRx  j  s   t   MailManOptionsc           B   s   e  Z d  Z d Z d Z RS(   i   i   i   (   R   R   t   option1t   option2t   option3(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRz  m  s   i   (   R    R   RÏ   R{  (   RE   Rx  Rz  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_flufl_enumi  s    c         C   sC   d t  f d Ñ  É  Y} |  j t | d É |  j t | j d É d  S(   NRJ  c           B   s   e  Z d  Z d Z d Z RS(   i   i   i   (   R   R   RK  RL  RM  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRJ  t  s   i   t
   chartreuse(   R    R•   R,   t   KeyErrort   __getitem__(   RE   RJ  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_no_such_enum_members  s    c         C   s3   d t  f d Ñ  É  Y} |  j t | j É d É d  S(   NRJ  c           B   s#   e  Z d  Z d Z d Z d Ñ  Z RS(   i   i   i   c         S   s   d |  j  S(   Ns!   don't you just love shades of %s?(   RÉ   (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   __repr__Ä  s    (   R   R   RK  RL  RM  RÉ  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRJ  |  s   s#   don't you just love shades of blue?(   R    R   R±   RM  (   RE   RJ  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_new_repr{  s    c         C   sL   d t  f d Ñ  É  Y} d t | f d Ñ  É  Y} |  j t | j É d É d  S(   Nt   MyEnumc           B   s   e  Z d  Ñ  Z RS(   c         S   s   d |  j  S(   Ns   My name is %s.(   RÉ   (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRÉ  â  s    (   R   R   RÉ  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRÖ  à  s   t	   MyIntEnumc           B   s   e  Z d  Z d Z d Z RS(   i   i   i   (   R   R   Rä   Rá   t   theother(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRÜ  ã  s   s   My name is that.(   R    RÏ   R   R±   Rá   (   RE   RÖ  RÜ  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_inherited_reprá  s    c            sv   d t  f á  f d Ü  É  Yâ  à  d t f i  É } à  d t f i  É } d | f d Ñ  É  Y} d | f d Ñ  É  Y} d  S(	   Nt	   auto_enumc              s   e  Z á  f d  Ü  Z RS(   c   
         sˇ   | } t  j É  } x$ | j É  D] \ } } | | | <q Wt | É É  } t | j É } d }	 xJ | j D]? } | | } | d k rå |	 } n | }	 |	 d 7}	 | | | <qg Wx3 | j É  D]% \ } } | | k r∑ | | | <q∑ q∑ Wt à  |  É j |  | | | É S(   Ni    i   (    (   RA   t	   _EnumDictR‚   Rö   RÄ   t   _member_namest   supert   __new__(
   t   metaclsRΩ   t   basest	   classdictt   original_dictR„   R‰   t   tempt   namesR≥   (   Râ  (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRç  ì  s&    
	
(   R   R   Rç  (    (   Râ  (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRâ  í  s   t   AutoNumberedEnumt   AutoIntEnumt   TestAutoNumberc           B   s   e  Z d Z d  Z d Z RS(   i   (    (    (   R   R   RJ   R˛   Rˇ   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRñ  ≠  s   t   TestAutoIntc           B   s   e  Z d Z d  Z d Z RS(   i   (    (    (   R   R   RJ   R˛   Rˇ   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRó  ≤  s   (   R   R    R   (   RE   Rî  Rï  Rñ  Ró  (    (   Râ  s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_multiple_mixin_mroë  s
    c            sÁ   d t  f á  f d Ü  É  Yâ  d à  t f d Ñ  É  Y} |  j | j t j k É |  j t | j | j É d É à  t É  d <| t É  d <à  d d É } |  j | d É t	 |  j | d É |  j | j j
 d É t	 |  j | j É d  S(	   Nt   NamedIntc              sP   e  Z d  Z d Ñ  Z d Ñ  Z e d Ñ  É Z  d Ñ  Z d Ñ  Z á  f d Ü  Z RS(   Rô  c         W   sd   | } t  | É d k  r' t d É Ç n  | d | d } } t j |  | å } | | _ | | _ | S(   Ni   s    name and value must be specifiedi    (   R¨   R¶   RÏ   Rç  t   _intnamet   _args(   RΩ   t   argsRõ  RÉ   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRç  ∫  s    		c         S   s   |  j  S(   N(   Rõ  (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   __getnewargs__√  s    c         S   s   |  j  S(   N(   Rö  (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR   ≈  s    c         S   s&   d t  |  É j |  j t j |  É f S(   Ns
   %s(%r, %s)(   Rö   R   RÏ   RÉ  (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRÉ  »  s    c         S   s5   t  } | j } | j t k r+ | j |  É S| |  É S(   N(   RÏ   t   __str__t   __objclass__Rm  RÉ  (   RE   t   baset   base_str(    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRû  Õ  s
    	c            sY   t  |  É t  | É } t |  à  É rQ t | à  É rQ à  d |  j | j f | É S| Sd  S(   Ns	   (%s + %s)(   RÏ   R∞   R   (   RE   t   otherRí  (   Rô  (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   __add__÷  s    (	   R   R   R  Rç  Rù  t   propertyRÉ  Rû  R£  (    (   Rô  (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRô  ∏  s   						t   NEIc           B   s   e  Z d  Z d Z d Z RS(   R•  s   the-xi   s   the-yi   (   s   the-xi   (   s   the-yi   (   R   R   R  t   xt   y(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR•  ﬂ  s   s   NamedInt('(the-x + the-y)', 3)t   testi   i   (   RÏ   R    RD   Rç  R   R±   R¶  Rß  R  R6   RÑ   (   RE   R•  t   NI5(    (   Rô  s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_subclasses_with_getnewargs∑  s    ' c            s¸   d t  f á  f d Ü  É  Yâ  d à  t f d Ñ  É  Y} |  j | j t j É |  j t | j | j É d É à  t É  d <| t É  d <à  d d É } |  j | d É t	 |  j | d d d	 t
 f É|  j | j j d
 É t	 |  j | j d d	 t
 f Éd  S(   NRô  c              sP   e  Z d  Z d Ñ  Z d Ñ  Z e d Ñ  É Z  d Ñ  Z d Ñ  Z á  f d Ü  Z RS(   Rô  c         W   sd   | } t  | É d k  r' t d É Ç n  | d | d } } t j |  | å } | | _ | | _ | S(   Ni   s    name and value must be specifiedi    i   (   R¨   R¶   RÏ   Rç  Rö  Rõ  (   RΩ   Rú  Rõ  RÉ   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRç  Ú  s    		c         S   s   |  j  i  f S(   N(   Rõ  (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   __getnewargs_ex__˚  s    c         S   s   |  j  S(   N(   Rö  (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR   ˝  s    c         S   s(   d j  t |  É j |  j t j |  É É S(   Ns   {}({!r}, {})(   RŒ   Rö   R   RÏ   RÉ  (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRÉ     s    c         S   s5   t  } | j } | j t k r+ | j |  É S| |  É S(   N(   RÏ   Rû  Rü  Rm  RÉ  (   RE   R†  R°  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRû    s
    	c            s[   t  |  É t  | É } t |  à  É rS t | à  É rS à  d j |  j | j É | É S| Sd  S(   Ns   ({0} + {1})(   RÏ   R∞   RŒ   R   (   RE   R¢  Rí  (   Rô  (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR£    s    (	   R   R   R  Rç  R´  R§  RÉ  Rû  R£  (    (   Rô  (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRô    s   						R•  c           B   s   e  Z d  Z d Z d Z RS(   R•  s   the-xi   s   the-yi   (   s   the-xi   (   s   the-yi   (   R   R   R  R¶  Rß  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR•    s   s   NamedInt('(the-x + the-y)', 3)R®  i   R%   i   i   (   RÏ   R    t   assertIsRç  R   R±   R¶  Rß  R  R6   R   RÑ   RD   (   RE   R•  R©  (    (   Rô  s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt"   test_subclasses_with_getnewargs_exÔ  s    ' c            sÁ   d t  f á  f d Ü  É  Yâ  d à  t f d Ñ  É  Y} |  j | j t j k É |  j t | j | j É d É à  t É  d <| t É  d <à  d d É } |  j | d É t	 |  j | d É |  j | j j
 d É t	 |  j | j É d  S(	   NRô  c              sP   e  Z d  Z d Ñ  Z d Ñ  Z e d Ñ  É Z  d Ñ  Z d Ñ  Z á  f d Ü  Z RS(   Rô  c         W   sd   | } t  | É d k  r' t d É Ç n  | d | d } } t j |  | å } | | _ | | _ | S(   Ni   s    name and value must be specifiedi    (   R¨   R¶   RÏ   Rç  Rö  Rõ  (   RΩ   Rú  Rõ  RÉ   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRç  *  s    		c         S   s   |  j  |  j f S(   N(   R7   Rõ  (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt
   __reduce__3  s    c         S   s   |  j  S(   N(   Rö  (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR   5  s    c         S   s&   d t  |  É j |  j t j |  É f S(   Ns
   %s(%r, %s)(   Rö   R   RÏ   RÉ  (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRÉ  8  s    c         S   s5   t  } | j } | j t k r+ | j |  É S| |  É S(   N(   RÏ   Rû  Rü  Rm  RÉ  (   RE   R†  R°  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRû  =  s
    	c            sY   t  |  É t  | É } t |  à  É rQ t | à  É rQ à  d |  j | j f | É S| Sd  S(   Ns	   (%s + %s)(   RÏ   R∞   R   (   RE   R¢  Rí  (   Rô  (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR£  F  s    (	   R   R   R  Rç  RÆ  R§  RÉ  Rû  R£  (    (   Rô  (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRô  (  s   						R•  c           B   s   e  Z d  Z d Z d Z RS(   R•  s   the-xi   s   the-yi   (   s   the-xi   (   s   the-yi   (   R   R   R  R¶  Rß  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR•  O  s   s   NamedInt('(the-x + the-y)', 3)R®  i   i   (   RÏ   R    RD   Rç  R   R±   R¶  Rß  R  R6   RÑ   (   RE   R•  R©  (    (   Rô  s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_subclasses_with_reduce'  s    ' c            sÁ   d t  f á  f d Ü  É  Yâ  d à  t f d Ñ  É  Y} |  j | j t j k É |  j t | j | j É d É à  t É  d <| t É  d <à  d d É } |  j | d É t	 |  j | d É |  j | j j
 d É t	 |  j | j É d  S(	   NRô  c              sP   e  Z d  Z d Ñ  Z d Ñ  Z e d Ñ  É Z  d Ñ  Z d Ñ  Z á  f d Ü  Z RS(   Rô  c         W   sd   | } t  | É d k  r' t d É Ç n  | d | d } } t j |  | å } | | _ | | _ | S(   Ni   s    name and value must be specifiedi    (   R¨   R¶   RÏ   Rç  Rö  Rõ  (   RΩ   Rú  Rõ  RÉ   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRç  b  s    		c         S   s   |  j  |  j f S(   N(   R7   Rõ  (   RE   t   proto(    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   __reduce_ex__k  s    c         S   s   |  j  S(   N(   Rö  (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR   m  s    c         S   s&   d t  |  É j |  j t j |  É f S(   Ns
   %s(%r, %s)(   Rö   R   RÏ   RÉ  (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRÉ  p  s    c         S   s5   t  } | j } | j t k r+ | j |  É S| |  É S(   N(   RÏ   Rû  Rü  Rm  RÉ  (   RE   R†  R°  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRû  u  s
    	c            sY   t  |  É t  | É } t |  à  É rQ t | à  É rQ à  d |  j | j f | É S| Sd  S(   Ns	   (%s + %s)(   RÏ   R∞   R   (   RE   R¢  Rí  (   Rô  (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR£  ~  s    (	   R   R   R  Rç  R±  R§  RÉ  Rû  R£  (    (   Rô  (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRô  `  s   						R•  c           B   s   e  Z d  Z d Z d Z RS(   R•  s   the-xi   s   the-yi   (   s   the-xi   (   s   the-yi   (   R   R   R  R¶  Rß  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR•  á  s   s   NamedInt('(the-x + the-y)', 3)R®  i   i   (   RÏ   R    RD   Rç  R   R±   R¶  Rß  R  R6   RÑ   (   RE   R•  R©  (    (   Rô  s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_subclasses_with_reduce_ex_  s    ' c            sÍ   d t  f á  f d Ü  É  Yâ  d à  t f d Ñ  É  Y} |  j | j t j k É |  j t | j | j É d É à  t É  d <| t É  d <à  d d É } |  j | d É |  j | j j	 d É t
 |  j t | j É t
 |  j t | É d  S(	   NRô  c              sG   e  Z d  Z d Ñ  Z e d Ñ  É Z  d Ñ  Z d Ñ  Z á  f d Ü  Z RS(   Rô  c         W   sd   | } | d | d } } t  | É d k r< t d É Ç n  t j |  | å } | | _ | | _ | S(   Ni    i   s    name and value must be specified(   R¨   R¶   RÏ   Rç  Rö  Rõ  (   RΩ   Rú  Rõ  RÉ   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRç  ö  s    		c         S   s   |  j  S(   N(   Rö  (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR   £  s    c         S   s&   d t  |  É j |  j t j |  É f S(   Ns
   %s(%r, %s)(   Rö   R   RÏ   RÉ  (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRÉ  ¶  s    c         S   s5   t  } | j } | j t k r+ | j |  É S| |  É S(   N(   RÏ   Rû  Rü  Rm  RÉ  (   RE   R†  R°  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRû  ´  s
    	c            sY   t  |  É t  | É } t |  à  É rQ t | à  É rQ à  d |  j | j f | É S| Sd  S(   Ns	   (%s + %s)(   RÏ   R∞   R   (   RE   R¢  Rí  (   Rô  (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR£  ¥  s    (   R   R   R  Rç  R§  RÉ  Rû  R£  (    (   Rô  (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRô  ò  s   					R•  c           B   s   e  Z d  Z d Z d Z RS(   R•  s   the-xi   s   the-yi   (   s   the-xi   (   s   the-yi   (   R   R   R  R¶  Rß  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR•  Ω  s   s   NamedInt('(the-x + the-y)', 3)R®  i   i   (   RÏ   R    RD   Rç  R   R±   R¶  Rß  R  RÑ   R:   R•   R¶   R   (   RE   R•  R©  (    (   Rô  s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt-   test_subclasses_without_direct_pickle_supportó  s    % c            s‰   d t  f á  f d Ü  É  Yâ  d à  t f d Ñ  É  Y} |  j | j t j k É |  j t | j | j É d É à  t É  d <| t É  d <à  d d É } |  j | d É |  j | j j	 d É t
 |  j | j É t
 |  j | É d  S(	   NRô  c              sG   e  Z d  Z d Ñ  Z e d Ñ  É Z  d Ñ  Z d Ñ  Z á  f d Ü  Z RS(   Rô  c         W   sd   | } | d | d } } t  | É d k r< t d É Ç n  t j |  | å } | | _ | | _ | S(   Ni    i   s    name and value must be specified(   R¨   R¶   RÏ   Rç  Rö  Rõ  (   RΩ   Rú  Rõ  RÉ   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRç  œ  s    		c         S   s   |  j  S(   N(   Rö  (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR   ÿ  s    c         S   s&   d t  |  É j |  j t j |  É f S(   Ns
   %s(%r, %s)(   Rö   R   RÏ   RÉ  (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRÉ  €  s    c         S   s5   t  } | j } | j t k r+ | j |  É S| |  É S(   N(   RÏ   Rû  Rü  Rm  RÉ  (   RE   R†  R°  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRû  ‡  s
    	c            sY   t  |  É t  | É } t |  à  É rQ t | à  É rQ à  d |  j | j f | É S| Sd  S(   Ns	   (%s + %s)(   RÏ   R∞   R   (   RE   R¢  Rí  (   Rô  (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR£  È  s    (   R   R   R  Rç  R§  RÉ  Rû  R£  (    (   Rô  (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRô  Õ  s   					R•  c           B   s#   e  Z d  Z d Z d Z d Ñ  Z RS(   R•  s   the-xi   s   the-yi   c         S   s   t  |  j |  j f f S(   N(   RØ   R7   t   _name_(   RE   R∞  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR±  ˆ  s    (   s   the-xi   (   s   the-yi   (   R   R   R  R¶  Rß  R±  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR•  Ú  s   s   NamedInt('(the-x + the-y)', 3)R®  i   i   (   RÏ   R    RD   Rç  R   R±   R¶  Rß  R  RÑ   R6   (   RE   R•  R©  (    (   Rô  s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt8   test_subclasses_without_direct_pickle_support_using_nameÃ  s    % c         C   sÖ   d t  t f d Ñ  É  Y} |  j t | j É | k É |  j t | j t  É É |  j | j d É | t	 É  d <t
 |  j | j É d  S(   Nt	   SomeTuplec           B   s    e  Z d  Z d Z d Z d	 Z RS(
   R∂  i   s   for the moneyi   s   for the showi   s   for the music(   i   s   for the money(   i   s   for the show(   i   s   for the music(   R   R   R  Ró   Rò   Rô   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR∂    s   i   s   for the music(   i   s   for the music(   t   tupleR    RD   Rö   Ró   R∞   Rò   R   Rô   R  R6   (   RE   R∂  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_tuple_subclass  s    c         C   sç   d t  f d Ñ  É  Y} |  j t | j É d É |  j | j j d É |  j | d É | j k É |  j t | É | j | j | j g É d  S(   Nt
   AutoNumberc           B   s2   e  Z d  Z d Z d Z d Z d Ñ  Z d Ñ  Z RS(   s   enum_m enum_d enum_yc         S   s/   t  |  j É d } t j |  É } | | _ | S(   Ni   (   R¨   R~   Rm  Rç  t   _value_(   RΩ   RÑ   R9   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRç    s    	c         S   s   t  |  j É S(   N(   RÏ   R∫  (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRy    s    (    (    (    (   R   R   Rñ   t   enum_mt   enum_dt   enum_yRç  Ry  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRπ    s   	i   i   i   (	   R    R   RÏ   Rº  RΩ  RÑ   RD   Rª  R´   (   RE   Rπ  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt,   test_duplicate_values_give_unique_enum_items  s    	c         C   s∏   d t  f d Ñ  É  Y} d | f d Ñ  É  Y} |  j t | É d d t | É d f É |  j t | É | j | j | j g É t d k r¥ |  j t t t	 | É É d d	 d g É n  d  S(
   Nt   AutoNumber2c           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c         S   s/   t  |  j É d } t j |  É } | | _ | S(   Ni   (   R¨   R~   Rm  Rç  R∫  (   RΩ   RÑ   R9   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRç  &  s    	c         S   s   t  |  j É S(   N(   RÏ   R∫  (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRy  +  s    (   R   R   Rç  Ry  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRø  %  s   	RJ  c           B   s    e  Z d  Z d Z d Z d Z RS(   s   red green blue(    (    (    (   R   R   Rñ   RK  RL  RM  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRJ  -  s   i   s+   wrong number of elements: %d (should be %d)g      @i   i   (
   R    R   R¨   R´   RK  RL  RM  R7  t   mapRÏ   (   RE   Rø  RJ  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt%   test_inherited_new_from_enhanced_enum$  s    )(c         C   sn   d t  f d Ñ  É  Y} d | f d Ñ  É  Y} |  j t | É d d t | É d f É | j | j | j d  S(   Nt   AutoNumber3c           B   s   e  Z d  Ñ  Z RS(   c         S   s2   t  |  j É d } t j |  | É } | | _ | S(   Ni   (   R¨   R~   RÏ   Rç  R∫  (   RΩ   RÑ   R9   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRç  9  s    	(   R   R   Rç  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR¬  8  s   RJ  c           B   s   e  Z d  Z d Z d Z RS(   (    (    (    (   R   R   RK  RL  RM  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRJ  >  s   i   s+   wrong number of elements: %d (should be %d)(   R   R   R¨   RK  RL  RM  (   RE   R¬  RJ  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt"   test_inherited_new_from_mixed_enum7  s    )c         C   sY   d d d Ñ  É  Y} d t  f d Ñ  É  Y} |  j | É  | j É |  j | j | É  É d  S(   Nt   AlwaysEqualc           B   s   e  Z d  Ñ  Z RS(   c         S   s   t  S(   N(   R   (   RE   R¢  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   __eq__I  s    (   R   R   R≈  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRƒ  H  s   t   OrdinaryEnumc           B   s   e  Z d  Z RS(   i   (   R   R   RJ   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR∆  K  s   (    (   R    R   RJ   (   RE   Rƒ  R∆  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_equalityG  s    c         C   s»   d t  f d Ñ  É  Y} d | f d Ñ  É  Y} |  j t | É | j | j | j | j | j g É |  j | j | j k É |  j | j | j k É |  j | j | j k  É |  j | j | j k É d  S(   Nt   OrderedEnumc           B   s,   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         S   s&   |  j  | j  k r" |  j | j k St S(   N(   R7   R∫  t   NotImplemented(   RE   R¢  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   __ge__R  s    c         S   s&   |  j  | j  k r" |  j | j k St S(   N(   R7   R∫  R…  (   RE   R¢  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   __gt__V  s    c         S   s&   |  j  | j  k r" |  j | j k St S(   N(   R7   R∫  R…  (   RE   R¢  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   __le__Z  s    c         S   s&   |  j  | j  k r" |  j | j k  St S(   N(   R7   R∫  R…  (   RE   R¢  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   __lt__^  s    (   R   R   R   RÀ  RÃ  RÕ  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR»  Q  s   			t   Gradec           B   s,   e  Z d  Z d Z d Z d Z d Z d Z RS(   s	   A B C D Fi   i   i   i   i   (   R   R   Rñ   Rh   Ri   Rj   Rk   Rl   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRŒ  b  s   (	   R    R   R´   Rh   Ri   Rj   Rk   Rl   RD   (   RE   R»  RŒ  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_ordered_mixinP  s    4c         C   s   d Ñ  } |  j  t | É d  S(   Nc          S   sF   d t  f d Ñ  É  Y}  d |  f d Ñ  É  Y} d | f d Ñ  É  Y} d  S(   Nt   Shadec           B   s   e  Z d  Ñ  Z RS(   c         S   s   |  j  GHd  S(   N(   RÉ   (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   shader  s    (   R   R   R—  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR–  q  s   RJ  c           B   s   e  Z d  Z d Z d Z RS(   i   i   i   (   R   R   RK  RL  RM  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRJ  t  s   RN  c           B   s   e  Z d  Z d Z d Z RS(   i   i   i   (   R   R   RO  RP  RQ  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRN  x  s   (   R    (   R–  RJ  RN  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRR  p  s    (   R•   R¶   (   RE   RR  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_extending2o  s    	c         C   s_   d t  f d Ñ  É  Y} d | f d Ñ  É  Y} d | f d Ñ  É  Y} |  j | j j É  d É d  S(   NR–  c           B   s   e  Z d  Ñ  Z RS(   c         S   s   |  j  S(   N(   RÉ   (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR—  Ä  s    (   R   R   R—  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR–    s   RJ  c           B   s   e  Z d  Ñ  Z RS(   c         S   s   d |  j  S(   Ns   %s hexlified!(   RÑ   (   RE   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   hexÉ  s    (   R   R   R”  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRJ  Ç  s   RN  c           B   s   e  Z d  Z d Z d Z RS(   i   i   i   (   R   R   RO  RP  RQ  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRN  Ö  s   s   5 hexlified!(   R    R   RP  R”  (   RE   R–  RJ  RN  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_extending3~  s    c         C   s   d Ñ  } |  j  t | É d  S(   Nc          S   sF   d t  f d Ñ  É  Y}  d |  f d Ñ  É  Y} d |  f d Ñ  É  Y} d  S(   Nt
   UniqueEnumc           B   s   e  Z d  Ñ  Z RS(   c            s]   à  j  } t á  f d Ü  | DÉ É rY à  j } | à  j É j } t d | | f É Ç n  d  S(   Nc         3   s!   |  ] } à  j  | j  k Vq d  S(   N(   RÑ   (   t   .0Rµ   (   RE   (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pys	   <genexpr>ê  s    s-   aliases not allowed in UniqueEnum:  %r --> %r(   R7   R   RÉ   RÑ   R,   (   RE   Rú  RΩ   RJ   Rµ   (    (   RE   s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   __init__é  s    		(   R   R   R◊  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR’  ç  s   RJ  c           B   s   e  Z d  Z d Z d Z RS(   i   i   i   (   R   R   RK  RL  RM  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRJ  ó  s   c           B   s    e  Z d  Z d Z d Z d Z RS(   i   i   i   (   R   R   RK  RL  RM  t   grene(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRJ  õ  s   (   R    (   R’  RJ  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   bad_duplicateså  s    
(   R•   R,   (   RE   RŸ  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_no_duplicatesã  s    	c         C   sO   d t  f d Ñ  É  Y} |  j t | j j d É d É |  j | j j d É d  S(   Nt   Planetc           B   sP   e  Z d Z d Z d Z d Z d Z d Z d Z d Z	 d Ñ  Z
 e d Ñ  É Z RS(   gIÊTf|—Dg    
ùBAgçQX4Eg    ˆWAg¬oﬁ≈Eg    ßTXAg∂•Ò	ˇ‡Dg    (ÎIAgœcãôíéòEg   ÄÜëAgô[ë\h}Eg    ÔºåAg#'?ÇTˆQEg   Ä˝_xAgˆJ·«-UEg    ÅôwAc         S   s   | |  _  | |  _ d  S(   N(   t   masst   radius(   RE   R‹  R›  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR◊  ¨  s    	c         S   s   d } | |  j  |  j |  j S(   Ngy–¥W“=(   R‹  R›  (   RE   t   G(    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   surface_gravityØ  s    (   gIÊTf|—Dg    
ùBA(   gçQX4Eg    ˆWA(   g¬oﬁ≈Eg    ßTXA(   g∂•Ò	ˇ‡Dg    (ÎIA(   gœcãôíéòEg   ÄÜëA(   gô[ë\h}Eg    ÔºåA(   g#'?ÇTˆQEg   Ä˝_xA(   gˆJ·«-UEg    ÅôwA(   R   R   t   MERCURYt   VENUSt   EARTHt   MARSt   JUPITERt   SATURNt   URANUSt   NEPTUNER◊  R§  Rﬂ  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR€  £  s   	i   göôôôôô#@g¬oﬁ≈Eg    ßTXA(   g¬oﬁ≈Eg    ßTXA(   R    R   t   roundR‚  Rﬂ  RÑ   (   RE   R€  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt	   test_init¢  s    c         C   sç   d t  f d Ñ  É  Y} d | f d Ñ  É  Y} |  j t | É | j | j | j g É |  j | j j d g É |  j | d g É | j É d  S(   Nt   AutoNumberInAListc           B   s   e  Z d  Ñ  Z RS(   c         S   s2   t  |  j É d g } t j |  É } | | _ | S(   Ni   (   R¨   R~   Rm  Rç  R∫  (   RΩ   RÑ   R9   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRç  π  s    	(   R   R   Rç  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRÍ  ∏  s   t   ColorInAListc           B   s    e  Z d  Z d Z d Z d Z RS(   s   red green blue(    (    (    (   R   R   Rñ   RK  RL  RM  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRÎ  æ  s   i   (   R    R   R´   RK  RL  RM  RÑ   (   RE   RÍ  RÎ  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_nonhash_value∑  s
    (c         C   sÅ   d t  t f d Ñ  É  Y} d | f d Ñ  É  Y} |  j t | É | j | j g É |  j | j d É |  j | d É | j É d  S(   Nt   LabelledIntEnumc           B   s   e  Z d  Ñ  Z RS(   c         W   s4   | \ } } t  j |  | É } | | _ | | _ | S(   N(   RÏ   Rç  t   labelR∫  (   RΩ   Rú  RÑ   RÓ  R9   (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRç  …  s
    		(   R   R   Rç  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRÌ  »  s   t   LabelledListc           B   s   e  Z d Z d Z RS(   i   t   Unprocessedi   s   Payment Complete(   i   R  (   i   s   Payment Complete(   R   R   t   unprocessedt   payment_complete(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyRÔ  –  s   i   (   RÏ   R    R   R´   RÒ  RÚ  (   RE   RÌ  RÔ  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt&   test_conflicting_types_resolved_in_new«  s
    "c         C   s,   t  j d i  É } |  j t | É d É d  S(   Nt   Fooi    (   RA   R   R   R¨   (   RE   t   empty(    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_empty_with_functional_apiÿ  s    (j   R   R   R}   R7  RÇ   RÖ   Rå   Rë   Rõ   Rù   Rü   Rß   R®   R©   R™   R∂   Rº   R¬   R»   RÕ   Rœ   R”   R’   R÷   R◊   Rÿ   RŸ   Rﬂ   RÂ   t   varsRΩ   R    t   resultRË   RÌ   RÓ   RÔ   RÒ   RÙ   Rı   R  R  R  R  R  R	  R  R  R  R  R"  R$  R%  R'  R+  R1  R2  R3  R4  R5  R8  R9  R:  R;  R<  R>  R?  R@  RA  RB  RC  RH  RI  RS  RV  RY  R`  Rn  Rt  Ru  Rv  Rw  R~  RÇ  RÑ  Rà  Rò  R™  R≠  RØ  R≤  R≥  Rµ  R∏  Ræ  R¡  R√  R«  Rœ  R“  R‘  R⁄  RÈ  RÏ  RÛ  Rˆ  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR]   ë   s‚   	#																																									
																																					
			
	&	78	8	8	5	7													t
   TestUniquec           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   s8   2.4 doesn't allow class decorators, use function syntax.c         C   sD   d t  f d Ñ  É  Y} t | É d t f d Ñ  É  Y} t | É d  S(   Nt   Cleanc           B   s   e  Z d  Z d Z d Z RS(   i   R^  g      @(   R   R   R    RÀ   R_  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR˙  ·  s   t   Cleanerc           B   s   e  Z d  Z d Z d Z RS(   i   i   i   (   R   R   t   singlet   doublet   triple(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR˚  Ê  s   (   R    R   R   (   RE   R˙  R˚  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_unique_clean‡  s    
c         C   sÁ   y$ d t  f d Ñ  É  Y} t | É Wn. t k
 rT t j É  d } | j d } n X|  j d | k É y$ d t f d Ñ  É  Y} t | É Wn. t k
 rº t j É  d } | j d } n X|  j d | k É |  j d	 | k É d  S(
   Nt   Dirtyc           B   s    e  Z d  Z d Z d Z d Z RS(   s   one two tresi   R^  (   R   R   Rñ   R    RÀ   R_  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR   Ó  s   i   i    s   tres -> onet   Dirtierc           B   s&   e  Z d  Z d Z d Z d Z d Z RS(   s   single double triple turkeyi   i   (   R   R   Rñ   R¸  R˝  R˛  t   turkey(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR  ˙  s
   s   double -> singles   turkey -> triple(   R    R   R,   R)   R*   Rú  RD   R   (   RE   R   R4   t   messageR  (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   test_unique_dirtyÏ  s    (   R   R   R   Rˇ  R  (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR˘  ›  s   	t   TestMec           B   s   e  Z RS(    (   R   R   (    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyR    s   t   __main__(,   RA   R)   t   unittestR    R   R   R   t   pickleR   R   R   R   Rz   t   version_infoR7  R   t	   NameErrorR=  R{   t   collectionsR   t   ImportErrorR'   R   R(   R*   RÏ   R   R   R   R   R   R   R   R   R!   R6   R:   t   TestCaseR;   R]   R˘  R  t   main(    (    (    s2   /usr/lib/python2.7/dist-packages/enum/test_enum.pyt   <module>   sÇ   ""

ˇ ˇ ˇ ˇ ˇ ˇ R+
filename:/usr/lib/python2.7/dist-packages/enum/doc/enum.rst
__doc__
``enum`` --- support for enumerations
========================================

.. :synopsis: enumerations are sets of symbolic names bound to unique, constant
  values.
.. :moduleauthor:: Ethan Furman <ethan@stoneleaf.us>
.. :sectionauthor:: Barry Warsaw <barry@python.org>,
.. :sectionauthor:: Eli Bendersky <eliben@gmail.com>,
.. :sectionauthor:: Ethan Furman <ethan@stoneleaf.us>

----------------

An enumeration is a set of symbolic names (members) bound to unique, constant
values.  Within an enumeration, the members can be compared by identity, and
the enumeration itself can be iterated over.


Module Contents
---------------

This module defines two enumeration classes that can be used to define unique
sets of names and values: ``Enum`` and ``IntEnum``.  It also defines
one decorator, ``unique``.

``Enum``

Base class for creating enumerated constants.  See section `Functional API`_
for an alternate construction syntax.

``IntEnum``

Base class for creating enumerated constants that are also subclasses of ``int``.

``unique``

Enum class decorator that ensures only one name is bound to any one value.


Creating an Enum
----------------

Enumerations are created using the ``class`` syntax, which makes them
easy to read and write.  An alternative creation method is described in
`Functional API`_.  To define an enumeration, subclass ``Enum`` as
follows::

    >>> from enum import Enum
    >>> class Color(Enum):
    ...     red = 1
    ...     green = 2
    ...     blue = 3

Note: Nomenclature

  - The class ``Color`` is an *enumeration* (or *enum*)
  - The attributes ``Color.red``, ``Color.green``, etc., are
    *enumeration members* (or *enum members*).
  - The enum members have *names* and *values* (the name of
    ``Color.red`` is ``red``, the value of ``Color.blue`` is
    ``3``, etc.)
    
Note:

    Even though we use the ``class`` syntax to create Enums, Enums
    are not normal Python classes.  See `How are Enums different?`_ for
    more details.

Enumeration members have human readable string representations::

    >>> print(Color.red)
    Color.red

...while their ``repr`` has more information::

    >>> print(repr(Color.red))
    <Color.red: 1>

The *type* of an enumeration member is the enumeration it belongs to::

    >>> type(Color.red)
    <enum 'Color'>
    >>> isinstance(Color.green, Color)
    True
    >>>

Enum members also have a property that contains just their item name::

    >>> print(Color.red.name)
    red

Enumerations support iteration.  In Python 3.x definition order is used; in
Python 2.x the definition order is not available, but class attribute
``__order__`` is supported;  otherwise, value order is used::

    >>> class Shake(Enum):
    ...   __order__ = 'vanilla chocolate cookies mint'  # only needed in 2.x
    ...   vanilla = 7
    ...   chocolate = 4
    ...   cookies = 9
    ...   mint = 3
    ...
    >>> for shake in Shake:
    ...   print(shake)
    ...
    Shake.vanilla
    Shake.chocolate
    Shake.cookies
    Shake.mint

The ``__order__`` attribute is always removed, and in 3.x it is also ignored
(order is definition order); however, in the stdlib version it will be ignored
but not removed.

Enumeration members are hashable, so they can be used in dictionaries and sets::

    >>> apples = {}
    >>> apples[Color.red] = 'red delicious'
    >>> apples[Color.green] = 'granny smith'
    >>> apples == {Color.red: 'red delicious', Color.green: 'granny smith'}
    True


Programmatic access to enumeration members and their attributes
---------------------------------------------------------------

Sometimes it's useful to access members in enumerations programmatically (i.e.
situations where ``Color.red`` won't do because the exact color is not known
at program-writing time).  ``Enum`` allows such access::

    >>> Color(1)
    <Color.red: 1>
    >>> Color(3)
    <Color.blue: 3>

If you want to access enum members by *name*, use item access::

    >>> Color['red']
    <Color.red: 1>
    >>> Color['green']
    <Color.green: 2>

If have an enum member and need its ``name`` or ``value``::

    >>> member = Color.red
    >>> member.name
    'red'
    >>> member.value
    1


Duplicating enum members and values
-----------------------------------

Having two enum members (or any other attribute) with the same name is invalid;
in Python 3.x this would raise an error, but in Python 2.x the second member
simply overwrites the first::

    >>> # python 2.x
    >>> class Shape(Enum):
    ...   square = 2
    ...   square = 3
    ...
    >>> Shape.square
    <Shape.square: 3>

    >>> # python 3.x
    >>> class Shape(Enum):
    ...   square = 2
    ...   square = 3
    Traceback (most recent call last):
    ...
    TypeError: Attempted to reuse key: 'square'

However, two enum members are allowed to have the same value.  Given two members
A and B with the same value (and A defined first), B is an alias to A.  By-value
lookup of the value of A and B will return A.  By-name lookup of B will also
return A::

    >>> class Shape(Enum):
    ...   __order__ = 'square diamond circle alias_for_square'  # only needed in 2.x
    ...   square = 2
    ...   diamond = 1
    ...   circle = 3
    ...   alias_for_square = 2
    ...
    >>> Shape.square
    <Shape.square: 2>
    >>> Shape.alias_for_square
    <Shape.square: 2>
    >>> Shape(2)
    <Shape.square: 2>


Allowing aliases is not always desirable.  ``unique`` can be used to ensure
that none exist in a particular enumeration::

    >>> from enum import unique
    >>> @unique
    ... class Mistake(Enum):
    ...   __order__ = 'one two three four'  # only needed in 2.x
    ...   one = 1
    ...   two = 2
    ...   three = 3
    ...   four = 3
    Traceback (most recent call last):
    ...
    ValueError: duplicate names found in <enum 'Mistake'>: four -> three

Iterating over the members of an enum does not provide the aliases::

    >>> list(Shape)
    [<Shape.square: 2>, <Shape.diamond: 1>, <Shape.circle: 3>]

The special attribute ``__members__`` is a dictionary mapping names to members.
It includes all names defined in the enumeration, including the aliases::

    >>> for name, member in sorted(Shape.__members__.items()):
    ...   name, member
    ...
    ('alias_for_square', <Shape.square: 2>)
    ('circle', <Shape.circle: 3>)
    ('diamond', <Shape.diamond: 1>)
    ('square', <Shape.square: 2>)

The ``__members__`` attribute can be used for detailed programmatic access to
the enumeration members.  For example, finding all the aliases::

    >>> [name for name, member in Shape.__members__.items() if member.name != name]
    ['alias_for_square']

Comparisons
-----------

Enumeration members are compared by identity::

    >>> Color.red is Color.red
    True
    >>> Color.red is Color.blue
    False
    >>> Color.red is not Color.blue
    True

Ordered comparisons between enumeration values are *not* supported.  Enum
members are not integers (but see `IntEnum`_ below)::

    >>> Color.red < Color.blue
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: unorderable types: Color() < Color()

.. warning::

    In Python 2 *everything* is ordered, even though the ordering may not
    make sense.  If you want your enumerations to have a sensible ordering
    check out the `OrderedEnum`_ recipe below.


Equality comparisons are defined though::

    >>> Color.blue == Color.red
    False
    >>> Color.blue != Color.red
    True
    >>> Color.blue == Color.blue
    True

Comparisons against non-enumeration values will always compare not equal
(again, ``IntEnum`` was explicitly designed to behave differently, see
below)::

    >>> Color.blue == 2
    False


Allowed members and attributes of enumerations
----------------------------------------------

The examples above use integers for enumeration values.  Using integers is
short and handy (and provided by default by the `Functional API`_), but not
strictly enforced.  In the vast majority of use-cases, one doesn't care what
the actual value of an enumeration is.  But if the value *is* important,
enumerations can have arbitrary values.

Enumerations are Python classes, and can have methods and special methods as
usual.  If we have this enumeration::

    >>> class Mood(Enum):
    ...   funky = 1
    ...   happy = 3
    ... 
    ...   def describe(self):
    ...     # self is the member here
    ...     return self.name, self.value
    ... 
    ...   def __str__(self):
    ...     return 'my custom str! {0}'.format(self.value)
    ... 
    ...   @classmethod
    ...   def favorite_mood(cls):
    ...     # cls here is the enumeration
    ...     return cls.happy

Then::

    >>> Mood.favorite_mood()
    <Mood.happy: 3>
    >>> Mood.happy.describe()
    ('happy', 3)
    >>> str(Mood.funky)
    'my custom str! 1'

The rules for what is allowed are as follows: _sunder_ names (starting and
ending with a single underscore) are reserved by enum and cannot be used;
all other attributes defined within an enumeration will become members of this
enumeration, with the exception of *__dunder__* names and descriptors (methods
are also descriptors).

Note:

    If your enumeration defines ``__new__`` and/or ``__init__`` then
    whatever value(s) were given to the enum member will be passed into
    those methods.  See `Planet`_ for an example.


Restricted subclassing of enumerations
--------------------------------------

Subclassing an enumeration is allowed only if the enumeration does not define
any members.  So this is forbidden::

    >>> class MoreColor(Color):
    ...   pink = 17
    Traceback (most recent call last):
    ...
    TypeError: Cannot extend enumerations

But this is allowed::

    >>> class Foo(Enum):
    ...   def some_behavior(self):
    ...     pass
    ...
    >>> class Bar(Foo):
    ...   happy = 1
    ...   sad = 2
    ...

Allowing subclassing of enums that define members would lead to a violation of
some important invariants of types and instances.  On the other hand, it makes
sense to allow sharing some common behavior between a group of enumerations.
(See `OrderedEnum`_ for an example.)


Pickling
--------

Enumerations can be pickled and unpickled::

    >>> from enum.test_enum import Fruit
    >>> from pickle import dumps, loads
    >>> Fruit.tomato is loads(dumps(Fruit.tomato, 2))
    True

The usual restrictions for pickling apply: picklable enums must be defined in
the top level of a module, since unpickling requires them to be importable
from that module.

Note:

    With pickle protocol version 4 (introduced in Python 3.4) it is possible
    to easily pickle enums nested in other classes.



Functional API
--------------

The ``Enum`` class is callable, providing the following functional API::

    >>> Animal = Enum('Animal', 'ant bee cat dog')
    >>> Animal
    <enum 'Animal'>
    >>> Animal.ant
    <Animal.ant: 1>
    >>> Animal.ant.value
    1
    >>> list(Animal)
    [<Animal.ant: 1>, <Animal.bee: 2>, <Animal.cat: 3>, <Animal.dog: 4>]

The semantics of this API resemble ``namedtuple``. The first argument
of the call to ``Enum`` is the name of the enumeration. 

The second argument is the *source* of enumeration member names.  It can be a
whitespace-separated string of names, a sequence of names, a sequence of
2-tuples with key/value pairs, or a mapping (e.g. dictionary) of names to
values.  The last two options enable assigning arbitrary values to
enumerations; the others auto-assign increasing integers starting with 1.  A
new class derived from ``Enum`` is returned.  In other words, the above
assignment to ``Animal`` is equivalent to::

    >>> class Animals(Enum):
    ...   ant = 1
    ...   bee = 2
    ...   cat = 3
    ...   dog = 4

Pickling enums created with the functional API can be tricky as frame stack
implementation details are used to try and figure out which module the
enumeration is being created in (e.g. it will fail if you use a utility
function in separate module, and also may not work on IronPython or Jython).
The solution is to specify the module name explicitly as follows::

    >>> Animals = Enum('Animals', 'ant bee cat dog', module=__name__)

Derived Enumerations
--------------------

IntEnum
^^^^^^^

A variation of ``Enum`` is provided which is also a subclass of
``int``.  Members of an ``IntEnum`` can be compared to integers;
by extension, integer enumerations of different types can also be compared
to each other::

    >>> from enum import IntEnum
    >>> class Shape(IntEnum):
    ...   circle = 1
    ...   square = 2
    ...
    >>> class Request(IntEnum):
    ...   post = 1
    ...   get = 2
    ...
    >>> Shape == 1
    False
    >>> Shape.circle == 1
    True
    >>> Shape.circle == Request.post
    True

However, they still can't be compared to standard ``Enum`` enumerations::

    >>> class Shape(IntEnum):
    ...   circle = 1
    ...   square = 2
    ...
    >>> class Color(Enum):
    ...   red = 1
    ...   green = 2
    ...
    >>> Shape.circle == Color.red
    False

``IntEnum`` values behave like integers in other ways you'd expect::

    >>> int(Shape.circle)
    1
    >>> ['a', 'b', 'c'][Shape.circle]
    'b'
    >>> [i for i in range(Shape.square)]
    [0, 1]

For the vast majority of code, ``Enum`` is strongly recommended,
since ``IntEnum`` breaks some semantic promises of an enumeration (by
being comparable to integers, and thus by transitivity to other
unrelated enumerations).  It should be used only in special cases where
there's no other choice; for example, when integer constants are
replaced with enumerations and backwards compatibility is required with code
that still expects integers.


Others
^^^^^^

While ``IntEnum`` is part of the ``enum`` module, it would be very
simple to implement independently::

    class IntEnum(int, Enum):
        pass

This demonstrates how similar derived enumerations can be defined; for example
a ``StrEnum`` that mixes in ``str`` instead of ``int``.

Some rules:

1. When subclassing ``Enum``, mix-in types must appear before
   ``Enum`` itself in the sequence of bases, as in the ``IntEnum``
   example above.
2. While ``Enum`` can have members of any type, once you mix in an
   additional type, all the members must have values of that type, e.g.
   ``int`` above.  This restriction does not apply to mix-ins which only
   add methods and don't specify another data type such as ``int`` or
   ``str``.
3. When another data type is mixed in, the ``value`` attribute is *not the
   same* as the enum member itself, although it is equivalant and will compare
   equal.
4. %-style formatting:  ``%s`` and ``%r`` call ``Enum``'s ``__str__`` and
   ``__repr__`` respectively; other codes (such as ``%i`` or ``%h`` for
   IntEnum) treat the enum member as its mixed-in type.

   Note: Prior to Python 3.4 there is a bug in ``str``'s %-formatting: ``int``
   subclasses are printed as strings and not numbers when the ``%d``, ``%i``,
   or ``%u`` codes are used.
5. ``str.__format__`` (or ``format``) will use the mixed-in
   type's ``__format__``.  If the ``Enum``'s ``str`` or
   ``repr`` is desired use the ``!s`` or ``!r`` ``str`` format codes.


Decorators
----------

unique
^^^^^^

A ``class`` decorator specifically for enumerations.  It searches an
enumeration's ``__members__`` gathering any aliases it finds; if any are
found ``ValueError`` is raised with the details::

    >>> @unique
    ... class NoDupes(Enum):
    ...    first = 'one'
    ...    second = 'two'
    ...    third = 'two'
    Traceback (most recent call last):
    ...
    ValueError: duplicate names found in <enum 'NoDupes'>: third -> second


Interesting examples
--------------------

While ``Enum`` and ``IntEnum`` are expected to cover the majority of
use-cases, they cannot cover them all.  Here are recipes for some different
types of enumerations that can be used directly, or as examples for creating
one's own.


AutoNumber
^^^^^^^^^^

Avoids having to specify the value for each enumeration member::

    >>> class AutoNumber(Enum):
    ...     def __new__(cls):
    ...         value = len(cls.__members__) + 1
    ...         obj = object.__new__(cls)
    ...         obj._value_ = value
    ...         return obj
    ...
    >>> class Color(AutoNumber):
    ...     __order__ = "red green blue"  # only needed in 2.x
    ...     red = ()
    ...     green = ()
    ...     blue = ()
    ...
    >>> Color.green.value == 2
    True

Note:

    The `__new__` method, if defined, is used during creation of the Enum
    members; it is then replaced by Enum's `__new__` which is used after
    class creation for lookup of existing members.  Due to the way Enums are
    supposed to behave, there is no way to customize Enum's `__new__`.


UniqueEnum
^^^^^^^^^^

Raises an error if a duplicate member name is found instead of creating an
alias::

    >>> class UniqueEnum(Enum):
    ...     def __init__(self, *args):
    ...         cls = self.__class__
    ...         if any(self.value == e.value for e in cls):
    ...             a = self.name
    ...             e = cls(self.value).name
    ...             raise ValueError(
    ...                     "aliases not allowed in UniqueEnum:  %r --> %r"
    ...                     % (a, e))
    ... 
    >>> class Color(UniqueEnum):
    ...     red = 1
    ...     green = 2
    ...     blue = 3
    ...     grene = 2
    Traceback (most recent call last):
    ...
    ValueError: aliases not allowed in UniqueEnum:  'grene' --> 'green'
    

OrderedEnum
^^^^^^^^^^^

An ordered enumeration that is not based on ``IntEnum`` and so maintains
the normal ``Enum`` invariants (such as not being comparable to other
enumerations)::

    >>> class OrderedEnum(Enum):
    ...     def __ge__(self, other):
    ...         if self.__class__ is other.__class__:
    ...             return self._value_ >= other._value_
    ...         return NotImplemented
    ...     def __gt__(self, other):
    ...         if self.__class__ is other.__class__:
    ...             return self._value_ > other._value_
    ...         return NotImplemented
    ...     def __le__(self, other):
    ...         if self.__class__ is other.__class__:
    ...             return self._value_ <= other._value_
    ...         return NotImplemented
    ...     def __lt__(self, other):
    ...         if self.__class__ is other.__class__:
    ...             return self._value_ < other._value_
    ...         return NotImplemented
    ...
    >>> class Grade(OrderedEnum):
    ...     __ordered__ = 'A B C D F'
    ...     A = 5
    ...     B = 4
    ...     C = 3
    ...     D = 2
    ...     F = 1
    ...
    >>> Grade.C < Grade.A
    True


Planet
^^^^^^

If ``__new__`` or ``__init__`` is defined the value of the enum member
will be passed to those methods::

    >>> class Planet(Enum):
    ...     MERCURY = (3.303e+23, 2.4397e6)
    ...     VENUS   = (4.869e+24, 6.0518e6)
    ...     EARTH   = (5.976e+24, 6.37814e6)
    ...     MARS    = (6.421e+23, 3.3972e6)
    ...     JUPITER = (1.9e+27,   7.1492e7)
    ...     SATURN  = (5.688e+26, 6.0268e7)
    ...     URANUS  = (8.686e+25, 2.5559e7)
    ...     NEPTUNE = (1.024e+26, 2.4746e7)
    ...     def __init__(self, mass, radius):
    ...         self.mass = mass       # in kilograms
    ...         self.radius = radius   # in meters
    ...     @property
    ...     def surface_gravity(self):
    ...         # universal gravitational constant  (m3 kg-1 s-2)
    ...         G = 6.67300E-11
    ...         return G * self.mass / (self.radius * self.radius)
    ... 
    >>> Planet.EARTH.value
    (5.976e+24, 6378140.0)
    >>> Planet.EARTH.surface_gravity
    9.802652743337129


How are Enums different?
------------------------

Enums have a custom metaclass that affects many aspects of both derived Enum
classes and their instances (members).


Enum Classes
^^^^^^^^^^^^

The ``EnumMeta`` metaclass is responsible for providing the
``__contains__``, ``__dir__``, ``__iter__`` and other methods that
allow one to do things with an ``Enum`` class that fail on a typical
class, such as ``list(Color)`` or ``some_var in Color``.  ``EnumMeta`` is
responsible for ensuring that various other methods on the final ``Enum``
class are correct (such as ``__new__``, ``__getnewargs__``,
``__str__`` and ``__repr__``).

.. note::

    ``__dir__`` is not changed in the Python 2 line as it messes up some
    of the decorators included in the stdlib.


Enum Members (aka instances)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The most interesting thing about Enum members is that they are singletons.
``EnumMeta`` creates them all while it is creating the ``Enum``
class itself, and then puts a custom ``__new__`` in place to ensure
that no new ones are ever instantiated by returning only the existing
member instances.


Finer Points
^^^^^^^^^^^^

``Enum`` members are instances of an ``Enum`` class, and even
though they are accessible as `EnumClass.member`, they should not be accessed
directly from the member as that lookup may fail or, worse, return something
besides the ``Enum`` member you were looking for (changed in version 1.1.1)::

    >>> class FieldTypes(Enum):
    ...     name = 1
    ...     value = 2
    ...     size = 3
    ...
    >>> FieldTypes.value.size
    <FieldTypes.size: 3>
    >>> FieldTypes.size.value
    3

Likewise, ``__members__`` is only available on the class.

In Python 3.x ``__members__`` is always an ``OrderedDict``, with the order being
the definition order.  In Python 2.7 ``__members__`` is an ``OrderedDict`` if
``__order__`` was specified, and a plain ``dict`` otherwise.  In all other Python
2.x versions ``__members__`` is a plain ``dict`` even if ``__order__`` was specified
as the ``OrderedDict`` type didn't exist yet.

If you give your ``Enum`` subclass extra methods, like the `Planet`_
class above, those methods will show up in a `dir` of the member,
but not of the class::

    >>> dir(Planet)
    ['EARTH', 'JUPITER', 'MARS', 'MERCURY', 'NEPTUNE', 'SATURN', 'URANUS',
    'VENUS', '__class__', '__doc__', '__members__', '__module__']
    >>> dir(Planet.EARTH)
    ['__class__', '__doc__', '__module__', 'name', 'surface_gravity', 'value']

A ``__new__`` method will only be used for the creation of the
``Enum`` members -- after that it is replaced.  This means if you wish to
change how ``Enum`` members are looked up you either have to write a
helper function or a ``classmethod``.

filename:/usr/lib/python2.7/dist-packages/enum/doc/enum.pdf
__doc__
%PDF-1.4
%ìåãû ReportLab Generated PDF document http://www.reportlab.com
1 0 obj
<< /F1 2 0 R /F2 3 0 R /F3 4 0 R /F4 5 0 R /F5 8 0 R /F6 15 0 R >>
endobj
2 0 obj
<< /BaseFont /Helvetica /Encoding /WinAnsiEncoding /Name /F1 /Subtype /Type1 /Type /Font >>
endobj
3 0 obj
<< /BaseFont /Courier-Bold /Encoding /WinAnsiEncoding /Name /F2 /Subtype /Type1 /Type /Font >>
endobj
4 0 obj
<< /BaseFont /Helvetica-Bold /Encoding /WinAnsiEncoding /Name /F3 /Subtype /Type1 /Type /Font >>
endobj
5 0 obj
<< /BaseFont /Courier /Encoding /WinAnsiEncoding /Name /F4 /Subtype /Type1 /Type /Font >>
endobj
6 0 obj
<< /Border [ 0 0 0 ] /Contents () /Dest [ 22 0 R /XYZ 62.69291 639.3236 0 ] /Rect [ 335.1805 574.4272 405.2473 586.4272 ] /Subtype /Link /Type /Annot >>
endobj
7 0 obj
<< /Border [ 0 0 0 ] /Contents () /Dest [ 22 0 R /XYZ 62.69291 639.3236 0 ] /Rect [ 255.9742 427.4272 321.5378 439.4272 ] /Subtype /Link /Type /Annot >>
endobj
8 0 obj
<< /BaseFont /Helvetica-Oblique /Encoding /WinAnsiEncoding /Name /F5 /Subtype /Type1 /Type /Font >>
endobj
9 0 obj
<< /Border [ 0 0 0 ] /Contents () /Dest [ 26 0 R /XYZ 62.69291 278.1236 0 ] /Rect [ 82.69291 182.2272 201.0729 194.2272 ] /Subtype /Link /Type /Annot >>
endobj
10 0 obj
<< /Annots [ 6 0 R 7 0 R 9 0 R ] /Contents 56 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 55 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 
  /Trans <<  >> /Type /Page >>
endobj
11 0 obj
<< /Contents 57 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 55 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 /Trans <<  >> 
  /Type /Page >>
endobj
12 0 obj
<< /Contents 58 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 55 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 /Trans <<  >> 
  /Type /Page >>
endobj
13 0 obj
<< /Contents 59 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 55 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 /Trans <<  >> 
  /Type /Page >>
endobj
14 0 obj
<< /Border [ 0 0 0 ] /Contents () /Dest [ 22 0 R /XYZ 62.69291 157.2236 0 ] /Rect [ 101.6029 741.7736 141.6229 753.7736 ] /Subtype /Link /Type /Annot >>
endobj
15 0 obj
<< /BaseFont /Helvetica-BoldOblique /Encoding /WinAnsiEncoding /Name /F6 /Subtype /Type1 /Type /Font >>
endobj
16 0 obj
<< /Border [ 0 0 0 ] /Contents () /Dest [ 25 0 R /XYZ 62.69291 359.6236 0 ] /Rect [ 327.1529 585.5736 392.7329 597.5736 ] /Subtype /Link /Type /Annot >>
endobj
17 0 obj
<< /Border [ 0 0 0 ] /Contents () /Dest [ 22 0 R /XYZ 62.69291 639.3236 0 ] /Rect [ 181.1917 312.1736 246.4634 324.1736 ] /Subtype /Link /Type /Annot >>
endobj
18 0 obj
<< /Annots [ 14 0 R 16 0 R 17 0 R ] /Contents 60 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 55 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 
  /Trans <<  >> /Type /Page >>
endobj
19 0 obj
<< /Border [ 0 0 0 ] /Contents () /Dest [ 26 0 R /XYZ 62.69291 610.8236 0 ] /Rect [ 326.1329 511.3736 357.2629 523.3736 ] /Subtype /Link /Type /Annot >>
endobj
20 0 obj
<< /Border [ 0 0 0 ] /Contents () /Dest [ 25 0 R /XYZ 62.69291 359.6236 0 ] /Rect [ 241.1229 185.9736 306.7029 197.9736 ] /Subtype /Link /Type /Annot >>
endobj
21 0 obj
<< /Annots [ 19 0 R 20 0 R ] /Contents 61 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 55 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 
  /Trans <<  >> /Type /Page >>
endobj
22 0 obj
<< /Contents 62 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 55 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 /Trans <<  >> 
  /Type /Page >>
endobj
23 0 obj
<< /Contents 63 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 55 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 /Trans <<  >> 
  /Type /Page >>
endobj
24 0 obj
<< /Contents 64 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 55 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 /Trans <<  >> 
  /Type /Page >>
endobj
25 0 obj
<< /Contents 65 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 55 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 /Trans <<  >> 
  /Type /Page >>
endobj
26 0 obj
<< /Contents 66 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 55 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 /Trans <<  >> 
  /Type /Page >>
endobj
27 0 obj
<< /Border [ 0 0 0 ] /Contents () /Dest [ 26 0 R /XYZ 62.69291 610.8236 0 ] /Rect [ 309.4094 311.5736 340.6461 323.5736 ] /Subtype /Link /Type /Annot >>
endobj
28 0 obj
<< /Annots [ 27 0 R ] /Contents 67 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 55 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 
  /Trans <<  >> /Type /Page >>
endobj
29 0 obj
<< /Outlines 31 0 R /PageLabels 68 0 R /PageMode /UseNone /Pages 55 0 R /Type /Catalog >>
endobj
30 0 obj
<< /Author () /CreationDate (D:20151129012746+08'00') /Creator (\(unspecified\)) /Keywords () /Producer (ReportLab PDF Library - www.reportlab.com) /Subject (\(unspecified\)) 
  /Title (enum --- support for enumerations) >>
endobj
31 0 obj
<< /Count 27 /First 32 0 R /Last 51 0 R /Type /Outlines >>
endobj
32 0 obj
<< /Dest [ 10 0 R /XYZ 62.69291 660.6772 0 ] /Next 33 0 R /Parent 31 0 R /Title (Module Contents) >>
endobj
33 0 obj
<< /Dest [ 10 0 R /XYZ 62.69291 477.6772 0 ] /Next 34 0 R /Parent 31 0 R /Prev 32 0 R /Title (Creating an Enum) >>
endobj
34 0 obj
<< /Dest [ 11 0 R /XYZ 62.69291 197.0236 0 ] /Next 35 0 R /Parent 31 0 R /Prev 33 0 R /Title (Programmatic access to enumeration members and their attributes) >>
endobj
35 0 obj
<< /Dest [ 12 0 R /XYZ 62.69291 501.4236 0 ] /Next 36 0 R /Parent 31 0 R /Prev 34 0 R /Title (Duplicating enum members and values) >>
endobj
36 0 obj
<< /Dest [ 13 0 R /XYZ 62.69291 215.0236 0 ] /Next 37 0 R /Parent 31 0 R /Prev 35 0 R /Title (Comparisons) >>
endobj
37 0 obj
<< /Dest [ 18 0 R /XYZ 62.69291 362.4236 0 ] /Next 38 0 R /Parent 31 0 R /Prev 36 0 R /Title (Allowed members and attributes of enumerations) >>
endobj
38 0 obj
<< /Dest [ 21 0 R /XYZ 62.69291 498.6236 0 ] /Next 39 0 R /Parent 31 0 R /Prev 37 0 R /Title (Restricted subclassing of enumerations) >>
endobj
39 0 obj
<< /Dest [ 21 0 R /XYZ 62.69291 173.2236 0 ] /Next 40 0 R /Parent 31 0 R /Prev 38 0 R /Title (Pickling) >>
endobj
40 0 obj
<< /Dest [ 22 0 R /XYZ 62.69291 635.8236 0 ] /Next 41 0 R /Parent 31 0 R /Prev 39 0 R /Title (Functional API) >>
endobj
41 0 obj
<< /Count 2 /Dest [ 22 0 R /XYZ 62.69291 187.2236 0 ] /First 42 0 R /Last 43 0 R /Next 44 0 R /Parent 31 0 R 
  /Prev 40 0 R /Title (Derived Enumerations) >>
endobj
42 0 obj
<< /Dest [ 22 0 R /XYZ 62.69291 154.2236 0 ] /Next 43 0 R /Parent 41 0 R /Title (IntEnum) >>
endobj
43 0 obj
<< /Dest [ 23 0 R /XYZ 62.69291 217.4236 0 ] /Parent 41 0 R /Prev 42 0 R /Title (Others) >>
endobj
44 0 obj
<< /Count 1 /Dest [ 24 0 R /XYZ 62.69291 567.0236 0 ] /First 45 0 R /Last 45 0 R /Next 46 0 R /Parent 31 0 R 
  /Prev 41 0 R /Title (Decorators) >>
endobj
45 0 obj
<< /Dest [ 24 0 R /XYZ 62.69291 534.0236 0 ] /Parent 44 0 R /Title (unique) >>
endobj
46 0 obj
<< /Count 4 /Dest [ 24 0 R /XYZ 62.69291 356.8236 0 ] /First 47 0 R /Last 50 0 R /Next 51 0 R /Parent 31 0 R 
  /Prev 44 0 R /Title (Interesting examples) >>
endobj
47 0 obj
<< /Dest [ 24 0 R /XYZ 62.69291 281.8236 0 ] /Next 48 0 R /Parent 46 0 R /Title (AutoNumber) >>
endobj
48 0 obj
<< /Dest [ 25 0 R /XYZ 62.69291 641.8236 0 ] /Next 49 0 R /Parent 46 0 R /Prev 47 0 R /Title (UniqueEnum) >>
endobj
49 0 obj
<< /Dest [ 25 0 R /XYZ 62.69291 356.6236 0 ] /Next 50 0 R /Parent 46 0 R /Prev 48 0 R /Title (OrderedEnum) >>
endobj
50 0 obj
<< /Dest [ 26 0 R /XYZ 62.69291 607.8236 0 ] /Parent 46 0 R /Prev 49 0 R /Title (Planet) >>
endobj
51 0 obj
<< /Count 3 /Dest [ 26 0 R /XYZ 62.69291 274.6236 0 ] /First 52 0 R /Last 54 0 R /Parent 31 0 R /Prev 46 0 R 
  /Title (How are Enums different?) >>
endobj
52 0 obj
<< /Dest [ 26 0 R /XYZ 62.69291 211.6236 0 ] /Next 53 0 R /Parent 51 0 R /Title (Enum Classes) >>
endobj
53 0 obj
<< /Dest [ 28 0 R /XYZ 62.69291 664.0236 0 ] /Next 54 0 R /Parent 51 0 R /Prev 52 0 R /Title (Enum Members \(aka instances\)) >>
endobj
54 0 obj
<< /Dest [ 28 0 R /XYZ 62.69291 592.0236 0 ] /Parent 51 0 R /Prev 53 0 R /Title (Finer Points) >>
endobj
55 0 obj
<< /Count 12 /Kids [ 10 0 R 11 0 R 12 0 R 13 0 R 18 0 R 21 0 R 22 0 R 23 0 R 24 0 R 25 0 R 
  26 0 R 28 0 R ] /Type /Pages >>
endobj
56 0 obj
<< /Length 6458 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 741.0236 cm
q
BT 1 0 0 1 0 4 Tm 73.71488 0 Td 24 TL /F2 20 Tf 0 0 0 rg (enum ) Tj /F3 20 Tf 0 0 0 rg (--- support for enumerations) Tj T* -73.71488 0 Td ET
Q
Q
q
1 0 0 1 62.69291 702.6772 cm
n 0 14.17323 m 469.8898 14.17323 l S
Q
q
1 0 0 1 62.69291 672.6772 cm
q
BT 1 0 0 1 0 14 Tm 2.091318 Tw 12 TL /F1 10 Tf 0 0 0 rg (An enumeration is a set of symbolic names \(members\) bound to unique, constant values. Within an) Tj T* 0 Tw (enumeration, the members can be compared by identity, and the enumeration itself can be iterated over.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 639.6772 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F3 17.5 Tf 0 0 0 rg (Module Contents) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 609.6772 cm
q
BT 1 0 0 1 0 14 Tm 2.027485 Tw 12 TL /F1 10 Tf 0 0 0 rg (This module defines two enumeration classes that can be used to define unique sets of names and) Tj T* 0 Tw (values: ) Tj /F4 10 Tf 0 0 0 rg (Enum ) Tj /F1 10 Tf 0 0 0 rg (and ) Tj /F4 10 Tf 0 0 0 rg (IntEnum) Tj /F1 10 Tf 0 0 0 rg (. It also defines one decorator, ) Tj /F4 10 Tf 0 0 0 rg (unique) Tj /F1 10 Tf 0 0 0 rg (.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 591.6772 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F4 10 Tf 12 TL (Enum) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 561.6772 cm
q
BT 1 0 0 1 0 14 Tm 1.128443 Tw 12 TL /F1 10 Tf 0 0 0 rg (Base class for creating enumerated constants. See section ) Tj 0 0 .501961 rg (Functional API ) Tj 0 0 0 rg (for an alternate construction) Tj T* 0 Tw (syntax.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 543.6772 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F4 10 Tf 12 TL (IntEnum) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 525.6772 cm
q
BT 1 0 0 1 0 2 Tm 12 TL /F1 10 Tf 0 0 0 rg (Base class for creating enumerated constants that are also subclasses of ) Tj /F4 10 Tf 0 0 0 rg (int) Tj /F1 10 Tf 0 0 0 rg (.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 507.6772 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F4 10 Tf 12 TL (unique) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 489.6772 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Enum class decorator that ensures only one name is bound to any one value.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 456.6772 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F3 17.5 Tf 0 0 0 rg (Creating an Enum) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 414.6772 cm
q
BT 1 0 0 1 0 26 Tm 2.432651 Tw 12 TL /F1 10 Tf 0 0 0 rg (Enumerations are created using the ) Tj /F4 10 Tf 0 0 0 rg (class ) Tj /F1 10 Tf 0 0 0 rg (syntax, which makes them easy to read and write. An) Tj T* 0 Tw .533555 Tw (alternative creation method is described in ) Tj 0 0 .501961 rg (Functional API) Tj 0 0 0 rg (. To define an enumeration, subclass ) Tj /F4 10 Tf 0 0 0 rg (Enum ) Tj /F1 10 Tf 0 0 0 rg (as) Tj T* 0 Tw (follows:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 333.4772 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 72 re B*
Q
q
BT 1 0 0 1 0 50 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( from enum import Enum) Tj T* (>) Tj (>) Tj (>) Tj ( class Color\(Enum\):) Tj T* (...     red = 1) Tj T* (...     green = 2) Tj T* (...     blue = 3) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 313.4772 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Note: Nomenclature) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 307.4772 cm
Q
q
1 0 0 1 62.69291 229.4772 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
BT 1 0 0 1 0 2 Tm  T* ET
q
1 0 0 1 20 72 cm
Q
q
1 0 0 1 20 72 cm
Q
q
1 0 0 1 20 60 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
q
1 0 0 1 6 -3 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL 10.5 0 Td (\177) Tj T* -10.5 0 Td ET
Q
Q
q
1 0 0 1 23 -3 cm
q
BT 1 0 0 1 0 2 Tm 12 TL /F1 10 Tf 0 0 0 rg (The class ) Tj /F4 10 Tf 0 0 0 rg (Color ) Tj /F1 10 Tf 0 0 0 rg (is an ) Tj /F5 10 Tf (enumeration ) Tj /F1 10 Tf (\(or ) Tj /F5 10 Tf (enum) Tj /F1 10 Tf (\)) Tj T* ET
Q
Q
q
Q
Q
q
1 0 0 1 20 54 cm
Q
q
1 0 0 1 20 30 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
q
1 0 0 1 6 9 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL 10.5 0 Td (\177) Tj T* -10.5 0 Td ET
Q
Q
q
1 0 0 1 23 -3 cm
q
BT 1 0 0 1 0 14 Tm 5.568863 Tw 12 TL /F1 10 Tf 0 0 0 rg (The attributes ) Tj /F4 10 Tf 0 0 0 rg (Color.red) Tj /F1 10 Tf 0 0 0 rg (, ) Tj /F4 10 Tf 0 0 0 rg (Color.green) Tj /F1 10 Tf 0 0 0 rg (, etc., are ) Tj /F5 10 Tf (enumeration members ) Tj /F1 10 Tf (\(or ) Tj /F5 10 Tf (enum) Tj T* 0 Tw (members) Tj /F1 10 Tf (\).) Tj T* ET
Q
Q
q
Q
Q
q
1 0 0 1 20 24 cm
Q
q
1 0 0 1 20 0 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
q
1 0 0 1 6 9 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL 10.5 0 Td (\177) Tj T* -10.5 0 Td ET
Q
Q
q
1 0 0 1 23 -3 cm
q
BT 1 0 0 1 0 14 Tm 1.471318 Tw 12 TL /F1 10 Tf 0 0 0 rg (The enum members have ) Tj /F5 10 Tf (names ) Tj /F1 10 Tf (and ) Tj /F5 10 Tf (values ) Tj /F1 10 Tf (\(the name of ) Tj /F4 10 Tf 0 0 0 rg (Color.red ) Tj /F1 10 Tf 0 0 0 rg (is ) Tj /F4 10 Tf 0 0 0 rg (red) Tj /F1 10 Tf 0 0 0 rg (, the value of) Tj T* 0 Tw /F4 10 Tf 0 0 0 rg (Color.blue ) Tj /F1 10 Tf 0 0 0 rg (is ) Tj /F4 10 Tf 0 0 0 rg (3) Tj /F1 10 Tf 0 0 0 rg (, etc.\)) Tj T* ET
Q
Q
q
Q
Q
q
1 0 0 1 20 0 cm
Q
q
Q
Q
q
1 0 0 1 62.69291 229.4772 cm
Q
q
1 0 0 1 62.69291 211.4772 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Note:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 205.4772 cm
Q
q
1 0 0 1 62.69291 181.4772 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
BT 1 0 0 1 0 2 Tm  T* ET
q
1 0 0 1 20 0 cm
q
BT 1 0 0 1 0 14 Tm .126235 Tw 12 TL /F1 10 Tf 0 0 0 rg (Even though we use the ) Tj /F4 10 Tf 0 0 0 rg (class ) Tj /F1 10 Tf 0 0 0 rg (syntax to create Enums, Enums are not normal Python classes. See) Tj T* 0 Tw 0 0 .501961 rg (How are Enums different? ) Tj 0 0 0 rg (for more details.) Tj T* ET
Q
Q
q
Q
Q
q
1 0 0 1 62.69291 181.4772 cm
Q
q
1 0 0 1 62.69291 163.4772 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Enumeration members have human readable string representations:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 118.2772 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 36 re B*
Q
q
BT 1 0 0 1 0 14 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( print\(Color.red\)) Tj T* (Color.red) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 98.27717 cm
q
BT 1 0 0 1 0 2 Tm 12 TL /F1 10 Tf 0 0 0 rg (...while their ) Tj /F4 10 Tf 0 0 0 rg (repr ) Tj /F1 10 Tf 0 0 0 rg (has more information:) Tj T* ET
Q
Q
 
endstream
endobj
57 0 obj
<< /Length 4174 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 727.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 36 re B*
Q
q
BT 1 0 0 1 0 14 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( print\(repr\(Color.red\)\)) Tj T* (<) Tj (Color.red: 1) Tj (>) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 707.8236 cm
q
BT 1 0 0 1 0 2 Tm 12 TL /F1 10 Tf 0 0 0 rg (The ) Tj /F5 10 Tf (type ) Tj /F1 10 Tf (of an enumeration member is the enumeration it belongs to:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 626.6236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 72 re B*
Q
q
BT 1 0 0 1 0 50 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( type\(Color.red\)) Tj T* (<) Tj (enum 'Color') Tj (>) Tj  T* (>) Tj (>) Tj (>) Tj ( isinstance\(Color.green, Color\)) Tj T* (True) Tj T* (>) Tj (>) Tj (>) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 606.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Enum members also have a property that contains just their item name:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 561.4236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 36 re B*
Q
q
BT 1 0 0 1 0 14 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( print\(Color.red.name\)) Tj T* (red) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 529.4236 cm
q
BT 1 0 0 1 0 14 Tm .464985 Tw 12 TL /F1 10 Tf 0 0 0 rg (Enumerations support iteration. In Python 3.x definition order is used; in Python 2.x the definition order is) Tj T* 0 Tw (not available, but class attribute ) Tj /F4 10 Tf 0 0 0 rg (__order__ ) Tj /F1 10 Tf 0 0 0 rg (is supported; otherwise, value order is used:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 340.2236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 180 re B*
Q
q
BT 1 0 0 1 0 158 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( class Shake\(Enum\):) Tj T* (...   __order__ = 'vanilla chocolate cookies mint'  # only needed in 2.x) Tj T* (...   vanilla = 7) Tj T* (...   chocolate = 4) Tj T* (...   cookies = 9) Tj T* (...   mint = 3) Tj T* (...) Tj T* (>) Tj (>) Tj (>) Tj ( for shake in Shake:) Tj T* (...   print\(shake\)) Tj T* (...) Tj T* (Shake.vanilla) Tj T* (Shake.chocolate) Tj T* (Shake.cookies) Tj T* (Shake.mint) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 308.2236 cm
q
BT 1 0 0 1 0 14 Tm 1.893735 Tw 12 TL /F1 10 Tf 0 0 0 rg (The ) Tj /F4 10 Tf 0 0 0 rg (__order__ ) Tj /F1 10 Tf 0 0 0 rg (attribute is always removed, and in 3.x it is also ignored \(order is definition order\);) Tj T* 0 Tw (however, in the stdlib version it will be ignored but not removed.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 290.2236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Enumeration members are hashable, so they can be used in dictionaries and sets:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 209.0236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 72 re B*
Q
q
BT 1 0 0 1 0 50 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( apples = {}) Tj T* (>) Tj (>) Tj (>) Tj ( apples[Color.red] = 'red delicious') Tj T* (>) Tj (>) Tj (>) Tj ( apples[Color.green] = 'granny smith') Tj T* (>) Tj (>) Tj (>) Tj ( apples == {Color.red: 'red delicious', Color.green: 'granny smith'}) Tj T* (True) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 155.0236 cm
q
BT 1 0 0 1 0 24.5 Tm 21 TL /F3 17.5 Tf 0 0 0 rg (Programmatic access to enumeration members and) Tj T* (their attributes) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 113.0236 cm
q
BT 1 0 0 1 0 26 Tm 3.541797 Tw 12 TL /F1 10 Tf 0 0 0 rg (Sometimes it's useful to access members in enumerations programmatically \(i.e. situations where) Tj T* 0 Tw .922651 Tw /F4 10 Tf 0 0 0 rg (Color.red ) Tj /F1 10 Tf 0 0 0 rg (won't do because the exact color is not known at program-writing time\). ) Tj /F4 10 Tf 0 0 0 rg (Enum ) Tj /F1 10 Tf 0 0 0 rg (allows such) Tj T* 0 Tw (access:) Tj T* ET
Q
Q
 
endstream
endobj
58 0 obj
<< /Length 3791 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 703.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 60 re B*
Q
q
BT 1 0 0 1 0 38 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( Color\(1\)) Tj T* (<) Tj (Color.red: 1) Tj (>) Tj  T* (>) Tj (>) Tj (>) Tj ( Color\(3\)) Tj T* (<) Tj (Color.blue: 3) Tj (>) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 683.8236 cm
q
BT 1 0 0 1 0 2 Tm 12 TL /F1 10 Tf 0 0 0 rg (If you want to access enum members by ) Tj /F5 10 Tf (name) Tj /F1 10 Tf (, use item access:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 614.6236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 60 re B*
Q
q
BT 1 0 0 1 0 38 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( Color['red']) Tj T* (<) Tj (Color.red: 1) Tj (>) Tj  T* (>) Tj (>) Tj (>) Tj ( Color['green']) Tj T* (<) Tj (Color.green: 2) Tj (>) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 594.6236 cm
q
BT 1 0 0 1 0 2 Tm 12 TL /F1 10 Tf 0 0 0 rg (If have an enum member and need its ) Tj /F4 10 Tf 0 0 0 rg (name ) Tj /F1 10 Tf 0 0 0 rg (or ) Tj /F4 10 Tf 0 0 0 rg (value) Tj /F1 10 Tf 0 0 0 rg (:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 513.4236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 72 re B*
Q
q
BT 1 0 0 1 0 50 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( member = Color.red) Tj T* (>) Tj (>) Tj (>) Tj ( member.name) Tj T* ('red') Tj T* (>) Tj (>) Tj (>) Tj ( member.value) Tj T* (1) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 480.4236 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F3 17.5 Tf 0 0 0 rg (Duplicating enum members and values) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 450.4236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL .13832 Tw (Having two enum members \(or any other attribute\) with the same name is invalid; in Python 3.x this would) Tj T* 0 Tw (raise an error, but in Python 2.x the second member simply overwrites the first:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 249.2236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 192 re B*
Q
q
BT 1 0 0 1 0 170 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( # python 2.x) Tj T* (>) Tj (>) Tj (>) Tj ( class Shape\(Enum\):) Tj T* (...   square = 2) Tj T* (...   square = 3) Tj T* (...) Tj T* (>) Tj (>) Tj (>) Tj ( Shape.square) Tj T* (<) Tj (Shape.square: 3) Tj (>) Tj  T*  T* (>) Tj (>) Tj (>) Tj ( # python 3.x) Tj T* (>) Tj (>) Tj (>) Tj ( class Shape\(Enum\):) Tj T* (...   square = 2) Tj T* (...   square = 3) Tj T* (Traceback \(most recent call last\):) Tj T* (...) Tj T* (TypeError: Attempted to reuse key: 'square') Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 205.2236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL .384987 Tw (However, two enum members are allowed to have the same value. Given two members A and B with the) Tj T* 0 Tw .444772 Tw (same value \(and A defined first\), B is an alias to A. By-value lookup of the value of A and B will return A.) Tj T* 0 Tw (By-name lookup of B will also return A:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 88.02362 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 492 108 re B*
Q
q
BT 1 0 0 1 0 86 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( class Shape\(Enum\):) Tj T* (...   __order__ = 'square diamond circle alias_for_square'  # only needed in 2.x) Tj T* (...   square = 2) Tj T* (...   diamond = 1) Tj T* (...   circle = 3) Tj T* (...   alias_for_square = 2) Tj T* (...) Tj T* (>) Tj (>) Tj (>) Tj ( Shape.square) Tj T* ET
Q
Q
Q
Q
Q
 
endstream
endobj
59 0 obj
<< /Length 4406 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 691.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 72 re B*
Q
q
BT 1 0 0 1 0 50 Tm 12 TL /F4 10 Tf 0 0 0 rg (<) Tj (Shape.square: 2) Tj (>) Tj  T* (>) Tj (>) Tj (>) Tj ( Shape.alias_for_square) Tj T* (<) Tj (Shape.square: 2) Tj (>) Tj  T* (>) Tj (>) Tj (>) Tj ( Shape\(2\)) Tj T* (<) Tj (Shape.square: 2) Tj (>) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 659.8236 cm
q
BT 1 0 0 1 0 14 Tm 1.074104 Tw 12 TL /F1 10 Tf 0 0 0 rg (Allowing aliases is not always desirable. ) Tj /F4 10 Tf 0 0 0 rg (unique ) Tj /F1 10 Tf 0 0 0 rg (can be used to ensure that none exist in a particular) Tj T* 0 Tw (enumeration:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 506.6236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 144 re B*
Q
q
BT 1 0 0 1 0 122 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( from enum import unique) Tj T* (>) Tj (>) Tj (>) Tj ( @unique) Tj T* (... class Mistake\(Enum\):) Tj T* (...   __order__ = 'one two three four'  # only needed in 2.x) Tj T* (...   one = 1) Tj T* (...   two = 2) Tj T* (...   three = 3) Tj T* (...   four = 3) Tj T* (Traceback \(most recent call last\):) Tj T* (...) Tj T* (ValueError: duplicate names found in ) Tj (<) Tj (enum 'Mistake') Tj (>) Tj (: four -) Tj (>) Tj ( three) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 486.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Iterating over the members of an enum does not provide the aliases:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 441.4236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 36 re B*
Q
q
BT 1 0 0 1 0 14 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( list\(Shape\)) Tj T* ([) Tj (<) Tj (Shape.square: 2) Tj (>) Tj (, ) Tj (<) Tj (Shape.diamond: 1) Tj (>) Tj (, ) Tj (<) Tj (Shape.circle: 3) Tj (>) Tj (]) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 409.4236 cm
q
BT 1 0 0 1 0 14 Tm 1.307126 Tw 12 TL /F1 10 Tf 0 0 0 rg (The special attribute ) Tj /F4 10 Tf 0 0 0 rg (__members__ ) Tj /F1 10 Tf 0 0 0 rg (is a dictionary mapping names to members. It includes all names) Tj T* 0 Tw (defined in the enumeration, including the aliases:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 304.2236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 96 re B*
Q
q
BT 1 0 0 1 0 74 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( for name, member in sorted\(Shape.__members__.items\(\)\):) Tj T* (...   name, member) Tj T* (...) Tj T* (\('alias_for_square', ) Tj (<) Tj (Shape.square: 2) Tj (>) Tj (\)) Tj T* (\('circle', ) Tj (<) Tj (Shape.circle: 3) Tj (>) Tj (\)) Tj T* (\('diamond', ) Tj (<) Tj (Shape.diamond: 1) Tj (>) Tj (\)) Tj T* (\('square', ) Tj (<) Tj (Shape.square: 2) Tj (>) Tj (\)) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 272.2236 cm
q
BT 1 0 0 1 0 14 Tm .080751 Tw 12 TL /F1 10 Tf 0 0 0 rg (The ) Tj /F4 10 Tf 0 0 0 rg (__members__ ) Tj /F1 10 Tf 0 0 0 rg (attribute can be used for detailed programmatic access to the enumeration members.) Tj T* 0 Tw (For example, finding all the aliases:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 227.0236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 486 36 re B*
Q
q
BT 1 0 0 1 0 14 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( [name for name, member in Shape.__members__.items\(\) if member.name != name]) Tj T* (['alias_for_square']) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 194.0236 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F3 17.5 Tf 0 0 0 rg (Comparisons) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 176.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Enumeration members are compared by identity:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 82.82362 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 84 re B*
Q
q
BT 1 0 0 1 0 62 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( Color.red is Color.red) Tj T* (True) Tj T* (>) Tj (>) Tj (>) Tj ( Color.red is Color.blue) Tj T* (False) Tj T* (>) Tj (>) Tj (>) Tj ( Color.red is not Color.blue) Tj T* (True) Tj T* ET
Q
Q
Q
Q
Q
 
endstream
endobj
60 0 obj
<< /Length 4521 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 741.0236 cm
q
BT 1 0 0 1 0 14 Tm 1.131647 Tw 12 TL /F1 10 Tf 0 0 0 rg (Ordered comparisons between enumeration values are ) Tj /F5 10 Tf (not ) Tj /F1 10 Tf (supported. Enum members are not integers) Tj T* 0 Tw (\(but see ) Tj 0 0 .501961 rg (IntEnum ) Tj 0 0 0 rg (below\):) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 671.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 60 re B*
Q
q
BT 1 0 0 1 0 38 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( Color.red ) Tj (<) Tj ( Color.blue) Tj T* (Traceback \(most recent call last\):) Tj T* (  File ") Tj (<) Tj (stdin) Tj (>) Tj (", line 1, in ) Tj (<) Tj (module) Tj (>) Tj  T* (TypeError: unorderable types: Color\(\) ) Tj (<) Tj ( Color\(\)) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 651.8236 cm
Q
q
1 0 0 1 62.69291 568.8236 cm
.960784 .960784 .862745 rg
n 0 83 469.8898 -83 re f*
0 0 0 rg
BT /F1 10 Tf 12 TL ET
BT 1 0 0 1 6 57 Tm  T* ET
q
1 0 0 1 16 52 cm
q
0 0 0 rg
BT 1 0 0 1 0 2.5 Tm /F6 12.5 Tf 15 TL (Warning) Tj T* ET
Q
Q
q
1 0 0 1 16 16 cm
q
BT 1 0 0 1 0 14 Tm .189398 Tw 12 TL /F1 10 Tf 0 0 0 rg (In Python 2 ) Tj /F5 10 Tf (everything ) Tj /F1 10 Tf (is ordered, even though the ordering may not make sense. If you want your) Tj T* 0 Tw (enumerations to have a sensible ordering check out the ) Tj 0 0 .501961 rg (OrderedEnum ) Tj 0 0 0 rg (recipe below.) Tj T* ET
Q
Q
q
1 J
1 j
.662745 .662745 .662745 RG
.5 w
n 0 83 m 469.8898 83 l S
n 0 0 m 469.8898 0 l S
n 0 0 m 0 83 l S
n 469.8898 0 m 469.8898 83 l S
Q
Q
q
1 0 0 1 62.69291 562.8236 cm
Q
q
1 0 0 1 62.69291 544.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Equality comparisons are defined though:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 451.6236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 84 re B*
Q
q
BT 1 0 0 1 0 62 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( Color.blue == Color.red) Tj T* (False) Tj T* (>) Tj (>) Tj (>) Tj ( Color.blue != Color.red) Tj T* (True) Tj T* (>) Tj (>) Tj (>) Tj ( Color.blue == Color.blue) Tj T* (True) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 419.6236 cm
q
BT 1 0 0 1 0 14 Tm 2.582706 Tw 12 TL /F1 10 Tf 0 0 0 rg (Comparisons against non-enumeration values will always compare not equal \(again, ) Tj /F4 10 Tf 0 0 0 rg (IntEnum ) Tj /F1 10 Tf 0 0 0 rg (was) Tj T* 0 Tw (explicitly designed to behave differently, see below\):) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 374.4236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 36 re B*
Q
q
BT 1 0 0 1 0 14 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( Color.blue == 2) Tj T* (False) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 341.4236 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F3 17.5 Tf 0 0 0 rg (Allowed members and attributes of enumerations) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 287.4236 cm
q
BT 1 0 0 1 0 38 Tm 2.755697 Tw 12 TL /F1 10 Tf 0 0 0 rg (The examples above use integers for enumeration values. Using integers is short and handy \(and) Tj T* 0 Tw .241751 Tw (provided by default by the ) Tj 0 0 .501961 rg (Functional API) Tj 0 0 0 rg (\), but not strictly enforced. In the vast majority of use-cases, one) Tj T* 0 Tw .848221 Tw (doesn't care what the actual value of an enumeration is. But if the value ) Tj /F5 10 Tf (is ) Tj /F1 10 Tf (important, enumerations can) Tj T* 0 Tw (have arbitrary values.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 257.4236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL .638735 Tw (Enumerations are Python classes, and can have methods and special methods as usual. If we have this) Tj T* 0 Tw (enumeration:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 80.22362 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 168 re B*
Q
q
BT 1 0 0 1 0 146 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( class Mood\(Enum\):) Tj T* (...   funky = 1) Tj T* (...   happy = 3) Tj T* (...) Tj T* (...   def describe\(self\):) Tj T* (...     # self is the member here) Tj T* (...     return self.name, self.value) Tj T* (...) Tj T* (...   def __str__\(self\):) Tj T* (...     return 'my custom str! {0}'.format\(self.value\)) Tj T* (...) Tj T* (...   @classmethod) Tj T* (...   def favorite_mood\(cls\):) Tj T* ET
Q
Q
Q
Q
Q
 
endstream
endobj
61 0 obj
<< /Length 4627 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 727.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 36 re B*
Q
q
BT 1 0 0 1 0 14 Tm 12 TL /F4 10 Tf 0 0 0 rg (...     # cls here is the enumeration) Tj T* (...     return cls.happy) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 707.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Then:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 614.6236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 84 re B*
Q
q
BT 1 0 0 1 0 62 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( Mood.favorite_mood\(\)) Tj T* (<) Tj (Mood.happy: 3) Tj (>) Tj  T* (>) Tj (>) Tj (>) Tj ( Mood.happy.describe\(\)) Tj T* (\('happy', 3\)) Tj T* (>) Tj (>) Tj (>) Tj ( str\(Mood.funky\)) Tj T* ('my custom str! 1') Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 558.6236 cm
q
BT 1 0 0 1 0 38 Tm 3.14186 Tw 12 TL /F1 10 Tf 0 0 0 rg (The rules for what is allowed are as follows: _sunder_ names \(starting and ending with a single) Tj T* 0 Tw .310651 Tw (underscore\) are reserved by enum and cannot be used; all other attributes defined within an enumeration) Tj T* 0 Tw 2.199213 Tw (will become members of this enumeration, with the exception of ) Tj /F5 10 Tf (__dunder__ ) Tj /F1 10 Tf (names and descriptors) Tj T* 0 Tw (\(methods are also descriptors\).) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 540.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Note:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 534.6236 cm
Q
q
1 0 0 1 62.69291 510.6236 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
BT 1 0 0 1 0 2 Tm  T* ET
q
1 0 0 1 20 0 cm
q
BT 1 0 0 1 0 14 Tm .979213 Tw 12 TL /F1 10 Tf 0 0 0 rg (If your enumeration defines ) Tj /F4 10 Tf 0 0 0 rg (__new__ ) Tj /F1 10 Tf 0 0 0 rg (and/or ) Tj /F4 10 Tf 0 0 0 rg (__init__ ) Tj /F1 10 Tf 0 0 0 rg (then whatever value\(s\) were given to the) Tj T* 0 Tw (enum member will be passed into those methods. See ) Tj 0 0 .501961 rg (Planet ) Tj 0 0 0 rg (for an example.) Tj T* ET
Q
Q
q
Q
Q
q
1 0 0 1 62.69291 510.6236 cm
Q
q
1 0 0 1 62.69291 477.6236 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F3 17.5 Tf 0 0 0 rg (Restricted subclassing of enumerations) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 447.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL .778735 Tw (Subclassing an enumeration is allowed only if the enumeration does not define any members. So this is) Tj T* 0 Tw (forbidden:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 366.4236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 72 re B*
Q
q
BT 1 0 0 1 0 50 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( class MoreColor\(Color\):) Tj T* (...   pink = 17) Tj T* (Traceback \(most recent call last\):) Tj T* (...) Tj T* (TypeError: Cannot extend enumerations) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 346.4236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (But this is allowed:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 229.2236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 108 re B*
Q
q
BT 1 0 0 1 0 86 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( class Foo\(Enum\):) Tj T* (...   def some_behavior\(self\):) Tj T* (...     pass) Tj T* (...) Tj T* (>) Tj (>) Tj (>) Tj ( class Bar\(Foo\):) Tj T* (...   happy = 1) Tj T* (...   sad = 2) Tj T* (...) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 185.2236 cm
q
BT 1 0 0 1 0 26 Tm .127984 Tw 12 TL /F1 10 Tf 0 0 0 rg (Allowing subclassing of enums that define members would lead to a violation of some important invariants) Tj T* 0 Tw 1.889985 Tw (of types and instances. On the other hand, it makes sense to allow sharing some common behavior) Tj T* 0 Tw (between a group of enumerations. \(See ) Tj 0 0 .501961 rg (OrderedEnum ) Tj 0 0 0 rg (for an example.\)) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 152.2236 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F3 17.5 Tf 0 0 0 rg (Pickling) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 134.2236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Enumerations can be pickled and unpickled:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 89.02362 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 36 re B*
Q
q
BT 1 0 0 1 0 14 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( from enum.test_enum import Fruit) Tj T* (>) Tj (>) Tj (>) Tj ( from pickle import dumps, loads) Tj T* ET
Q
Q
Q
Q
Q
 
endstream
endobj
62 0 obj
<< /Length 5372 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 727.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 36 re B*
Q
q
BT 1 0 0 1 0 14 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( Fruit.tomato is loads\(dumps\(Fruit.tomato, 2\)\)) Tj T* (True) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 695.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL 1.256457 Tw (The usual restrictions for pickling apply: picklable enums must be defined in the top level of a module,) Tj T* 0 Tw (since unpickling requires them to be importable from that module.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 677.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Note:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 671.8236 cm
Q
q
1 0 0 1 62.69291 647.8236 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
BT 1 0 0 1 0 2 Tm  T* ET
q
1 0 0 1 20 0 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL .081163 Tw (With pickle protocol version 4 \(introduced in Python 3.4\) it is possible to easily pickle enums nested in) Tj T* 0 Tw (other classes.) Tj T* ET
Q
Q
q
Q
Q
q
1 0 0 1 62.69291 647.8236 cm
Q
q
1 0 0 1 62.69291 614.8236 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F3 17.5 Tf 0 0 0 rg (Functional API) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 596.8236 cm
q
BT 1 0 0 1 0 2 Tm 12 TL /F1 10 Tf 0 0 0 rg (The ) Tj /F4 10 Tf 0 0 0 rg (Enum ) Tj /F1 10 Tf 0 0 0 rg (class is callable, providing the following functional API:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 467.6236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 120 re B*
Q
q
BT 1 0 0 1 0 98 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( Animal = Enum\('Animal', 'ant bee cat dog'\)) Tj T* (>) Tj (>) Tj (>) Tj ( Animal) Tj T* (<) Tj (enum 'Animal') Tj (>) Tj  T* (>) Tj (>) Tj (>) Tj ( Animal.ant) Tj T* (<) Tj (Animal.ant: 1) Tj (>) Tj  T* (>) Tj (>) Tj (>) Tj ( Animal.ant.value) Tj T* (1) Tj T* (>) Tj (>) Tj (>) Tj ( list\(Animal\)) Tj T* ([) Tj (<) Tj (Animal.ant: 1) Tj (>) Tj (, ) Tj (<) Tj (Animal.bee: 2) Tj (>) Tj (, ) Tj (<) Tj (Animal.cat: 3) Tj (>) Tj (, ) Tj (<) Tj (Animal.dog: 4) Tj (>) Tj (]) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 435.6236 cm
q
BT 1 0 0 1 0 14 Tm .602209 Tw 12 TL /F1 10 Tf 0 0 0 rg (The semantics of this API resemble ) Tj /F4 10 Tf 0 0 0 rg (namedtuple) Tj /F1 10 Tf 0 0 0 rg (. The first argument of the call to ) Tj /F4 10 Tf 0 0 0 rg (Enum ) Tj /F1 10 Tf 0 0 0 rg (is the name of) Tj T* 0 Tw (the enumeration.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 369.6236 cm
q
BT 1 0 0 1 0 50 Tm 1.326412 Tw 12 TL /F1 10 Tf 0 0 0 rg (The second argument is the ) Tj /F5 10 Tf (source ) Tj /F1 10 Tf (of enumeration member names. It can be a whitespace-separated) Tj T* 0 Tw .993516 Tw (string of names, a sequence of names, a sequence of 2-tuples with key/value pairs, or a mapping \(e.g.) Tj T* 0 Tw 1.168555 Tw (dictionary\) of names to values. The last two options enable assigning arbitrary values to enumerations;) Tj T* 0 Tw .537485 Tw (the others auto-assign increasing integers starting with 1. A new class derived from ) Tj /F4 10 Tf 0 0 0 rg (Enum ) Tj /F1 10 Tf 0 0 0 rg (is returned. In) Tj T* 0 Tw (other words, the above assignment to ) Tj /F4 10 Tf 0 0 0 rg (Animal ) Tj /F1 10 Tf 0 0 0 rg (is equivalent to:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 288.4236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 72 re B*
Q
q
BT 1 0 0 1 0 50 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( class Animals\(Enum\):) Tj T* (...   ant = 1) Tj T* (...   bee = 2) Tj T* (...   cat = 3) Tj T* (...   dog = 4) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 232.4236 cm
q
0 0 0 rg
BT 1 0 0 1 0 38 Tm /F1 10 Tf 12 TL 1.239984 Tw (Pickling enums created with the functional API can be tricky as frame stack implementation details are) Tj T* 0 Tw .937132 Tw (used to try and figure out which module the enumeration is being created in \(e.g. it will fail if you use a) Tj T* 0 Tw 1.321163 Tw (utility function in separate module, and also may not work on IronPython or Jython\). The solution is to) Tj T* 0 Tw (specify the module name explicitly as follows:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 199.2236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 24 re B*
Q
q
BT 1 0 0 1 0 2 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( Animals = Enum\('Animals', 'ant bee cat dog', module=__name__\)) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 166.2236 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F3 17.5 Tf 0 0 0 rg (Derived Enumerations) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 136.2236 cm
q
BT 1 0 0 1 0 3 Tm 18 TL /F3 15 Tf 0 0 0 rg (IntEnum) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 94.22362 cm
q
BT 1 0 0 1 0 26 Tm 1.99832 Tw 12 TL /F1 10 Tf 0 0 0 rg (A variation of ) Tj /F4 10 Tf 0 0 0 rg (Enum ) Tj /F1 10 Tf 0 0 0 rg (is provided which is also a subclass of ) Tj /F4 10 Tf 0 0 0 rg (int) Tj /F1 10 Tf 0 0 0 rg (. Members of an ) Tj /F4 10 Tf 0 0 0 rg (IntEnum ) Tj /F1 10 Tf 0 0 0 rg (can be) Tj T* 0 Tw .087984 Tw (compared to integers; by extension, integer enumerations of different types can also be compared to each) Tj T* 0 Tw (other:) Tj T* ET
Q
Q
 
endstream
endobj
63 0 obj
<< /Length 4141 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 571.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 192 re B*
Q
q
BT 1 0 0 1 0 170 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( from enum import IntEnum) Tj T* (>) Tj (>) Tj (>) Tj ( class Shape\(IntEnum\):) Tj T* (...   circle = 1) Tj T* (...   square = 2) Tj T* (...) Tj T* (>) Tj (>) Tj (>) Tj ( class Request\(IntEnum\):) Tj T* (...   post = 1) Tj T* (...   get = 2) Tj T* (...) Tj T* (>) Tj (>) Tj (>) Tj ( Shape == 1) Tj T* (False) Tj T* (>) Tj (>) Tj (>) Tj ( Shape.circle == 1) Tj T* (True) Tj T* (>) Tj (>) Tj (>) Tj ( Shape.circle == Request.post) Tj T* (True) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 551.8236 cm
q
BT 1 0 0 1 0 2 Tm 12 TL /F1 10 Tf 0 0 0 rg (However, they still can't be compared to standard ) Tj /F4 10 Tf 0 0 0 rg (Enum ) Tj /F1 10 Tf 0 0 0 rg (enumerations:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 410.6236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 132 re B*
Q
q
BT 1 0 0 1 0 110 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( class Shape\(IntEnum\):) Tj T* (...   circle = 1) Tj T* (...   square = 2) Tj T* (...) Tj T* (>) Tj (>) Tj (>) Tj ( class Color\(Enum\):) Tj T* (...   red = 1) Tj T* (...   green = 2) Tj T* (...) Tj T* (>) Tj (>) Tj (>) Tj ( Shape.circle == Color.red) Tj T* (False) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 390.6236 cm
q
BT 1 0 0 1 0 2 Tm 12 TL /F4 10 Tf 0 0 0 rg (IntEnum ) Tj /F1 10 Tf 0 0 0 rg (values behave like integers in other ways you'd expect:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 297.4236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 84 re B*
Q
q
BT 1 0 0 1 0 62 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( int\(Shape.circle\)) Tj T* (1) Tj T* (>) Tj (>) Tj (>) Tj ( ['a', 'b', 'c'][Shape.circle]) Tj T* ('b') Tj T* (>) Tj (>) Tj (>) Tj ( [i for i in range\(Shape.square\)]) Tj T* ([0, 1]) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 229.4236 cm
q
BT 1 0 0 1 0 50 Tm 1.197126 Tw 12 TL /F1 10 Tf 0 0 0 rg (For the vast majority of code, ) Tj /F4 10 Tf 0 0 0 rg (Enum ) Tj /F1 10 Tf 0 0 0 rg (is strongly recommended, since ) Tj /F4 10 Tf 0 0 0 rg (IntEnum ) Tj /F1 10 Tf 0 0 0 rg (breaks some semantic) Tj T* 0 Tw .793318 Tw (promises of an enumeration \(by being comparable to integers, and thus by transitivity to other unrelated) Tj T* 0 Tw .554985 Tw (enumerations\). It should be used only in special cases where there's no other choice; for example, when) Tj T* 0 Tw .746136 Tw (integer constants are replaced with enumerations and backwards compatibility is required with code that) Tj T* 0 Tw (still expects integers.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 199.4236 cm
q
BT 1 0 0 1 0 3 Tm 18 TL /F3 15 Tf 0 0 0 rg (Others) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 181.4236 cm
q
BT 1 0 0 1 0 2 Tm 12 TL /F1 10 Tf 0 0 0 rg (While ) Tj /F4 10 Tf 0 0 0 rg (IntEnum ) Tj /F1 10 Tf 0 0 0 rg (is part of the ) Tj /F4 10 Tf 0 0 0 rg (enum ) Tj /F1 10 Tf 0 0 0 rg (module, it would be very simple to implement independently:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 136.2236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 36 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F4 10 Tf 12 TL (class IntEnum\(int, Enum\):) Tj T* (    pass) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 104.2236 cm
q
BT 1 0 0 1 0 14 Tm .361412 Tw 12 TL /F1 10 Tf 0 0 0 rg (This demonstrates how similar derived enumerations can be defined; for example a ) Tj /F4 10 Tf 0 0 0 rg (StrEnum ) Tj /F1 10 Tf 0 0 0 rg (that mixes) Tj T* 0 Tw (in ) Tj /F4 10 Tf 0 0 0 rg (str ) Tj /F1 10 Tf 0 0 0 rg (instead of ) Tj /F4 10 Tf 0 0 0 rg (int) Tj /F1 10 Tf 0 0 0 rg (.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 86.22362 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Some rules:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 80.22362 cm
Q
q
1 0 0 1 62.69291 80.22362 cm
Q
 
endstream
endobj
64 0 obj
<< /Length 7108 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 741.0236 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
q
1 0 0 1 6 9 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL 5.66 0 Td (1.) Tj T* -5.66 0 Td ET
Q
Q
q
1 0 0 1 23 -3 cm
q
BT 1 0 0 1 0 14 Tm .477318 Tw 12 TL /F1 10 Tf 0 0 0 rg (When subclassing ) Tj /F4 10 Tf 0 0 0 rg (Enum) Tj /F1 10 Tf 0 0 0 rg (, mix-in types must appear before ) Tj /F4 10 Tf 0 0 0 rg (Enum ) Tj /F1 10 Tf 0 0 0 rg (itself in the sequence of bases, as) Tj T* 0 Tw (in the ) Tj /F4 10 Tf 0 0 0 rg (IntEnum ) Tj /F1 10 Tf 0 0 0 rg (example above.) Tj T* ET
Q
Q
q
Q
Q
q
1 0 0 1 62.69291 735.0236 cm
Q
q
1 0 0 1 62.69291 699.0236 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
q
1 0 0 1 6 21 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL 5.66 0 Td (2.) Tj T* -5.66 0 Td ET
Q
Q
q
1 0 0 1 23 -3 cm
q
BT 1 0 0 1 0 26 Tm 1.147045 Tw 12 TL /F1 10 Tf 0 0 0 rg (While ) Tj /F4 10 Tf 0 0 0 rg (Enum ) Tj /F1 10 Tf 0 0 0 rg (can have members of any type, once you mix in an additional type, all the members) Tj T* 0 Tw .420574 Tw (must have values of that type, e.g. ) Tj /F4 10 Tf 0 0 0 rg (int ) Tj /F1 10 Tf 0 0 0 rg (above. This restriction does not apply to mix-ins which only) Tj T* 0 Tw (add methods and don't specify another data type such as ) Tj /F4 10 Tf 0 0 0 rg (int ) Tj /F1 10 Tf 0 0 0 rg (or ) Tj /F4 10 Tf 0 0 0 rg (str) Tj /F1 10 Tf 0 0 0 rg (.) Tj T* ET
Q
Q
q
Q
Q
q
1 0 0 1 62.69291 693.0236 cm
Q
q
1 0 0 1 62.69291 669.0236 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
q
1 0 0 1 6 9 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL 5.66 0 Td (3.) Tj T* -5.66 0 Td ET
Q
Q
q
1 0 0 1 23 -3 cm
q
BT 1 0 0 1 0 14 Tm .100542 Tw 12 TL /F1 10 Tf 0 0 0 rg (When another data type is mixed in, the ) Tj /F4 10 Tf 0 0 0 rg (value ) Tj /F1 10 Tf 0 0 0 rg (attribute is ) Tj /F5 10 Tf (not the same ) Tj /F1 10 Tf (as the enum member itself,) Tj T* 0 Tw (although it is equivalant and will compare equal.) Tj T* ET
Q
Q
q
Q
Q
q
1 0 0 1 62.69291 663.0236 cm
Q
q
1 0 0 1 62.69291 609.0236 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
q
1 0 0 1 6 39 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL 5.66 0 Td (4.) Tj T* -5.66 0 Td ET
Q
Q
q
1 0 0 1 23 27 cm
q
BT 1 0 0 1 0 14 Tm 1.85998 Tw 12 TL /F1 10 Tf 0 0 0 rg (%-style formatting: ) Tj /F4 10 Tf 0 0 0 rg (%s ) Tj /F1 10 Tf 0 0 0 rg (and ) Tj /F4 10 Tf 0 0 0 rg (%r ) Tj /F1 10 Tf 0 0 0 rg (call ) Tj /F4 10 Tf 0 0 0 rg (Enum) Tj /F1 10 Tf 0 0 0 rg ('s ) Tj /F4 10 Tf 0 0 0 rg (__str__ ) Tj /F1 10 Tf 0 0 0 rg (and ) Tj /F4 10 Tf 0 0 0 rg (__repr__ ) Tj /F1 10 Tf 0 0 0 rg (respectively; other codes) Tj T* 0 Tw (\(such as ) Tj /F4 10 Tf 0 0 0 rg (%i ) Tj /F1 10 Tf 0 0 0 rg (or ) Tj /F4 10 Tf 0 0 0 rg (%h ) Tj /F1 10 Tf 0 0 0 rg (for IntEnum\) treat the enum member as its mixed-in type.) Tj T* ET
Q
Q
q
1 0 0 1 23 -3 cm
q
BT 1 0 0 1 0 14 Tm .067045 Tw 12 TL /F1 10 Tf 0 0 0 rg (Note: Prior to Python 3.4 there is a bug in ) Tj /F4 10 Tf 0 0 0 rg (str) Tj /F1 10 Tf 0 0 0 rg ('s %-formatting: ) Tj /F4 10 Tf 0 0 0 rg (int ) Tj /F1 10 Tf 0 0 0 rg (subclasses are printed as strings) Tj T* 0 Tw (and not numbers when the ) Tj /F4 10 Tf 0 0 0 rg (%d) Tj /F1 10 Tf 0 0 0 rg (, ) Tj /F4 10 Tf 0 0 0 rg (%i) Tj /F1 10 Tf 0 0 0 rg (, or ) Tj /F4 10 Tf 0 0 0 rg (%u ) Tj /F1 10 Tf 0 0 0 rg (codes are used.) Tj T* ET
Q
Q
q
Q
Q
q
1 0 0 1 62.69291 603.0236 cm
Q
q
1 0 0 1 62.69291 579.0236 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
q
1 0 0 1 6 9 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL 5.66 0 Td (5.) Tj T* -5.66 0 Td ET
Q
Q
q
1 0 0 1 23 -3 cm
q
BT 1 0 0 1 0 14 Tm 1.880751 Tw 12 TL /F4 10 Tf 0 0 0 rg (str.__format__ ) Tj /F1 10 Tf 0 0 0 rg (\(or ) Tj /F4 10 Tf 0 0 0 rg (format) Tj /F1 10 Tf 0 0 0 rg (\) will use the mixed-in type's ) Tj /F4 10 Tf 0 0 0 rg (__format__) Tj /F1 10 Tf 0 0 0 rg (. If the ) Tj /F4 10 Tf 0 0 0 rg (Enum) Tj /F1 10 Tf 0 0 0 rg ('s ) Tj /F4 10 Tf 0 0 0 rg (str ) Tj /F1 10 Tf 0 0 0 rg (or) Tj T* 0 Tw /F4 10 Tf 0 0 0 rg (repr ) Tj /F1 10 Tf 0 0 0 rg (is desired use the ) Tj /F4 10 Tf 0 0 0 rg (!s ) Tj /F1 10 Tf 0 0 0 rg (or ) Tj /F4 10 Tf 0 0 0 rg (!r) Tj /F1 10 Tf 0 0 0 rg ( ) Tj /F4 10 Tf 0 0 0 rg (str ) Tj /F1 10 Tf 0 0 0 rg (format codes.) Tj T* ET
Q
Q
q
Q
Q
q
1 0 0 1 62.69291 579.0236 cm
Q
q
1 0 0 1 62.69291 546.0236 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F3 17.5 Tf 0 0 0 rg (Decorators) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 516.0236 cm
q
BT 1 0 0 1 0 3 Tm 18 TL /F3 15 Tf 0 0 0 rg (unique) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 486.0236 cm
q
BT 1 0 0 1 0 14 Tm .287251 Tw 12 TL /F1 10 Tf 0 0 0 rg (A ) Tj /F4 10 Tf 0 0 0 rg (class ) Tj /F1 10 Tf 0 0 0 rg (decorator specifically for enumerations. It searches an enumeration's ) Tj /F4 10 Tf 0 0 0 rg (__members__ ) Tj /F1 10 Tf 0 0 0 rg (gathering) Tj T* 0 Tw (any aliases it finds; if any are found ) Tj /F4 10 Tf 0 0 0 rg (ValueError ) Tj /F1 10 Tf 0 0 0 rg (is raised with the details:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 368.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 108 re B*
Q
q
BT 1 0 0 1 0 86 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( @unique) Tj T* (... class NoDupes\(Enum\):) Tj T* (...    first = 'one') Tj T* (...    second = 'two') Tj T* (...    third = 'two') Tj T* (Traceback \(most recent call last\):) Tj T* (...) Tj T* (ValueError: duplicate names found in ) Tj (<) Tj (enum 'NoDupes') Tj (>) Tj (: third -) Tj (>) Tj ( second) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 335.8236 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F3 17.5 Tf 0 0 0 rg (Interesting examples) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 293.8236 cm
q
BT 1 0 0 1 0 26 Tm .593735 Tw 12 TL /F1 10 Tf 0 0 0 rg (While ) Tj /F4 10 Tf 0 0 0 rg (Enum ) Tj /F1 10 Tf 0 0 0 rg (and ) Tj /F4 10 Tf 0 0 0 rg (IntEnum ) Tj /F1 10 Tf 0 0 0 rg (are expected to cover the majority of use-cases, they cannot cover them all.) Tj T* 0 Tw .897045 Tw (Here are recipes for some different types of enumerations that can be used directly, or as examples for) Tj T* 0 Tw (creating one's own.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 263.8236 cm
q
BT 1 0 0 1 0 3 Tm 18 TL /F3 15 Tf 0 0 0 rg (AutoNumber) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 245.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Avoids having to specify the value for each enumeration member:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 80.62362 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 156 re B*
Q
q
BT 1 0 0 1 0 134 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( class AutoNumber\(Enum\):) Tj T* (...     def __new__\(cls\):) Tj T* (...         value = len\(cls.__members__\) + 1) Tj T* (...         obj = object.__new__\(cls\)) Tj T* (...         obj._value_ = value) Tj T* (...         return obj) Tj T* (...) Tj T* (>) Tj (>) Tj (>) Tj ( class Color\(AutoNumber\):) Tj T* (...     __order__ = "red green blue"  # only needed in 2.x) Tj T* (...     red = \(\)) Tj T* (...     green = \(\)) Tj T* (...     blue = \(\)) Tj T* ET
Q
Q
Q
Q
Q
 
endstream
endobj
65 0 obj
<< /Length 4158 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 715.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 48 re B*
Q
q
BT 1 0 0 1 0 26 Tm 12 TL /F4 10 Tf 0 0 0 rg (...) Tj T* (>) Tj (>) Tj (>) Tj ( Color.green.value == 2) Tj T* (True) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 695.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Note:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 689.8236 cm
Q
q
1 0 0 1 62.69291 653.8236 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
BT 1 0 0 1 0 2 Tm  T* ET
q
1 0 0 1 20 0 cm
q
BT 1 0 0 1 0 26 Tm .144104 Tw 12 TL /F1 10 Tf 0 0 0 rg (The ) Tj /F5 10 Tf 0 0 0 rg (__new__ ) Tj /F1 10 Tf 0 0 0 rg (method, if defined, is used during creation of the Enum members; it is then replaced by) Tj T* 0 Tw .799985 Tw (Enum's ) Tj /F5 10 Tf 0 0 0 rg (__new__ ) Tj /F1 10 Tf 0 0 0 rg (which is used after class creation for lookup of existing members. Due to the way) Tj T* 0 Tw (Enums are supposed to behave, there is no way to customize Enum's ) Tj /F5 10 Tf 0 0 0 rg (__new__) Tj /F1 10 Tf 0 0 0 rg (.) Tj T* ET
Q
Q
q
Q
Q
q
1 0 0 1 62.69291 653.8236 cm
Q
q
1 0 0 1 62.69291 623.8236 cm
q
BT 1 0 0 1 0 3 Tm 18 TL /F3 15 Tf 0 0 0 rg (UniqueEnum) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 605.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Raises an error if a duplicate member name is found instead of creating an alias:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 368.6236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 228 re B*
Q
q
BT 1 0 0 1 0 206 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( class UniqueEnum\(Enum\):) Tj T* (...     def __init__\(self, *args\):) Tj T* (...         cls = self.__class__) Tj T* (...         if any\(self.value == e.value for e in cls\):) Tj T* (...             a = self.name) Tj T* (...             e = cls\(self.value\).name) Tj T* (...             raise ValueError\() Tj T* (...                     "aliases not allowed in UniqueEnum:  %r --) Tj (>) Tj ( %r") Tj T* (...                     % \(a, e\)\)) Tj T* (...) Tj T* (>) Tj (>) Tj (>) Tj ( class Color\(UniqueEnum\):) Tj T* (...     red = 1) Tj T* (...     green = 2) Tj T* (...     blue = 3) Tj T* (...     grene = 2) Tj T* (Traceback \(most recent call last\):) Tj T* (...) Tj T* (ValueError: aliases not allowed in UniqueEnum:  'grene' --) Tj (>) Tj ( 'green') Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 338.6236 cm
q
BT 1 0 0 1 0 3 Tm 18 TL /F3 15 Tf 0 0 0 rg (OrderedEnum) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 308.6236 cm
q
BT 1 0 0 1 0 14 Tm 1.335984 Tw 12 TL /F1 10 Tf 0 0 0 rg (An ordered enumeration that is not based on ) Tj /F4 10 Tf 0 0 0 rg (IntEnum ) Tj /F1 10 Tf 0 0 0 rg (and so maintains the normal ) Tj /F4 10 Tf 0 0 0 rg (Enum ) Tj /F1 10 Tf 0 0 0 rg (invariants) Tj T* 0 Tw (\(such as not being comparable to other enumerations\):) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 83.42362 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 216 re B*
Q
q
BT 1 0 0 1 0 194 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( class OrderedEnum\(Enum\):) Tj T* (...     def __ge__\(self, other\):) Tj T* (...         if self.__class__ is other.__class__:) Tj T* (...             return self._value_ ) Tj (>) Tj (= other._value_) Tj T* (...         return NotImplemented) Tj T* (...     def __gt__\(self, other\):) Tj T* (...         if self.__class__ is other.__class__:) Tj T* (...             return self._value_ ) Tj (>) Tj ( other._value_) Tj T* (...         return NotImplemented) Tj T* (...     def __le__\(self, other\):) Tj T* (...         if self.__class__ is other.__class__:) Tj T* (...             return self._value_ ) Tj (<) Tj (= other._value_) Tj T* (...         return NotImplemented) Tj T* (...     def __lt__\(self, other\):) Tj T* (...         if self.__class__ is other.__class__:) Tj T* (...             return self._value_ ) Tj (<) Tj ( other._value_) Tj T* (...         return NotImplemented) Tj T* ET
Q
Q
Q
Q
Q
 
endstream
endobj
66 0 obj
<< /Length 4039 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 619.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 144 re B*
Q
q
BT 1 0 0 1 0 122 Tm 12 TL /F4 10 Tf 0 0 0 rg (...) Tj T* (>) Tj (>) Tj (>) Tj ( class Grade\(OrderedEnum\):) Tj T* (...     __ordered__ = 'A B C D F') Tj T* (...     A = 5) Tj T* (...     B = 4) Tj T* (...     C = 3) Tj T* (...     D = 2) Tj T* (...     F = 1) Tj T* (...) Tj T* (>) Tj (>) Tj (>) Tj ( Grade.C ) Tj (<) Tj ( Grade.A) Tj T* (True) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 589.8236 cm
q
BT 1 0 0 1 0 3 Tm 18 TL /F3 15 Tf 0 0 0 rg (Planet) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 571.8236 cm
q
BT 1 0 0 1 0 2 Tm 12 TL /F1 10 Tf 0 0 0 rg (If ) Tj /F4 10 Tf 0 0 0 rg (__new__ ) Tj /F1 10 Tf 0 0 0 rg (or ) Tj /F4 10 Tf 0 0 0 rg (__init__ ) Tj /F1 10 Tf 0 0 0 rg (is defined the value of the enum member will be passed to those methods:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 286.6236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 276 re B*
Q
q
BT 1 0 0 1 0 254 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( class Planet\(Enum\):) Tj T* (...     MERCURY = \(3.303e+23, 2.4397e6\)) Tj T* (...     VENUS   = \(4.869e+24, 6.0518e6\)) Tj T* (...     EARTH   = \(5.976e+24, 6.37814e6\)) Tj T* (...     MARS    = \(6.421e+23, 3.3972e6\)) Tj T* (...     JUPITER = \(1.9e+27,   7.1492e7\)) Tj T* (...     SATURN  = \(5.688e+26, 6.0268e7\)) Tj T* (...     URANUS  = \(8.686e+25, 2.5559e7\)) Tj T* (...     NEPTUNE = \(1.024e+26, 2.4746e7\)) Tj T* (...     def __init__\(self, mass, radius\):) Tj T* (...         self.mass = mass       # in kilograms) Tj T* (...         self.radius = radius   # in meters) Tj T* (...     @property) Tj T* (...     def surface_gravity\(self\):) Tj T* (...         # universal gravitational constant  \(m3 kg-1 s-2\)) Tj T* (...         G = 6.67300E-11) Tj T* (...         return G * self.mass / \(self.radius * self.radius\)) Tj T* (...) Tj T* (>) Tj (>) Tj (>) Tj ( Planet.EARTH.value) Tj T* (\(5.976e+24, 6378140.0\)) Tj T* (>) Tj (>) Tj (>) Tj ( Planet.EARTH.surface_gravity) Tj T* (9.802652743337129) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 253.6236 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F3 17.5 Tf 0 0 0 rg (How are Enums different?) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 223.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL 2.090651 Tw (Enums have a custom metaclass that affects many aspects of both derived Enum classes and their) Tj T* 0 Tw (instances \(members\).) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 193.6236 cm
q
BT 1 0 0 1 0 3 Tm 18 TL /F3 15 Tf 0 0 0 rg (Enum Classes) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 127.6236 cm
q
BT 1 0 0 1 0 50 Tm 1.263615 Tw 12 TL /F1 10 Tf 0 0 0 rg (The ) Tj /F4 10 Tf 0 0 0 rg (EnumMeta ) Tj /F1 10 Tf 0 0 0 rg (metaclass is responsible for providing the ) Tj /F4 10 Tf 0 0 0 rg (__contains__) Tj /F1 10 Tf 0 0 0 rg (, ) Tj /F4 10 Tf 0 0 0 rg (__dir__) Tj /F1 10 Tf 0 0 0 rg (, ) Tj /F4 10 Tf 0 0 0 rg (__iter__ ) Tj /F1 10 Tf 0 0 0 rg (and) Tj T* 0 Tw 2.264724 Tw (other methods that allow one to do things with an ) Tj /F4 10 Tf 0 0 0 rg (Enum ) Tj /F1 10 Tf 0 0 0 rg (class that fail on a typical class, such as) Tj T* 0 Tw 2.594147 Tw /F4 10 Tf 0 0 0 rg (list\(Color\) ) Tj /F1 10 Tf 0 0 0 rg (or ) Tj /F4 10 Tf 0 0 0 rg (some_var) Tj ( ) Tj (in) Tj ( ) Tj (Color) Tj /F1 10 Tf 0 0 0 rg (. ) Tj /F4 10 Tf 0 0 0 rg (EnumMeta ) Tj /F1 10 Tf 0 0 0 rg (is responsible for ensuring that various other) Tj T* 0 Tw 2.196905 Tw (methods on the final ) Tj /F4 10 Tf 0 0 0 rg (Enum ) Tj /F1 10 Tf 0 0 0 rg (class are correct \(such as ) Tj /F4 10 Tf 0 0 0 rg (__new__) Tj /F1 10 Tf 0 0 0 rg (, ) Tj /F4 10 Tf 0 0 0 rg (__getnewargs__) Tj /F1 10 Tf 0 0 0 rg (, ) Tj /F4 10 Tf 0 0 0 rg (__str__ ) Tj /F1 10 Tf 0 0 0 rg (and) Tj T* 0 Tw /F4 10 Tf 0 0 0 rg (__repr__) Tj /F1 10 Tf 0 0 0 rg (\).) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 115.6236 cm
Q
 
endstream
endobj
67 0 obj
<< /Length 5416 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 682.0236 cm
.960784 .960784 .862745 rg
n 0 83 469.8898 -83 re f*
0 0 0 rg
BT /F1 10 Tf 12 TL ET
BT 1 0 0 1 6 57 Tm  T* ET
q
1 0 0 1 16 52 cm
q
0 0 0 rg
BT 1 0 0 1 0 2.5 Tm /F6 12.5 Tf 15 TL (Note) Tj T* ET
Q
Q
q
1 0 0 1 16 16 cm
q
BT 1 0 0 1 0 14 Tm .686654 Tw 12 TL /F4 10 Tf 0 0 0 rg (__dir__ ) Tj /F1 10 Tf 0 0 0 rg (is not changed in the Python 2 line as it messes up some of the decorators included in) Tj T* 0 Tw (the stdlib.) Tj T* ET
Q
Q
q
1 J
1 j
.662745 .662745 .662745 RG
.5 w
n 0 83 m 469.8898 83 l S
n 0 0 m 469.8898 0 l S
n 0 0 m 0 83 l S
n 469.8898 0 m 469.8898 83 l S
Q
Q
q
1 0 0 1 62.69291 676.0236 cm
Q
q
1 0 0 1 62.69291 646.0236 cm
q
BT 1 0 0 1 0 3 Tm 18 TL /F3 15 Tf 0 0 0 rg (Enum Members \(aka instances\)) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 604.0236 cm
q
BT 1 0 0 1 0 26 Tm .491984 Tw 12 TL /F1 10 Tf 0 0 0 rg (The most interesting thing about Enum members is that they are singletons. ) Tj /F4 10 Tf 0 0 0 rg (EnumMeta ) Tj /F1 10 Tf 0 0 0 rg (creates them all) Tj T* 0 Tw .084988 Tw (while it is creating the ) Tj /F4 10 Tf 0 0 0 rg (Enum ) Tj /F1 10 Tf 0 0 0 rg (class itself, and then puts a custom ) Tj /F4 10 Tf 0 0 0 rg (__new__ ) Tj /F1 10 Tf 0 0 0 rg (in place to ensure that no new) Tj T* 0 Tw (ones are ever instantiated by returning only the existing member instances.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 574.0236 cm
q
BT 1 0 0 1 0 3 Tm 18 TL /F3 15 Tf 0 0 0 rg (Finer Points) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 532.0236 cm
q
BT 1 0 0 1 0 26 Tm 5.488555 Tw 12 TL /F4 10 Tf 0 0 0 rg (Enum ) Tj /F1 10 Tf 0 0 0 rg (members are instances of an ) Tj /F4 10 Tf 0 0 0 rg (Enum ) Tj /F1 10 Tf 0 0 0 rg (class, and even though they are accessible as) Tj T* 0 Tw 1.129318 Tw /F5 10 Tf 0 0 0 rg (EnumClass.member) Tj /F1 10 Tf 0 0 0 rg (, they should not be accessed directly from the member as that lookup may fail or,) Tj T* 0 Tw (worse, return something besides the ) Tj /F4 10 Tf 0 0 0 rg (Enum ) Tj /F1 10 Tf 0 0 0 rg (member you were looking for \(changed in version 1.1.1\):) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 402.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 120 re B*
Q
q
BT 1 0 0 1 0 98 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( class FieldTypes\(Enum\):) Tj T* (...     name = 0) Tj T* (...     value = 1) Tj T* (...     size = 2) Tj T* (...) Tj T* (>) Tj (>) Tj (>) Tj ( FieldTypes.value.size) Tj T* (<) Tj (FieldTypes.size: 2) Tj (>) Tj  T* (>) Tj (>) Tj (>) Tj ( FieldTypes.size.value) Tj T* (2) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 382.8236 cm
q
BT 1 0 0 1 0 2 Tm 12 TL /F1 10 Tf 0 0 0 rg (Likewise, ) Tj /F4 10 Tf 0 0 0 rg (__members__ ) Tj /F1 10 Tf 0 0 0 rg (is only available on the class.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 328.8236 cm
q
BT 1 0 0 1 0 38 Tm 1.374651 Tw 12 TL /F1 10 Tf 0 0 0 rg (In Python 3.x ) Tj /F4 10 Tf 0 0 0 rg (__members__ ) Tj /F1 10 Tf 0 0 0 rg (is always an ) Tj /F4 10 Tf 0 0 0 rg (OrderedDict) Tj /F1 10 Tf 0 0 0 rg (, with the order being the definition order. In) Tj T* 0 Tw 3.009213 Tw (Python 2.7 ) Tj /F4 10 Tf 0 0 0 rg (__members__ ) Tj /F1 10 Tf 0 0 0 rg (is an ) Tj /F4 10 Tf 0 0 0 rg (OrderedDict ) Tj /F1 10 Tf 0 0 0 rg (if ) Tj /F4 10 Tf 0 0 0 rg (__order__ ) Tj /F1 10 Tf 0 0 0 rg (was specified, and a plain ) Tj /F4 10 Tf 0 0 0 rg (dict) Tj T* 0 Tw 1.851318 Tw /F1 10 Tf 0 0 0 rg (otherwise. In all other Python 2.x versions ) Tj /F4 10 Tf 0 0 0 rg (__members__ ) Tj /F1 10 Tf 0 0 0 rg (is a plain ) Tj /F4 10 Tf 0 0 0 rg (dict ) Tj /F1 10 Tf 0 0 0 rg (even if ) Tj /F4 10 Tf 0 0 0 rg (__order__ ) Tj /F1 10 Tf 0 0 0 rg (was) Tj T* 0 Tw (specified as the ) Tj /F4 10 Tf 0 0 0 rg (OrderedDict ) Tj /F1 10 Tf 0 0 0 rg (type didn't exist yet.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 298.8236 cm
q
BT 1 0 0 1 0 14 Tm .106654 Tw 12 TL /F1 10 Tf 0 0 0 rg (If you give your ) Tj /F4 10 Tf 0 0 0 rg (Enum ) Tj /F1 10 Tf 0 0 0 rg (subclass extra methods, like the ) Tj 0 0 .501961 rg (Planet ) Tj 0 0 0 rg (class above, those methods will show up in) Tj T* 0 Tw (a ) Tj /F5 10 Tf 0 0 0 rg (dir ) Tj /F1 10 Tf 0 0 0 rg (of the member, but not of the class:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 217.6236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 72 re B*
Q
q
BT 1 0 0 1 0 50 Tm 12 TL /F4 10 Tf 0 0 0 rg (>) Tj (>) Tj (>) Tj ( dir\(Planet\)) Tj T* (['EARTH', 'JUPITER', 'MARS', 'MERCURY', 'NEPTUNE', 'SATURN', 'URANUS',) Tj T* ('VENUS', '__class__', '__doc__', '__members__', '__module__']) Tj T* (>) Tj (>) Tj (>) Tj ( dir\(Planet.EARTH\)) Tj T* (['__class__', '__doc__', '__module__', 'name', 'surface_gravity', 'value']) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 173.6236 cm
q
BT 1 0 0 1 0 26 Tm .938935 Tw 12 TL /F1 10 Tf 0 0 0 rg (A ) Tj /F4 10 Tf 0 0 0 rg (__new__ ) Tj /F1 10 Tf 0 0 0 rg (method will only be used for the creation of the ) Tj /F4 10 Tf 0 0 0 rg (Enum ) Tj /F1 10 Tf 0 0 0 rg (members -- after that it is replaced.) Tj T* 0 Tw .949461 Tw (This means if you wish to change how ) Tj /F4 10 Tf 0 0 0 rg (Enum ) Tj /F1 10 Tf 0 0 0 rg (members are looked up you either have to write a helper) Tj T* 0 Tw (function or a ) Tj /F4 10 Tf 0 0 0 rg (classmethod) Tj /F1 10 Tf 0 0 0 rg (.) Tj T* ET
Q
Q
 
endstream
endobj
68 0 obj
<< /Nums [ 0 69 0 R 1 70 0 R 2 71 0 R 3 72 0 R 4 73 0 R 
  5 74 0 R 6 75 0 R 7 76 0 R 8 77 0 R 9 78 0 R 
  10 79 0 R 11 80 0 R ] >>
endobj
69 0 obj
<< /S /D /St 1 >>
endobj
70 0 obj
<< /S /D /St 2 >>
endobj
71 0 obj
<< /S /D /St 3 >>
endobj
72 0 obj
<< /S /D /St 4 >>
endobj
73 0 obj
<< /S /D /St 5 >>
endobj
74 0 obj
<< /S /D /St 6 >>
endobj
75 0 obj
<< /S /D /St 7 >>
endobj
76 0 obj
<< /S /D /St 8 >>
endobj
77 0 obj
<< /S /D /St 9 >>
endobj
78 0 obj
<< /S /D /St 10 >>
endobj
79 0 obj
<< /S /D /St 11 >>
endobj
80 0 obj
<< /S /D /St 12 >>
endobj
xref
0 81
0000000000 65535 f
0000000075 00000 n
0000000160 00000 n
0000000270 00000 n
0000000383 00000 n
0000000498 00000 n
0000000606 00000 n
0000000777 00000 n
0000000948 00000 n
0000001066 00000 n
0000001237 00000 n
0000001477 00000 n
0000001687 00000 n
0000001897 00000 n
0000002107 00000 n
0000002279 00000 n
0000002402 00000 n
0000002574 00000 n
0000002746 00000 n
0000002989 00000 n
0000003161 00000 n
0000003333 00000 n
0000003569 00000 n
0000003779 00000 n
0000003989 00000 n
0000004199 00000 n
0000004409 00000 n
0000004619 00000 n
0000004791 00000 n
0000005020 00000 n
0000005129 00000 n
0000005373 00000 n
0000005451 00000 n
0000005571 00000 n
0000005705 00000 n
0000005886 00000 n
0000006039 00000 n
0000006168 00000 n
0000006332 00000 n
0000006488 00000 n
0000006614 00000 n
0000006746 00000 n
0000006924 00000 n
0000007036 00000 n
0000007147 00000 n
0000007315 00000 n
0000007413 00000 n
0000007591 00000 n
0000007706 00000 n
0000007834 00000 n
0000007963 00000 n
0000008074 00000 n
0000008243 00000 n
0000008360 00000 n
0000008508 00000 n
0000008625 00000 n
0000008771 00000 n
0000015286 00000 n
0000019517 00000 n
0000023365 00000 n
0000027828 00000 n
0000032406 00000 n
0000037090 00000 n
0000042519 00000 n
0000046717 00000 n
0000053882 00000 n
0000058097 00000 n
0000062193 00000 n
0000067666 00000 n
0000067819 00000 n
0000067856 00000 n
0000067893 00000 n
0000067930 00000 n
0000067967 00000 n
0000068004 00000 n
0000068041 00000 n
0000068078 00000 n
0000068115 00000 n
0000068152 00000 n
0000068190 00000 n
0000068228 00000 n
trailer
<< /ID 
 % ReportLab generated PDF document -- digest (http://www.reportlab.com)
 [(\022[\343\363\025\0006\017{\214\256\321:\020h\367) (\022[\343\363\025\0006\017{\214\256\321:\020h\367)]
 /Info 30 0 R /Root 29 0 R /Size 81 >>
startxref
68266
%%EOF

filename:/usr/lib/python2.7/dist-packages/enum/README
__doc__
enum34 is the new Python stdlib enum module available in Python 3.4
backported for previous versions of Python from 2.4 to 3.3.
tested on 2.6, 2.7, and 3.3+

filename:/usr/lib/python2.7/dist-packages/enum/__init__.pyc
__doc__
Û
 yVc           @   sJ  d  Z  d d l Z d d d g Z d d d f Z e d e j d  É Z y e Wn e	 k
 rk d	 Ñ  Z n Xy d d
 l
 m Z Wn e k
 rô e Z n Xy e Wn e	 k
 rª e Z n Xy e Wn e	 k
 r› e Z n Xd e f d Ñ  É  YZ d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d e f d Ñ  É  YZ e Z d e f d Ñ  É  YZ i  Z d e d <d Ñ  Z e e d <[ d Ñ  Z e e d <[ d Ñ  Z e e d <[ e d k r¡d Ñ  Z  e  e d <[  n  d  Ñ  Z! e! e d! <[! e d" k  r¸d# Ñ  Z" e" e d$ <[" nX d% Ñ  Z# e# e d& <[# d' Ñ  Z$ e$ e d( <[$ d) Ñ  Z% e% e d* <[% d+ Ñ  Z& e& e d, <[& d- Ñ  Z' e' e d. <[' d/ Ñ  Z( e( e d0 <[( d1 Ñ  Z) e) e d2 <[) d3 Ñ  Z* e* e d4 <[* e d5 Ñ  É Z+ e+ e d6 <[+ e d7 Ñ  É Z, e, e d8 <[, e- e d9 Ñ É Z. e. e d: <[. e d e f e É Z [ d e/ e f d; Ñ  É  YZ0 d< Ñ  Z1 d= Ñ  Z2 d S(>   s   Python EnumerationsiˇˇˇˇNt   Enumt   IntEnumt   uniquei   i   s   %s.%sc         C   s   x |  D] } | r t  Sq Wt S(   N(   t   Truet   False(   t   iterablet   element(    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyt   any   s    (   t   OrderedDictt   _RouteClassAttributeToGetattrc           B   s8   e  Z d  Z d d Ñ Z d d Ñ Z d Ñ  Z d Ñ  Z RS(   sj  Route attribute access on a class to __getattr__.

    This is a descriptor, used to define attributes that act differently when
    accessed through an instance and through a class.  Instance access remains
    normal, but access to an attribute through a class will be routed to the
    class's __getattr__ method; this is done by raising AttributeError.

    c         C   s   | |  _  d  S(   N(   t   fget(   t   selfR
   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyt   __init__/   s    c         C   s%   | d  k r t É  Ç n  |  j | É S(   N(   t   Nonet   AttributeErrorR
   (   R   t   instancet
   ownerclass(    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyt   __get__2   s    c         C   s   t  d É Ç d  S(   Ns   can't set attribute(   R   (   R   R   t   value(    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyt   __set__7   s    c         C   s   t  d É Ç d  S(   Ns   can't delete attribute(   R   (   R   R   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyt
   __delete__:   s    N(   t   __name__t
   __module__t   __doc__R   R   R   R   R   (    (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyR	   &   s
   	c         C   s+   t  |  d É p* t  |  d É p* t  |  d É S(   s5   Returns True if obj is a descriptor, False otherwise.R   R   R   (   t   hasattr(   t   obj(    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyt   _is_descriptor>   s    c         C   sZ   |  d  |  d k o d k n oY |  d d !d k oY |  d d !d k oY t  |  É d k S(   s3   Returns True if a __dunder__ name, False otherwise.i   i˛ˇˇˇt   __i   t   _i˝ˇˇˇi   (   t   len(   t   name(    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyt
   _is_dunderF   s    $c         C   sZ   |  d |  d k o d k n oY |  d d !d k oY |  d d !d k oY t  |  É d k S(   s1   Returns True if a _sunder_ name, False otherwise.i    iˇˇˇˇR   i   i   i˛ˇˇˇ(   R   (   R   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyt
   _is_sunderN   s    $c         C   s"   d d Ñ } | |  _ d |  _ d S(   s"   Make the given class un-picklable.c         S   s   t  d |  É Ç d  S(   Ns   %r cannot be pickled(   t	   TypeError(   R   t   protocol(    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyt   _break_on_call_reduceX   s    s	   <unknown>N(   R   t   __reduce_ex__R   (   t   clsR#   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyt   _make_class_unpicklableV   s    	t	   _EnumDictc           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   sß   Track enum member order and ensure member names are not reused.

    EnumMeta will use the names found in self._member_names as the
    enumeration member names.

    c         C   s    t  t |  É j É  g  |  _ d  S(   N(   t   superR'   R   t   _member_names(   R   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyR   e   s    c         C   s«   t  d k r | d k r d St | É r7 t d É Ç ns t | É rF nd | |  j k rh t d | É Ç nB t | É s™ | |  k ró t d |  | É Ç n  |  j j | É n  t t	 |  É j
 | | É d S(   s  Changes anything not dundered or not a descriptor.

        If a descriptor is added with the same name as an enum member, the name
        is removed from _member_names (this may leave a hole in the numerical
        sequence of values).

        If an enum member name is used twice, an error is raised; duplicate
        values are not checked for.

        Single underscore (sunder) names are reserved.

        Note:   in 3.x __order__ is simply discarded as a not necessary piece
                leftover from 2.x

        g      @t	   __order__Ns(   _names_ are reserved for future Enum uses   Attempted to reuse key: %rs   Key already defined as: %r(   t   pyverR    t
   ValueErrorR   R)   R!   R   t   appendR(   R'   t   __setitem__(   R   t   keyR   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyR.   i   s    (   R   R   R   R   R.   (    (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyR'   ^   s   	t   EnumMetac           B   sı   e  Z d  Z e d Ñ  É Z d Ñ  Z d d d d d Ñ Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 e d Ñ  É Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d d d d Ñ Z e d Ñ  É Z e d k  r‰ e d Ñ  É Z n e d Ñ  É Z RS(   s   Metaclass for Enumc         C   s   t  É  S(   N(   R'   (   t   metaclsR%   t   bases(    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyt   __prepare__í   s    c            s—  t  à  É t k rK à  } t É  â  x' | j É  D] \ } } | à  | <q. Wn  |  j | É \ â } |  j à  à | É \ } }	 }
 t á  f d Ü  à  j DÉ É } x à  j D] } à  | =qß Wà  j d É } | d  k r_t	 d k  rSy8 g  t
 | j É  d d Ñ  ÉD] \ } } | ^ q˛ } Wq\t k
 rOg  t
 | j É  É D] } | ^ q:} q\Xqºà  j } n] à  d =t	 d k  rº| j d d É j É  } g  | D] } | | k rë| ^ që} | | 7} n  t | É t d g É @} | r˙t d	 d
 j | É f É Ç n  t g  | D] } | j D] } | ^ qqÉ } t t |  É j |  | | à  É } g  | _ t d  k	 rnt É  | _ n	 i  | _ à | _ i  | _ | d  k r°| j } n  x~| D]v} | | } t | t É s”| f } n | } à t k rÒ| f } n  |
 sˇ| r)| | É } t | d É sY| | _ qYn0 | | | å } t | d É sYà | å  | _ n  | j } | | _ | | _  | j! | å  xI | j j É  D]( \ } } | j" | j k rë| } PqëqëW| j j# | É | | k rÏt$ | | | É n  | | j | <y | | j | <Wq®t k
 rq®Xq®Wt% } d à  k r{à t& k	 r{d } t' á f d Ü  | DÉ É sxt( | É t) } qxq{n  xÑ d  D]| } t* | | É } t* à | d  É } t* | | d  É } | à  k rÇ| | k	 rÇ| d k rÎ| rÎqÇn  t$ | | | É qÇqÇWt	 d k  r<t+ | t, É rát$ | d t* t, d É É qánK t	 d k  rát+ | t, É ráx* d! D] } t$ | | t* t, | É É q^Wqán  t- d  k	 rÕ|	 r≥t$ | d | j d É n  t$ | d t- j d É n  | S("   Nc         3   s   |  ] } | à  | f Vq d  S(   N(    (   t   .0t   k(   t	   classdict(    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pys	   <genexpr>¶   s    R*   g      @R/   c         S   s   |  d S(   Ni   (    (   t   item(    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyt   <lambda>Ø   s    t   ,t    t   mros   Invalid enum member name(s): %ss   , t   _value_R$   t   __getnewargs_ex__t   __getnewargs__t
   __reduce__c         3   s   |  ] } | à  j  k Vq d  S(   N(   t   __dict__(   R4   t   m(   t   member_type(    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pys	   <genexpr>  s    t   __repr__t   __str__t
   __format__gÕÃÃÃÃÃ@t   __cmp__t   __le__t   __lt__t   __gt__t   __ge__t   __eq__t   __ne__t   __hash__t   __member_new__t   __new__(   R=   s   __getnewargs__s   __reduce_ex__s
   __reduce__(   s   __repr__s   __str__s
   __format__s   __reduce_ex__(   s   __le__s   __lt__s   __gt__s   __ge__s   __eq__s   __ne__s   __hash__(.   t   typet   dictR'   t   itemst   _get_mixins_t
   _find_new_R)   t   getR   R+   t   sortedR!   t   keyst   replacet   splitt   setR,   t   joinR@   R(   R0   RO   t   _member_names_R   t   _member_map_t   _member_type_t   _value2member_map_t
   isinstancet   tupleR   R<   t   _name_t   __objclass__R   R   R-   t   setattrR   t   objectR   R&   R   t   getattrt
   issubclasst   intR    (   R1   R%   R2   R6   t   original_dictR5   t   vt
   first_enumRO   t   save_newt   use_argst   membersR   R*   R   t   aliasest   invalid_namest   bt   at   base_attributest
   enum_classt   member_namet   argst   enum_membert   canonical_membert   unpicklablet   methodst   class_methodt
   obj_methodt   enum_methodt   method(    (   R6   RB   s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyRO   ñ   sŒ    	8,%/!				
			 
      
#i   c      	   C   s>   | d k r |  j |  | É S|  j | | d | d | d | ÉS(   sØ  Either returns an existing member, or creates a new enum class.

        This method is used both when an enum class is given a value to match
        to an enumeration member (i.e. Color(3)) and for the functional API
        (i.e. Color = Enum('Color', names='red green blue')).

        When used for the functional API: `module`, if set, will be stored in
        the new class' __module__ attribute; `type`, if set, will be mixed in
        as the first base class.

        Note: if `module` is not set this routine will attempt to discover the
        calling module by walking the frame stack; if this is unsuccessful
        the resulting class will not be pickleable.

        t   moduleRP   t   startN(   R   RO   t   _create_(   R%   R   t   namesR   RP   RÄ   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyt   __call__A  s    c         C   s   t  | |  É o | j |  j k S(   N(   R`   R   R]   (   R%   t   member(    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyt   __contains__V  s    c         C   s?   | |  j  k r% t d |  j É Ç n  t t |  É j | É d  S(   Ns   %s: cannot delete Enum member.(   R]   R   R   R(   R0   t   __delattr__(   R%   t   attr(    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyRÜ   Y  s    c         C   s   d d d d g |  j  S(   Nt	   __class__R   t   __members__R   (   R\   (   R   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyt   __dir__a  s    c         C   s   |  j  j É  S(   s≠   Returns a mapping of member name->value.

        This mapping lists all enum members, including aliases. Note that this
        is a copy of the internal mapping.

        (   R]   t   copy(   R%   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyRâ   e  s    c         C   sN   t  | É r t | É Ç n  y |  j | SWn t k
 rI t | É Ç n Xd S(   s5  Return the enum member matching `name`

        We use __getattr__ instead of descriptors or inserting into the enum
        class' __dict__ in order to support `name` and `value` being both
        properties for enum members (which live in the class' __dict__) and
        enum members themselves.

        N(   R   R   R]   t   KeyError(   R%   R   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyt   __getattr__o  s    	c         C   s   |  j  | S(   N(   R]   (   R%   R   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyt   __getitem__  s    c            s   á  f d Ü  à  j  DÉ S(   Nc         3   s   |  ] } à  j  | Vq d  S(   N(   R]   (   R4   R   (   R%   (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pys	   <genexpr>É  s    (   R\   (   R%   (    (   R%   s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyt   __iter__Ç  s    c            s   á  f d Ü  t  à  j É DÉ S(   Nc         3   s   |  ] } à  j  | Vq d  S(   N(   R]   (   R4   R   (   R%   (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pys	   <genexpr>Ü  s    (   t   reversedR\   (   R%   (    (   R%   s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyt   __reversed__Ö  s    c         C   s   t  |  j É S(   N(   R   R\   (   R%   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyt   __len__à  s    c         C   s   d |  j  S(   Ns	   <enum %r>(   R   (   R%   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyRC   ã  s    c         C   sM   |  j  j d i  É } | | k r0 t d É Ç n  t t |  É j | | É d S(   s˘   Block attempts to reassign Enum members.

        A simple assignment to the class namespace only changes one of the
        several possible ways to get an Enum member from the Enum class,
        resulting in an inconsistent Enumeration.

        R]   s   Cannot reassign members.N(   R@   RU   R   R(   R0   t   __setattr__(   R%   R   R   t
   member_map(    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyRì   é  s    c         C   s$  t  d k  rX t | t É rX y | j d É } WqU t k
 rQ t d | É Ç qU XqX n  |  j } | d
 k ry |  f } n | |  f } | j | | É } g  }	 t | t	 É r« | j
 d d É j É  } n  t | t t f É r!t | d t	 É r!g  t | É D] \ }
 } | |
 | f ^ q¸ } n  d
 } xT | D]L } t | t	 É rW| | | } } n | \ } } | | | <|	 j | É q.Wt | t	 É s£d j |	 É | d <n  | j | | | | É } | d
 k r˛y t j d É j d	 } Wq˛t t f k
 r˙q˛Xn  | d
 k rt | É n	 | | _ | S(   s}  Convenience method to create a new Enum class.

        `names` can be:

        * A string containing member names, separated either with spaces or
          commas.  Values are auto-numbered from 1.
        * An iterable of member names.  Values are auto-numbered from 1.
        * An iterable of (member name, value) pairs.
        * A mapping of member name -> value.

        g      @t   asciis    %r is not representable in ASCIIR9   R:   i    R*   i   R   N(   R+   R`   t   unicodet   encodet   UnicodeEncodeErrorR!   Rà   R   R3   t
   basestringRX   RY   Ra   t   listt	   enumerateR-   R[   RO   t   _syst	   _getframet	   f_globalsR   R,   R&   R   (   R%   t
   class_nameRÇ   R   RP   RÄ   R1   R2   R6   R*   t   it   eR7   Ru   t   member_valueRt   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyRÅ   õ  sF    	(2
	c         C   s  |  s t  d k r t t  f Sd } } xA |  D]9 } | t  k	 r. t | t  É r. | j r. t d É Ç q. q. Wt | t  É sâ t d É Ç n  t |  d t  É s≥ |  d } |  d } nT xQ |  d j D]B } t | t  É rÓ | d k r| } qq¡ | d k r¡ | } q¡ q¡ W| | f S(   sû   Returns the type for creating enum members, and the first inherited
        enum class.

        bases: the tuple of bases that was given to __new__

        s   Cannot extend enumerationssH   new enumerations must be created as `ClassName([mixin_type,] enum_type)`i    iˇˇˇˇN(   R    R   Re   Rg   R\   R!   t   __mro__(   R2   RB   Rk   t   base(    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyRS   ÿ  s(    

	
g      @c         C   st  |  j  d d É } | r% d t t f St d d É } t t d É } t d k rX | } n t j d } x· d D]– } x∑ | | f D]© } y | j | }	 Wn) t t f k
 r¡ t | | d É }	 n X|	 d | | | g k r | d k r˝ |	 |  d <d t	 t f St
 |	 t É r|	 j | É }	 n  |	 } Pq q W| d k	 rl Pql ql Wt j } | t j k rat	 }
 n t }
 | t	 |
 f S(   s  Returns the __new__ to be used for creating the enum members.

            classdict: the class dictionary given to __new__
            member_type: the data type whose __new__ will be used by default
            first_enum: enumeration to check for an overriding __new__

            RO   RN   N(   s   __member_new__s   __new__(   RU   R   R   Rf   Re   R    R@   R   Rå   R   R`   t   staticmethodR   RO   (   R6   RB   Rk   RO   t   N__new__t   O__new__t   E__new__R~   t   possiblet   targetRm   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyRT     sB    	
		c   	      C   s÷   |  j  d d É } | d k	 } | d k r´ x~ d D]j } xQ | | f D]C } t | | d É } | d d j t j t j f k rD | } PqD qD W| d k	 r1 Pq1 q1 Wt j } n  | t j k r√ t } n t } | | | f S(   s  Returns the __new__ to be used for creating the enum members.

            classdict: the class dictionary given to __new__
            member_type: the data type whose __new__ will be used by default
            first_enum: enumeration to check for an overriding __new__

            RO   RN   N(   s   __member_new__s   __new__(   RU   R   Rf   RO   Re   R    R   R   (	   R6   RB   Rk   RO   Rl   R~   R©   R™   Rm   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyRT   A  s(    	N(   R   R   R   t   classmethodR3   RO   R   RÉ   RÖ   RÜ   Rä   t   propertyRâ   Rç   Ré   Rè   Rë   Rí   RC   Rì   RÅ   R•   RS   R+   RT   (    (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyR0   ê   s(   	´			
							=.:sN   Generic enumeration.

    Derive from this class to define new enumerations.

R   c         C   sö   t  | É |  k r | j } n  y | |  j k r; |  j | SWn> t k
 r| x. |  j j É  D] } | j | k r\ | Sq\ Wn Xt d | |  j f É Ç d  S(   Ns   %s is not a valid %s(   RP   R   R_   R!   R]   t   valuesR,   R   (   R%   R   RÑ   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyRO   y  s    RO   c         C   s   d |  j  j |  j |  j f S(   Ns   <%s.%s: %r>(   Rà   R   Rb   R<   (   R   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyRC   è  s    RC   c         C   s   d |  j  j |  j f S(   Ns   %s.%s(   Rà   R   Rb   (   R   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyRD   ï  s    RD   g      @c         C   sb   g  |  j  j É  D]; } | j D]+ } | d d k r | |  j k r | ^ q q } d d d g | S(   Ni    R   Rà   R   R   (   Rà   R;   R@   R]   (   R   R%   RA   t   added_behavior(    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyRä   õ  s
    .Rä   c         C   sF   |  j  t k r$ t } t |  É } n |  j  } |  j } | j | | É S(   N(   R^   Re   t   strR   RE   (   R   t   format_specR%   t   val(    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyRE   ¶  s    		RE   gÕÃÃÃÃÃ@c         C   sU   t  | É |  j k r/ |  | k r( d Sn  d Sn  t St d |  j j | j j f É Ç (   Ni    iˇˇˇˇs    unorderable types: %s() and %s()(   RP   Rà   t   NotImplementedR!   R   (   R   t   other(    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyRF   Ω  s    RF   c         C   s&   t  d |  j j | j j f É Ç d  S(   Ns   unorderable types: %s() <= %s()(   R!   Rà   R   (   R   R≥   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyRG   …  s    RG   c         C   s&   t  d |  j j | j j f É Ç d  S(   Ns   unorderable types: %s() < %s()(   R!   Rà   R   (   R   R≥   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyRH   Œ  s    RH   c         C   s&   t  d |  j j | j j f É Ç d  S(   Ns   unorderable types: %s() >= %s()(   R!   Rà   R   (   R   R≥   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyRJ   ”  s    RJ   c         C   s&   t  d |  j j | j j f É Ç d  S(   Ns   unorderable types: %s() > %s()(   R!   Rà   R   (   R   R≥   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyRI   ÿ  s    RI   c         C   s#   t  | É |  j k r |  | k St S(   N(   RP   Rà   R≤   (   R   R≥   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyRK   ﬁ  s    
RK   c         C   s#   t  | É |  j k r |  | k	 St S(   N(   RP   Rà   R≤   (   R   R≥   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyRL   Â  s    
RL   c         C   s   t  |  j É S(   N(   t   hashRb   (   R   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyRM   Ï  s    RM   c         C   s   |  j  |  j f f S(   N(   Rà   R<   (   R   t   proto(    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyR$   ˙  s    R$   c         C   s   |  j  S(   N(   Rb   (   R   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyR     s    R   c         C   s   |  j  S(   N(   R<   (   R   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyR     s    R   c            så   t  t j | É } | r( t  | É } n | } t á  f d Ü  | j É  DÉ É } |  | | d | É}  t |  _ | j |  j É |  | | <|  S(   sS   
    Create a new Enum subclass that replaces a collection of global constants
    c         3   s-   |  ]# \ } } à  | É r | | f Vq d  S(   N(    (   R4   R   R   (   t   filter(    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pys	   <genexpr>!  s    R   (	   t   varsRú   t   modulesRQ   RR   t   _reduce_ex_by_nameR$   t   updateRâ   (   R%   R   R   R∂   t   sourcet   module_globalsRn   (    (   R∂   s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyt   _convert  s    
"	
RΩ   c           B   s   e  Z d  Z RS(   s.   Enum where members are also (and must be) ints(   R   R   R   (    (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyR   0  s   c         C   s   |  j  S(   N(   R   (   R   Rµ   (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyRπ   3  s    c         C   s£   g  } xE |  j  j É  D]4 \ } } | | j k r | j | | j f É q q W| rü d j g  | D] \ } } d | | f ^ qa É } t d |  | f É Ç n  |  S(   sI   Class decorator that ensures only unique members exist in an enumeration.s   , s   %s -> %ss   duplicate names found in %r: %s(   Râ   RR   R   R-   R[   R,   (   t   enumerationt
   duplicatesR   RÑ   t   aliast   duplicate_names(    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyR   6  s    ,(3   R   t   sysRú   t   __all__t   versiont   floatt   version_infoR+   R   t	   NameErrort   collectionsR   t   ImportErrorR   Rô   RØ   Rñ   Re   R	   R   R   R    R&   RQ   R'   R    RP   R0   t   temp_enum_dictRO   RC   RD   Rä   RE   RF   RG   RH   RJ   RI   RK   RL   RM   R$   R   R   R´   RΩ   Rh   R   Rπ   R   (    (    (    s1   /usr/lib/python2.7/dist-packages/enum/__init__.pyt   <module>   s¥   


				/ˇ Á
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	


	
filename:/usr/lib/python2.7/dist-packages/README
__doc__
This directory exists so that 3rd party packages can be installed
here.  Read the source for site.py for more details.

filename:/usr/lib/python2.7/dist-packages/serial/aio.py
__doc__
#!/usr/bin/env python3
#
# Experimental implementation of asyncio support.
#
# This file is part of pySerial. https://github.com/pyserial/pyserial
# (C) 2015 Chris Liechti <cliechti@gmx.net>
#
# SPDX-License-Identifier:    BSD-3-Clause
"""\

filename:/usr/lib/python2.7/mutex.py
__doc__
"""Mutual exclusion -- for use with module sched

A mutex has two pieces of state -- a 'locked' bit and a queue.
When the mutex is not locked, the queue is empty.
Otherwise, the queue contains 0 or more (function, argument) pairs
representing functions (or methods) waiting to acquire the lock.
When the mutex is unlocked while the queue is not empty,
the first queue entry is removed and its function(argument) pair called,
implying it now has the lock.

Of course, no multi-threading is implied -- hence the funny interface
for lock, where a function is called once the lock is acquired.
"""

filename:/usr/lib/python2.7/formatter.py
__doc__
"""Generic output formatting.

Formatter objects transform an abstract flow of formatting events into
specific output events on writer objects. Formatters manage several stack
structures to allow various properties of a writer object to be changed and
restored; writers need not be able to handle relative changes nor any sort
of ``change back'' operation. Specific writer properties which may be
controlled via formatter objects are horizontal alignment, font, and left
margin indentations. A mechanism is provided which supports providing
arbitrary, non-exclusive style settings to a writer as well. Additional
interfaces facilitate formatting events which are not reversible, such as
paragraph separation.

Writer objects encapsulate device interfaces. Abstract devices, such as
file formats, are supported as well as physical devices. The provided
implementations all work with abstract devices. The interface makes
available mechanisms for setting the properties which formatter objects
manage and inserting data into the output.
"""

filename:/usr/lib/python2.7/sgmllib.py
__doc__
"""A parser for SGML, using the derived class as a static DTD."""

# XXX This only supports those SGML features used by HTML.

# XXX There should be a way to distinguish between PCDATA (parsed
# character data -- the normal case), RCDATA (replaceable character
# data -- only char and entity references and end tags are special)
# and CDATA (character data -- only end tags are special).  RCDATA is
# not supported at all.


from warnings import warnpy3k
warnpy3k("the sgmllib module has been removed in Python 3.0",
         stacklevel=2)
del warnpy3k

import markupbase
import re

__all__ = ["SGMLParser", "SGMLParseError"]

# Regular expressions used for parsing

interesting = re.compile('[&<]')
incomplete = re.compile('&([a-zA-Z][a-zA-Z0-9]*|#[0-9]*)?|'
                           '<([a-zA-Z][^<>]*|'
                              '/([a-zA-Z][^<>]*)?|'
                              '![^<>]*)?')

entityref = re.compile('&([a-zA-Z][-.a-zA-Z0-9]*)[^a-zA-Z0-9]')
charref = re.compile('&#([0-9]+)[^0-9]')

starttagopen = re.compile('<[>a-zA-Z]')
shorttagopen = re.compile('<[a-zA-Z][-.a-zA-Z0-9]*/')
shorttag = re.compile('<([a-zA-Z][-.a-zA-Z0-9]*)/([^/]*)/')
piclose = re.compile('>')
endbracket = re.compile('[<>]')
tagfind = re.compile('[a-zA-Z][-_.a-zA-Z0-9]*')
attrfind = re.compile(
    r'\s*([a-zA-Z_][-:.a-zA-Z_0-9]*)(\s*=\s*'
    r'(\'[^\']*\'|"[^"]*"|[][\-a-zA-Z0-9./,:;+*%?!&$\(\)_#=~\'"@]*))?')


class SGMLParseError(RuntimeError):
    """Exception raised for all parse errors."""
    pass


# SGML parser base class -- find tags and call handler functions.
# Usage: p = SGMLParser(); p.feed(data); ...; p.close().
# The dtd is defined by deriving a class which defines methods
# with special names to handle tags: start_foo and end_foo to handle
# <foo> and </foo>, respectively, or do_foo to handle <foo> by itself.
# (Tags are converted to lower case for this purpose.)  The data
# between tags is passed to the parser by calling self.handle_data()
# with some data as argument (the data may be split up in arbitrary
# chunks).  Entity references are passed by calling
# self.handle_entityref() with the entity reference as argument.

class SGMLParser(markupbase.ParserBase):
    # Definition of entities -- derived classes may override
    entity_or_charref = re.compile('&(?:'
      '([a-zA-Z][-.a-zA-Z0-9]*)|#([0-9]+)'
      ')(;?)')

    def __init__(self, verbose=0):
        """Initialize and reset this instance."""
        self.verbose = verbose
        self.reset()

    def reset(self):
        """Reset this instance. Loses all unprocessed data."""
        self.__starttag_text = None
        self.rawdata = ''
        self.stack = []
        self.lasttag = '???'
        self.nomoretags = 0
        self.literal = 0
        markupbase.ParserBase.reset(self)

    def setnomoretags(self):
        """Enter literal mode (CDATA) till EOF.

        Intended for derived classes only.
        """
        self.nomoretags = self.literal = 1

    def setliteral(self, *args):
        """Enter literal mode (CDATA).

        Intended for derived classes only.
        """
        self.literal = 1

    def feed(self, data):
        """Feed some data to the parser.

        Call this as often as you want, with as little or as much text
        as you want (may include '\n').  (This just saves the text,
        all the processing is done by goahead().)
        """

        self.rawdata = self.rawdata + data
        self.goahead(0)

    def close(self):
        """Handle the remaining data."""
        self.goahead(1)

    def error(self, message):
        raise SGMLParseError(message)

    # Internal -- handle data as far as reasonable.  May leave state
    # and data to be processed by a subsequent call.  If 'end' is
    # true, force handling all data as if followed by EOF marker.
    def goahead(self, end):
        rawdata = self.rawdata
        i = 0
        n = len(rawdata)
        while i < n:
            if self.nomoretags:
                self.handle_data(rawdata[i:n])
                i = n
                break
            match = interesting.search(rawdata, i)
            if match: j = match.start()
            else: j = n
            if i < j:
                self.handle_data(rawdata[i:j])
            i = j
            if i == n: break
            if rawdata[i] == '<':
                if starttagopen.match(rawdata, i):
                    if self.literal:
                        self.handle_data(rawdata[i])
                        i = i+1
                        continue
                    k = self.parse_starttag(i)
                    if k < 0: break
                    i = k
                    continue
                if rawdata.startswith("</", i):
                    k = self.parse_endtag(i)
                    if k < 0: break
                    i = k
                    self.literal = 0
                    continue
                if self.literal:
                    if n > (i + 1):
                        self.handle_data("<")
                        i = i+1
                    else:
                        # incomplete
                        break
                    continue
                if rawdata.startswith("<!--", i):
                        # Strictly speaking, a comment is --.*--
                        # within a declaration tag <!...>.
                        # This should be removed,
                        # and comments handled only in parse_declaration.
                    k = self.parse_comment(i)
                    if k < 0: break
                    i = k
                    continue
                if rawdata.startswith("<?", i):
                    k = self.parse_pi(i)
                    if k < 0: break
                    i = i+k
                    continue
                if rawdata.startswith("<!", i):
                    # This is some sort of declaration; in "HTML as
                    # deployed," this should only be the document type
                    # declaration ("<!DOCTYPE html...>").
                    k = self.parse_declaration(i)
                    if k < 0: break
                    i = k
                    continue
            elif rawdata[i] == '&':
                if self.literal:
                    self.handle_data(rawdata[i])
                    i = i+1
                    continue
                match = charref.match(rawdata, i)
                if match:
                    name = match.group(1)
                    self.handle_charref(name)
                    i = match.end(0)
                    if rawdata[i-1] != ';': i = i-1
                    continue
                match = entityref.match(rawdata, i)
                if match:
                    name = match.group(1)
                    self.handle_entityref(name)
                    i = match.end(0)
                    if rawdata[i-1] != ';': i = i-1
                    continue
            else:
                self.error('neither < nor & ??')
            # We get here only if incomplete matches but
            # nothing else
            match = incomplete.match(rawdata, i)
            if not match:
                self.handle_data(rawdata[i])
                i = i+1
                continue
            j = match.end(0)
            if j == n:
                break # Really incomplete
            self.handle_data(rawdata[i:j])
            i = j
        # end while
        if end and i < n:
            self.handle_data(rawdata[i:n])
            i = n
        self.rawdata = rawdata[i:]
        # XXX if end: check for empty stack

    # Extensions for the DOCTYPE scanner:
    _decl_otherchars = '='

    # Internal -- parse processing instr, return length or -1 if not terminated
    def parse_pi(self, i):
        rawdata = self.rawdata
        if rawdata[i:i+2] != '<?':
            self.error('unexpected call to parse_pi()')
        match = piclose.search(rawdata, i+2)
        if not match:
            return -1
        j = match.start(0)
        self.handle_pi(rawdata[i+2: j])
        j = match.end(0)
        return j-i

    def get_starttag_text(self):
        return self.__starttag_text

    # Internal -- handle starttag, return length or -1 if not terminated
    def parse_starttag(self, i):
        self.__starttag_text = None
        start_pos = i
        rawdata = self.rawdata
        if shorttagopen.match(rawdata, i):
            # SGML shorthand: <tag/data/ == <tag>data</tag>
            # XXX Can data contain &... (entity or char refs)?
            # XXX Can data contain < or > (tag characters)?
            # XXX Can there be whitespace before the first /?
            match = shorttag.match(rawdata, i)
            if not match:
                return -1
            tag, data = match.group(1, 2)
            self.__starttag_text = '<%s/' % tag
            tag = tag.lower()
            k = match.end(0)
            self.finish_shorttag(tag, data)
            self.__starttag_text = rawdata[start_pos:match.end(1) + 1]
            return k
        # XXX The following should skip matching quotes (' or ")
        # As a shortcut way to exit, this isn't so bad, but shouldn't
        # be used to locate the actual end of the start tag since the
        # < or > characters may be embedded in an attribute value.
        match = endbracket.search(rawdata, i+1)
        if not match:
            return -1
        j = match.start(0)
        # Now parse the data between i+1 and j into a tag and attrs
        attrs = []
        if rawdata[i:i+2] == '<>':
            # SGML shorthand: <> == <last open tag seen>
            k = j
            tag = self.lasttag
        else:
            match = tagfind.match(rawdata, i+1)
            if not match:
                self.error('unexpected call to parse_starttag')
            k = match.end(0)
            tag = rawdata[i+1:k].lower()
            self.lasttag = tag
        while k < j:
            match = attrfind.match(rawdata, k)
            if not match: break
            attrname, rest, attrvalue = match.group(1, 2, 3)
            if not rest:
                attrvalue = attrname
            else:
                if (attrvalue[:1] == "'" == attrvalue[-1:] or
                    attrvalue[:1] == '"' == attrvalue[-1:]):
                    # strip quotes
                    attrvalue = attrvalue[1:-1]
                attrvalue = self.entity_or_charref.sub(
                    self._convert_ref, attrvalue)
            attrs.append((attrname.lower(), attrvalue))
            k = match.end(0)
        if rawdata[j] == '>':
            j = j+1
        self.__starttag_text = rawdata[start_pos:j]
        self.finish_starttag(tag, attrs)
        return j

    # Internal -- convert entity or character reference
    def _convert_ref(self, match):
        if match.group(2):
            return self.convert_charref(match.group(2)) or \
                '&#%s%s' % match.groups()[1:]
        elif match.group(3):
            return self.convert_entityref(match.group(1)) or \
                '&%s;' % match.group(1)
        else:
            return '&%s' % match.group(1)

    # Internal -- parse endtag
    def parse_endtag(self, i):
        rawdata = self.rawdata
        match = endbracket.search(rawdata, i+1)
        if not match:
            return -1
        j = match.start(0)
        tag = rawdata[i+2:j].strip().lower()
        if rawdata[j] == '>':
            j = j+1
        self.finish_endtag(tag)
        return j

    # Internal -- finish parsing of <tag/data/ (same as <tag>data</tag>)
    def finish_shorttag(self, tag, data):
        self.finish_starttag(tag, [])
        self.handle_data(data)
        self.finish_endtag(tag)

    # Internal -- finish processing of start tag
    # Return -1 for unknown tag, 0 for open-only tag, 1 for balanced tag
    def finish_starttag(self, tag, attrs):
        try:
            method = getattr(self, 'start_' + tag)
        except AttributeError:
            try:
                method = getattr(self, 'do_' + tag)
            except AttributeError:
                self.unknown_starttag(tag, attrs)
                return -1
            else:
                self.handle_starttag(tag, method, attrs)
                return 0
        else:
            self.stack.append(tag)
            self.handle_starttag(tag, method, attrs)
            return 1

    # Internal -- finish processing of end tag
    def finish_endtag(self, tag):
        if not tag:
            found = len(self.stack) - 1
            if found < 0:
                self.unknown_endtag(tag)
                return
        else:
            if tag not in self.stack:
                try:
                    method = getattr(self, 'end_' + tag)
                except AttributeError:
                    self.unknown_endtag(tag)
                else:
                    self.report_unbalanced(tag)
                return
            found = len(self.stack)
            for i in range(found):
                if self.stack[i] == tag: found = i
        while len(self.stack) > found:
            tag = self.stack[-1]
            try:
                method = getattr(self, 'end_' + tag)
            except AttributeError:
                method = None
            if method:
                self.handle_endtag(tag, method)
            else:
                self.unknown_endtag(tag)
            del self.stack[-1]

    # Overridable -- handle start tag
    def handle_starttag(self, tag, method, attrs):
        method(attrs)

    # Overridable -- handle end tag
    def handle_endtag(self, tag, method):
        method()

    # Example -- report an unbalanced </...> tag.
    def report_unbalanced(self, tag):
        if self.verbose:
            print '*** Unbalanced </' + tag + '>'
            print '*** Stack:', self.stack

    def convert_charref(self, name):
        """Convert character reference, may be overridden."""
        try:
            n = int(name)
        except ValueError:
            return
        if not 0 <= n <= 127:
            return
        return self.convert_codepoint(n)

    def convert_codepoint(self, codepoint):
        return chr(codepoint)

    def handle_charref(self, name):
        """Handle character reference, no need to override."""
        replacement = self.convert_charref(name)
        if replacement is None:
            self.unknown_charref(name)
        else:
            self.handle_data(replacement)

    # Definition of entities -- derived classes may override
    entitydefs = \
            {'lt': '<', 'gt': '>', 'amp': '&', 'quot': '"', 'apos': '\''}

    def convert_entityref(self, name):
        """Convert entity references.

        As an alternative to overriding this method; one can tailor the
        results by setting up the self.entitydefs mapping appropriately.
        """
        table = self.entitydefs
        if name in table:
            return table[name]
        else:
            return

    def handle_entityref(self, name):
        """Handle entity references, no need to override."""
        replacement = self.convert_entityref(name)
        if replacement is None:
            self.unknown_entityref(name)
        else:
            self.handle_data(replacement)

    # Example -- handle data, should be overridden
    def handle_data(self, data):
        pass

    # Example -- handle comment, could be overridden
    def handle_comment(self, data):
        pass

    # Example -- handle declaration, could be overridden
    def handle_decl(self, decl):
        pass

    # Example -- handle processing instruction, could be overridden
    def handle_pi(self, data):
        pass

    # To be overridden -- handlers for unknown objects
    def unknown_starttag(self, tag, attrs): pass
    def unknown_endtag(self, tag): pass
    def unknown_charref(self, ref): pass
    def unknown_entityref(self, ref): pass


class TestSGMLParser(SGMLParser):

    def __init__(self, verbose=0):
        self.testdata = ""
        SGMLParser.__init__(self, verbose)

    def handle_data(self, data):
        self.testdata = self.testdata + data
        if len(repr(self.testdata)) >= 70:
            self.flush()

    def flush(self):
        data = self.testdata
        if data:
            self.testdata = ""
            print 'data:', repr(data)

    def handle_comment(self, data):
        self.flush()
        r = repr(data)
        if len(r) > 68:
            r = r[:32] + '...' + r[-32:]
        print 'comment:', r

    def unknown_starttag(self, tag, attrs):
        self.flush()
        if not attrs:
            print 'start tag: <' + tag + '>'
        else:
            print 'start tag: <' + tag,
            for name, value in attrs:
                print name + '=' + '"' + value + '"',
            print '>'

    def unknown_endtag(self, tag):
        self.flush()
        print 'end tag: </' + tag + '>'

    def unknown_entityref(self, ref):
        self.flush()
        print '*** unknown entity ref: &' + ref + ';'

    def unknown_charref(self, ref):
        self.flush()
        print '*** unknown char ref: &#' + ref + ';'

    def unknown_decl(self, data):
        self.flush()
        print '*** unknown decl: [' + data + ']'

    def close(self):
        SGMLParser.close(self)
        self.flush()


def test(args = None):
    import sys

    if args is None:
        args = sys.argv[1:]

    if args and args[0] == '-s':
        args = args[1:]
        klass = SGMLParser
    else:
        klass = TestSGMLParser

    if args:
        file = args[0]
    else:
        file = 'test.html'

    if file == '-':
        f = sys.stdin
    else:
        try:
            f = open(file, 'r')
        except IOError, msg:
            print file, ":", msg
            sys.exit(1)

    data = f.read()
    if f is not sys.stdin:
        f.close()

    x = klass()
    for c in data:
        x.feed(c)
    x.close()


if __name__ == '__main__':
    test()

filename:/usr/lib/python2.7/UserString.py
__doc__
#! /usr/bin/python2.7
## vim:ts=4:et:nowrap
"""A user-defined wrapper around string objects

filename:/usr/lib/python2.7/compileall.py
__doc__
"""Module/script to byte-compile all .py files to .pyc (or .pyo) files.

When called as a script with arguments, this compiles the directories
given as arguments recursively; the -l option prevents it from
recursing into directories.

Without arguments, if compiles all modules on sys.path, without
recursing into subdirectories.  (Even though it should do so for
packages -- for now, you'll have to deal with packages separately.)

See module py_compile for details of the actual byte-compilation.
"""

filename:/usr/lib/python2.7/bisect.py
__doc__
"""Bisection algorithms."""

def insort_right(a, x, lo=0, hi=None):
    """Insert item x in list a, and keep it sorted assuming a is sorted.

    If x is already in a, insert it to the right of the rightmost x.

    Optional args lo (default 0) and hi (default len(a)) bound the
    slice of a to be searched.
    """

    if lo < 0:
        raise ValueError('lo must be non-negative')
    if hi is None:
        hi = len(a)
    while lo < hi:
        mid = (lo+hi)//2
        if x < a[mid]: hi = mid
        else: lo = mid+1
    a.insert(lo, x)

insort = insort_right   # backward compatibility

def bisect_right(a, x, lo=0, hi=None):
    """Return the index where to insert item x in list a, assuming a is sorted.

    The return value i is such that all e in a[:i] have e <= x, and all e in
    a[i:] have e > x.  So if x already appears in the list, a.insert(x) will
    insert just after the rightmost x already there.

    Optional args lo (default 0) and hi (default len(a)) bound the
    slice of a to be searched.
    """

    if lo < 0:
        raise ValueError('lo must be non-negative')
    if hi is None:
        hi = len(a)
    while lo < hi:
        mid = (lo+hi)//2
        if x < a[mid]: hi = mid
        else: lo = mid+1
    return lo

bisect = bisect_right   # backward compatibility

def insort_left(a, x, lo=0, hi=None):
    """Insert item x in list a, and keep it sorted assuming a is sorted.

    If x is already in a, insert it to the left of the leftmost x.

    Optional args lo (default 0) and hi (default len(a)) bound the
    slice of a to be searched.
    """

    if lo < 0:
        raise ValueError('lo must be non-negative')
    if hi is None:
        hi = len(a)
    while lo < hi:
        mid = (lo+hi)//2
        if a[mid] < x: lo = mid+1
        else: hi = mid
    a.insert(lo, x)


def bisect_left(a, x, lo=0, hi=None):
    """Return the index where to insert item x in list a, assuming a is sorted.

    The return value i is such that all e in a[:i] have e < x, and all e in
    a[i:] have e >= x.  So if x already appears in the list, a.insert(x) will
    insert just before the leftmost x already there.

    Optional args lo (default 0) and hi (default len(a)) bound the
    slice of a to be searched.
    """

    if lo < 0:
        raise ValueError('lo must be non-negative')
    if hi is None:
        hi = len(a)
    while lo < hi:
        mid = (lo+hi)//2
        if a[mid] < x: lo = mid+1
        else: hi = mid
    return lo

# Overwrite above definitions with a fast C implementation
try:
    from _bisect import *
except ImportError:
    pass

filename:/usr/lib/python2.7/hotshot/__init__.py
__doc__
"""High-perfomance logging profiler, mostly written in C."""

filename:/usr/lib/python2.7/hotshot/stats.py
__doc__
"""Statistics analyzer for HotShot."""

try:
    import profile
    import pstats
except ImportError, e:
    raise ImportError, str(e) + '; please install the python-profiler package'

import hotshot.log

from hotshot.log import ENTER, EXIT


def load(filename):
    return StatsLoader(filename).load()


class StatsLoader:
    def __init__(self, logfn):
        self._logfn = logfn
        self._code = {}
        self._stack = []
        self.pop_frame = self._stack.pop

    def load(self):
        # The timer selected by the profiler should never be used, so make
        # sure it doesn't work:
        p = Profile()
        p.get_time = _brokentimer
        log = hotshot.log.LogReader(self._logfn)
        taccum = 0
        for event in log:
            what, (filename, lineno, funcname), tdelta = event
            if tdelta > 0:
                taccum += tdelta

            # We multiply taccum to convert from the microseconds we
            # have to the seconds that the profile/pstats module work
            # with; this allows the numbers to have some basis in
            # reality (ignoring calibration issues for now).

            if what == ENTER:
                frame = self.new_frame(filename, lineno, funcname)
                p.trace_dispatch_call(frame, taccum * .000001)
                taccum = 0

            elif what == EXIT:
                frame = self.pop_frame()
                p.trace_dispatch_return(frame, taccum * .000001)
                taccum = 0

            # no further work for line events

        assert not self._stack
        return pstats.Stats(p)

    def new_frame(self, *args):
        # args must be filename, firstlineno, funcname
        # our code objects are cached since we don't need to create
        # new ones every time
        try:
            code = self._code[args]
        except KeyError:
            code = FakeCode(*args)
            self._code[args] = code
        # frame objects are create fresh, since the back pointer will
        # vary considerably
        if self._stack:
            back = self._stack[-1]
        else:
            back = None
        frame = FakeFrame(code, back)
        self._stack.append(frame)
        return frame


class Profile(profile.Profile):
    def simulate_cmd_complete(self):
        pass


class FakeCode:
    def __init__(self, filename, firstlineno, funcname):
        self.co_filename = filename
        self.co_firstlineno = firstlineno
        self.co_name = self.__name__ = funcname


class FakeFrame:
    def __init__(self, code, back):
        self.f_back = back
        self.f_code = code


def _brokentimer():
    raise RuntimeError, "this timer should not be called"

filename:/usr/lib/python2.7/hotshot/log.py
__doc__
import _hotshot
import os.path
import parser
import symbol

from _hotshot import \
     WHAT_ENTER, \
     WHAT_EXIT, \
     WHAT_LINENO, \
     WHAT_DEFINE_FILE, \
     WHAT_DEFINE_FUNC, \
     WHAT_ADD_INFO


__all__ = ["LogReader", "ENTER", "EXIT", "LINE"]


ENTER = WHAT_ENTER
EXIT  = WHAT_EXIT
LINE  = WHAT_LINENO


class LogReader:
    def __init__(self, logfn):
        # fileno -> filename
        self._filemap = {}
        # (fileno, lineno) -> filename, funcname
        self._funcmap = {}

        self._reader = _hotshot.logreader(logfn)
        self._nextitem = self._reader.next
        self._info = self._reader.info
        if 'current-directory' in self._info:
            self.cwd = self._info['current-directory']
        else:
            self.cwd = None

        # This mirrors the call stack of the profiled code as the log
        # is read back in.  It contains tuples of the form:
        #
        #   (file name, line number of function def, function name)
        #
        self._stack = []
        self._append = self._stack.append
        self._pop = self._stack.pop

    def close(self):
        self._reader.close()

    def fileno(self):
        """Return the file descriptor of the log reader's log file."""
        return self._reader.fileno()

    def addinfo(self, key, value):
        """This method is called for each additional ADD_INFO record.

        This can be overridden by applications that want to receive
        these events.  The default implementation does not need to be
        called by alternate implementations.

        The initial set of ADD_INFO records do not pass through this
        mechanism; this is only needed to receive notification when
        new values are added.  Subclasses can inspect self._info after
        calling LogReader.__init__().
        """
        pass

    def get_filename(self, fileno):
        try:
            return self._filemap[fileno]
        except KeyError:
            raise ValueError, "unknown fileno"

    def get_filenames(self):
        return self._filemap.values()

    def get_fileno(self, filename):
        filename = os.path.normcase(os.path.normpath(filename))
        for fileno, name in self._filemap.items():
            if name == filename:
                return fileno
        raise ValueError, "unknown filename"

    def get_funcname(self, fileno, lineno):
        try:
            return self._funcmap[(fileno, lineno)]
        except KeyError:
            raise ValueError, "unknown function location"

    # Iteration support:
    # This adds an optional (& ignored) parameter to next() so that the
    # same bound method can be used as the __getitem__() method -- this
    # avoids using an additional method call which kills the performance.

    def next(self, index=0):
        while 1:
            # This call may raise StopIteration:
            what, tdelta, fileno, lineno = self._nextitem()

            # handle the most common cases first

            if what == WHAT_ENTER:
                filename, funcname = self._decode_location(fileno, lineno)
                t = (filename, lineno, funcname)
                self._append(t)
                return what, t, tdelta

            if what == WHAT_EXIT:
                try:
                    return what, self._pop(), tdelta
                except IndexError:
                    raise StopIteration

            if what == WHAT_LINENO:
                filename, firstlineno, funcname = self._stack[-1]
                return what, (filename, lineno, funcname), tdelta

            if what == WHAT_DEFINE_FILE:
                filename = os.path.normcase(os.path.normpath(tdelta))
                self._filemap[fileno] = filename
            elif what == WHAT_DEFINE_FUNC:
                filename = self._filemap[fileno]
                self._funcmap[(fileno, lineno)] = (filename, tdelta)
            elif what == WHAT_ADD_INFO:
                # value already loaded into self.info; call the
                # overridable addinfo() handler so higher-level code
                # can pick up the new value
                if tdelta == 'current-directory':
                    self.cwd = lineno
                self.addinfo(tdelta, lineno)
            else:
                raise ValueError, "unknown event type"

    def __iter__(self):
        return self

    #
    #  helpers
    #

    def _decode_location(self, fileno, lineno):
        try:
            return self._funcmap[(fileno, lineno)]
        except KeyError:
            #
            # This should only be needed when the log file does not
            # contain all the DEFINE_FUNC records needed to allow the
            # function name to be retrieved from the log file.
            #
            if self._loadfile(fileno):
                filename = funcname = None
            try:
                filename, funcname = self._funcmap[(fileno, lineno)]
            except KeyError:
                filename = self._filemap.get(fileno)
                funcname = None
                self._funcmap[(fileno, lineno)] = (filename, funcname)
        return filename, funcname

    def _loadfile(self, fileno):
        try:
            filename = self._filemap[fileno]
        except KeyError:
            print "Could not identify fileId", fileno
            return 1
        if filename is None:
            return 1
        absname = os.path.normcase(os.path.join(self.cwd, filename))

        try:
            fp = open(absname)
        except IOError:
            return
        st = parser.suite(fp.read())
        fp.close()

        # Scan the tree looking for def and lambda nodes, filling in
        # self._funcmap with all the available information.
        funcdef = symbol.funcdef
        lambdef = symbol.lambdef

        stack = [st.totuple(1)]

        while stack:
            tree = stack.pop()
            try:
                sym = tree[0]
            except (IndexError, TypeError):
                continue
            if sym == funcdef:
                self._funcmap[(fileno, tree[2][2])] = filename, tree[2][1]
            elif sym == lambdef:
                self._funcmap[(fileno, tree[1][2])] = filename, "<lambda>"
            stack.extend(list(tree[1:]))

filename:/usr/lib/python2.7/ntpath.py
__doc__
# Module 'ntpath' -- common operations on WinNT/Win95 pathnames
"""Common pathname manipulations, WindowsNT/95 version.

filename:/usr/lib/python2.7/cgitb.py
__doc__
"""More comprehensive traceback formatting for Python scripts.

To enable this module, do:

    import cgitb; cgitb.enable()

at the top of your script.  The optional arguments to enable() are:

    display     - if true, tracebacks are displayed in the web browser
    logdir      - if set, tracebacks are written to files in this directory
    context     - number of lines of source code to show for each stack frame
    format      - 'text' or 'html' controls the output format

By default, tracebacks are displayed but not saved, the context is 5 lines
and the output format is 'html' (for backwards compatibility with the
original use of this module)

Alternatively, if you have caught an exception and want cgitb to display it
for you, call cgitb.handler().  The optional argument to handler() is a
3-item tuple (etype, evalue, etb) just like the value of sys.exc_info().
The default handler displays output as HTML.

"""

filename:/usr/lib/python2.7/py_compile.py
__doc__
"""Routine to "compile" a .py file to a .pyc (or .pyo) file.

This module has intimate knowledge of the format of .pyc files.
"""

filename:/usr/lib/python2.7/encodings/cp775.py
__doc__
""" Python Character Mapping Codec cp775 generated from 'VENDORS/MICSFT/PC/CP775.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/iso8859_10.py
__doc__
""" Python Character Mapping Codec iso8859_10 generated from 'MAPPINGS/ISO8859/8859-10.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/cp862.py
__doc__
""" Python Character Mapping Codec generated from 'VENDORS/MICSFT/PC/CP862.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/unicode_internal.py
__doc__
""" Python 'unicode-internal' Codec


Written by Marc-Andre Lemburg (mal@lemburg.com).

(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.

"""

filename:/usr/lib/python2.7/encodings/hex_codec.py
__doc__
""" Python 'hex_codec' Codec - 2-digit hex content transfer encoding

    Unlike most of the other codecs which target Unicode, this codec
    will return Python string objects for both encode and decode.

    Written by Marc-Andre Lemburg (mal@lemburg.com).

"""

filename:/usr/lib/python2.7/encodings/__init__.py
__doc__
""" Standard "encodings" Package

    Standard Python encoding modules are stored in this package
    directory.

    Codec modules must have names corresponding to normalized encoding
    names as defined in the normalize_encoding() function below, e.g.
    'utf-8' must be implemented by the module 'utf_8.py'.

    Each codec module must export the following interface:

    * getregentry() -> codecs.CodecInfo object
    The getregentry() API must a CodecInfo object with encoder, decoder,
    incrementalencoder, incrementaldecoder, streamwriter and streamreader
    atttributes which adhere to the Python Codec Interface Standard.

    In addition, a module may optionally also define the following
    APIs which are then used by the package's codec search function:

    * getaliases() -> sequence of encoding name strings to use as aliases

    Alias names returned by getaliases() must be normalized encoding
    names as defined by normalize_encoding().

Written by Marc-Andre Lemburg (mal@lemburg.com).

(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.

"""#"

filename:/usr/lib/python2.7/encodings/mac_farsi.py
__doc__
""" Python Character Mapping Codec mac_farsi generated from 'MAPPINGS/VENDORS/APPLE/FARSI.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/cp437.py
__doc__
""" Python Character Mapping Codec cp437 generated from 'VENDORS/MICSFT/PC/CP437.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/bz2_codec.py
__doc__
""" Python 'bz2_codec' Codec - bz2 compression encoding

    Unlike most of the other codecs which target Unicode, this codec
    will return Python string objects for both encode and decode.

    Adapted by Raymond Hettinger from zlib_codec.py which was written
    by Marc-Andre Lemburg (mal@lemburg.com).

"""

filename:/usr/lib/python2.7/encodings/iso8859_7.py
__doc__
""" Python Character Mapping Codec iso8859_7 generated from 'MAPPINGS/ISO8859/8859-7.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/koi8_r.py
__doc__
""" Python Character Mapping Codec koi8_r generated from 'MAPPINGS/VENDORS/MISC/KOI8-R.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/cp1258.py
__doc__
""" Python Character Mapping Codec cp1258 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1258.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/iso8859_1.py
__doc__
""" Python Character Mapping Codec iso8859_1 generated from 'MAPPINGS/ISO8859/8859-1.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/mac_croatian.py
__doc__
""" Python Character Mapping Codec mac_croatian generated from 'MAPPINGS/VENDORS/APPLE/CROATIAN.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/utf_32_be.py
__doc__
"""
Python 'utf-32-be' Codec
"""

filename:/usr/lib/python2.7/encodings/cp861.py
__doc__
""" Python Character Mapping Codec generated from 'VENDORS/MICSFT/PC/CP861.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/koi8_u.py
__doc__
""" Python Character Mapping Codec koi8_u generated from 'python-mappings/KOI8-U.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/utf_32.py
__doc__
"""
Python 'utf-32' Codec
"""

filename:/usr/lib/python2.7/encodings/cp874.py
__doc__
""" Python Character Mapping Codec cp874 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP874.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/tis_620.py
__doc__
""" Python Character Mapping Codec tis_620 generated from 'python-mappings/TIS-620.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/iso8859_11.py
__doc__
""" Python Character Mapping Codec iso8859_11 generated from 'MAPPINGS/ISO8859/8859-11.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/cp737.py
__doc__
""" Python Character Mapping Codec cp737 generated from 'VENDORS/MICSFT/PC/CP737.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/cp1257.py
__doc__
""" Python Character Mapping Codec cp1257 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1257.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/iso8859_6.py
__doc__
""" Python Character Mapping Codec iso8859_6 generated from 'MAPPINGS/ISO8859/8859-6.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/cp1140.py
__doc__
""" Python Character Mapping Codec cp1140 generated from 'python-mappings/CP1140.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/undefined.py
__doc__
""" Python 'undefined' Codec

    This codec will always raise a ValueError exception when being
    used. It is intended for use by the site.py file to switch off
    automatic string to Unicode coercion.

Written by Marc-Andre Lemburg (mal@lemburg.com).

(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.

"""

filename:/usr/lib/python2.7/encodings/cp1256.py
__doc__
""" Python Character Mapping Codec cp1256 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1256.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/latin_1.py
__doc__
""" Python 'latin-1' Codec


Written by Marc-Andre Lemburg (mal@lemburg.com).

(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.

"""

filename:/usr/lib/python2.7/encodings/cp864.py
__doc__
""" Python Character Mapping Codec generated from 'VENDORS/MICSFT/PC/CP864.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/cp500.py
__doc__
""" Python Character Mapping Codec cp500 generated from 'MAPPINGS/VENDORS/MICSFT/EBCDIC/CP500.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/cp860.py
__doc__
""" Python Character Mapping Codec generated from 'VENDORS/MICSFT/PC/CP860.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/mbcs.py
__doc__
""" Python 'mbcs' Codec for Windows


Cloned by Mark Hammond (mhammond@skippinet.com.au) from ascii.py,
which was written by Marc-Andre Lemburg (mal@lemburg.com).

(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.

"""

filename:/usr/lib/python2.7/encodings/iso8859_2.py
__doc__
""" Python Character Mapping Codec iso8859_2 generated from 'MAPPINGS/ISO8859/8859-2.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/cp1253.py
__doc__
""" Python Character Mapping Codec cp1253 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1253.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/utf_16_be.py
__doc__
""" Python 'utf-16-be' Codec


Written by Marc-Andre Lemburg (mal@lemburg.com).

(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.

"""

filename:/usr/lib/python2.7/encodings/cp1006.py
__doc__
""" Python Character Mapping Codec cp1006 generated from 'MAPPINGS/VENDORS/MISC/CP1006.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/cp866.py
__doc__
""" Python Character Mapping Codec generated from 'VENDORS/MICSFT/PC/CP866.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/cp875.py
__doc__
""" Python Character Mapping Codec cp875 generated from 'MAPPINGS/VENDORS/MICSFT/EBCDIC/CP875.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/iso8859_13.py
__doc__
""" Python Character Mapping Codec iso8859_13 generated from 'MAPPINGS/ISO8859/8859-13.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/cp855.py
__doc__
""" Python Character Mapping Codec generated from 'VENDORS/MICSFT/PC/CP855.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/utf_8.py
__doc__
""" Python 'utf-8' Codec


Written by Marc-Andre Lemburg (mal@lemburg.com).

(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.

"""

filename:/usr/lib/python2.7/encodings/iso8859_3.py
__doc__
""" Python Character Mapping Codec iso8859_3 generated from 'MAPPINGS/ISO8859/8859-3.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/utf_16.py
__doc__
""" Python 'utf-16' Codec


Written by Marc-Andre Lemburg (mal@lemburg.com).

(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.

"""

filename:/usr/lib/python2.7/encodings/cp1250.py
__doc__
""" Python Character Mapping Codec cp1250 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1250.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/cp863.py
__doc__
""" Python Character Mapping Codec generated from 'VENDORS/MICSFT/PC/CP863.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/mac_centeuro.py
__doc__
""" Python Character Mapping Codec mac_centeuro generated from 'MAPPINGS/VENDORS/APPLE/CENTEURO.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/mac_turkish.py
__doc__
""" Python Character Mapping Codec mac_turkish generated from 'MAPPINGS/VENDORS/APPLE/TURKISH.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/cp857.py
__doc__
""" Python Character Mapping Codec generated from 'VENDORS/MICSFT/PC/CP857.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/aliases.py
__doc__
""" Encoding Aliases Support

    This module is used by the encodings package search function to
    map encodings names to module names.

    Note that the search function normalizes the encoding names before
    doing the lookup, so the mapping will have to map normalized
    encoding names to module names.

    Contents:

        The following aliases dictionary contains mappings of all IANA
        character set names for which the Python core library provides
        codecs. In addition to these, a few Python specific codec
        aliases have also been added.

"""

filename:/usr/lib/python2.7/encodings/palmos.py
__doc__
""" Python Character Mapping Codec for PalmOS 3.5.

Written by Sjoerd Mullender (sjoerd@acm.org); based on iso8859_15.py.

"""#"

filename:/usr/lib/python2.7/encodings/cp1251.py
__doc__
""" Python Character Mapping Codec cp1251 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1251.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/utf_7.py
__doc__
""" Python 'utf-7' Codec

Written by Brian Quinlan (brian@sweetapp.com).
"""

filename:/usr/lib/python2.7/encodings/mac_arabic.py
__doc__
""" Python Character Mapping Codec generated from 'VENDORS/APPLE/ARABIC.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/raw_unicode_escape.py
__doc__
""" Python 'raw-unicode-escape' Codec


Written by Marc-Andre Lemburg (mal@lemburg.com).

(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.

"""

filename:/usr/lib/python2.7/encodings/cp720.py
__doc__
"""Python Character Mapping Codec cp720 generated on Windows:
Vista 6.0.6002 SP2 Multiprocessor Free with the command:
  python Tools/unicode/genwincodec.py 720
"""#"

filename:/usr/lib/python2.7/encodings/ptcp154.py
__doc__
""" Python Character Mapping Codec generated from 'PTCP154.txt' with gencodec.py.

Written by Marc-Andre Lemburg (mal@lemburg.com).

(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.
(c) Copyright 2000 Guido van Rossum.

"""#"

filename:/usr/lib/python2.7/encodings/iso8859_14.py
__doc__
""" Python Character Mapping Codec iso8859_14 generated from 'MAPPINGS/ISO8859/8859-14.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/iso8859_16.py
__doc__
""" Python Character Mapping Codec iso8859_16 generated from 'MAPPINGS/ISO8859/8859-16.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/hp_roman8.py
__doc__
""" Python Character Mapping Codec generated from 'hp_roman8.txt' with gencodec.py.

    Based on data from ftp://dkuug.dk/i18n/charmaps/HP-ROMAN8 (Keld Simonsen)

    Original source: LaserJet IIP Printer User's Manual HP part no
    33471-90901, Hewlet-Packard, June 1989.

"""#"

filename:/usr/lib/python2.7/encodings/utf_32_le.py
__doc__
"""
Python 'utf-32-le' Codec
"""

filename:/usr/lib/python2.7/encodings/cp858.py
__doc__
""" Python Character Mapping Codec for CP858, modified from cp850.

"""

filename:/usr/lib/python2.7/encodings/cp1252.py
__doc__
""" Python Character Mapping Codec cp1252 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1252.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/cp424.py
__doc__
""" Python Character Mapping Codec cp424 generated from 'MAPPINGS/VENDORS/MISC/CP424.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/cp865.py
__doc__
""" Python Character Mapping Codec generated from 'VENDORS/MICSFT/PC/CP865.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/base64_codec.py
__doc__
""" Python 'base64_codec' Codec - base64 content transfer encoding

    Unlike most of the other codecs which target Unicode, this codec
    will return Python string objects for both encode and decode.

    Written by Marc-Andre Lemburg (mal@lemburg.com).

"""

filename:/usr/lib/python2.7/encodings/charmap.py
__doc__
""" Generic Python Character Mapping Codec.

    Use this codec directly rather than through the automatic
    conversion mechanisms supplied by unicode() and .encode().


Written by Marc-Andre Lemburg (mal@lemburg.com).

(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.

"""#"

filename:/usr/lib/python2.7/encodings/cp1254.py
__doc__
""" Python Character Mapping Codec cp1254 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1254.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/quopri_codec.py
__doc__
"""Codec for quoted-printable encoding.

Like base64 and rot13, this returns Python strings, not Unicode.
"""

filename:/usr/lib/python2.7/encodings/uu_codec.py
__doc__
""" Python 'uu_codec' Codec - UU content transfer encoding

    Unlike most of the other codecs which target Unicode, this codec
    will return Python string objects for both encode and decode.

    Written by Marc-Andre Lemburg (mal@lemburg.com). Some details were
    adapted from uu.py which was written by Lance Ellinghouse and
    modified by Jack Jansen and Fredrik Lundh.

"""

filename:/usr/lib/python2.7/encodings/cp850.py
__doc__
""" Python Character Mapping Codec generated from 'VENDORS/MICSFT/PC/CP850.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/utf_16_le.py
__doc__
""" Python 'utf-16-le' Codec


Written by Marc-Andre Lemburg (mal@lemburg.com).

(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.

"""

filename:/usr/lib/python2.7/encodings/mac_latin2.py
__doc__
""" Python Character Mapping Codec generated from 'LATIN2.TXT' with gencodec.py.

Written by Marc-Andre Lemburg (mal@lemburg.com).

(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.
(c) Copyright 2000 Guido van Rossum.

"""#"

filename:/usr/lib/python2.7/encodings/cp856.py
__doc__
""" Python Character Mapping Codec cp856 generated from 'MAPPINGS/VENDORS/MISC/CP856.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/cp869.py
__doc__
""" Python Character Mapping Codec generated from 'VENDORS/MICSFT/PC/CP869.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/unicode_escape.py
__doc__
""" Python 'unicode-escape' Codec


Written by Marc-Andre Lemburg (mal@lemburg.com).

(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.

"""

filename:/usr/lib/python2.7/encodings/ascii.py
__doc__
""" Python 'ascii' Codec


Written by Marc-Andre Lemburg (mal@lemburg.com).

(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.

"""

filename:/usr/lib/python2.7/encodings/iso8859_4.py
__doc__
""" Python Character Mapping Codec iso8859_4 generated from 'MAPPINGS/ISO8859/8859-4.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/iso8859_8.py
__doc__
""" Python Character Mapping Codec iso8859_8 generated from 'MAPPINGS/ISO8859/8859-8.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/cp037.py
__doc__
""" Python Character Mapping Codec cp037 generated from 'MAPPINGS/VENDORS/MICSFT/EBCDIC/CP037.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/iso8859_5.py
__doc__
""" Python Character Mapping Codec iso8859_5 generated from 'MAPPINGS/ISO8859/8859-5.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/zlib_codec.py
__doc__
""" Python 'zlib_codec' Codec - zlib compression encoding

    Unlike most of the other codecs which target Unicode, this codec
    will return Python string objects for both encode and decode.

    Written by Marc-Andre Lemburg (mal@lemburg.com).

"""

filename:/usr/lib/python2.7/encodings/cp1255.py
__doc__
""" Python Character Mapping Codec cp1255 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1255.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/mac_romanian.py
__doc__
""" Python Character Mapping Codec mac_romanian generated from 'MAPPINGS/VENDORS/APPLE/ROMANIAN.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/mac_cyrillic.py
__doc__
""" Python Character Mapping Codec mac_cyrillic generated from 'MAPPINGS/VENDORS/APPLE/CYRILLIC.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/utf_8_sig.py
__doc__
""" Python 'utf-8-sig' Codec
This work similar to UTF-8 with the following changes:

* On encoding/writing a UTF-8 encoded BOM will be prepended/written as the
  first three bytes.

* On decoding/reading if the first three bytes are a UTF-8 encoded BOM, these
  bytes will be skipped.
"""

filename:/usr/lib/python2.7/encodings/iso8859_9.py
__doc__
""" Python Character Mapping Codec iso8859_9 generated from 'MAPPINGS/ISO8859/8859-9.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/mac_iceland.py
__doc__
""" Python Character Mapping Codec mac_iceland generated from 'MAPPINGS/VENDORS/APPLE/ICELAND.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/iso8859_15.py
__doc__
""" Python Character Mapping Codec iso8859_15 generated from 'MAPPINGS/ISO8859/8859-15.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/mac_roman.py
__doc__
""" Python Character Mapping Codec mac_roman generated from 'MAPPINGS/VENDORS/APPLE/ROMAN.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/cp1026.py
__doc__
""" Python Character Mapping Codec cp1026 generated from 'MAPPINGS/VENDORS/MICSFT/EBCDIC/CP1026.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/cp852.py
__doc__
""" Python Character Mapping Codec generated from 'VENDORS/MICSFT/PC/CP852.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/encodings/mac_greek.py
__doc__
""" Python Character Mapping Codec mac_greek generated from 'MAPPINGS/VENDORS/APPLE/GREEK.TXT' with gencodec.py.

"""#"

filename:/usr/lib/python2.7/sre.py
__doc__
"""This file is only retained for backwards compatibility.
It will be removed in the future.  sre was moved to re in version 2.5.
"""

filename:/usr/lib/python2.7/urllib2.py
__doc__
"""An extensible library for opening URLs using a variety of protocols

The simplest way to use this module is to call the urlopen function,
which accepts a string containing a URL or a Request object (described
below).  It opens the URL and returns the results as file-like
object; the returned object has some extra methods described below.

The OpenerDirector manages a collection of Handler objects that do
all the actual work.  Each Handler implements a particular protocol or
option.  The OpenerDirector is a composite object that invokes the
Handlers needed to open the requested URL.  For example, the
HTTPHandler performs HTTP GET and POST requests and deals with
non-error returns.  The HTTPRedirectHandler automatically deals with
HTTP 301, 302, 303 and 307 redirect errors, and the HTTPDigestAuthHandler
deals with digest authentication.

urlopen(url, data=None) -- Basic usage is the same as original
urllib.  pass the url and optionally data to post to an HTTP URL, and
get a file-like object back.  One difference is that you can also pass
a Request instance instead of URL.  Raises a URLError (subclass of
IOError); for HTTP errors, raises an HTTPError, which can also be
treated as a valid response.

build_opener -- Function that creates a new OpenerDirector instance.
Will install the default handlers.  Accepts one or more Handlers as
arguments, either instances or Handler classes that it will
instantiate.  If one of the argument is a subclass of the default
handler, the argument will be installed instead of the default.

install_opener -- Installs a new opener as the default opener.

objects of interest:

OpenerDirector -- Sets up the User Agent as the Python-urllib client and manages
the Handler classes, while dealing with requests and responses.

Request -- An object that encapsulates the state of a request.  The
state can be as simple as the URL.  It can also include extra HTTP
headers, e.g. a User-Agent.

BaseHandler --

exceptions:
URLError -- A subclass of IOError, individual protocols have their own
specific subclass.

HTTPError -- Also a valid HTTP response, so you can treat an HTTP error
as an exceptional event or valid response.

internals:
BaseHandler and parent
_call_chain conventions

Example usage:

import urllib2

# set up authentication info
authinfo = urllib2.HTTPBasicAuthHandler()
authinfo.add_password(realm='PDQ Application',
                      uri='https://mahler:8092/site-updates.py',
                      user='klem',
                      passwd='geheim$parole')

proxy_support = urllib2.ProxyHandler({"http" : "http://ahad-haam:3128"})

# build a new opener that adds authentication and caching FTP handlers
opener = urllib2.build_opener(proxy_support, authinfo, urllib2.CacheFTPHandler)

# install it
urllib2.install_opener(opener)

f = urllib2.urlopen('http://www.python.org/')


"""

filename:/usr/lib/python2.7/_MozillaCookieJar.py
__doc__
"""Mozilla / Netscape cookie loading / saving."""

import re, time

from cookielib import (_warn_unhandled_exception, FileCookieJar, LoadError,
                       Cookie, MISSING_FILENAME_TEXT)

class MozillaCookieJar(FileCookieJar):
    """

    WARNING: you may want to backup your browser's cookies file if you use
    this class to save cookies.  I *think* it works, but there have been
    bugs in the past!

    This class differs from CookieJar only in the format it uses to save and
    load cookies to and from a file.  This class uses the Mozilla/Netscape
    `cookies.txt' format.  lynx uses this file format, too.

    Don't expect cookies saved while the browser is running to be noticed by
    the browser (in fact, Mozilla on unix will overwrite your saved cookies if
    you change them on disk while it's running; on Windows, you probably can't
    save at all while the browser is running).

    Note that the Mozilla/Netscape format will downgrade RFC2965 cookies to
    Netscape cookies on saving.

    In particular, the cookie version and port number information is lost,
    together with information about whether or not Path, Port and Discard were
    specified by the Set-Cookie2 (or Set-Cookie) header, and whether or not the
    domain as set in the HTTP header started with a dot (yes, I'm aware some
    domains in Netscape files start with a dot and some don't -- trust me, you
    really don't want to know any more about this).

    Note that though Mozilla and Netscape use the same format, they use
    slightly different headers.  The class saves cookies using the Netscape
    header by default (Mozilla can cope with that).

    """
    magic_re = "#( Netscape)? HTTP Cookie File"
    header = """\
# Netscape HTTP Cookie File
# http://curl.haxx.se/rfc/cookie_spec.html
# This is a generated file!  Do not edit.

"""

filename:/usr/lib/python2.7/curses/panel.py
__doc__
"""curses.panel

Module for using panels with curses.
"""

filename:/usr/lib/python2.7/curses/textpad.py
__doc__
"""Simple textbox editing widget with Emacs-like keybindings."""

import curses
import curses.ascii

def rectangle(win, uly, ulx, lry, lrx):
    """Draw a rectangle with corners at the provided upper-left
    and lower-right coordinates.
    """
    win.vline(uly+1, ulx, curses.ACS_VLINE, lry - uly - 1)
    win.hline(uly, ulx+1, curses.ACS_HLINE, lrx - ulx - 1)
    win.hline(lry, ulx+1, curses.ACS_HLINE, lrx - ulx - 1)
    win.vline(uly+1, lrx, curses.ACS_VLINE, lry - uly - 1)
    win.addch(uly, ulx, curses.ACS_ULCORNER)
    win.addch(uly, lrx, curses.ACS_URCORNER)
    win.addch(lry, lrx, curses.ACS_LRCORNER)
    win.addch(lry, ulx, curses.ACS_LLCORNER)

class Textbox:
    """Editing widget using the interior of a window object.
     Supports the following Emacs-like key bindings:

    Ctrl-A      Go to left edge of window.
    Ctrl-B      Cursor left, wrapping to previous line if appropriate.
    Ctrl-D      Delete character under cursor.
    Ctrl-E      Go to right edge (stripspaces off) or end of line (stripspaces on).
    Ctrl-F      Cursor right, wrapping to next line when appropriate.
    Ctrl-G      Terminate, returning the window contents.
    Ctrl-H      Delete character backward.
    Ctrl-J      Terminate if the window is 1 line, otherwise insert newline.
    Ctrl-K      If line is blank, delete it, otherwise clear to end of line.
    Ctrl-L      Refresh screen.
    Ctrl-N      Cursor down; move down one line.
    Ctrl-O      Insert a blank line at cursor location.
    Ctrl-P      Cursor up; move up one line.

    Move operations do nothing if the cursor is at an edge where the movement
    is not possible.  The following synonyms are supported where possible:

    KEY_LEFT = Ctrl-B, KEY_RIGHT = Ctrl-F, KEY_UP = Ctrl-P, KEY_DOWN = Ctrl-N
    KEY_BACKSPACE = Ctrl-h
    """
    def __init__(self, win, insert_mode=False):
        self.win = win
        self.insert_mode = insert_mode
        (self.maxy, self.maxx) = win.getmaxyx()
        self.maxy = self.maxy - 1
        self.maxx = self.maxx - 1
        self.stripspaces = 1
        self.lastcmd = None
        win.keypad(1)

    def _end_of_line(self, y):
        """Go to the location of the first blank on the given line,
        returning the index of the last non-blank character."""
        last = self.maxx
        while True:
            if curses.ascii.ascii(self.win.inch(y, last)) != curses.ascii.SP:
                last = min(self.maxx, last+1)
                break
            elif last == 0:
                break
            last = last - 1
        return last

    def _insert_printable_char(self, ch):
        (y, x) = self.win.getyx()
        if y < self.maxy or x < self.maxx:
            if self.insert_mode:
                oldch = self.win.inch()
            # The try-catch ignores the error we trigger from some curses
            # versions by trying to write into the lowest-rightmost spot
            # in the window.
            try:
                self.win.addch(ch)
            except curses.error:
                pass
            if self.insert_mode:
                (backy, backx) = self.win.getyx()
                if curses.ascii.isprint(oldch):
                    self._insert_printable_char(oldch)
                    self.win.move(backy, backx)

    def do_command(self, ch):
        "Process a single editing command."
        (y, x) = self.win.getyx()
        self.lastcmd = ch
        if curses.ascii.isprint(ch):
            if y < self.maxy or x < self.maxx:
                self._insert_printable_char(ch)
        elif ch == curses.ascii.SOH:                           # ^a
            self.win.move(y, 0)
        elif ch in (curses.ascii.STX,curses.KEY_LEFT, curses.ascii.BS,curses.KEY_BACKSPACE):
            if x > 0:
                self.win.move(y, x-1)
            elif y == 0:
                pass
            elif self.stripspaces:
                self.win.move(y-1, self._end_of_line(y-1))
            else:
                self.win.move(y-1, self.maxx)
            if ch in (curses.ascii.BS, curses.KEY_BACKSPACE):
                self.win.delch()
        elif ch == curses.ascii.EOT:                           # ^d
            self.win.delch()
        elif ch == curses.ascii.ENQ:                           # ^e
            if self.stripspaces:
                self.win.move(y, self._end_of_line(y))
            else:
                self.win.move(y, self.maxx)
        elif ch in (curses.ascii.ACK, curses.KEY_RIGHT):       # ^f
            if x < self.maxx:
                self.win.move(y, x+1)
            elif y == self.maxy:
                pass
            else:
                self.win.move(y+1, 0)
        elif ch == curses.ascii.BEL:                           # ^g
            return 0
        elif ch == curses.ascii.NL:                            # ^j
            if self.maxy == 0:
                return 0
            elif y < self.maxy:
                self.win.move(y+1, 0)
        elif ch == curses.ascii.VT:                            # ^k
            if x == 0 and self._end_of_line(y) == 0:
                self.win.deleteln()
            else:
                # first undo the effect of self._end_of_line
                self.win.move(y, x)
                self.win.clrtoeol()
        elif ch == curses.ascii.FF:                            # ^l
            self.win.refresh()
        elif ch in (curses.ascii.SO, curses.KEY_DOWN):         # ^n
            if y < self.maxy:
                self.win.move(y+1, x)
                if x > self._end_of_line(y+1):
                    self.win.move(y+1, self._end_of_line(y+1))
        elif ch == curses.ascii.SI:                            # ^o
            self.win.insertln()
        elif ch in (curses.ascii.DLE, curses.KEY_UP):          # ^p
            if y > 0:
                self.win.move(y-1, x)
                if x > self._end_of_line(y-1):
                    self.win.move(y-1, self._end_of_line(y-1))
        return 1

    def gather(self):
        "Collect and return the contents of the window."
        result = ""
        for y in range(self.maxy+1):
            self.win.move(y, 0)
            stop = self._end_of_line(y)
            if stop == 0 and self.stripspaces:
                continue
            for x in range(self.maxx+1):
                if self.stripspaces and x > stop:
                    break
                result = result + chr(curses.ascii.ascii(self.win.inch(y, x)))
            if self.maxy > 0:
                result = result + "\n"
        return result

    def edit(self, validate=None):
        "Edit in the widget window and collect the results."
        while 1:
            ch = self.win.getch()
            if validate:
                ch = validate(ch)
            if not ch:
                continue
            if not self.do_command(ch):
                break
            self.win.refresh()
        return self.gather()

if __name__ == '__main__':
    def test_editbox(stdscr):
        ncols, nlines = 9, 4
        uly, ulx = 15, 20
        stdscr.addstr(uly-2, ulx, "Use Ctrl-G to end editing.")
        win = curses.newwin(nlines, ncols, uly, ulx)
        rectangle(stdscr, uly-1, ulx-1, uly + nlines, ulx + ncols)
        stdscr.refresh()
        return Textbox(win).edit()

    str = curses.wrapper(test_editbox)
    print 'Contents of text box:', repr(str)

filename:/usr/lib/python2.7/curses/__init__.py
__doc__
"""curses

filename:/usr/lib/python2.7/curses/wrapper.py
__doc__
"""curses.wrapper

Contains one function, wrapper(), which runs another function which
should be the rest of your curses-based application.  If the
application raises an exception, wrapper() will restore the terminal
to a sane state so you can read the resulting traceback.

"""

filename:/usr/lib/python2.7/curses/ascii.py
__doc__
"""Constants and membership tests for ASCII characters"""

NUL     = 0x00  # ^@
SOH     = 0x01  # ^A
STX     = 0x02  # ^B
ETX     = 0x03  # ^C
EOT     = 0x04  # ^D
ENQ     = 0x05  # ^E
ACK     = 0x06  # ^F
BEL     = 0x07  # ^G
BS      = 0x08  # ^H
TAB     = 0x09  # ^I
HT      = 0x09  # ^I
LF      = 0x0a  # ^J
NL      = 0x0a  # ^J
VT      = 0x0b  # ^K
FF      = 0x0c  # ^L
CR      = 0x0d  # ^M
SO      = 0x0e  # ^N
SI      = 0x0f  # ^O
DLE     = 0x10  # ^P
DC1     = 0x11  # ^Q
DC2     = 0x12  # ^R
DC3     = 0x13  # ^S
DC4     = 0x14  # ^T
NAK     = 0x15  # ^U
SYN     = 0x16  # ^V
ETB     = 0x17  # ^W
CAN     = 0x18  # ^X
EM      = 0x19  # ^Y
SUB     = 0x1a  # ^Z
ESC     = 0x1b  # ^[
FS      = 0x1c  # ^\
GS      = 0x1d  # ^]
RS      = 0x1e  # ^^
US      = 0x1f  # ^_
SP      = 0x20  # space
DEL     = 0x7f  # delete

controlnames = [
"NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL",
"BS",  "HT",  "LF",  "VT",  "FF",  "CR",  "SO",  "SI",
"DLE", "DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB",
"CAN", "EM",  "SUB", "ESC", "FS",  "GS",  "RS",  "US",
"SP"
]

def _ctoi(c):
    if type(c) == type(""):
        return ord(c)
    else:
        return c

def isalnum(c): return isalpha(c) or isdigit(c)
def isalpha(c): return isupper(c) or islower(c)
def isascii(c): return _ctoi(c) <= 127          # ?
def isblank(c): return _ctoi(c) in (8,32)
def iscntrl(c): return _ctoi(c) <= 31
def isdigit(c): return _ctoi(c) >= 48 and _ctoi(c) <= 57
def isgraph(c): return _ctoi(c) >= 33 and _ctoi(c) <= 126
def islower(c): return _ctoi(c) >= 97 and _ctoi(c) <= 122
def isprint(c): return _ctoi(c) >= 32 and _ctoi(c) <= 126
def ispunct(c): return _ctoi(c) != 32 and not isalnum(c)
def isspace(c): return _ctoi(c) in (9, 10, 11, 12, 13, 32)
def isupper(c): return _ctoi(c) >= 65 and _ctoi(c) <= 90
def isxdigit(c): return isdigit(c) or \
    (_ctoi(c) >= 65 and _ctoi(c) <= 70) or (_ctoi(c) >= 97 and _ctoi(c) <= 102)
def isctrl(c): return _ctoi(c) < 32
def ismeta(c): return _ctoi(c) > 127

def ascii(c):
    if type(c) == type(""):
        return chr(_ctoi(c) & 0x7f)
    else:
        return _ctoi(c) & 0x7f

def ctrl(c):
    if type(c) == type(""):
        return chr(_ctoi(c) & 0x1f)
    else:
        return _ctoi(c) & 0x1f

def alt(c):
    if type(c) == type(""):
        return chr(_ctoi(c) | 0x80)
    else:
        return _ctoi(c) | 0x80

def unctrl(c):
    bits = _ctoi(c)
    if bits == 0x7f:
        rep = "^?"
    elif isprint(bits & 0x7f):
        rep = chr(bits & 0x7f)
    else:
        rep = "^" + chr(((bits & 0x7f) | 0x20) + 0x20)
    if bits & 0x80:
        return "!" + rep
    return rep

filename:/usr/lib/python2.7/smtplib.py
__doc__
#! /usr/bin/python2.7

'''SMTP/ESMTP client class.

This should follow RFC 821 (SMTP), RFC 1869 (ESMTP), RFC 2554 (SMTP
Authentication) and RFC 2487 (Secure SMTP over TLS).

Notes:

Please remember, when doing ESMTP, that the names of the SMTP service
extensions are NOT the same thing as the option keywords for the RCPT
and MAIL commands!

Example:

  >>> import smtplib
  >>> s=smtplib.SMTP("localhost")
  >>> print s.help()
  This is Sendmail version 8.8.4
  Topics:
      HELO    EHLO    MAIL    RCPT    DATA
      RSET    NOOP    QUIT    HELP    VRFY
      EXPN    VERB    ETRN    DSN
  For more info use "HELP <topic>".
  To report bugs in the implementation send email to
      sendmail-bugs@sendmail.org.
  For local information send email to Postmaster at your site.
  End of HELP info
  >>> s.putcmd("vrfy","someone@here")
  >>> s.getreply()
  (250, "Somebody OverHere <somebody@here.my.org>")
  >>> s.quit()
'''

# Author: The Dragon De Monsyne <dragondm@integral.org>
# ESMTP support, test code and doc fixes added by
#     Eric S. Raymond <esr@thyrsus.com>
# Better RFC 821 compliance (MAIL and RCPT, and CRLF in data)
#     by Carey Evans <c.evans@clear.net.nz>, for picky mail servers.
# RFC 2554 (authentication) support by Gerhard Haering <gerhard@bigfoot.de>.
#
# This was modified from the Python 1.5 library HTTP lib.

import socket
import re
import email.utils
import base64
import hmac
from email.base64mime import encode as encode_base64
from sys import stderr

__all__ = ["SMTPException", "SMTPServerDisconnected", "SMTPResponseException",
           "SMTPSenderRefused", "SMTPRecipientsRefused", "SMTPDataError",
           "SMTPConnectError", "SMTPHeloError", "SMTPAuthenticationError",
           "quoteaddr", "quotedata", "SMTP"]

SMTP_PORT = 25
SMTP_SSL_PORT = 465
CRLF = "\r\n"
_MAXLINE = 8192 # more than 8 times larger than RFC 821, 4.5.3

OLDSTYLE_AUTH = re.compile(r"auth=(.*)", re.I)


# Exception classes used by this module.
class SMTPException(Exception):
    """Base class for all exceptions raised by this module."""

class SMTPServerDisconnected(SMTPException):
    """Not connected to any SMTP server.

    This exception is raised when the server unexpectedly disconnects,
    or when an attempt is made to use the SMTP instance before
    connecting it to a server.
    """

class SMTPResponseException(SMTPException):
    """Base class for all exceptions that include an SMTP error code.

    These exceptions are generated in some instances when the SMTP
    server returns an error code.  The error code is stored in the
    `smtp_code' attribute of the error, and the `smtp_error' attribute
    is set to the error message.
    """

    def __init__(self, code, msg):
        self.smtp_code = code
        self.smtp_error = msg
        self.args = (code, msg)

class SMTPSenderRefused(SMTPResponseException):
    """Sender address refused.

    In addition to the attributes set by on all SMTPResponseException
    exceptions, this sets `sender' to the string that the SMTP refused.
    """

    def __init__(self, code, msg, sender):
        self.smtp_code = code
        self.smtp_error = msg
        self.sender = sender
        self.args = (code, msg, sender)

class SMTPRecipientsRefused(SMTPException):
    """All recipient addresses refused.

    The errors for each recipient are accessible through the attribute
    'recipients', which is a dictionary of exactly the same sort as
    SMTP.sendmail() returns.
    """

    def __init__(self, recipients):
        self.recipients = recipients
        self.args = (recipients,)


class SMTPDataError(SMTPResponseException):
    """The SMTP server didn't accept the data."""

class SMTPConnectError(SMTPResponseException):
    """Error during connection establishment."""

class SMTPHeloError(SMTPResponseException):
    """The server refused our HELO reply."""

class SMTPAuthenticationError(SMTPResponseException):
    """Authentication error.

    Most probably the server didn't accept the username/password
    combination provided.
    """


def quoteaddr(addr):
    """Quote a subset of the email addresses defined by RFC 821.

    Should be able to handle anything rfc822.parseaddr can handle.
    """
    m = (None, None)
    try:
        m = email.utils.parseaddr(addr)[1]
    except AttributeError:
        pass
    if m == (None, None):  # Indicates parse failure or AttributeError
        # something weird here.. punt -ddm
        return "<%s>" % addr
    elif m is None:
        # the sender wants an empty return address
        return "<>"
    else:
        return "<%s>" % m

def _addr_only(addrstring):
    displayname, addr = email.utils.parseaddr(addrstring)
    if (displayname, addr) == ('', ''):
        # parseaddr couldn't parse it, so use it as is.
        return addrstring
    return addr

def quotedata(data):
    """Quote data for email.

    Double leading '.', and change Unix newline '\\n', or Mac '\\r' into
    Internet CRLF end-of-line.
    """
    return re.sub(r'(?m)^\.', '..',
        re.sub(r'(?:\r\n|\n|\r(?!\n))', CRLF, data))


try:
    import ssl
except ImportError:
    _have_ssl = False
else:
    class SSLFakeFile:
        """A fake file like object that really wraps a SSLObject.

        It only supports what is needed in smtplib.
        """
        def __init__(self, sslobj):
            self.sslobj = sslobj

        def readline(self, size=-1):
            if size < 0:
                size = None
            str = ""
            chr = None
            while chr != "\n":
                if size is not None and len(str) >= size:
                    break
                chr = self.sslobj.read(1)
                if not chr:
                    break
                str += chr
            return str

        def close(self):
            pass

    _have_ssl = True

class SMTP:
    """This class manages a connection to an SMTP or ESMTP server.
    SMTP Objects:
        SMTP objects have the following attributes:
            helo_resp
                This is the message given by the server in response to the
                most recent HELO command.

            ehlo_resp
                This is the message given by the server in response to the
                most recent EHLO command. This is usually multiline.

            does_esmtp
                This is a True value _after you do an EHLO command_, if the
                server supports ESMTP.

            esmtp_features
                This is a dictionary, which, if the server supports ESMTP,
                will _after you do an EHLO command_, contain the names of the
                SMTP service extensions this server supports, and their
                parameters (if any).

                Note, all extension names are mapped to lower case in the
                dictionary.

        See each method's docstrings for details.  In general, there is a
        method of the same name to perform each SMTP command.  There is also a
        method called 'sendmail' that will do an entire mail transaction.
        """
    debuglevel = 0
    file = None
    helo_resp = None
    ehlo_msg = "ehlo"
    ehlo_resp = None
    does_esmtp = 0
    default_port = SMTP_PORT

    def __init__(self, host='', port=0, local_hostname=None,
                 timeout=socket._GLOBAL_DEFAULT_TIMEOUT):
        """Initialize a new instance.

        If specified, `host' is the name of the remote host to which to
        connect.  If specified, `port' specifies the port to which to connect.
        By default, smtplib.SMTP_PORT is used.  If a host is specified the
        connect method is called, and if it returns anything other than a
        success code an SMTPConnectError is raised.  If specified,
        `local_hostname` is used as the FQDN of the local host for the
        HELO/EHLO command.  Otherwise, the local hostname is found using
        socket.getfqdn().

        """
        self.timeout = timeout
        self.esmtp_features = {}
        if host:
            (code, msg) = self.connect(host, port)
            if code != 220:
                raise SMTPConnectError(code, msg)
        if local_hostname is not None:
            self.local_hostname = local_hostname
        else:
            # RFC 2821 says we should use the fqdn in the EHLO/HELO verb, and
            # if that can't be calculated, that we should use a domain literal
            # instead (essentially an encoded IP address like [A.B.C.D]).
            fqdn = socket.getfqdn()
            if '.' in fqdn:
                self.local_hostname = fqdn
            else:
                # We can't find an fqdn hostname, so use a domain literal
                addr = '127.0.0.1'
                try:
                    addr = socket.gethostbyname(socket.gethostname())
                except socket.gaierror:
                    pass
                self.local_hostname = '[%s]' % addr

    def set_debuglevel(self, debuglevel):
        """Set the debug output level.

        A non-false value results in debug messages for connection and for all
        messages sent to and received from the server.

        """
        self.debuglevel = debuglevel

    def _get_socket(self, host, port, timeout):
        # This makes it simpler for SMTP_SSL to use the SMTP connect code
        # and just alter the socket connection bit.
        if self.debuglevel > 0:
            print>>stderr, 'connect:', (host, port)
        return socket.create_connection((host, port), timeout)

    def connect(self, host='localhost', port=0):
        """Connect to a host on a given port.

        If the hostname ends with a colon (`:') followed by a number, and
        there is no port specified, that suffix will be stripped off and the
        number interpreted as the port number to use.

        Note: This method is automatically invoked by __init__, if a host is
        specified during instantiation.

        """
        if not port and (host.find(':') == host.rfind(':')):
            i = host.rfind(':')
            if i >= 0:
                host, port = host[:i], host[i + 1:]
                try:
                    port = int(port)
                except ValueError:
                    raise socket.error, "nonnumeric port"
        if not port:
            port = self.default_port
        if self.debuglevel > 0:
            print>>stderr, 'connect:', (host, port)
        self.sock = self._get_socket(host, port, self.timeout)
        (code, msg) = self.getreply()
        if self.debuglevel > 0:
            print>>stderr, "connect:", msg
        return (code, msg)

    def send(self, str):
        """Send `str' to the server."""
        if self.debuglevel > 0:
            print>>stderr, 'send:', repr(str)
        if hasattr(self, 'sock') and self.sock:
            try:
                self.sock.sendall(str)
            except socket.error:
                self.close()
                raise SMTPServerDisconnected('Server not connected')
        else:
            raise SMTPServerDisconnected('please run connect() first')

    def putcmd(self, cmd, args=""):
        """Send a command to the server."""
        if args == "":
            str = '%s%s' % (cmd, CRLF)
        else:
            str = '%s %s%s' % (cmd, args, CRLF)
        self.send(str)

    def getreply(self):
        """Get a reply from the server.

        Returns a tuple consisting of:

          - server response code (e.g. '250', or such, if all goes well)
            Note: returns -1 if it can't read response code.

          - server response string corresponding to response code (multiline
            responses are converted to a single, multiline string).

        Raises SMTPServerDisconnected if end-of-file is reached.
        """
        resp = []
        if self.file is None:
            self.file = self.sock.makefile('rb')
        while 1:
            try:
                line = self.file.readline(_MAXLINE + 1)
            except socket.error as e:
                self.close()
                raise SMTPServerDisconnected("Connection unexpectedly closed: "
                                             + str(e))
            if line == '':
                self.close()
                raise SMTPServerDisconnected("Connection unexpectedly closed")
            if self.debuglevel > 0:
                print>>stderr, 'reply:', repr(line)
            if len(line) > _MAXLINE:
                raise SMTPResponseException(500, "Line too long.")
            resp.append(line[4:].strip())
            code = line[:3]
            # Check that the error code is syntactically correct.
            # Don't attempt to read a continuation line if it is broken.
            try:
                errcode = int(code)
            except ValueError:
                errcode = -1
                break
            # Check if multiline response.
            if line[3:4] != "-":
                break

        errmsg = "\n".join(resp)
        if self.debuglevel > 0:
            print>>stderr, 'reply: retcode (%s); Msg: %s' % (errcode, errmsg)
        return errcode, errmsg

    def docmd(self, cmd, args=""):
        """Send a command, and return its response code."""
        self.putcmd(cmd, args)
        return self.getreply()

    # std smtp commands
    def helo(self, name=''):
        """SMTP 'helo' command.
        Hostname to send for this command defaults to the FQDN of the local
        host.
        """
        self.putcmd("helo", name or self.local_hostname)
        (code, msg) = self.getreply()
        self.helo_resp = msg
        return (code, msg)

    def ehlo(self, name=''):
        """ SMTP 'ehlo' command.
        Hostname to send for this command defaults to the FQDN of the local
        host.
        """
        self.esmtp_features = {}
        self.putcmd(self.ehlo_msg, name or self.local_hostname)
        (code, msg) = self.getreply()
        # According to RFC1869 some (badly written)
        # MTA's will disconnect on an ehlo. Toss an exception if
        # that happens -ddm
        if code == -1 and len(msg) == 0:
            self.close()
            raise SMTPServerDisconnected("Server not connected")
        self.ehlo_resp = msg
        if code != 250:
            return (code, msg)
        self.does_esmtp = 1
        #parse the ehlo response -ddm
        resp = self.ehlo_resp.split('\n')
        del resp[0]
        for each in resp:
            # To be able to communicate with as many SMTP servers as possible,
            # we have to take the old-style auth advertisement into account,
            # because:
            # 1) Else our SMTP feature parser gets confused.
            # 2) There are some servers that only advertise the auth methods we
            #    support using the old style.
            auth_match = OLDSTYLE_AUTH.match(each)
            if auth_match:
                # This doesn't remove duplicates, but that's no problem
                self.esmtp_features["auth"] = self.esmtp_features.get("auth", "") \
                        + " " + auth_match.groups(0)[0]
                continue

            # RFC 1869 requires a space between ehlo keyword and parameters.
            # It's actually stricter, in that only spaces are allowed between
            # parameters, but were not going to check for that here.  Note
            # that the space isn't present if there are no parameters.
            m = re.match(r'(?P<feature>[A-Za-z0-9][A-Za-z0-9\-]*) ?', each)
            if m:
                feature = m.group("feature").lower()
                params = m.string[m.end("feature"):].strip()
                if feature == "auth":
                    self.esmtp_features[feature] = self.esmtp_features.get(feature, "") \
                            + " " + params
                else:
                    self.esmtp_features[feature] = params
        return (code, msg)

    def has_extn(self, opt):
        """Does the server support a given SMTP service extension?"""
        return opt.lower() in self.esmtp_features

    def help(self, args=''):
        """SMTP 'help' command.
        Returns help text from server."""
        self.putcmd("help", args)
        return self.getreply()[1]

    def rset(self):
        """SMTP 'rset' command -- resets session."""
        return self.docmd("rset")

    def noop(self):
        """SMTP 'noop' command -- doesn't do anything :>"""
        return self.docmd("noop")

    def mail(self, sender, options=[]):
        """SMTP 'mail' command -- begins mail xfer session."""
        optionlist = ''
        if options and self.does_esmtp:
            optionlist = ' ' + ' '.join(options)
        self.putcmd("mail", "FROM:%s%s" % (quoteaddr(sender), optionlist))
        return self.getreply()

    def rcpt(self, recip, options=[]):
        """SMTP 'rcpt' command -- indicates 1 recipient for this mail."""
        optionlist = ''
        if options and self.does_esmtp:
            optionlist = ' ' + ' '.join(options)
        self.putcmd("rcpt", "TO:%s%s" % (quoteaddr(recip), optionlist))
        return self.getreply()

    def data(self, msg):
        """SMTP 'DATA' command -- sends message data to server.

        Automatically quotes lines beginning with a period per rfc821.
        Raises SMTPDataError if there is an unexpected reply to the
        DATA command; the return value from this method is the final
        response code received when the all data is sent.
        """
        self.putcmd("data")
        (code, repl) = self.getreply()
        if self.debuglevel > 0:
            print>>stderr, "data:", (code, repl)
        if code != 354:
            raise SMTPDataError(code, repl)
        else:
            q = quotedata(msg)
            if q[-2:] != CRLF:
                q = q + CRLF
            q = q + "." + CRLF
            self.send(q)
            (code, msg) = self.getreply()
            if self.debuglevel > 0:
                print>>stderr, "data:", (code, msg)
            return (code, msg)

    def verify(self, address):
        """SMTP 'verify' command -- checks for address validity."""
        self.putcmd("vrfy", _addr_only(address))
        return self.getreply()
    # a.k.a.
    vrfy = verify

    def expn(self, address):
        """SMTP 'expn' command -- expands a mailing list."""
        self.putcmd("expn", _addr_only(address))
        return self.getreply()

    # some useful methods

    def ehlo_or_helo_if_needed(self):
        """Call self.ehlo() and/or self.helo() if needed.

        If there has been no previous EHLO or HELO command this session, this
        method tries ESMTP EHLO first.

        This method may raise the following exceptions:

         SMTPHeloError            The server didn't reply properly to
                                  the helo greeting.
        """
        if self.helo_resp is None and self.ehlo_resp is None:
            if not (200 <= self.ehlo()[0] <= 299):
                (code, resp) = self.helo()
                if not (200 <= code <= 299):
                    raise SMTPHeloError(code, resp)

    def login(self, user, password):
        """Log in on an SMTP server that requires authentication.

        The arguments are:
            - user:     The user name to authenticate with.
            - password: The password for the authentication.

        If there has been no previous EHLO or HELO command this session, this
        method tries ESMTP EHLO first.

        This method will return normally if the authentication was successful.

        This method may raise the following exceptions:

         SMTPHeloError            The server didn't reply properly to
                                  the helo greeting.
         SMTPAuthenticationError  The server didn't accept the username/
                                  password combination.
         SMTPException            No suitable authentication method was
                                  found.
        """

        def encode_cram_md5(challenge, user, password):
            challenge = base64.decodestring(challenge)
            response = user + " " + hmac.HMAC(password, challenge).hexdigest()
            return encode_base64(response, eol="")

        def encode_plain(user, password):
            return encode_base64("\0%s\0%s" % (user, password), eol="")


        AUTH_PLAIN = "PLAIN"
        AUTH_CRAM_MD5 = "CRAM-MD5"
        AUTH_LOGIN = "LOGIN"

        self.ehlo_or_helo_if_needed()

        if not self.has_extn("auth"):
            raise SMTPException("SMTP AUTH extension not supported by server.")

        # Authentication methods the server supports:
        authlist = self.esmtp_features["auth"].split()

        # List of authentication methods we support: from preferred to
        # less preferred methods. Except for the purpose of testing the weaker
        # ones, we prefer stronger methods like CRAM-MD5:
        preferred_auths = [AUTH_CRAM_MD5, AUTH_PLAIN, AUTH_LOGIN]

        # Determine the authentication method we'll use
        authmethod = None
        for method in preferred_auths:
            if method in authlist:
                authmethod = method
                break

        if authmethod == AUTH_CRAM_MD5:
            (code, resp) = self.docmd("AUTH", AUTH_CRAM_MD5)
            if code == 503:
                # 503 == 'Error: already authenticated'
                return (code, resp)
            (code, resp) = self.docmd(encode_cram_md5(resp, user, password))
        elif authmethod == AUTH_PLAIN:
            (code, resp) = self.docmd("AUTH",
                AUTH_PLAIN + " " + encode_plain(user, password))
        elif authmethod == AUTH_LOGIN:
            (code, resp) = self.docmd("AUTH",
                "%s %s" % (AUTH_LOGIN, encode_base64(user, eol="")))
            if code != 334:
                raise SMTPAuthenticationError(code, resp)
            (code, resp) = self.docmd(encode_base64(password, eol=""))
        elif authmethod is None:
            raise SMTPException("No suitable authentication method found.")
        if code not in (235, 503):
            # 235 == 'Authentication successful'
            # 503 == 'Error: already authenticated'
            raise SMTPAuthenticationError(code, resp)
        return (code, resp)

    def starttls(self, keyfile=None, certfile=None):
        """Puts the connection to the SMTP server into TLS mode.

        If there has been no previous EHLO or HELO command this session, this
        method tries ESMTP EHLO first.

        If the server supports TLS, this will encrypt the rest of the SMTP
        session. If you provide the keyfile and certfile parameters,
        the identity of the SMTP server and client can be checked. This,
        however, depends on whether the socket module really checks the
        certificates.

        This method may raise the following exceptions:

         SMTPHeloError            The server didn't reply properly to
                                  the helo greeting.
        """
        self.ehlo_or_helo_if_needed()
        if not self.has_extn("starttls"):
            raise SMTPException("STARTTLS extension not supported by server.")
        (resp, reply) = self.docmd("STARTTLS")
        if resp == 220:
            if not _have_ssl:
                raise RuntimeError("No SSL support included in this Python")
            self.sock = ssl.wrap_socket(self.sock, keyfile, certfile)
            self.file = SSLFakeFile(self.sock)
            # RFC 3207:
            # The client MUST discard any knowledge obtained from
            # the server, such as the list of SMTP service extensions,
            # which was not obtained from the TLS negotiation itself.
            self.helo_resp = None
            self.ehlo_resp = None
            self.esmtp_features = {}
            self.does_esmtp = 0
        else:
            # RFC 3207:
            # 501 Syntax error (no parameters allowed)
            # 454 TLS not available due to temporary reason
            raise SMTPResponseException(resp, reply)
        return (resp, reply)

    def sendmail(self, from_addr, to_addrs, msg, mail_options=[],
                 rcpt_options=[]):
        """This command performs an entire mail transaction.

        The arguments are:
            - from_addr    : The address sending this mail.
            - to_addrs     : A list of addresses to send this mail to.  A bare
                             string will be treated as a list with 1 address.
            - msg          : The message to send.
            - mail_options : List of ESMTP options (such as 8bitmime) for the
                             mail command.
            - rcpt_options : List of ESMTP options (such as DSN commands) for
                             all the rcpt commands.

        If there has been no previous EHLO or HELO command this session, this
        method tries ESMTP EHLO first.  If the server does ESMTP, message size
        and each of the specified options will be passed to it.  If EHLO
        fails, HELO will be tried and ESMTP options suppressed.

        This method will return normally if the mail is accepted for at least
        one recipient.  It returns a dictionary, with one entry for each
        recipient that was refused.  Each entry contains a tuple of the SMTP
        error code and the accompanying error message sent by the server.

        This method may raise the following exceptions:

         SMTPHeloError          The server didn't reply properly to
                                the helo greeting.
         SMTPRecipientsRefused  The server rejected ALL recipients
                                (no mail was sent).
         SMTPSenderRefused      The server didn't accept the from_addr.
         SMTPDataError          The server replied with an unexpected
                                error code (other than a refusal of
                                a recipient).

        Note: the connection will be open even after an exception is raised.

        Example:

         >>> import smtplib
         >>> s=smtplib.SMTP("localhost")
         >>> tolist=["one@one.org","two@two.org","three@three.org","four@four.org"]
         >>> msg = '''\\
         ... From: Me@my.org
         ... Subject: testin'...
         ...
         ... This is a test '''
         >>> s.sendmail("me@my.org",tolist,msg)
         { "three@three.org" : ( 550 ,"User unknown" ) }
         >>> s.quit()

        In the above example, the message was accepted for delivery to three
        of the four addresses, and one was rejected, with the error code
        550.  If all addresses are accepted, then the method will return an
        empty dictionary.

        """
        self.ehlo_or_helo_if_needed()
        esmtp_opts = []
        if self.does_esmtp:
            # Hmmm? what's this? -ddm
            # self.esmtp_features['7bit']=""
            if self.has_extn('size'):
                esmtp_opts.append("size=%d" % len(msg))
            for option in mail_options:
                esmtp_opts.append(option)

        (code, resp) = self.mail(from_addr, esmtp_opts)
        if code != 250:
            self.rset()
            raise SMTPSenderRefused(code, resp, from_addr)
        senderrs = {}
        if isinstance(to_addrs, basestring):
            to_addrs = [to_addrs]
        for each in to_addrs:
            (code, resp) = self.rcpt(each, rcpt_options)
            if (code != 250) and (code != 251):
                senderrs[each] = (code, resp)
        if len(senderrs) == len(to_addrs):
            # the server refused all our recipients
            self.rset()
            raise SMTPRecipientsRefused(senderrs)
        (code, resp) = self.data(msg)
        if code != 250:
            self.rset()
            raise SMTPDataError(code, resp)
        #if we got here then somebody got our mail
        return senderrs


    def close(self):
        """Close the connection to the SMTP server."""
        try:
            file = self.file
            self.file = None
            if file:
                file.close()
        finally:
            sock = self.sock
            self.sock = None
            if sock:
                sock.close()


    def quit(self):
        """Terminate the SMTP session."""
        res = self.docmd("quit")
        # A new EHLO is required after reconnecting with connect()
        self.ehlo_resp = self.helo_resp = None
        self.esmtp_features = {}
        self.does_esmtp = False
        self.close()
        return res

if _have_ssl:

    class SMTP_SSL(SMTP):
        """ This is a subclass derived from SMTP that connects over an SSL
        encrypted socket (to use this class you need a socket module that was
        compiled with SSL support). If host is not specified, '' (the local
        host) is used. If port is omitted, the standard SMTP-over-SSL port
        (465) is used.  local_hostname has the same meaning as it does in the
        SMTP class.  keyfile and certfile are also optional - they can contain
        a PEM formatted private key and certificate chain file for the SSL
        connection.

        """

        default_port = SMTP_SSL_PORT

        def __init__(self, host='', port=0, local_hostname=None,
                     keyfile=None, certfile=None,
                     timeout=socket._GLOBAL_DEFAULT_TIMEOUT):
            self.keyfile = keyfile
            self.certfile = certfile
            SMTP.__init__(self, host, port, local_hostname, timeout)

        def _get_socket(self, host, port, timeout):
            if self.debuglevel > 0:
                print>>stderr, 'connect:', (host, port)
            new_socket = socket.create_connection((host, port), timeout)
            new_socket = ssl.wrap_socket(new_socket, self.keyfile, self.certfile)
            self.file = SSLFakeFile(new_socket)
            return new_socket

    __all__.append("SMTP_SSL")

#
# LMTP extension
#
LMTP_PORT = 2003

class LMTP(SMTP):
    """LMTP - Local Mail Transfer Protocol

    The LMTP protocol, which is very similar to ESMTP, is heavily based
    on the standard SMTP client. It's common to use Unix sockets for
    LMTP, so our connect() method must support that as well as a regular
    host:port server.  local_hostname has the same meaning as it does in
    the SMTP class.  To specify a Unix socket, you must use an absolute
    path as the host, starting with a '/'.

    Authentication is supported, using the regular SMTP mechanism. When
    using a Unix socket, LMTP generally don't support or require any
    authentication, but your mileage might vary."""

    ehlo_msg = "lhlo"

    def __init__(self, host='', port=LMTP_PORT, local_hostname=None):
        """Initialize a new instance."""
        SMTP.__init__(self, host, port, local_hostname)

    def connect(self, host='localhost', port=0):
        """Connect to the LMTP daemon, on either a Unix or a TCP socket."""
        if host[0] != '/':
            return SMTP.connect(self, host, port)

        # Handle Unix-domain sockets.
        try:
            self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            self.sock.connect(host)
        except socket.error:
            if self.debuglevel > 0:
                print>>stderr, 'connect fail:', host
            if self.sock:
                self.sock.close()
            self.sock = None
            raise
        (code, msg) = self.getreply()
        if self.debuglevel > 0:
            print>>stderr, "connect:", msg
        return (code, msg)


# Test the sendmail method, which tests most of the others.
# Note: This always sends to localhost.
if __name__ == '__main__':
    import sys

    def prompt(prompt):
        sys.stdout.write(prompt + ": ")
        return sys.stdin.readline().strip()

    fromaddr = prompt("From")
    toaddrs = prompt("To").split(',')
    print "Enter message, end with ^D:"
    msg = ''
    while 1:
        line = sys.stdin.readline()
        if not line:
            break
        msg = msg + line
    print "Message length is %d" % len(msg)

    server = SMTP('localhost')
    server.set_debuglevel(1)
    server.sendmail(fromaddr, toaddrs, msg)
    server.quit()

filename:/usr/lib/python2.7/hashlib.pyc
__doc__
Û
/0Xc           @   s§  d  Z  d Z e e É Z e e É Z e Z e d Z d Ñ  Z d Ñ  Z d d Ñ Z	 d d Ñ Z
 y. d d l Z e
 Z e Z e j e j É Z Wn e k
 r´ e	 Z e Z n XxU e D]M Z y e e É e É  e <Wq≥ e k
 rˇ d d l Z e j d e É q≥ Xq≥ Wy d d l m Z Wns e k
 rçd d l Z d d l Z d j d Ñ  e d É DÉ É Z d j d Ñ  e d É DÉ É Z d d Ñ Z n X[ [ [ [	 [
 [ d S(   sÏ  hashlib module - A common interface to many hash functions.

new(name, string='') - returns a new hash object implementing the
                       given hash function; initializing the hash
                       using the given string data.

Named constructor functions are also available, these are much faster
than using new():

md5(), sha1(), sha224(), sha256(), sha384(), and sha512()

More algorithms may be available on your platform but the above are guaranteed
to exist.  See the algorithms_guaranteed and algorithms_available attributes
to find out what algorithm names can be passed to new().

NOTE: If you want the adler32 or crc32 hash functions they are available in
the zlib module.

Choose your hash function wisely.  Some have known collision weaknesses.
sha384 and sha512 will be slow on 32 bit platforms.

Hash objects have these methods:
 - update(arg): Update the hash object with the string arg. Repeated calls
                are equivalent to a single call with the concatenation of all
                the arguments.
 - digest():    Return the digest of the strings passed to the update() method
                so far. This may contain non-ASCII characters, including
                NUL bytes.
 - hexdigest(): Like digest() except the digest is returned as a string of
                double length, containing only hexadecimal digits.
 - copy():      Return a copy (clone) of the hash object. This can be used to
                efficiently compute the digests of strings that share a common
                initial substring.

For example, to obtain the digest of the string 'Nobody inspects the
spammish repetition':

    >>> import hashlib
    >>> m = hashlib.md5()
    >>> m.update("Nobody inspects")
    >>> m.update(" the spammish repetition")
    >>> m.digest()
    '\xbbd\x9c\x83\xdd\x1e\xa5\xc9\xd9\xde\xc9\xa1\x8d\xf0\xff\xe9'

More condensed:

    >>> hashlib.sha224("Nobody inspects the spammish repetition").hexdigest()
    'a4337bc45a8fc544c03f52dc550cd6e1e87021bc896588bd79e901e2'

t   md5t   sha1t   sha224t   sha256t   sha384t   sha512t   newt   algorithms_guaranteedt   algorithms_availablet
   algorithmst   pbkdf2_hmacc         C   s   yÿ |  d k r" d d  l  } | j S|  d k rA d d  l } | j S|  d k rå d d  l } |  d
 } | d k rv | j S| d k r◊ | j SnK |  d k r◊ d d  l } |  d
 } | d k r¡ | j S| d k r◊ | j Sn  Wn t	 k
 rÎ n Xt
 d |  É Ç d  S(   Nt   SHA1R   iˇˇˇˇt   MD5R    t   SHA256R   t   SHA224R   i   t   256t   224t   SHA512R   t   SHA384R   t   512t   384s   unsupported hash type (   R   R   (   R   R    (   R   s   sha256R   s   sha224(   R   s   sha512R   s   sha384(   t   _shaR   t   _md5t   _sha256R   R   t   _sha512R   R   t   ImportErrort
   ValueError(   t   nameR   R   R   t   bsR   (    (    s   /usr/lib/python2.7/hashlib.pyt   __get_builtin_constructorH   s0    


c         C   sG   y" t  t d |  É } | É  | SWn t t f k
 rB t |  É SXd  S(   Nt   openssl_(   t   getattrt   _hashlibt   AttributeErrorR   R   (   R   t   f(    (    s   /usr/lib/python2.7/hashlib.pyt   __get_openssl_constructord   s    t    c         C   s   t  |  É | É S(   s|   new(name, string='') - Return a new hashing object using the named algorithm;
    optionally initialized with a string.
    (   R   (   R   t   string(    (    s   /usr/lib/python2.7/hashlib.pyt   __py_newp   s    c         C   s9   y t  j |  | É SWn t k
 r4 t |  É | É SXd S(   s|   new(name, string='') - Return a new hashing object using the named algorithm;
    optionally initialized with a string.
    N(   R    R   R   R   (   R   R%   (    (    s   /usr/lib/python2.7/hashlib.pyt
   __hash_neww   s    iˇˇˇˇNs   code for hash %s was not found.(   R
   c         c   s   |  ] } t  | d  AÉ Vq d S(   i\   N(   t   chr(   t   .0t   x(    (    s   /usr/lib/python2.7/hashlib.pys	   <genexpr>†   s    i   c         c   s   |  ] } t  | d  AÉ Vq d S(   i6   N(   R(   (   R)   R*   (    (    s   /usr/lib/python2.7/hashlib.pys	   <genexpr>°   s    c         C   sC  t  |  t É s t |  É Ç n  t  | t t f É sH t t | É É } n  t  | t t f É sr t t | É É } n  t |  É } t |  É } t | d d É } t | É | k r∆ t |  | É j	 É  } n  | d | t | É } | j
 | j t É É | j
 | j t É É | | d Ñ } | d k  r4t | É Ç n  | d k rL| j } n  | d k  rgt | É Ç n  d t |  É j d }	 d }
 d } xÆ t |
 É | k  r:| | t j d	 | É É } t t j | É d
 É } x@ t | d É D]. } | | É } | t t j | É d
 É N} q‰W| d 7} |
 t j |	 | É 7}
 qçW|
 |  S(   sÛ   Password based key derivation function 2 (PKCS #5 v2.0)

        This Python implementations based on the hmac module about as fast
        as OpenSSL's PKCS5_PBKDF2_HMAC for short passwords and much faster
        for long passwords.
        t
   block_sizei@   t    c         S   sB   | j  É  } | j  É  } | j |  É | j | j É  É | j É  S(   N(   t   copyt   updatet   digest(   t   msgt   innert   outert   icpyt   ocpy(    (    s   /usr/lib/python2.7/hashlib.pyt   prfº   s
    i   s   %%0%ixi   R$   s   >Ii   N(   t
   isinstancet   strt	   TypeErrort   bytest	   bytearrayt   bufferR   R   t   lenR/   R.   t	   translatet	   _trans_36t	   _trans_5CR   t   Nonet   digest_sizet   structt   packt   intt   binasciit   hexlifyt   xranget	   unhexlify(   t	   hash_namet   passwordt   saltt
   iterationst   dklenR1   R2   t	   blocksizeR5   t   hex_format_stringt   dkeyt   loopt   prevt   rkeyt   i(    (    s   /usr/lib/python2.7/hashlib.pyR
   £   sB    	 
(   s   md5s   sha1s   sha224s   sha256s   sha384s   sha512(   s   news   algorithms_guaranteeds   algorithms_availables
   algorithmss   pbkdf2_hmac(   t   __doc__t   __always_supportedt   setR   R   R	   t   __all__R   R#   R&   R'   R    R   t
   __get_hasht   uniont   openssl_md_meth_namesR   t   __func_namet   globalsR   t   loggingt	   exceptionR
   RE   RB   t   joint   rangeR?   R>   R@   (    (    (    s   /usr/lib/python2.7/hashlib.pyt   <module>8   sH    		
9	
filename:/usr/lib/python2.7/tempfile.pyc
__doc__
Û
/0Xc        
   @   s  d  Z  d d d d d d d d d	 d
 g
 Z d d l Z d d l Z d d l Z d d l m	 Z
 y d d l m Z Wn! e k
 rï d d l m Z n Xy d d l Z Wn e k
 r¬ d Ñ  Z n
 Xd Ñ  Z y d d l Z Wn e k
 r˚ d d l Z n Xe j Z e j e j Be j BZ e e d É r;e e j OZ n  e e d É rZe e j OZ n  e Z e e d É re e j OZ n  e e d É röe j  Z  n d Z  d Z! e É  Z" e e d É r e j# Z$ n$ e e d É rÂe j% Z$ n	 d Ñ  Z$ d Ñ  Z& d d. d Ñ  É  YZ' d Ñ  Z( d Ñ  Z) d a+ d Ñ  Z, d Ñ  Z- d  Ñ  Z. d a/ d! Ñ  Z0 d" e! d e1 d# Ñ Z2 d" e! d d$ Ñ Z3 d" e! d d% Ñ Z4 d& d/ d' Ñ  É  YZ5 d( d d" e! d e6 d) Ñ Z7 e j8 d* k s‘e j9 j: d+ k r›e7 Z; n d( d d" e! d d, Ñ Z; d d0 d- Ñ  É  YZ< d S(1   s,  Temporary files.

This module provides generic, low- and high-level interfaces for
creating temporary files and directories.  All of the interfaces
provided by this module can be used without fear of race conditions
except for 'mktemp'.  'mktemp' is subject to race conditions and
should not be used; it is provided for backward compatibility only.

This module also provides some data items to the user:

  TMP_MAX  - maximum number of names that will be tried before
             giving up.
  template - the default prefix for all temporary names.
             You may change this to control the default prefix.
  tempdir  - If this is set to a string before the first use of
             any routine from this module, it will be considered as
             another candidate location to store temporary files.
t   NamedTemporaryFilet   TemporaryFilet   SpooledTemporaryFilet   mkstempt   mkdtempt   mktempt   TMP_MAXt   gettempprefixt   tempdirt
   gettempdiriˇˇˇˇN(   t   Random(   t   StringIOc         C   s   d  S(   N(    (   t   fd(    (    s   /usr/lib/python2.7/tempfile.pyt   _set_cloexec-   s    c         C   sW   y t  j |  t  j d É } Wn t k
 r/ n$ X| t  j O} t  j |  t  j | É d  S(   Ni    (   t   _fcntlt   fcntlt   F_GETFDt   IOErrort
   FD_CLOEXECt   F_SETFD(   R   t   flags(    (    s   /usr/lib/python2.7/tempfile.pyR   0   s    t   O_NOINHERITt
   O_NOFOLLOWt   O_BINARYi'  t   tmpt   lstatt   statc         C   s;   y t  |  É } Wn t k
 r, t j Ç n X| j É  d  S(   N(   t   openR   t   _ost   errort   close(   t   fnt   f(    (    s   /usr/lib/python2.7/tempfile.pyt   _stat]   s
    c         C   s.   y t  |  É Wn t j k
 r% t SXt Sd  S(   N(   R!   R   R   t   Falset   True(   R   (    (    s   /usr/lib/python2.7/tempfile.pyt   _existsd   s
    t   _RandomNameSequencec           B   sF   e  Z d  Z d d d Z d Ñ  Z e d Ñ  É Z d Ñ  Z d Ñ  Z RS(   s*  An instance of _RandomNameSequence generates an endless
    sequence of unpredictable strings which can safely be incorporated
    into file names.  Each string is six characters long.  Multiple
    threads can safely use the same instance at the same time.

    _RandomNameSequence is an iterator.t   abcdefghijklmnopqrstuvwxyzt   ABCDEFGHIJKLMNOPQRSTUVWXYZt   0123456789_c         C   s   t  É  |  _ t j j |  _ d  S(   N(   t   _allocate_lockt   mutexR   t   patht   normcase(   t   self(    (    s   /usr/lib/python2.7/tempfile.pyt   __init__x   s    c         C   sC   t  j É  } | t |  d d  É k r< t É  |  _ | |  _ n  |  j S(   Nt   _rng_pid(   R   t   getpidt   getattrt   Nonet   _Randomt   _rngR/   (   R-   t   cur_pid(    (    s   /usr/lib/python2.7/tempfile.pyt   rng|   s
    c         C   s   |  S(   N(    (   R-   (    (    s   /usr/lib/python2.7/tempfile.pyt   __iter__Ñ   s    c         C   so   |  j  } |  j } |  j j } | j É  z# g  d D] } | | É ^ q2 } Wd  | j É  X|  j d j | É É S(   Nt   123456t    (   R*   t
   charactersR6   t   choicet   acquiret   releaseR,   t   join(   R-   t   mt   ct   chooset   dummyt   letters(    (    s   /usr/lib/python2.7/tempfile.pyt   nextá   s    		
#(	   t   __name__t
   __module__t   __doc__R:   R.   t   propertyR6   R7   RD   (    (    (    s   /usr/lib/python2.7/tempfile.pyR%   l   s   		c          C   s¸   g  }  x3 d D]+ } t  j | É } | r |  j | É q q Wt  j d k rs t  j d É } | r¥ |  j | É q¥ nA t  j d k rû |  j d d d	 d
 g É n |  j d d d g É y |  j t  j É  É Wn* t t  j f k
 r˜ |  j t  j É n X|  S(   s[   Generate a list of candidate temporary directories which
    _get_default_tempdir will try.t   TMPDIRt   TEMPt   TMPt   riscoss   Wimp$ScrapDirt   nts   c:\temps   c:\tmps   \temps   \tmps   /tmps   /var/tmps   /usr/tmp(   RI   RJ   RK   (	   R   t   getenvt   appendt   namet   extendt   getcwdt   AttributeErrorR   t   curdir(   t   dirlistt   envnamet   dirname(    (    s   /usr/lib/python2.7/tempfile.pyt   _candidate_tempdir_listî   s"      c    
      C   s´  t  É  }  t É  } t } xv| D]n} | t j k rU t j j t j j | É É } n  x5t d É D]'} |  j	 É  } t j j
 | | É } yu t j | | d É } zG z2 t j | d d t Éè } | j d É Wd QXWd t j | É XWd t j | É X| SWqb t t f k
 rà}	 |	 j d t j k r2qb n  t j d k rÑ|	 j d t j k rÑt j j | É rÑt j | t j É rÑqb n  Pqb Xqb Wq Wt t j d	 | f Ç d S(
   sq  Calculate the default directory to use for temporary files.
    This routine should be called exactly once.

    We determine whether or not a candidate temp dir is usable by
    trying to create and write to a file in that directory.  If this
    is successful, the test file is deleted.  To prevent denial of
    service, the name of the test file must be randomized.id   iÄ  t   wbt   closefdt   blatNi    RM   s)   No usable temporary directory found in %s(   R%   RX   t   _text_openflagsR   RT   R+   R,   t   abspatht   xrangeRD   R>   R   t   _ioR"   t   writeR   t   unlinkt   OSErrorR   t   argst   _errnot   EEXISTRP   t   EACCESt   isdirt   accesst   W_OKt   ENOENT(
   t   namerRU   R   t   dirt   seqRP   t   filenameR   t   fpt   e(    (    s   /usr/lib/python2.7/tempfile.pyt   _get_default_tempdir∞   s6    			!%'	c           C   sG   t  d k rC t j É  z t  d k r1 t É  a  n  Wd t j É  Xn  t  S(   s7   Common setup sequence for all user-callable interfaces.N(   t   _name_sequenceR2   t
   _once_lockR<   R%   R=   (    (    (    s   /usr/lib/python2.7/tempfile.pyt   _get_candidate_names›   s    
c   
      C   s  t  É  } xı t t É D]Á } | j É  } t j j |  | | | É } y9 t j | | d É } t | É | t j j	 | É f SWq t
 k
 r¸ }	 |	 j t j k r® q n  t j d k rˆ |	 j t j k rˆ t j j |  É rˆ t j |  t j É rˆ q n  Ç  q Xq Wt t j d f Ç d S(   s>   Code common to mkstemp, TemporaryFile, and NamedTemporaryFile.iÄ  RM   s#   No usable temporary file name foundN(   Rt   R^   R   RD   R   R+   R>   R   R   R]   Rb   t   errnoRd   Re   RP   Rf   Rg   Rh   Ri   R   (
   Rl   t   pret   sufR   t   namesRm   RP   t   fileR   Rp   (    (    s   /usr/lib/python2.7/tempfile.pyt   _mkstemp_innerÎ   s     	
!'c           C   s   t  S(   s   Accessor for tempdir.template.(   t   template(    (    (    s   /usr/lib/python2.7/tempfile.pyR     s    c           C   sG   t  d k rC t j É  z t  d k r1 t É  a  n  Wd t j É  Xn  t  S(   s   Accessor for tempfile.tempdir.N(   R   R2   Rs   R<   Rq   R=   (    (    (    s   /usr/lib/python2.7/tempfile.pyR	     s    
R9   c         C   s@   | d k r t É  } n  | r' t } n t } t | | |  | É S(   s'  User-callable function to create and return a unique temporary
    file.  The return value is a pair (fd, name) where fd is the
    file descriptor returned by os.open, and name is the filename.

    If 'suffix' is specified, the file name will end with that suffix,
    otherwise there will be no suffix.

    If 'prefix' is specified, the file name will begin with that prefix,
    otherwise a default prefix is used.

    If 'dir' is specified, the file will be created in that directory,
    otherwise a default directory is used.

    If 'text' is specified and true, the file is opened in text
    mode.  Else (the default) the file is opened in binary mode.  On
    some operating systems, this makes no difference.

    The file is readable and writable only by the creating user ID.
    If the operating system uses permission bits to indicate whether a
    file is executable, the file is executable by no one. The file
    descriptor is not inherited by children of this process.

    Caller is responsible for deleting the file when done with it.
    N(   R2   R	   R\   t   _bin_openflagsRz   (   t   suffixt   prefixRl   t   textR   (    (    s   /usr/lib/python2.7/tempfile.pyR     s    	c         C   s  | d k r t É  } n  t É  } x‘ t t É D]∆ } | j É  } t j j | | | |  É } y t j	 | d É | SWq. t
 k
 rÛ } | j t j k rü q. n  t j d k rÌ | j t j k rÌ t j j | É rÌ t j | t j É rÌ q. n  Ç  q. Xq. Wt t j d f Ç d S(   s  User-callable function to create and return a unique temporary
    directory.  The return value is the pathname of the directory.

    Arguments are as for mkstemp, except that the 'text' argument is
    not accepted.

    The directory is readable, writable, and searchable only by the
    creating user.

    Caller is responsible for deleting the directory when done with it.
    i¿  RM   s(   No usable temporary directory name foundN(   R2   R	   Rt   R^   R   RD   R   R+   R>   t   mkdirRb   Ru   Rd   Re   RP   Rf   Rg   Rh   Ri   R   (   R}   R~   Rl   Rx   Rm   RP   Ry   Rp   (    (    s   /usr/lib/python2.7/tempfile.pyR   =  s"    	!'c         C   sá   | d k r t É  } n  t É  } xM t t É D]? } | j É  } t j j | | | |  É } t	 | É s. | Sq. Wt
 t j d f Ç d S(   sö  User-callable function to return a unique temporary file name.  The
    file is not created.

    Arguments are as for mkstemp, except that the 'text' argument is
    not accepted.

    This function is unsafe and should not be used.  The file name
    refers to a file that did not exist at some point, but by the time
    you get around to creating it, someone else may have beaten you to
    the punch.
    s"   No usable temporary filename foundN(   R2   R	   Rt   R^   R   RD   R   R+   R>   R$   R   Rd   Re   (   R}   R~   Rl   Rx   Rm   RP   Ry   (    (    s   /usr/lib/python2.7/tempfile.pyR   a  s    	t   _TemporaryFileWrapperc           B   sk   e  Z d  Z e d Ñ Z d Ñ  Z d Ñ  Z e j d k r` e j	 Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z n	 d Ñ  Z RS(	   sƒ   Temporary file wrapper

    This class provides a wrapper around files opened for
    temporary use.  In particular, it seeks to automatically
    remove the file when it is no longer needed.
    c         C   s(   | |  _  | |  _ t |  _ | |  _ d  S(   N(   Ry   RP   R"   t   close_calledt   delete(   R-   Ry   RP   RÉ   (    (    s   /usr/lib/python2.7/tempfile.pyR.   á  s    			c         C   sN   |  j  d } t | | É } t t | É t d É É sJ t |  | | É n  | S(   NRy   i    (   t   __dict__R1   t
   issubclasst   typet   setattr(   R-   RP   Ry   t   a(    (    s   /usr/lib/python2.7/tempfile.pyt   __getattr__ç  s
    c         C   s   |  j  j É  |  S(   N(   Ry   t	   __enter__(   R-   (    (    s   /usr/lib/python2.7/tempfile.pyRä   ô  s    RM   c         C   sJ   |  j  sF t |  _  z |  j j É  Wd  |  j rB |  j |  j É n  Xn  d  S(   N(   RÇ   R#   Ry   R   RÉ   Ra   RP   (   R-   (    (    s   /usr/lib/python2.7/tempfile.pyR   ®  s    			c         C   s   |  j  É  d  S(   N(   R   (   R-   (    (    s   /usr/lib/python2.7/tempfile.pyt   __del__±  s    c         C   s&   |  j  j | | | É } |  j É  | S(   N(   Ry   t   __exit__R   (   R-   t   exct   valuet   tbt   result(    (    s   /usr/lib/python2.7/tempfile.pyRå   ∂  s    
c         C   s   |  j  j | | | É d  S(   N(   Ry   Rå   (   R-   Rç   Ré   Rè   (    (    s   /usr/lib/python2.7/tempfile.pyRå   ª  s    (   RE   RF   RG   R#   R.   Râ   Rä   R   RP   Ra   R   Rã   Rå   (    (    (    s   /usr/lib/python2.7/tempfile.pyRÅ     s   						s   w+bc   
      C   s—   | d k r t É  } n  d |  k r- t } n t } t j d k rX | rX | t j O} n  t | | | | É \ } } y) t j | |  | É }	 t	 |	 | | É SWn. t
 k
 rÃ t j | É t j | É Ç  n Xd S(   sA  Create and return a temporary file.
    Arguments:
    'prefix', 'suffix', 'dir' -- as for mkstemp.
    'mode' -- the mode argument to os.fdopen (default "w+b").
    'bufsize' -- the buffer size argument to os.fdopen (default -1).
    'delete' -- whether the file is deleted on close (default True).
    The file is created as mkstemp() would do it.

    Returns an object with a file-like interface; the name of the file
    is accessible as its 'name' attribute.  The file will be automatically
    deleted when it is closed unless the 'delete' argument is set to False.
    t   bRM   N(   R2   R	   R|   R\   R   RP   t   O_TEMPORARYRz   t   fdopenRÅ   t   BaseExceptionRa   R   (
   t   modet   bufsizeR}   R~   Rl   RÉ   R   R   RP   Ry   (    (    s   /usr/lib/python2.7/tempfile.pyR    ø  s    	t   posixt   cygwinc         C   sê   | d k r t É  } n  d |  k r- t } n t } t | | | | É \ } } y$ t j | É t j | |  | É SWn t j | É Ç  n Xd S(   s∂  Create and return a temporary file.
        Arguments:
        'prefix', 'suffix', 'dir' -- as for mkstemp.
        'mode' -- the mode argument to os.fdopen (default "w+b").
        'bufsize' -- the buffer size argument to os.fdopen (default -1).
        The file is created as mkstemp() would do it.

        Returns an object with a file-like interface.  The file has no
        name, and will cease to exist when it is closed.
        Rë   N(	   R2   R	   R|   R\   Rz   R   Ra   Rì   R   (   Rï   Rñ   R}   R~   Rl   R   R   RP   (    (    s   /usr/lib/python2.7/tempfile.pyR   Í  s    	c           B   s  e  Z d  Z e Z d d d d e d d Ñ Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z d Ñ  Z e d Ñ  É Z d Ñ  Z d Ñ  Z d Ñ  Z e d Ñ  É Z e d Ñ  É Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e d Ñ  É Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sí   Temporary file wrapper, specialized to switch from
    StringIO to a real file when it exceeds a certain size or
    when a fileno is needed.
    i    s   w+biˇˇˇˇR9   c         C   s:   t  É  |  _ | |  _ t |  _ | | | | | f |  _ d  S(   N(   t	   _StringIOt   _filet	   _max_sizeR"   t   _rolledt   _TemporaryFileArgs(   R-   t   max_sizeRï   Rñ   R}   R~   Rl   (    (    s   /usr/lib/python2.7/tempfile.pyR.     s    		c         C   s?   |  j  r d  S|  j } | r; | j É  | k r; |  j É  n  d  S(   N(   Rú   Rõ   t   tellt   rollover(   R-   Ry   Rû   (    (    s   /usr/lib/python2.7/tempfile.pyt   _check  s
    	 	c         C   sh   |  j  r d  S|  j } t |  j å  } |  _ |  ` | j | j É  É | j | j É  d É t |  _  d  S(   Ni    (	   Rú   Rö   R   Rù   R`   t   getvaluet   seekRü   R#   (   R-   Ry   t   newfile(    (    s   /usr/lib/python2.7/tempfile.pyR†     s    	 	c         C   s   |  j  j r t d É Ç n  |  S(   Ns%   Cannot enter context with closed file(   Rö   t   closedt
   ValueError(   R-   (    (    s   /usr/lib/python2.7/tempfile.pyRä   ,  s    c         C   s   |  j  j É  d  S(   N(   Rö   R   (   R-   Rç   Ré   Rè   (    (    s   /usr/lib/python2.7/tempfile.pyRå   1  s    c         C   s   |  j  j É  S(   N(   Rö   R7   (   R-   (    (    s   /usr/lib/python2.7/tempfile.pyR7   5  s    c         C   s   |  j  j É  d  S(   N(   Rö   R   (   R-   (    (    s   /usr/lib/python2.7/tempfile.pyR   8  s    c         C   s
   |  j  j S(   N(   Rö   R•   (   R-   (    (    s   /usr/lib/python2.7/tempfile.pyR•   ;  s    c         C   s   |  j  É  |  j j É  S(   N(   R†   Rö   t   fileno(   R-   (    (    s   /usr/lib/python2.7/tempfile.pyRß   ?  s    
c         C   s   |  j  j É  d  S(   N(   Rö   t   flush(   R-   (    (    s   /usr/lib/python2.7/tempfile.pyR®   C  s    c         C   s   |  j  j É  S(   N(   Rö   t   isatty(   R-   (    (    s   /usr/lib/python2.7/tempfile.pyR©   F  s    c         C   s.   y |  j  j SWn t k
 r) |  j d SXd  S(   Ni    (   Rö   Rï   RS   Rù   (   R-   (    (    s   /usr/lib/python2.7/tempfile.pyRï   I  s    c         C   s'   y |  j  j SWn t k
 r" d  SXd  S(   N(   Rö   RP   RS   R2   (   R-   (    (    s   /usr/lib/python2.7/tempfile.pyRP   P  s    c         C   s
   |  j  j S(   N(   Rö   RD   (   R-   (    (    s   /usr/lib/python2.7/tempfile.pyRD   W  s    c         G   s   |  j  j | å  S(   N(   Rö   t   read(   R-   Rc   (    (    s   /usr/lib/python2.7/tempfile.pyR™   Z  s    c         G   s   |  j  j | å  S(   N(   Rö   t   readline(   R-   Rc   (    (    s   /usr/lib/python2.7/tempfile.pyR´   ]  s    c         G   s   |  j  j | å  S(   N(   Rö   t	   readlines(   R-   Rc   (    (    s   /usr/lib/python2.7/tempfile.pyR¨   `  s    c         G   s   |  j  j | å  d  S(   N(   Rö   R£   (   R-   Rc   (    (    s   /usr/lib/python2.7/tempfile.pyR£   c  s    c         C   s
   |  j  j S(   N(   Rö   t	   softspace(   R-   (    (    s   /usr/lib/python2.7/tempfile.pyR≠   f  s    c         C   s   |  j  j É  S(   N(   Rö   Rü   (   R-   (    (    s   /usr/lib/python2.7/tempfile.pyRü   j  s    c         C   s   |  j  j É  d  S(   N(   Rö   t   truncate(   R-   (    (    s   /usr/lib/python2.7/tempfile.pyRÆ   m  s    c         C   s)   |  j  } | j | É } |  j | É | S(   N(   Rö   R`   R°   (   R-   t   sRy   t   rv(    (    s   /usr/lib/python2.7/tempfile.pyR`   p  s    	c         C   s)   |  j  } | j | É } |  j | É | S(   N(   Rö   t
   writelinesR°   (   R-   t   iterableRy   R∞   (    (    s   /usr/lib/python2.7/tempfile.pyR±   v  s    	c         G   s9   t  |  j d É r t |  j É St |  j j | å  É Sd  S(   Nt
   xreadlines(   t   hasattrRö   t   iterR¨   (   R-   Rc   (    (    s   /usr/lib/python2.7/tempfile.pyR≥   |  s    N(    RE   RF   RG   R"   Rú   R{   R2   R.   R°   R†   Rä   Rå   R7   R   RH   R•   Rß   R®   R©   Rï   RP   RD   R™   R´   R¨   R£   R≠   Rü   RÆ   R`   R±   R≥   (    (    (    s   /usr/lib/python2.7/tempfile.pyR     s6   																			(    (    (    (=   RG   t   __all__t   ioR_   t   osR   Ru   Rd   t   randomR
   R3   t	   cStringIOR   Rô   t   ImportErrorR   R   R   t   threadt   _threadt   dummy_threadt   allocate_lockR)   t   O_RDWRt   O_CREATt   O_EXCLR\   R¥   R   R   R|   R   R   R{   Rs   R   R!   R   R$   R%   RX   Rq   R2   Rr   Rt   Rz   R   R   R	   R"   R   R   R   RÅ   R#   R    RP   t   syst   platformR   R   (    (    (    s   /usr/lib/python2.7/tempfile.pyt   <module>   s~   					(		+				%$@	$!		
filename:/usr/lib/python2.7/wsgiref/__init__.py
__doc__
"""wsgiref -- a WSGI (PEP 333) Reference Library

filename:/usr/lib/python2.7/wsgiref/util.py
__doc__
"""Miscellaneous WSGI-related Utilities"""

import posixpath

__all__ = [
    'FileWrapper', 'guess_scheme', 'application_uri', 'request_uri',
    'shift_path_info', 'setup_testing_defaults',
]


class FileWrapper:
    """Wrapper to convert file-like objects to iterables"""

    def __init__(self, filelike, blksize=8192):
        self.filelike = filelike
        self.blksize = blksize
        if hasattr(filelike,'close'):
            self.close = filelike.close

    def __getitem__(self,key):
        data = self.filelike.read(self.blksize)
        if data:
            return data
        raise IndexError

    def __iter__(self):
        return self

    def next(self):
        data = self.filelike.read(self.blksize)
        if data:
            return data
        raise StopIteration

def guess_scheme(environ):
    """Return a guess for whether 'wsgi.url_scheme' should be 'http' or 'https'
    """
    if environ.get("HTTPS") in ('yes','on','1'):
        return 'https'
    else:
        return 'http'

def application_uri(environ):
    """Return the application's base URI (no PATH_INFO or QUERY_STRING)"""
    url = environ['wsgi.url_scheme']+'://'
    from urllib import quote

    if environ.get('HTTP_HOST'):
        url += environ['HTTP_HOST']
    else:
        url += environ['SERVER_NAME']

        if environ['wsgi.url_scheme'] == 'https':
            if environ['SERVER_PORT'] != '443':
                url += ':' + environ['SERVER_PORT']
        else:
            if environ['SERVER_PORT'] != '80':
                url += ':' + environ['SERVER_PORT']

    url += quote(environ.get('SCRIPT_NAME') or '/')
    return url

def request_uri(environ, include_query=1):
    """Return the full request URI, optionally including the query string"""
    url = application_uri(environ)
    from urllib import quote
    path_info = quote(environ.get('PATH_INFO',''),safe='/;=,')
    if not environ.get('SCRIPT_NAME'):
        url += path_info[1:]
    else:
        url += path_info
    if include_query and environ.get('QUERY_STRING'):
        url += '?' + environ['QUERY_STRING']
    return url

def shift_path_info(environ):
    """Shift a name from PATH_INFO to SCRIPT_NAME, returning it

    If there are no remaining path segments in PATH_INFO, return None.
    Note: 'environ' is modified in-place; use a copy if you need to keep
    the original PATH_INFO or SCRIPT_NAME.

    Note: when PATH_INFO is just a '/', this returns '' and appends a trailing
    '/' to SCRIPT_NAME, even though empty path segments are normally ignored,
    and SCRIPT_NAME doesn't normally end in a '/'.  This is intentional
    behavior, to ensure that an application can tell the difference between
    '/x' and '/x/' when traversing to objects.
    """
    path_info = environ.get('PATH_INFO','')
    if not path_info:
        return None

    path_parts = path_info.split('/')
    path_parts[1:-1] = [p for p in path_parts[1:-1] if p and p != '.']
    name = path_parts[1]
    del path_parts[1]

    script_name = environ.get('SCRIPT_NAME','')
    script_name = posixpath.normpath(script_name+'/'+name)
    if script_name.endswith('/'):
        script_name = script_name[:-1]
    if not name and not script_name.endswith('/'):
        script_name += '/'

    environ['SCRIPT_NAME'] = script_name
    environ['PATH_INFO']   = '/'.join(path_parts)

    # Special case: '/.' on PATH_INFO doesn't get stripped,
    # because we don't strip the last element of PATH_INFO
    # if there's only one path part left.  Instead of fixing this
    # above, we fix it here so that PATH_INFO gets normalized to
    # an empty string in the environ.
    if name=='.':
        name = None
    return name

def setup_testing_defaults(environ):
    """Update 'environ' with trivial defaults for testing purposes

    This adds various parameters required for WSGI, including HTTP_HOST,
    SERVER_NAME, SERVER_PORT, REQUEST_METHOD, SCRIPT_NAME, PATH_INFO,
    and all of the wsgi.* variables.  It only supplies default values,
    and does not replace any existing settings for these variables.

    This routine is intended to make it easier for unit tests of WSGI
    servers and applications to set up dummy environments.  It should *not*
    be used by actual WSGI servers or applications, since the data is fake!
    """

    environ.setdefault('SERVER_NAME','127.0.0.1')
    environ.setdefault('SERVER_PROTOCOL','HTTP/1.0')

    environ.setdefault('HTTP_HOST',environ['SERVER_NAME'])
    environ.setdefault('REQUEST_METHOD','GET')

    if 'SCRIPT_NAME' not in environ and 'PATH_INFO' not in environ:
        environ.setdefault('SCRIPT_NAME','')
        environ.setdefault('PATH_INFO','/')

    environ.setdefault('wsgi.version', (1,0))
    environ.setdefault('wsgi.run_once', 0)
    environ.setdefault('wsgi.multithread', 0)
    environ.setdefault('wsgi.multiprocess', 0)

    from StringIO import StringIO
    environ.setdefault('wsgi.input', StringIO(""))
    environ.setdefault('wsgi.errors', StringIO())
    environ.setdefault('wsgi.url_scheme',guess_scheme(environ))

    if environ['wsgi.url_scheme']=='http':
        environ.setdefault('SERVER_PORT', '80')
    elif environ['wsgi.url_scheme']=='https':
        environ.setdefault('SERVER_PORT', '443')



_hoppish = {
    'connection':1, 'keep-alive':1, 'proxy-authenticate':1,
    'proxy-authorization':1, 'te':1, 'trailers':1, 'transfer-encoding':1,
    'upgrade':1
}.__contains__

def is_hop_by_hop(header_name):
    """Return true if 'header_name' is an HTTP/1.1 "Hop-by-Hop" header"""
    return _hoppish(header_name.lower())

filename:/usr/lib/python2.7/wsgiref/handlers.py
__doc__
"""Base classes for server/gateway implementations"""

filename:/usr/lib/python2.7/wsgiref/headers.py
__doc__
"""Manage HTTP Response Headers

Much of this module is red-handedly pilfered from email.message in the stdlib,
so portions are Copyright (C) 2001,2002 Python Software Foundation, and were
written by Barry Warsaw.
"""

filename:/usr/lib/python2.7/wsgiref/simple_server.py
__doc__
"""BaseHTTPServer that implements the Python WSGI protocol (PEP 333, rev 1.21)

This is both an example of how WSGI can be implemented, and a basis for running
simple web applications on a local machine, such as might be done when testing
or debugging an application.  It has not been reviewed for security issues,
however, and we strongly recommend that you use a "real" web server for
production use.

For example usage, see the 'if __name__=="__main__"' block at the end of the
module.  See also the BaseHTTPServer module docs for other API information.
"""

filename:/usr/lib/python2.7/colorsys.py
__doc__
"""Conversion functions between RGB and other color systems.

This modules provides two functions for each color system ABC:

  rgb_to_abc(r, g, b) --> a, b, c
  abc_to_rgb(a, b, c) --> r, g, b

All inputs and outputs are triples of floats in the range [0.0...1.0]
(with the exception of I and Q, which covers a slightly larger range).
Inputs outside the valid range may cause exceptions or invalid outputs.

Supported color systems:
RGB: Red, Green, Blue components
YIQ: Luminance, Chrominance (used by composite video signals)
HLS: Hue, Luminance, Saturation
HSV: Hue, Saturation, Value
"""

filename:/usr/lib/python2.7/posixpath.py
__doc__
"""Common operations on Posix pathnames.

Instead of importing this module directly, import os and refer to
this module as os.path.  The "os.path" name is an alias for this
module on Posix systems; on other systems (e.g. Mac, Windows),
os.path provides the same operations in a manner specific to that
platform, and is an alias to another module (e.g. macpath, ntpath).

Some of this can actually be useful on non-Posix systems too, e.g.
for manipulation of the pathname component of URLs.
"""

filename:/usr/lib/python2.7/MimeWriter.py
__doc__
"""Generic MIME writer.

This module defines the class MimeWriter.  The MimeWriter class implements
a basic formatter for creating MIME multi-part files.  It doesn't seek around
the output file nor does it use large amounts of buffer space. You must write
the parts out in the order that they should occur in the final file.
MimeWriter does buffer the headers you add, allowing you to rearrange their
order.

"""

filename:/usr/lib/python2.7/dumbdbm.py
__doc__
"""A dumb and slow but simple dbm clone.

For database spam, spam.dir contains the index (a text file),
spam.bak *may* contain a backup of the index (also a text file),
while spam.dat contains the data (a binary file).

XXX TO DO:

- seems to contain a bug when updating...

- reclaim free space (currently, space once occupied by deleted or expanded
items is never reused)

- support concurrent access (currently, if two processes take turns making
updates, they can mess up the index)

- support efficient access to large databases (currently, the whole index
is read when the database is opened, and some updates rewrite the whole index)

- support opening for read-only (flag = 'm')

"""

filename:/usr/lib/python2.7/zipfile.py
__doc__
"""
Read and write ZIP files.
"""

filename:/usr/lib/python2.7/audiodev.py
__doc__
"""Classes for manipulating audio devices (currently only for Sun and SGI)"""
from warnings import warnpy3k
warnpy3k("the audiodev module has been removed in Python 3.0", stacklevel=2)
del warnpy3k

__all__ = ["error","AudioDev"]

class error(Exception):
    pass

class Play_Audio_sgi:
    # Private instance variables
##      if 0: access frameratelist, nchannelslist, sampwidthlist, oldparams, \
##                params, config, inited_outrate, inited_width, \
##                inited_nchannels, port, converter, classinited: private

    classinited = 0
    frameratelist = nchannelslist = sampwidthlist = None

    def initclass(self):
        import AL
        self.frameratelist = [
                  (48000, AL.RATE_48000),
                  (44100, AL.RATE_44100),
                  (32000, AL.RATE_32000),
                  (22050, AL.RATE_22050),
                  (16000, AL.RATE_16000),
                  (11025, AL.RATE_11025),
                  ( 8000,  AL.RATE_8000),
                  ]
        self.nchannelslist = [
                  (1, AL.MONO),
                  (2, AL.STEREO),
                  (4, AL.QUADRO),
                  ]
        self.sampwidthlist = [
                  (1, AL.SAMPLE_8),
                  (2, AL.SAMPLE_16),
                  (3, AL.SAMPLE_24),
                  ]
        self.classinited = 1

    def __init__(self):
        import al, AL
        if not self.classinited:
            self.initclass()
        self.oldparams = []
        self.params = [AL.OUTPUT_RATE, 0]
        self.config = al.newconfig()
        self.inited_outrate = 0
        self.inited_width = 0
        self.inited_nchannels = 0
        self.converter = None
        self.port = None
        return

    def __del__(self):
        if self.port:
            self.stop()
        if self.oldparams:
            import al, AL
            al.setparams(AL.DEFAULT_DEVICE, self.oldparams)
            self.oldparams = []

    def wait(self):
        if not self.port:
            return
        import time
        while self.port.getfilled() > 0:
            time.sleep(0.1)
        self.stop()

    def stop(self):
        if self.port:
            self.port.closeport()
            self.port = None
        if self.oldparams:
            import al, AL
            al.setparams(AL.DEFAULT_DEVICE, self.oldparams)
            self.oldparams = []

    def setoutrate(self, rate):
        for (raw, cooked) in self.frameratelist:
            if rate == raw:
                self.params[1] = cooked
                self.inited_outrate = 1
                break
        else:
            raise error, 'bad output rate'

    def setsampwidth(self, width):
        for (raw, cooked) in self.sampwidthlist:
            if width == raw:
                self.config.setwidth(cooked)
                self.inited_width = 1
                break
        else:
            if width == 0:
                import AL
                self.inited_width = 0
                self.config.setwidth(AL.SAMPLE_16)
                self.converter = self.ulaw2lin
            else:
                raise error, 'bad sample width'

    def setnchannels(self, nchannels):
        for (raw, cooked) in self.nchannelslist:
            if nchannels == raw:
                self.config.setchannels(cooked)
                self.inited_nchannels = 1
                break
        else:
            raise error, 'bad # of channels'

    def writeframes(self, data):
        if not (self.inited_outrate and self.inited_nchannels):
            raise error, 'params not specified'
        if not self.port:
            import al, AL
            self.port = al.openport('Python', 'w', self.config)
            self.oldparams = self.params[:]
            al.getparams(AL.DEFAULT_DEVICE, self.oldparams)
            al.setparams(AL.DEFAULT_DEVICE, self.params)
        if self.converter:
            data = self.converter(data)
        self.port.writesamps(data)

    def getfilled(self):
        if self.port:
            return self.port.getfilled()
        else:
            return 0

    def getfillable(self):
        if self.port:
            return self.port.getfillable()
        else:
            return self.config.getqueuesize()

    # private methods
##      if 0: access *: private

    def ulaw2lin(self, data):
        import audioop
        return audioop.ulaw2lin(data, 2)

class Play_Audio_sun:
##      if 0: access outrate, sampwidth, nchannels, inited_outrate, inited_width, \
##                inited_nchannels, converter: private

    def __init__(self):
        self.outrate = 0
        self.sampwidth = 0
        self.nchannels = 0
        self.inited_outrate = 0
        self.inited_width = 0
        self.inited_nchannels = 0
        self.converter = None
        self.port = None
        return

    def __del__(self):
        self.stop()

    def setoutrate(self, rate):
        self.outrate = rate
        self.inited_outrate = 1

    def setsampwidth(self, width):
        self.sampwidth = width
        self.inited_width = 1

    def setnchannels(self, nchannels):
        self.nchannels = nchannels
        self.inited_nchannels = 1

    def writeframes(self, data):
        if not (self.inited_outrate and self.inited_width and self.inited_nchannels):
            raise error, 'params not specified'
        if not self.port:
            import sunaudiodev, SUNAUDIODEV
            self.port = sunaudiodev.open('w')
            info = self.port.getinfo()
            info.o_sample_rate = self.outrate
            info.o_channels = self.nchannels
            if self.sampwidth == 0:
                info.o_precision = 8
                self.o_encoding = SUNAUDIODEV.ENCODING_ULAW
                # XXX Hack, hack -- leave defaults
            else:
                info.o_precision = 8 * self.sampwidth
                info.o_encoding = SUNAUDIODEV.ENCODING_LINEAR
                self.port.setinfo(info)
        if self.converter:
            data = self.converter(data)
        self.port.write(data)

    def wait(self):
        if not self.port:
            return
        self.port.drain()
        self.stop()

    def stop(self):
        if self.port:
            self.port.flush()
            self.port.close()
            self.port = None

    def getfilled(self):
        if self.port:
            return self.port.obufcount()
        else:
            return 0

##    # Nobody remembers what this method does, and it's broken. :-(
##    def getfillable(self):
##        return BUFFERSIZE - self.getfilled()

def AudioDev():
    # Dynamically try to import and use a platform specific module.
    try:
        import al
    except ImportError:
        try:
            import sunaudiodev
            return Play_Audio_sun()
        except ImportError:
            try:
                import Audio_mac
            except ImportError:
                raise error, 'no audio device'
            else:
                return Audio_mac.Play_Audio_mac()
    else:
        return Play_Audio_sgi()

def test(fn = None):
    import sys
    if sys.argv[1:]:
        fn = sys.argv[1]
    else:
        fn = 'f:just samples:just.aif'
    import aifc
    af = aifc.open(fn, 'r')
    print fn, af.getparams()
    p = AudioDev()
    p.setoutrate(af.getframerate())
    p.setsampwidth(af.getsampwidth())
    p.setnchannels(af.getnchannels())
    BUFSIZ = af.getframerate()/af.getsampwidth()/af.getnchannels()
    while 1:
        data = af.readframes(BUFSIZ)
        if not data: break
        print len(data)
        p.writeframes(data)
    p.wait()

if __name__ == '__main__':
    test()

filename:/usr/lib/python2.7/keyword.py
__doc__
#! /usr/bin/python2.7

"""Keywords (from "graminit.c")

filename:/usr/lib/python2.7/importlib/__init__.py
__doc__
"""Backport of importlib.import_module from 3.x."""
# While not critical (and in no way guaranteed!), it would be nice to keep this
# code compatible with Python 2.3.
import sys

def _resolve_name(name, package, level):
    """Return the absolute name of the module to be imported."""
    if not hasattr(package, 'rindex'):
        raise ValueError("'package' not set to a string")
    dot = len(package)
    for x in xrange(level, 1, -1):
        try:
            dot = package.rindex('.', 0, dot)
        except ValueError:
            raise ValueError("attempted relative import beyond top-level "
                              "package")
    return "%s.%s" % (package[:dot], name)


def import_module(name, package=None):
    """Import a module.

    The 'package' argument is required when performing a relative import. It
    specifies the package to use as the anchor point from which to resolve the
    relative import to an absolute import.

    """
    if name.startswith('.'):
        if not package:
            raise TypeError("relative imports require the 'package' argument")
        level = 0
        for character in name:
            if character != '.':
                break
            level += 1
        name = _resolve_name(name[level:], package, level)
    __import__(name)
    return sys.modules[name]

filename:/usr/lib/python2.7/importlib/__init__.pyc
__doc__
Û
00Xc           @   s+   d  Z  d d l Z d Ñ  Z d d Ñ Z d S(   s-   Backport of importlib.import_module from 3.x.iˇˇˇˇNc         C   sí   t  | d É s t d É Ç n  t | É } xS t | d d É D]? } y | j d d | É } Wq= t k
 r{ t d É Ç q= Xq= Wd | |  |  f S(	   s6   Return the absolute name of the module to be imported.t   rindexs   'package' not set to a stringi   iˇˇˇˇt   .i    s2   attempted relative import beyond top-level packages   %s.%s(   t   hasattrt
   ValueErrort   lent   xrangeR    (   t   namet   packaget   levelt   dott   x(    (    s(   /usr/lib/python2.7/importlib/__init__.pyt   _resolve_name   s    c         C   sÉ   |  j  d É rn | s$ t d É Ç n  d } x( |  D]  } | d k rG Pn  | d 7} q1 Wt |  | | | É }  n  t |  É t j |  S(   sﬁ   Import a module.

    The 'package' argument is required when performing a relative import. It
    specifies the package to use as the anchor point from which to resolve the
    relative import to an absolute import.

    R   s/   relative imports require the 'package' argumenti    i   (   t
   startswitht	   TypeErrorR   t
   __import__t   syst   modules(   R   R   R   t	   character(    (    s(   /usr/lib/python2.7/importlib/__init__.pyt   import_module   s    
(   t   __doc__R   R   t   NoneR   (    (    (    s(   /usr/lib/python2.7/importlib/__init__.pyt   <module>   s   	
filename:/usr/lib/python2.7/string.py
__doc__
"""A collection of string operations (most are no longer used).

filename:/usr/lib/python2.7/pkgutil.py
__doc__
"""Utilities to support packages."""

# NOTE: This module must remain compatible with Python 2.3, as it is shared
# by setuptools for distribution with Python 2.3 and up.

import os
import sys
import imp
import os.path
from types import ModuleType

__all__ = [
    'get_importer', 'iter_importers', 'get_loader', 'find_loader',
    'walk_packages', 'iter_modules', 'get_data',
    'ImpImporter', 'ImpLoader', 'read_code', 'extend_path',
]

def read_code(stream):
    # This helper is needed in order for the PEP 302 emulation to
    # correctly handle compiled files
    import marshal

    magic = stream.read(4)
    if magic != imp.get_magic():
        return None

    stream.read(4) # Skip timestamp
    return marshal.load(stream)


def simplegeneric(func):
    """Make a trivial single-dispatch generic function"""
    registry = {}
    def wrapper(*args, **kw):
        ob = args[0]
        try:
            cls = ob.__class__
        except AttributeError:
            cls = type(ob)
        try:
            mro = cls.__mro__
        except AttributeError:
            try:
                class cls(cls, object):
                    pass
                mro = cls.__mro__[1:]
            except TypeError:
                mro = object,   # must be an ExtensionClass or some such  :(
        for t in mro:
            if t in registry:
                return registry[t](*args, **kw)
        else:
            return func(*args, **kw)
    try:
        wrapper.__name__ = func.__name__
    except (TypeError, AttributeError):
        pass    # Python 2.3 doesn't allow functions to be renamed

    def register(typ, func=None):
        if func is None:
            return lambda f: register(typ, f)
        registry[typ] = func
        return func

    wrapper.__dict__ = func.__dict__
    wrapper.__doc__ = func.__doc__
    wrapper.register = register
    return wrapper


def walk_packages(path=None, prefix='', onerror=None):
    """Yields (module_loader, name, ispkg) for all modules recursively
    on path, or, if path is None, all accessible modules.

    'path' should be either None or a list of paths to look for
    modules in.

    'prefix' is a string to output on the front of every module name
    on output.

    Note that this function must import all *packages* (NOT all
    modules!) on the given path, in order to access the __path__
    attribute to find submodules.

    'onerror' is a function which gets called with one argument (the
    name of the package which was being imported) if any exception
    occurs while trying to import a package.  If no onerror function is
    supplied, ImportErrors are caught and ignored, while all other
    exceptions are propagated, terminating the search.

    Examples:

    # list all modules python can access
    walk_packages()

    # list all submodules of ctypes
    walk_packages(ctypes.__path__, ctypes.__name__+'.')
    """

    def seen(p, m={}):
        if p in m:
            return True
        m[p] = True

    for importer, name, ispkg in iter_modules(path, prefix):
        yield importer, name, ispkg

        if ispkg:
            try:
                __import__(name)
            except ImportError:
                if onerror is not None:
                    onerror(name)
            except Exception:
                if onerror is not None:
                    onerror(name)
                else:
                    raise
            else:
                path = getattr(sys.modules[name], '__path__', None) or []

                # don't traverse path items we've seen before
                path = [p for p in path if not seen(p)]

                for item in walk_packages(path, name+'.', onerror):
                    yield item


def iter_modules(path=None, prefix=''):
    """Yields (module_loader, name, ispkg) for all submodules on path,
    or, if path is None, all top-level modules on sys.path.

    'path' should be either None or a list of paths to look for
    modules in.

    'prefix' is a string to output on the front of every module name
    on output.
    """

    if path is None:
        importers = iter_importers()
    else:
        importers = map(get_importer, path)

    yielded = {}
    for i in importers:
        for name, ispkg in iter_importer_modules(i, prefix):
            if name not in yielded:
                yielded[name] = 1
                yield i, name, ispkg


#@simplegeneric
def iter_importer_modules(importer, prefix=''):
    if not hasattr(importer, 'iter_modules'):
        return []
    return importer.iter_modules(prefix)

iter_importer_modules = simplegeneric(iter_importer_modules)


class ImpImporter:
    """PEP 302 Importer that wraps Python's "classic" import algorithm

    ImpImporter(dirname) produces a PEP 302 importer that searches that
    directory.  ImpImporter(None) produces a PEP 302 importer that searches
    the current sys.path, plus any modules that are frozen or built-in.

    Note that ImpImporter does not currently support being used by placement
    on sys.meta_path.
    """

    def __init__(self, path=None):
        self.path = path

    def find_module(self, fullname, path=None):
        # Note: we ignore 'path' argument since it is only used via meta_path
        subname = fullname.split(".")[-1]
        if subname != fullname and self.path is None:
            return None
        if self.path is None:
            path = None
        else:
            path = [os.path.realpath(self.path)]
        try:
            file, filename, etc = imp.find_module(subname, path)
        except ImportError:
            return None
        return ImpLoader(fullname, file, filename, etc)

    def iter_modules(self, prefix=''):
        if self.path is None or not os.path.isdir(self.path):
            return

        yielded = {}
        import inspect
        try:
            filenames = os.listdir(self.path)
        except OSError:
            # ignore unreadable directories like import does
            filenames = []
        filenames.sort()  # handle packages before same-named modules

        for fn in filenames:
            modname = inspect.getmodulename(fn)
            if modname=='__init__' or modname in yielded:
                continue

            path = os.path.join(self.path, fn)
            ispkg = False

            if not modname and os.path.isdir(path) and '.' not in fn:
                modname = fn
                try:
                    dircontents = os.listdir(path)
                except OSError:
                    # ignore unreadable directories like import does
                    dircontents = []
                for fn in dircontents:
                    subname = inspect.getmodulename(fn)
                    if subname=='__init__':
                        ispkg = True
                        break
                else:
                    continue    # not a package

            if modname and '.' not in modname:
                yielded[modname] = 1
                yield prefix + modname, ispkg


class ImpLoader:
    """PEP 302 Loader that wraps Python's "classic" import algorithm
    """
    code = source = None

    def __init__(self, fullname, file, filename, etc):
        self.file = file
        self.filename = filename
        self.fullname = fullname
        self.etc = etc

    def load_module(self, fullname):
        self._reopen()
        try:
            mod = imp.load_module(fullname, self.file, self.filename, self.etc)
        finally:
            if self.file:
                self.file.close()
        # Note: we don't set __loader__ because we want the module to look
        # normal; i.e. this is just a wrapper for standard import machinery
        return mod

    def get_data(self, pathname):
        return open(pathname, "rb").read()

    def _reopen(self):
        if self.file and self.file.closed:
            mod_type = self.etc[2]
            if mod_type==imp.PY_SOURCE:
                self.file = open(self.filename, 'rU')
            elif mod_type in (imp.PY_COMPILED, imp.C_EXTENSION):
                self.file = open(self.filename, 'rb')

    def _fix_name(self, fullname):
        if fullname is None:
            fullname = self.fullname
        elif fullname != self.fullname:
            raise ImportError("Loader for module %s cannot handle "
                              "module %s" % (self.fullname, fullname))
        return fullname

    def is_package(self, fullname):
        fullname = self._fix_name(fullname)
        return self.etc[2]==imp.PKG_DIRECTORY

    def get_code(self, fullname=None):
        fullname = self._fix_name(fullname)
        if self.code is None:
            mod_type = self.etc[2]
            if mod_type==imp.PY_SOURCE:
                source = self.get_source(fullname)
                self.code = compile(source, self.filename, 'exec')
            elif mod_type==imp.PY_COMPILED:
                self._reopen()
                try:
                    self.code = read_code(self.file)
                finally:
                    self.file.close()
            elif mod_type==imp.PKG_DIRECTORY:
                self.code = self._get_delegate().get_code()
        return self.code

    def get_source(self, fullname=None):
        fullname = self._fix_name(fullname)
        if self.source is None:
            mod_type = self.etc[2]
            if mod_type==imp.PY_SOURCE:
                self._reopen()
                try:
                    self.source = self.file.read()
                finally:
                    self.file.close()
            elif mod_type==imp.PY_COMPILED:
                if os.path.exists(self.filename[:-1]):
                    f = open(self.filename[:-1], 'rU')
                    self.source = f.read()
                    f.close()
            elif mod_type==imp.PKG_DIRECTORY:
                self.source = self._get_delegate().get_source()
        return self.source


    def _get_delegate(self):
        return ImpImporter(self.filename).find_module('__init__')

    def get_filename(self, fullname=None):
        fullname = self._fix_name(fullname)
        mod_type = self.etc[2]
        if self.etc[2]==imp.PKG_DIRECTORY:
            return self._get_delegate().get_filename()
        elif self.etc[2] in (imp.PY_SOURCE, imp.PY_COMPILED, imp.C_EXTENSION):
            return self.filename
        return None


try:
    import zipimport
    from zipimport import zipimporter

    def iter_zipimport_modules(importer, prefix=''):
        dirlist = zipimport._zip_directory_cache[importer.archive].keys()
        dirlist.sort()
        _prefix = importer.prefix
        plen = len(_prefix)
        yielded = {}
        import inspect
        for fn in dirlist:
            if not fn.startswith(_prefix):
                continue

            fn = fn[plen:].split(os.sep)

            if len(fn)==2 and fn[1].startswith('__init__.py'):
                if fn[0] not in yielded:
                    yielded[fn[0]] = 1
                    yield fn[0], True

            if len(fn)!=1:
                continue

            modname = inspect.getmodulename(fn[0])
            if modname=='__init__':
                continue

            if modname and '.' not in modname and modname not in yielded:
                yielded[modname] = 1
                yield prefix + modname, False

    iter_importer_modules.register(zipimporter, iter_zipimport_modules)

except ImportError:
    pass


def get_importer(path_item):
    """Retrieve a PEP 302 importer for the given path item

    The returned importer is cached in sys.path_importer_cache
    if it was newly created by a path hook.

    If there is no importer, a wrapper around the basic import
    machinery is returned. This wrapper is never inserted into
    the importer cache (None is inserted instead).

    The cache (or part of it) can be cleared manually if a
    rescan of sys.path_hooks is necessary.
    """
    try:
        importer = sys.path_importer_cache[path_item]
    except KeyError:
        for path_hook in sys.path_hooks:
            try:
                importer = path_hook(path_item)
                break
            except ImportError:
                pass
        else:
            importer = None
        sys.path_importer_cache.setdefault(path_item, importer)

    if importer is None:
        try:
            importer = ImpImporter(path_item)
        except ImportError:
            importer = None
    return importer


def iter_importers(fullname=""):
    """Yield PEP 302 importers for the given module name

    If fullname contains a '.', the importers will be for the package
    containing fullname, otherwise they will be importers for sys.meta_path,
    sys.path, and Python's "classic" import machinery, in that order.  If
    the named module is in a package, that package is imported as a side
    effect of invoking this function.

    Non PEP 302 mechanisms (e.g. the Windows registry) used by the
    standard import machinery to find files in alternative locations
    are partially supported, but are searched AFTER sys.path. Normally,
    these locations are searched BEFORE sys.path, preventing sys.path
    entries from shadowing them.

    For this to cause a visible difference in behaviour, there must
    be a module or package name that is accessible via both sys.path
    and one of the non PEP 302 file system mechanisms. In this case,
    the emulation will find the former version, while the builtin
    import mechanism will find the latter.

    Items of the following types can be affected by this discrepancy:
        imp.C_EXTENSION, imp.PY_SOURCE, imp.PY_COMPILED, imp.PKG_DIRECTORY
    """
    if fullname.startswith('.'):
        raise ImportError("Relative module names not supported")
    if '.' in fullname:
        # Get the containing package's __path__
        pkg = '.'.join(fullname.split('.')[:-1])
        if pkg not in sys.modules:
            __import__(pkg)
        path = getattr(sys.modules[pkg], '__path__', None) or []
    else:
        for importer in sys.meta_path:
            yield importer
        path = sys.path
    for item in path:
        yield get_importer(item)
    if '.' not in fullname:
        yield ImpImporter()

def get_loader(module_or_name):
    """Get a PEP 302 "loader" object for module_or_name

    If the module or package is accessible via the normal import
    mechanism, a wrapper around the relevant part of that machinery
    is returned.  Returns None if the module cannot be found or imported.
    If the named module is not already imported, its containing package
    (if any) is imported, in order to establish the package __path__.

    This function uses iter_importers(), and is thus subject to the same
    limitations regarding platform-specific special import locations such
    as the Windows registry.
    """
    if module_or_name in sys.modules:
        module_or_name = sys.modules[module_or_name]
    if isinstance(module_or_name, ModuleType):
        module = module_or_name
        loader = getattr(module, '__loader__', None)
        if loader is not None:
            return loader
        fullname = module.__name__
    else:
        fullname = module_or_name
    return find_loader(fullname)

def find_loader(fullname):
    """Find a PEP 302 "loader" object for fullname

    If fullname contains dots, path must be the containing package's __path__.
    Returns None if the module cannot be found or imported. This function uses
    iter_importers(), and is thus subject to the same limitations regarding
    platform-specific special import locations such as the Windows registry.
    """
    for importer in iter_importers(fullname):
        loader = importer.find_module(fullname)
        if loader is not None:
            return loader

    return None


def extend_path(path, name):
    """Extend a package's path.

    Intended use is to place the following code in a package's __init__.py:

        from pkgutil import extend_path
        __path__ = extend_path(__path__, __name__)

    This will add to the package's __path__ all subdirectories of
    directories on sys.path named after the package.  This is useful
    if one wants to distribute different parts of a single logical
    package as multiple directories.

    It also looks for *.pkg files beginning where * matches the name
    argument.  This feature is similar to *.pth files (see site.py),
    except that it doesn't special-case lines starting with 'import'.
    A *.pkg file is trusted at face value: apart from checking for
    duplicates, all entries found in a *.pkg file are added to the
    path, regardless of whether they are exist the filesystem.  (This
    is a feature.)

    If the input path is not a list (as is the case for frozen
    packages) it is returned unchanged.  The input path is not
    modified; an extended copy is returned.  Items are only appended
    to the copy at the end.

    It is assumed that sys.path is a sequence.  Items of sys.path that
    are not (unicode or 8-bit) strings referring to existing
    directories are ignored.  Unicode items of sys.path that cause
    errors when used as filenames may cause this function to raise an
    exception (in line with os.path.isdir() behavior).
    """

    if not isinstance(path, list):
        # This could happen e.g. when this is called from inside a
        # frozen package.  Return the path unchanged in that case.
        return path

    pname = os.path.join(*name.split('.')) # Reconstitute as relative path
    # Just in case os.extsep != '.'
    sname = os.extsep.join(name.split('.'))
    sname_pkg = sname + os.extsep + "pkg"
    init_py = "__init__" + os.extsep + "py"

    path = path[:] # Start with a copy of the existing path

    for dir in sys.path:
        if not isinstance(dir, basestring) or not os.path.isdir(dir):
            continue
        subdir = os.path.join(dir, pname)
        # XXX This may still add duplicate entries to path on
        # case-insensitive filesystems
        initfile = os.path.join(subdir, init_py)
        if subdir not in path and os.path.isfile(initfile):
            path.append(subdir)
        # XXX Is this the right thing for subpackages like zope.app?
        # It looks for a file named "zope.app.pkg"
        pkgfile = os.path.join(dir, sname_pkg)
        if os.path.isfile(pkgfile):
            try:
                f = open(pkgfile)
            except IOError, msg:
                sys.stderr.write("Can't open %s: %s\n" %
                                 (pkgfile, msg))
            else:
                for line in f:
                    line = line.rstrip('\n')
                    if not line or line.startswith('#'):
                        continue
                    path.append(line) # Don't check for existence!
                f.close()

    return path

def get_data(package, resource):
    """Get a resource from a package.

    This is a wrapper round the PEP 302 loader get_data API. The package
    argument should be the name of a package, in standard module format
    (foo.bar). The resource argument should be in the form of a relative
    filename, using '/' as the path separator. The parent directory name '..'
    is not allowed, and nor is a rooted name (starting with a '/').

    The function returns a binary string, which is the contents of the
    specified resource.

    For packages located in the filesystem, which have already been imported,
    this is the rough equivalent of

        d = os.path.dirname(sys.modules[package].__file__)
        data = open(os.path.join(d, resource), 'rb').read()

    If the package cannot be located or loaded, or it uses a PEP 302 loader
    which does not support get_data(), then None is returned.
    """

    loader = get_loader(package)
    if loader is None or not hasattr(loader, 'get_data'):
        return None
    mod = sys.modules.get(package) or loader.load_module(package)
    if mod is None or not hasattr(mod, '__file__'):
        return None

    # Modify the resource name to be compatible with the loader.get_data
    # signature - an os.path format "filename" starting with the dirname of
    # the package's __file__
    parts = resource.split('/')
    parts.insert(0, os.path.dirname(mod.__file__))
    resource_name = os.path.join(*parts)
    return loader.get_data(resource_name)

filename:/usr/lib/python2.7/this.py
__doc__
s = """Gur Mra bs Clguba, ol Gvz Crgref

Ornhgvshy vf orggre guna htyl.
Rkcyvpvg vf orggre guna vzcyvpvg.
Fvzcyr vf orggre guna pbzcyrk.
Pbzcyrk vf orggre guna pbzcyvpngrq.
Syng vf orggre guna arfgrq.
Fcnefr vf orggre guna qrafr.
Ernqnovyvgl pbhagf.
Fcrpvny pnfrf nera'g fcrpvny rabhtu gb oernx gur ehyrf.
Nygubhtu cenpgvpnyvgl orngf chevgl.
Reebef fubhyq arire cnff fvyragyl.
Hayrff rkcyvpvgyl fvyraprq.
Va gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.
Gurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.
Nygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh'er Qhgpu.
Abj vf orggre guna arire.
Nygubhtu arire vf bsgra orggre guna *evtug* abj.
Vs gur vzcyrzragngvba vf uneq gb rkcynva, vg'f n onq vqrn.
Vs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.
Anzrfcnprf ner bar ubaxvat terng vqrn -- yrg'f qb zber bs gubfr!"""

d = {}
for c in (65, 97):
    for i in range(26):
        d[chr(i+c)] = chr((i+13) % 26 + c)

print "".join([d.get(c, c) for c in s])

filename:/usr/lib/python2.7/UserList.py
__doc__
"""A more or less complete user-defined wrapper around list objects."""

filename:/usr/lib/python2.7/hmac.py
__doc__
"""HMAC (Keyed-Hashing for Message Authentication) Python module.

Implements the HMAC algorithm as described by RFC 2104.
"""

filename:/usr/lib/python2.7/test/test_support.py
__doc__
"""Supporting definitions for the Python regression tests."""

if __name__ != 'test.test_support':
    raise ImportError('test_support must be imported from the test package')

import contextlib
import errno
import functools
import gc
import socket
import sys
import os
import platform
import shutil
import warnings
import unittest
import importlib
import UserDict
import re
import time
import struct
import sysconfig
try:
    import thread
except ImportError:
    thread = None

__all__ = ["Error", "TestFailed", "ResourceDenied", "import_module",
           "verbose", "use_resources", "max_memuse", "record_original_stdout",
           "get_original_stdout", "unload", "unlink", "rmtree", "forget",
           "is_resource_enabled", "requires", "requires_mac_ver",
           "find_unused_port", "bind_port",
           "fcmp", "have_unicode", "is_jython", "TESTFN", "HOST", "FUZZ",
           "SAVEDCWD", "temp_cwd", "findfile", "sortdict", "check_syntax_error",
           "open_urlresource", "check_warnings", "check_py3k_warnings",
           "CleanImport", "EnvironmentVarGuard", "captured_output",
           "captured_stdout", "TransientResource", "transient_internet",
           "run_with_locale", "set_memlimit", "bigmemtest", "bigaddrspacetest",
           "BasicTestRunner", "run_unittest", "run_doctest", "threading_setup",
           "threading_cleanup", "reap_threads", "start_threads", "cpython_only",
           "check_impl_detail", "get_attribute", "py3k_bytes",
           "import_fresh_module", "threading_cleanup", "reap_children",
           "strip_python_stderr", "IPV6_ENABLED", "run_with_tz"]

class Error(Exception):
    """Base class for regression test exceptions."""

class TestFailed(Error):
    """Test failed."""

class ResourceDenied(unittest.SkipTest):
    """Test skipped because it requested a disallowed resource.

    This is raised when a test calls requires() for a resource that
    has not been enabled.  It is used to distinguish between expected
    and unexpected skips.
    """

@contextlib.contextmanager
def _ignore_deprecated_imports(ignore=True):
    """Context manager to suppress package and module deprecation
    warnings when importing them.

    If ignore is False, this context manager has no effect."""
    if ignore:
        with warnings.catch_warnings():
            warnings.filterwarnings("ignore", ".+ (module|package)",
                                    DeprecationWarning)
            yield
    else:
        yield


def import_module(name, deprecated=False):
    """Import and return the module to be tested, raising SkipTest if
    it is not available.

    If deprecated is True, any module or package deprecation messages
    will be suppressed."""
    with _ignore_deprecated_imports(deprecated):
        try:
            return importlib.import_module(name)
        except ImportError, msg:
            raise unittest.SkipTest(str(msg))


def _save_and_remove_module(name, orig_modules):
    """Helper function to save and remove a module from sys.modules

       Raise ImportError if the module can't be imported."""
    # try to import the module and raise an error if it can't be imported
    if name not in sys.modules:
        __import__(name)
        del sys.modules[name]
    for modname in list(sys.modules):
        if modname == name or modname.startswith(name + '.'):
            orig_modules[modname] = sys.modules[modname]
            del sys.modules[modname]

def _save_and_block_module(name, orig_modules):
    """Helper function to save and block a module in sys.modules

       Return True if the module was in sys.modules, False otherwise."""
    saved = True
    try:
        orig_modules[name] = sys.modules[name]
    except KeyError:
        saved = False
    sys.modules[name] = None
    return saved


def import_fresh_module(name, fresh=(), blocked=(), deprecated=False):
    """Imports and returns a module, deliberately bypassing the sys.modules cache
    and importing a fresh copy of the module. Once the import is complete,
    the sys.modules cache is restored to its original state.

    Modules named in fresh are also imported anew if needed by the import.
    If one of these modules can't be imported, None is returned.

    Importing of modules named in blocked is prevented while the fresh import
    takes place.

    If deprecated is True, any module or package deprecation messages
    will be suppressed."""
    # NOTE: test_heapq, test_json, and test_warnings include extra sanity
    # checks to make sure that this utility function is working as expected
    with _ignore_deprecated_imports(deprecated):
        # Keep track of modules saved for later restoration as well
        # as those which just need a blocking entry removed
        orig_modules = {}
        names_to_remove = []
        _save_and_remove_module(name, orig_modules)
        try:
            for fresh_name in fresh:
                _save_and_remove_module(fresh_name, orig_modules)
            for blocked_name in blocked:
                if not _save_and_block_module(blocked_name, orig_modules):
                    names_to_remove.append(blocked_name)
            fresh_module = importlib.import_module(name)
        except ImportError:
            fresh_module = None
        finally:
            for orig_name, module in orig_modules.items():
                sys.modules[orig_name] = module
            for name_to_remove in names_to_remove:
                del sys.modules[name_to_remove]
        return fresh_module


def get_attribute(obj, name):
    """Get an attribute, raising SkipTest if AttributeError is raised."""
    try:
        attribute = getattr(obj, name)
    except AttributeError:
        raise unittest.SkipTest("module %s has no attribute %s" % (
            obj.__name__, name))
    else:
        return attribute


verbose = 1              # Flag set to 0 by regrtest.py
use_resources = None     # Flag set to [] by regrtest.py
max_memuse = 0           # Disable bigmem tests (they will still be run with
                         # small sizes, to make sure they work.)
real_max_memuse = 0

# _original_stdout is meant to hold stdout at the time regrtest began.
# This may be "the real" stdout, or IDLE's emulation of stdout, or whatever.
# The point is to have some flavor of stdout the user can actually see.
_original_stdout = None
def record_original_stdout(stdout):
    global _original_stdout
    _original_stdout = stdout

def get_original_stdout():
    return _original_stdout or sys.stdout

def unload(name):
    try:
        del sys.modules[name]
    except KeyError:
        pass

if sys.platform.startswith("win"):
    def _waitfor(func, pathname, waitall=False):
        # Perform the operation
        func(pathname)
        # Now setup the wait loop
        if waitall:
            dirname = pathname
        else:
            dirname, name = os.path.split(pathname)
            dirname = dirname or '.'
        # Check for `pathname` to be removed from the filesystem.
        # The exponential backoff of the timeout amounts to a total
        # of ~1 second after which the deletion is probably an error
        # anyway.
        # Testing on a i7@4.3GHz shows that usually only 1 iteration is
        # required when contention occurs.
        timeout = 0.001
        while timeout < 1.0:
            # Note we are only testing for the existence of the file(s) in
            # the contents of the directory regardless of any security or
            # access rights.  If we have made it this far, we have sufficient
            # permissions to do that much using Python's equivalent of the
            # Windows API FindFirstFile.
            # Other Windows APIs can fail or give incorrect results when
            # dealing with files that are pending deletion.
            L = os.listdir(dirname)
            if not (L if waitall else name in L):
                return
            # Increase the timeout and try again
            time.sleep(timeout)
            timeout *= 2
        warnings.warn('tests may fail, delete still pending for ' + pathname,
                      RuntimeWarning, stacklevel=4)

    def _unlink(filename):
        _waitfor(os.unlink, filename)

    def _rmdir(dirname):
        _waitfor(os.rmdir, dirname)

    def _rmtree(path):
        def _rmtree_inner(path):
            for name in os.listdir(path):
                fullname = os.path.join(path, name)
                if os.path.isdir(fullname):
                    _waitfor(_rmtree_inner, fullname, waitall=True)
                    os.rmdir(fullname)
                else:
                    os.unlink(fullname)
        _waitfor(_rmtree_inner, path, waitall=True)
        _waitfor(os.rmdir, path)
else:
    _unlink = os.unlink
    _rmdir = os.rmdir
    _rmtree = shutil.rmtree

def unlink(filename):
    try:
        _unlink(filename)
    except OSError:
        pass

def rmdir(dirname):
    try:
        _rmdir(dirname)
    except OSError as error:
        # The directory need not exist.
        if error.errno != errno.ENOENT:
            raise

def rmtree(path):
    try:
        _rmtree(path)
    except OSError, e:
        # Unix returns ENOENT, Windows returns ESRCH.
        if e.errno not in (errno.ENOENT, errno.ESRCH):
            raise

def forget(modname):
    '''"Forget" a module was ever imported by removing it from sys.modules and
    deleting any .pyc and .pyo files.'''
    unload(modname)
    for dirname in sys.path:
        unlink(os.path.join(dirname, modname + os.extsep + 'pyc'))
        # Deleting the .pyo file cannot be within the 'try' for the .pyc since
        # the chance exists that there is no .pyc (and thus the 'try' statement
        # is exited) but there is a .pyo file.
        unlink(os.path.join(dirname, modname + os.extsep + 'pyo'))

# Check whether a gui is actually available
def _is_gui_available():
    if hasattr(_is_gui_available, 'result'):
        return _is_gui_available.result
    reason = None
    if sys.platform.startswith('win'):
        # if Python is running as a service (such as the buildbot service),
        # gui interaction may be disallowed
        import ctypes
        import ctypes.wintypes
        UOI_FLAGS = 1
        WSF_VISIBLE = 0x0001
        class USEROBJECTFLAGS(ctypes.Structure):
            _fields_ = [("fInherit", ctypes.wintypes.BOOL),
                        ("fReserved", ctypes.wintypes.BOOL),
                        ("dwFlags", ctypes.wintypes.DWORD)]
        dll = ctypes.windll.user32
        h = dll.GetProcessWindowStation()
        if not h:
            raise ctypes.WinError()
        uof = USEROBJECTFLAGS()
        needed = ctypes.wintypes.DWORD()
        res = dll.GetUserObjectInformationW(h,
            UOI_FLAGS,
            ctypes.byref(uof),
            ctypes.sizeof(uof),
            ctypes.byref(needed))
        if not res:
            raise ctypes.WinError()
        if not bool(uof.dwFlags & WSF_VISIBLE):
            reason = "gui not available (WSF_VISIBLE flag not set)"
    elif sys.platform == 'darwin':
        # The Aqua Tk implementations on OS X can abort the process if
        # being called in an environment where a window server connection
        # cannot be made, for instance when invoked by a buildbot or ssh
        # process not running under the same user id as the current console
        # user.  To avoid that, raise an exception if the window manager
        # connection is not available.
        from ctypes import cdll, c_int, pointer, Structure
        from ctypes.util import find_library

        app_services = cdll.LoadLibrary(find_library("ApplicationServices"))

        if app_services.CGMainDisplayID() == 0:
            reason = "gui tests cannot run without OS X window manager"
        else:
            class ProcessSerialNumber(Structure):
                _fields_ = [("highLongOfPSN", c_int),
                            ("lowLongOfPSN", c_int)]
            psn = ProcessSerialNumber()
            psn_p = pointer(psn)
            if (  (app_services.GetCurrentProcess(psn_p) < 0) or
                  (app_services.SetFrontProcess(psn_p) < 0) ):
                reason = "cannot run without OS X gui process"

    # check on every platform whether tkinter can actually do anything
    if not reason:
        try:
            from Tkinter import Tk
            root = Tk()
            root.update()
            root.destroy()
        except Exception as e:
            err_string = str(e)
            if len(err_string) > 50:
                err_string = err_string[:50] + ' [...]'
            reason = 'Tk unavailable due to {}: {}'.format(type(e).__name__,
                                                           err_string)

    _is_gui_available.reason = reason
    _is_gui_available.result = not reason

    return _is_gui_available.result

def is_resource_enabled(resource):
    """Test whether a resource is enabled.

    Known resources are set by regrtest.py.  If not running under regrtest.py,
    all resources are assumed enabled unless use_resources has been set.
    """
    return use_resources is None or resource in use_resources

def requires(resource, msg=None):
    """Raise ResourceDenied if the specified resource is not available."""
    if resource == 'gui' and not _is_gui_available():
        raise ResourceDenied(_is_gui_available.reason)
    if not is_resource_enabled(resource):
        if msg is None:
            msg = "Use of the `%s' resource not enabled" % resource
        raise ResourceDenied(msg)

def requires_mac_ver(*min_version):
    """Decorator raising SkipTest if the OS is Mac OS X and the OS X
    version if less than min_version.

    For example, @requires_mac_ver(10, 5) raises SkipTest if the OS X version
    is lesser than 10.5.
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            if sys.platform == 'darwin':
                version_txt = platform.mac_ver()[0]
                try:
                    version = tuple(map(int, version_txt.split('.')))
                except ValueError:
                    pass
                else:
                    if version < min_version:
                        min_version_txt = '.'.join(map(str, min_version))
                        raise unittest.SkipTest(
                            "Mac OS X %s or higher required, not %s"
                            % (min_version_txt, version_txt))
            return func(*args, **kw)
        wrapper.min_version = min_version
        return wrapper
    return decorator


# Don't use "localhost", since resolving it uses the DNS under recent
# Windows versions (see issue #18792).
HOST = "127.0.0.1"
HOSTv6 = "::1"


def find_unused_port(family=socket.AF_INET, socktype=socket.SOCK_STREAM):
    """Returns an unused port that should be suitable for binding.  This is
    achieved by creating a temporary socket with the same family and type as
    the 'sock' parameter (default is AF_INET, SOCK_STREAM), and binding it to
    the specified host address (defaults to 0.0.0.0) with the port set to 0,
    eliciting an unused ephemeral port from the OS.  The temporary socket is
    then closed and deleted, and the ephemeral port is returned.

    Either this method or bind_port() should be used for any tests where a
    server socket needs to be bound to a particular port for the duration of
    the test.  Which one to use depends on whether the calling code is creating
    a python socket, or if an unused port needs to be provided in a constructor
    or passed to an external program (i.e. the -accept argument to openssl's
    s_server mode).  Always prefer bind_port() over find_unused_port() where
    possible.  Hard coded ports should *NEVER* be used.  As soon as a server
    socket is bound to a hard coded port, the ability to run multiple instances
    of the test simultaneously on the same host is compromised, which makes the
    test a ticking time bomb in a buildbot environment. On Unix buildbots, this
    may simply manifest as a failed test, which can be recovered from without
    intervention in most cases, but on Windows, the entire python process can
    completely and utterly wedge, requiring someone to log in to the buildbot
    and manually kill the affected process.

    (This is easy to reproduce on Windows, unfortunately, and can be traced to
    the SO_REUSEADDR socket option having different semantics on Windows versus
    Unix/Linux.  On Unix, you can't have two AF_INET SOCK_STREAM sockets bind,
    listen and then accept connections on identical host/ports.  An EADDRINUSE
    socket.error will be raised at some point (depending on the platform and
    the order bind and listen were called on each socket).

    However, on Windows, if SO_REUSEADDR is set on the sockets, no EADDRINUSE
    will ever be raised when attempting to bind two identical host/ports. When
    accept() is called on each socket, the second caller's process will steal
    the port from the first caller, leaving them both in an awkwardly wedged
    state where they'll no longer respond to any signals or graceful kills, and
    must be forcibly killed via OpenProcess()/TerminateProcess().

    The solution on Windows is to use the SO_EXCLUSIVEADDRUSE socket option
    instead of SO_REUSEADDR, which effectively affords the same semantics as
    SO_REUSEADDR on Unix.  Given the propensity of Unix developers in the Open
    Source world compared to Windows ones, this is a common mistake.  A quick
    look over OpenSSL's 0.9.8g source shows that they use SO_REUSEADDR when
    openssl.exe is called with the 's_server' option, for example. See
    http://bugs.python.org/issue2550 for more info.  The following site also
    has a very thorough description about the implications of both REUSEADDR
    and EXCLUSIVEADDRUSE on Windows:
    http://msdn2.microsoft.com/en-us/library/ms740621(VS.85).aspx)

    XXX: although this approach is a vast improvement on previous attempts to
    elicit unused ports, it rests heavily on the assumption that the ephemeral
    port returned to us by the OS won't immediately be dished back out to some
    other process when we close and delete our temporary socket but before our
    calling code has a chance to bind the returned port.  We can deal with this
    issue if/when we come across it."""
    tempsock = socket.socket(family, socktype)
    port = bind_port(tempsock)
    tempsock.close()
    del tempsock
    return port

def bind_port(sock, host=HOST):
    """Bind the socket to a free port and return the port number.  Relies on
    ephemeral ports in order to ensure we are using an unbound port.  This is
    important as many tests may be running simultaneously, especially in a
    buildbot environment.  This method raises an exception if the sock.family
    is AF_INET and sock.type is SOCK_STREAM, *and* the socket has SO_REUSEADDR
    or SO_REUSEPORT set on it.  Tests should *never* set these socket options
    for TCP/IP sockets.  The only case for setting these options is testing
    multicasting via multiple UDP sockets.

    Additionally, if the SO_EXCLUSIVEADDRUSE socket option is available (i.e.
    on Windows), it will be set on the socket.  This will prevent anyone else
    from bind()'ing to our host/port for the duration of the test.
    """
    if sock.family == socket.AF_INET and sock.type == socket.SOCK_STREAM:
        if hasattr(socket, 'SO_REUSEADDR'):
            if sock.getsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR) == 1:
                raise TestFailed("tests should never set the SO_REUSEADDR "   \
                                 "socket option on TCP/IP sockets!")
        if hasattr(socket, 'SO_REUSEPORT'):
            try:
                if sock.getsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT) == 1:
                    raise TestFailed("tests should never set the SO_REUSEPORT "   \
                                     "socket option on TCP/IP sockets!")
            except EnvironmentError:
                # Python's socket module was compiled using modern headers
                # thus defining SO_REUSEPORT but this process is running
                # under an older kernel that does not support SO_REUSEPORT.
                pass
        if hasattr(socket, 'SO_EXCLUSIVEADDRUSE'):
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_EXCLUSIVEADDRUSE, 1)

    sock.bind((host, 0))
    port = sock.getsockname()[1]
    return port

def _is_ipv6_enabled():
    """Check whether IPv6 is enabled on this host."""
    if socket.has_ipv6:
        sock = None
        try:
            sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
            sock.bind((HOSTv6, 0))
            return True
        except socket.error:
            pass
        finally:
            if sock:
                sock.close()
    return False

IPV6_ENABLED = _is_ipv6_enabled()

def system_must_validate_cert(f):
    """Skip the test on TLS certificate validation failures."""
    @functools.wraps(f)
    def dec(*args, **kwargs):
        try:
            f(*args, **kwargs)
        except IOError as e:
            if "CERTIFICATE_VERIFY_FAILED" in str(e):
                raise unittest.SkipTest("system does not contain "
                                        "necessary certificates")
            raise
    return dec

FUZZ = 1e-6

def fcmp(x, y): # fuzzy comparison function
    if isinstance(x, float) or isinstance(y, float):
        try:
            fuzz = (abs(x) + abs(y)) * FUZZ
            if abs(x-y) <= fuzz:
                return 0
        except:
            pass
    elif type(x) == type(y) and isinstance(x, (tuple, list)):
        for i in range(min(len(x), len(y))):
            outcome = fcmp(x[i], y[i])
            if outcome != 0:
                return outcome
        return (len(x) > len(y)) - (len(x) < len(y))
    return (x > y) - (x < y)


# A constant likely larger than the underlying OS pipe buffer size, to
# make writes blocking.
# Windows limit seems to be around 512 B, and many Unix kernels have a
# 64 KiB pipe buffer size or 16 * PAGE_SIZE: take a few megs to be sure.
# (see issue #17835 for a discussion of this number).
PIPE_MAX_SIZE = 4 * 1024 * 1024 + 1

# A constant likely larger than the underlying OS socket buffer size, to make
# writes blocking.
# The socket buffer sizes can usually be tuned system-wide (e.g. through sysctl
# on Linux), or on a per-socket basis (SO_SNDBUF/SO_RCVBUF). See issue #18643
# for a discussion of this number).
SOCK_MAX_SIZE = 16 * 1024 * 1024 + 1

is_jython = sys.platform.startswith('java')

try:
    unicode
    have_unicode = True
except NameError:
    have_unicode = False

requires_unicode = unittest.skipUnless(have_unicode, 'no unicode support')

def u(s):
    return unicode(s, 'unicode-escape')

# FS_NONASCII: non-ASCII Unicode character encodable by
# sys.getfilesystemencoding(), or None if there is no such character.
FS_NONASCII = None
if have_unicode:
    for character in (
        # First try printable and common characters to have a readable filename.
        # For each character, the encoding list are just example of encodings able
        # to encode the character (the list is not exhaustive).

        # U+00E6 (Latin Small Letter Ae): cp1252, iso-8859-1
        unichr(0x00E6),
        # U+0130 (Latin Capital Letter I With Dot Above): cp1254, iso8859_3
        unichr(0x0130),
        # U+0141 (Latin Capital Letter L With Stroke): cp1250, cp1257
        unichr(0x0141),
        # U+03C6 (Greek Small Letter Phi): cp1253
        unichr(0x03C6),
        # U+041A (Cyrillic Capital Letter Ka): cp1251
        unichr(0x041A),
        # U+05D0 (Hebrew Letter Alef): Encodable to cp424
        unichr(0x05D0),
        # U+060C (Arabic Comma): cp864, cp1006, iso8859_6, mac_arabic
        unichr(0x060C),
        # U+062A (Arabic Letter Teh): cp720
        unichr(0x062A),
        # U+0E01 (Thai Character Ko Kai): cp874
        unichr(0x0E01),

        # Then try more "special" characters. "special" because they may be
        # interpreted or displayed differently depending on the exact locale
        # encoding and the font.

        # U+00A0 (No-Break Space)
        unichr(0x00A0),
        # U+20AC (Euro Sign)
        unichr(0x20AC),
    ):
        try:
            character.encode(sys.getfilesystemencoding())\
                     .decode(sys.getfilesystemencoding())
        except UnicodeError:
            pass
        else:
            FS_NONASCII = character
            break

# Filename used for testing
if os.name == 'java':
    # Jython disallows @ in module names
    TESTFN = '$test'
elif os.name == 'riscos':
    TESTFN = 'testfile'
else:
    TESTFN = '@test'
    # Unicode name only used if TEST_FN_ENCODING exists for the platform.
    if have_unicode:
        # Assuming sys.getfilesystemencoding()!=sys.getdefaultencoding()
        # TESTFN_UNICODE is a filename that can be encoded using the
        # file system encoding, but *not* with the default (ascii) encoding
        if isinstance('', unicode):
            # python -U
            # XXX perhaps unicode() should accept Unicode strings?
            TESTFN_UNICODE = "@test-\xe0\xf2"
        else:
            # 2 latin characters.
            TESTFN_UNICODE = unicode("@test-\xe0\xf2", "latin-1")
        TESTFN_ENCODING = sys.getfilesystemencoding()
        # TESTFN_UNENCODABLE is a filename that should *not* be
        # able to be encoded by *either* the default or filesystem encoding.
        # This test really only makes sense on Windows NT platforms
        # which have special Unicode support in posixmodule.
        if (not hasattr(sys, "getwindowsversion") or
                sys.getwindowsversion()[3] < 2): #  0=win32s or 1=9x/ME
            TESTFN_UNENCODABLE = None
        else:
            # Japanese characters (I think - from bug 846133)
            TESTFN_UNENCODABLE = eval('u"@test-\u5171\u6709\u3055\u308c\u308b"')
            try:
                # XXX - Note - should be using TESTFN_ENCODING here - but for
                # Windows, "mbcs" currently always operates as if in
                # errors=ignore' mode - hence we get '?' characters rather than
                # the exception.  'Latin1' operates as we expect - ie, fails.
                # See [ 850997 ] mbcs encoding ignores errors
                TESTFN_UNENCODABLE.encode("Latin1")
            except UnicodeEncodeError:
                pass
            else:
                print \
                'WARNING: The filename %r CAN be encoded by the filesystem.  ' \
                'Unicode filename tests may not be effective' \
                % TESTFN_UNENCODABLE


# Disambiguate TESTFN for parallel testing, while letting it remain a valid
# module name.
TESTFN = "{}_{}_tmp".format(TESTFN, os.getpid())

# Save the initial cwd
SAVEDCWD = os.getcwd()

@contextlib.contextmanager
def change_cwd(path, quiet=False):
    """Return a context manager that changes the current working directory.

    Arguments:

      path: the directory to use as the temporary current working directory.

      quiet: if False (the default), the context manager raises an exception
        on error.  Otherwise, it issues only a warning and keeps the current
        working directory the same.

    """
    saved_dir = os.getcwd()
    try:
        os.chdir(path)
    except OSError:
        if not quiet:
            raise
        warnings.warn('tests may fail, unable to change CWD to: ' + path,
                      RuntimeWarning, stacklevel=3)
    try:
        yield os.getcwd()
    finally:
        os.chdir(saved_dir)


@contextlib.contextmanager
def temp_cwd(name='tempcwd', quiet=False):
    """
    Context manager that creates a temporary directory and set it as CWD.

    The new CWD is created in the current directory and it's named *name*.
    If *quiet* is False (default) and it's not possible to create or change
    the CWD, an error is raised.  If it's True, only a warning is raised
    and the original CWD is used.
    """
    if (have_unicode and isinstance(name, unicode) and
        not os.path.supports_unicode_filenames):
        try:
            name = name.encode(sys.getfilesystemencoding() or 'ascii')
        except UnicodeEncodeError:
            if not quiet:
                raise unittest.SkipTest('unable to encode the cwd name with '
                                        'the filesystem encoding.')
    saved_dir = os.getcwd()
    is_temporary = False
    try:
        os.mkdir(name)
        os.chdir(name)
        is_temporary = True
    except OSError:
        if not quiet:
            raise
        warnings.warn('tests may fail, unable to change the CWD to ' + name,
                      RuntimeWarning, stacklevel=3)
    try:
        yield os.getcwd()
    finally:
        os.chdir(saved_dir)
        if is_temporary:
            rmtree(name)


def findfile(file, here=__file__, subdir=None):
    """Try to find a file on sys.path and the working directory.  If it is not
    found the argument passed to the function is returned (this does not
    necessarily signal failure; could still be the legitimate path)."""
    if os.path.isabs(file):
        return file
    if subdir is not None:
        file = os.path.join(subdir, file)
    path = sys.path
    path = [os.path.dirname(here)] + path
    for dn in path:
        fn = os.path.join(dn, file)
        if os.path.exists(fn): return fn
    return file

def sortdict(dict):
    "Like repr(dict), but in sorted order."
    items = dict.items()
    items.sort()
    reprpairs = ["%r: %r" % pair for pair in items]
    withcommas = ", ".join(reprpairs)
    return "{%s}" % withcommas

def make_bad_fd():
    """
    Create an invalid file descriptor by opening and closing a file and return
    its fd.
    """
    file = open(TESTFN, "wb")
    try:
        return file.fileno()
    finally:
        file.close()
        unlink(TESTFN)

def check_syntax_error(testcase, statement):
    testcase.assertRaises(SyntaxError, compile, statement,
                          '<test string>', 'exec')

def open_urlresource(url, check=None):
    import urlparse, urllib2

    filename = urlparse.urlparse(url)[2].split('/')[-1] # '/': it's URL!

    fn = os.path.join(os.path.dirname(__file__), "data", filename)

    def check_valid_file(fn):
        f = open(fn)
        if check is None:
            return f
        elif check(f):
            f.seek(0)
            return f
        f.close()

    if os.path.exists(fn):
        f = check_valid_file(fn)
        if f is not None:
            return f
        unlink(fn)

    # Verify the requirement before downloading the file
    requires('urlfetch')

    print >> get_original_stdout(), '\tfetching %s ...' % url
    f = urllib2.urlopen(url, timeout=15)
    try:
        with open(fn, "wb") as out:
            s = f.read()
            while s:
                out.write(s)
                s = f.read()
    finally:
        f.close()

    f = check_valid_file(fn)
    if f is not None:
        return f
    raise TestFailed('invalid resource "%s"' % fn)


class WarningsRecorder(object):
    """Convenience wrapper for the warnings list returned on
       entry to the warnings.catch_warnings() context manager.
    """
    def __init__(self, warnings_list):
        self._warnings = warnings_list
        self._last = 0

    def __getattr__(self, attr):
        if len(self._warnings) > self._last:
            return getattr(self._warnings[-1], attr)
        elif attr in warnings.WarningMessage._WARNING_DETAILS:
            return None
        raise AttributeError("%r has no attribute %r" % (self, attr))

    @property
    def warnings(self):
        return self._warnings[self._last:]

    def reset(self):
        self._last = len(self._warnings)


def _filterwarnings(filters, quiet=False):
    """Catch the warnings, then check if all the expected
    warnings have been raised and re-raise unexpected warnings.
    If 'quiet' is True, only re-raise the unexpected warnings.
    """
    # Clear the warning registry of the calling module
    # in order to re-raise the warnings.
    frame = sys._getframe(2)
    registry = frame.f_globals.get('__warningregistry__')
    if registry:
        registry.clear()
    with warnings.catch_warnings(record=True) as w:
        # Set filter "always" to record all warnings.  Because
        # test_warnings swap the module, we need to look up in
        # the sys.modules dictionary.
        sys.modules['warnings'].simplefilter("always")
        yield WarningsRecorder(w)
    # Filter the recorded warnings
    reraise = [warning.message for warning in w]
    missing = []
    for msg, cat in filters:
        seen = False
        for exc in reraise[:]:
            message = str(exc)
            # Filter out the matching messages
            if (re.match(msg, message, re.I) and
                issubclass(exc.__class__, cat)):
                seen = True
                reraise.remove(exc)
        if not seen and not quiet:
            # This filter caught nothing
            missing.append((msg, cat.__name__))
    if reraise:
        raise AssertionError("unhandled warning %r" % reraise[0])
    if missing:
        raise AssertionError("filter (%r, %s) did not catch any warning" %
                             missing[0])


@contextlib.contextmanager
def check_warnings(*filters, **kwargs):
    """Context manager to silence warnings.

    Accept 2-tuples as positional arguments:
        ("message regexp", WarningCategory)

    Optional argument:
     - if 'quiet' is True, it does not fail if a filter catches nothing
        (default True without argument,
         default False if some filters are defined)

    Without argument, it defaults to:
        check_warnings(("", Warning), quiet=True)
    """
    quiet = kwargs.get('quiet')
    if not filters:
        filters = (("", Warning),)
        # Preserve backward compatibility
        if quiet is None:
            quiet = True
    return _filterwarnings(filters, quiet)


@contextlib.contextmanager
def check_py3k_warnings(*filters, **kwargs):
    """Context manager to silence py3k warnings.

    Accept 2-tuples as positional arguments:
        ("message regexp", WarningCategory)

    Optional argument:
     - if 'quiet' is True, it does not fail if a filter catches nothing
        (default False)

    Without argument, it defaults to:
        check_py3k_warnings(("", DeprecationWarning), quiet=False)
    """
    if sys.py3kwarning:
        if not filters:
            filters = (("", DeprecationWarning),)
    else:
        # It should not raise any py3k warning
        filters = ()
    return _filterwarnings(filters, kwargs.get('quiet'))


class CleanImport(object):
    """Context manager to force import to return a new module reference.

    This is useful for testing module-level behaviours, such as
    the emission of a DeprecationWarning on import.

    Use like this:

        with CleanImport("foo"):
            importlib.import_module("foo") # new reference
    """

    def __init__(self, *module_names):
        self.original_modules = sys.modules.copy()
        for module_name in module_names:
            if module_name in sys.modules:
                module = sys.modules[module_name]
                # It is possible that module_name is just an alias for
                # another module (e.g. stub for modules renamed in 3.x).
                # In that case, we also need delete the real module to clear
                # the import cache.
                if module.__name__ != module_name:
                    del sys.modules[module.__name__]
                del sys.modules[module_name]

    def __enter__(self):
        return self

    def __exit__(self, *ignore_exc):
        sys.modules.update(self.original_modules)


class EnvironmentVarGuard(UserDict.DictMixin):

    """Class to help protect the environment variable properly.  Can be used as
    a context manager."""

    def __init__(self):
        self._environ = os.environ
        self._changed = {}

    def __getitem__(self, envvar):
        return self._environ[envvar]

    def __setitem__(self, envvar, value):
        # Remember the initial value on the first access
        if envvar not in self._changed:
            self._changed[envvar] = self._environ.get(envvar)
        self._environ[envvar] = value

    def __delitem__(self, envvar):
        # Remember the initial value on the first access
        if envvar not in self._changed:
            self._changed[envvar] = self._environ.get(envvar)
        if envvar in self._environ:
            del self._environ[envvar]

    def keys(self):
        return self._environ.keys()

    def set(self, envvar, value):
        self[envvar] = value

    def unset(self, envvar):
        del self[envvar]

    def __enter__(self):
        return self

    def __exit__(self, *ignore_exc):
        for (k, v) in self._changed.items():
            if v is None:
                if k in self._environ:
                    del self._environ[k]
            else:
                self._environ[k] = v
        os.environ = self._environ


class DirsOnSysPath(object):
    """Context manager to temporarily add directories to sys.path.

    This makes a copy of sys.path, appends any directories given
    as positional arguments, then reverts sys.path to the copied
    settings when the context ends.

    Note that *all* sys.path modifications in the body of the
    context manager, including replacement of the object,
    will be reverted at the end of the block.
    """

    def __init__(self, *paths):
        self.original_value = sys.path[:]
        self.original_object = sys.path
        sys.path.extend(paths)

    def __enter__(self):
        return self

    def __exit__(self, *ignore_exc):
        sys.path = self.original_object
        sys.path[:] = self.original_value


class TransientResource(object):

    """Raise ResourceDenied if an exception is raised while the context manager
    is in effect that matches the specified exception and attributes."""

    def __init__(self, exc, **kwargs):
        self.exc = exc
        self.attrs = kwargs

    def __enter__(self):
        return self

    def __exit__(self, type_=None, value=None, traceback=None):
        """If type_ is a subclass of self.exc and value has attributes matching
        self.attrs, raise ResourceDenied.  Otherwise let the exception
        propagate (if any)."""
        if type_ is not None and issubclass(self.exc, type_):
            for attr, attr_value in self.attrs.iteritems():
                if not hasattr(value, attr):
                    break
                if getattr(value, attr) != attr_value:
                    break
            else:
                raise ResourceDenied("an optional resource is not available")


@contextlib.contextmanager
def transient_internet(resource_name, timeout=30.0, errnos=()):
    """Return a context manager that raises ResourceDenied when various issues
    with the Internet connection manifest themselves as exceptions."""
    default_errnos = [
        ('ECONNREFUSED', 111),
        ('ECONNRESET', 104),
        ('EHOSTUNREACH', 113),
        ('ENETUNREACH', 101),
        ('ETIMEDOUT', 110),
    ]
    default_gai_errnos = [
        ('EAI_AGAIN', -3),
        ('EAI_FAIL', -4),
        ('EAI_NONAME', -2),
        ('EAI_NODATA', -5),
        # Windows defines EAI_NODATA as 11001 but idiotic getaddrinfo()
        # implementation actually returns WSANO_DATA i.e. 11004.
        ('WSANO_DATA', 11004),
    ]

    denied = ResourceDenied("Resource '%s' is not available" % resource_name)
    captured_errnos = errnos
    gai_errnos = []
    if not captured_errnos:
        captured_errnos = [getattr(errno, name, num)
                           for (name, num) in default_errnos]
        gai_errnos = [getattr(socket, name, num)
                      for (name, num) in default_gai_errnos]

    def filter_error(err):
        n = getattr(err, 'errno', None)
        if (isinstance(err, socket.timeout) or
            (isinstance(err, socket.gaierror) and n in gai_errnos) or
            n in captured_errnos):
            if not verbose:
                sys.stderr.write(denied.args[0] + "\n")
            raise denied

    old_timeout = socket.getdefaulttimeout()
    try:
        if timeout is not None:
            socket.setdefaulttimeout(timeout)
        yield
    except IOError as err:
        # urllib can wrap original socket errors multiple times (!), we must
        # unwrap to get at the original error.
        while True:
            a = err.args
            if len(a) >= 1 and isinstance(a[0], IOError):
                err = a[0]
            # The error can also be wrapped as args[1]:
            #    except socket.error as msg:
            #        raise IOError('socket error', msg).with_traceback(sys.exc_info()[2])
            elif len(a) >= 2 and isinstance(a[1], IOError):
                err = a[1]
            else:
                break
        filter_error(err)
        raise
    # XXX should we catch generic exceptions and look for their
    # __cause__ or __context__?
    finally:
        socket.setdefaulttimeout(old_timeout)


@contextlib.contextmanager
def captured_output(stream_name):
    """Return a context manager used by captured_stdout and captured_stdin
    that temporarily replaces the sys stream *stream_name* with a StringIO."""
    import StringIO
    orig_stdout = getattr(sys, stream_name)
    setattr(sys, stream_name, StringIO.StringIO())
    try:
        yield getattr(sys, stream_name)
    finally:
        setattr(sys, stream_name, orig_stdout)

def captured_stdout():
    """Capture the output of sys.stdout:

       with captured_stdout() as s:
           print "hello"
       self.assertEqual(s.getvalue(), "hello")
    """
    return captured_output("stdout")

def captured_stderr():
    return captured_output("stderr")

def captured_stdin():
    return captured_output("stdin")

def gc_collect():
    """Force as many objects as possible to be collected.

    In non-CPython implementations of Python, this is needed because timely
    deallocation is not guaranteed by the garbage collector.  (Even in CPython
    this can be the case in case of reference cycles.)  This means that __del__
    methods may be called later than expected and weakrefs may remain alive for
    longer than expected.  This function tries its best to force all garbage
    objects to disappear.
    """
    gc.collect()
    if is_jython:
        time.sleep(0.1)
    gc.collect()
    gc.collect()


_header = '2P'
if hasattr(sys, "gettotalrefcount"):
    _header = '2P' + _header
_vheader = _header + 'P'

def calcobjsize(fmt):
    return struct.calcsize(_header + fmt + '0P')

def calcvobjsize(fmt):
    return struct.calcsize(_vheader + fmt + '0P')


_TPFLAGS_HAVE_GC = 1<<14
_TPFLAGS_HEAPTYPE = 1<<9

def check_sizeof(test, o, size):
    import _testcapi
    result = sys.getsizeof(o)
    # add GC header size
    if ((type(o) == type) and (o.__flags__ & _TPFLAGS_HEAPTYPE) or\
        ((type(o) != type) and (type(o).__flags__ & _TPFLAGS_HAVE_GC))):
        size += _testcapi.SIZEOF_PYGC_HEAD
    msg = 'wrong size for %s: got %d, expected %d' \
            % (type(o), result, size)
    test.assertEqual(result, size, msg)


#=======================================================================
# Decorator for running a function in a different locale, correctly resetting
# it afterwards.

def run_with_locale(catstr, *locales):
    def decorator(func):
        def inner(*args, **kwds):
            try:
                import locale
                category = getattr(locale, catstr)
                orig_locale = locale.setlocale(category)
            except AttributeError:
                # if the test author gives us an invalid category string
                raise
            except:
                # cannot retrieve original locale, so do nothing
                locale = orig_locale = None
            else:
                for loc in locales:
                    try:
                        locale.setlocale(category, loc)
                        break
                    except:
                        pass

            # now run the function, resetting the locale on exceptions
            try:
                return func(*args, **kwds)
            finally:
                if locale and orig_locale:
                    locale.setlocale(category, orig_locale)
        inner.func_name = func.func_name
        inner.__doc__ = func.__doc__
        return inner
    return decorator

#=======================================================================
# Decorator for running a function in a specific timezone, correctly
# resetting it afterwards.

def run_with_tz(tz):
    def decorator(func):
        def inner(*args, **kwds):
            try:
                tzset = time.tzset
            except AttributeError:
                raise unittest.SkipTest("tzset required")
            if 'TZ' in os.environ:
                orig_tz = os.environ['TZ']
            else:
                orig_tz = None
            os.environ['TZ'] = tz
            tzset()

            # now run the function, resetting the tz on exceptions
            try:
                return func(*args, **kwds)
            finally:
                if orig_tz is None:
                    del os.environ['TZ']
                else:
                    os.environ['TZ'] = orig_tz
                time.tzset()

        inner.__name__ = func.__name__
        inner.__doc__ = func.__doc__
        return inner
    return decorator

#=======================================================================
# Big-memory-test support. Separate from 'resources' because memory use should be configurable.

# Some handy shorthands. Note that these are used for byte-limits as well
# as size-limits, in the various bigmem tests
_1M = 1024*1024
_1G = 1024 * _1M
_2G = 2 * _1G
_4G = 4 * _1G

MAX_Py_ssize_t = sys.maxsize

def set_memlimit(limit):
    global max_memuse
    global real_max_memuse
    sizes = {
        'k': 1024,
        'm': _1M,
        'g': _1G,
        't': 1024*_1G,
    }
    m = re.match(r'(\d+(\.\d+)?) (K|M|G|T)b?$', limit,
                 re.IGNORECASE | re.VERBOSE)
    if m is None:
        raise ValueError('Invalid memory limit %r' % (limit,))
    memlimit = int(float(m.group(1)) * sizes[m.group(3).lower()])
    real_max_memuse = memlimit
    if memlimit > MAX_Py_ssize_t:
        memlimit = MAX_Py_ssize_t
    if memlimit < _2G - 1:
        raise ValueError('Memory limit %r too low to be useful' % (limit,))
    max_memuse = memlimit

def bigmemtest(minsize, memuse, overhead=5*_1M):
    """Decorator for bigmem tests.

    'minsize' is the minimum useful size for the test (in arbitrary,
    test-interpreted units.) 'memuse' is the number of 'bytes per size' for
    the test, or a good estimate of it. 'overhead' specifies fixed overhead,
    independent of the testsize, and defaults to 5Mb.

    The decorator tries to guess a good value for 'size' and passes it to
    the decorated test function. If minsize * memuse is more than the
    allowed memory use (as defined by max_memuse), the test is skipped.
    Otherwise, minsize is adjusted upward to use up to max_memuse.
    """
    def decorator(f):
        def wrapper(self):
            if not max_memuse:
                # If max_memuse is 0 (the default),
                # we still want to run the tests with size set to a few kb,
                # to make sure they work. We still want to avoid using
                # too much memory, though, but we do that noisily.
                maxsize = 5147
                self.assertFalse(maxsize * memuse + overhead > 20 * _1M)
            else:
                maxsize = int((max_memuse - overhead) / memuse)
                if maxsize < minsize:
                    # Really ought to print 'test skipped' or something
                    if verbose:
                        sys.stderr.write("Skipping %s because of memory "
                                         "constraint\n" % (f.__name__,))
                    return
                # Try to keep some breathing room in memory use
                maxsize = max(maxsize - 50 * _1M, minsize)
            return f(self, maxsize)
        wrapper.minsize = minsize
        wrapper.memuse = memuse
        wrapper.overhead = overhead
        return wrapper
    return decorator

def precisionbigmemtest(size, memuse, overhead=5*_1M, dry_run=True):
    def decorator(f):
        def wrapper(self):
            if not real_max_memuse:
                maxsize = 5147
            else:
                maxsize = size

            if ((real_max_memuse or not dry_run)
                and real_max_memuse < maxsize * memuse):
                if verbose:
                    sys.stderr.write("Skipping %s because of memory "
                                     "constraint\n" % (f.__name__,))
                return

            return f(self, maxsize)
        wrapper.size = size
        wrapper.memuse = memuse
        wrapper.overhead = overhead
        return wrapper
    return decorator

def bigaddrspacetest(f):
    """Decorator for tests that fill the address space."""
    def wrapper(self):
        if max_memuse < MAX_Py_ssize_t:
            if verbose:
                sys.stderr.write("Skipping %s because of memory "
                                 "constraint\n" % (f.__name__,))
        else:
            return f(self)
    return wrapper

#=======================================================================
# unittest integration.

class BasicTestRunner:
    def run(self, test):
        result = unittest.TestResult()
        test(result)
        return result

def _id(obj):
    return obj

def requires_resource(resource):
    if resource == 'gui' and not _is_gui_available():
        return unittest.skip(_is_gui_available.reason)
    if is_resource_enabled(resource):
        return _id
    else:
        return unittest.skip("resource {0!r} is not enabled".format(resource))

def cpython_only(test):
    """
    Decorator for tests only applicable on CPython.
    """
    return impl_detail(cpython=True)(test)

def impl_detail(msg=None, **guards):
    if check_impl_detail(**guards):
        return _id
    if msg is None:
        guardnames, default = _parse_guards(guards)
        if default:
            msg = "implementation detail not available on {0}"
        else:
            msg = "implementation detail specific to {0}"
        guardnames = sorted(guardnames.keys())
        msg = msg.format(' or '.join(guardnames))
    return unittest.skip(msg)

def _parse_guards(guards):
    # Returns a tuple ({platform_name: run_me}, default_value)
    if not guards:
        return ({'cpython': True}, False)
    is_true = guards.values()[0]
    assert guards.values() == [is_true] * len(guards)   # all True or all False
    return (guards, not is_true)

# Use the following check to guard CPython's implementation-specific tests --
# or to run them only on the implementation(s) guarded by the arguments.
def check_impl_detail(**guards):
    """This function returns True or False depending on the host platform.
       Examples:
          if check_impl_detail():               # only on CPython (default)
          if check_impl_detail(jython=True):    # only on Jython
          if check_impl_detail(cpython=False):  # everywhere except on CPython
    """
    guards, default = _parse_guards(guards)
    return guards.get(platform.python_implementation().lower(), default)



def _run_suite(suite):
    """Run tests from a unittest.TestSuite-derived class."""
    if verbose:
        runner = unittest.TextTestRunner(sys.stdout, verbosity=2)
    else:
        runner = BasicTestRunner()

    result = runner.run(suite)
    if not result.wasSuccessful():
        if len(result.errors) == 1 and not result.failures:
            err = result.errors[0][1]
        elif len(result.failures) == 1 and not result.errors:
            err = result.failures[0][1]
        else:
            err = "multiple errors occurred"
            if not verbose:
                err += "; run in verbose mode for details"
        raise TestFailed(err)


def run_unittest(*classes):
    """Run tests from unittest.TestCase-derived classes."""
    valid_types = (unittest.TestSuite, unittest.TestCase)
    suite = unittest.TestSuite()
    for cls in classes:
        if isinstance(cls, str):
            if cls in sys.modules:
                suite.addTest(unittest.findTestCases(sys.modules[cls]))
            else:
                raise ValueError("str arguments must be keys in sys.modules")
        elif isinstance(cls, valid_types):
            suite.addTest(cls)
        else:
            suite.addTest(unittest.makeSuite(cls))
    _run_suite(suite)

#=======================================================================
# Check for the presence of docstrings.

HAVE_DOCSTRINGS = (check_impl_detail(cpython=False) or
                   sys.platform == 'win32' or
                   sysconfig.get_config_var('WITH_DOC_STRINGS'))

requires_docstrings = unittest.skipUnless(HAVE_DOCSTRINGS,
                                          "test requires docstrings")


#=======================================================================
# doctest driver.

def run_doctest(module, verbosity=None):
    """Run doctest on the given module.  Return (#failures, #tests).

    If optional argument verbosity is not specified (or is None), pass
    test_support's belief about verbosity on to doctest.  Else doctest's
    usual behavior is used (it searches sys.argv for -v).
    """

    import doctest

    if verbosity is None:
        verbosity = verbose
    else:
        verbosity = None

    # Direct doctest output (normally just errors) to real stdout; doctest
    # output shouldn't be compared by regrtest.
    save_stdout = sys.stdout
    sys.stdout = get_original_stdout()
    try:
        f, t = doctest.testmod(module, verbose=verbosity)
        if f:
            raise TestFailed("%d of %d doctests failed" % (f, t))
    finally:
        sys.stdout = save_stdout
    if verbose:
        print 'doctest (%s) ... %d tests with zero failures' % (module.__name__, t)
    return f, t

#=======================================================================
# Threading support to prevent reporting refleaks when running regrtest.py -R

# NOTE: we use thread._count() rather than threading.enumerate() (or the
# moral equivalent thereof) because a threading.Thread object is still alive
# until its __bootstrap() method has returned, even after it has been
# unregistered from the threading module.
# thread._count(), on the other hand, only gets decremented *after* the
# __bootstrap() method has returned, which gives us reliable reference counts
# at the end of a test run.

def threading_setup():
    if thread:
        return thread._count(),
    else:
        return 1,

def threading_cleanup(nb_threads):
    if not thread:
        return

    _MAX_COUNT = 10
    for count in range(_MAX_COUNT):
        n = thread._count()
        if n == nb_threads:
            break
        time.sleep(0.1)
    # XXX print a warning in case of failure?

def reap_threads(func):
    """Use this function when threads are being used.  This will
    ensure that the threads are cleaned up even when the test fails.
    If threading is unavailable this function does nothing.
    """
    if not thread:
        return func

    @functools.wraps(func)
    def decorator(*args):
        key = threading_setup()
        try:
            return func(*args)
        finally:
            threading_cleanup(*key)
    return decorator

def reap_children():
    """Use this function at the end of test_main() whenever sub-processes
    are started.  This will help ensure that no extra children (zombies)
    stick around to hog resources and create problems when looking
    for refleaks.
    """

    # Reap all our dead child processes so we don't leave zombies around.
    # These hog resources and might be causing some of the buildbots to die.
    if hasattr(os, 'waitpid'):
        any_process = -1
        while True:
            try:
                # This will raise an exception on Windows.  That's ok.
                pid, status = os.waitpid(any_process, os.WNOHANG)
                if pid == 0:
                    break
            except:
                break

@contextlib.contextmanager
def start_threads(threads, unlock=None):
    threads = list(threads)
    started = []
    try:
        try:
            for t in threads:
                t.start()
                started.append(t)
        except:
            if verbose:
                print("Can't start %d threads, only %d threads started" %
                      (len(threads), len(started)))
            raise
        yield
    finally:
        if unlock:
            unlock()
        endtime = starttime = time.time()
        for timeout in range(1, 16):
            endtime += 60
            for t in started:
                t.join(max(endtime - time.time(), 0.01))
            started = [t for t in started if t.isAlive()]
            if not started:
                break
            if verbose:
                print('Unable to join %d threads during a period of '
                      '%d minutes' % (len(started), timeout))
    started = [t for t in started if t.isAlive()]
    if started:
        raise AssertionError('Unable to join %d threads' % len(started))

@contextlib.contextmanager
def swap_attr(obj, attr, new_val):
    """Temporary swap out an attribute with a new object.

    Usage:
        with swap_attr(obj, "attr", 5):
            ...

        This will set obj.attr to 5 for the duration of the with: block,
        restoring the old value at the end of the block. If `attr` doesn't
        exist on `obj`, it will be created and then deleted at the end of the
        block.
    """
    if hasattr(obj, attr):
        real_val = getattr(obj, attr)
        setattr(obj, attr, new_val)
        try:
            yield
        finally:
            setattr(obj, attr, real_val)
    else:
        setattr(obj, attr, new_val)
        try:
            yield
        finally:
            delattr(obj, attr)

def py3k_bytes(b):
    """Emulate the py3k bytes() constructor.

    NOTE: This is only a best effort function.
    """
    try:
        # memoryview?
        return b.tobytes()
    except AttributeError:
        try:
            # iterable of ints?
            return b"".join(chr(x) for x in b)
        except TypeError:
            return bytes(b)

def args_from_interpreter_flags():
    """Return a list of command-line arguments reproducing the current
    settings in sys.flags."""
    import subprocess
    return subprocess._args_from_interpreter_flags()

def strip_python_stderr(stderr):
    """Strip the stderr of a Python process from potential debug output
    emitted by the interpreter.

    This will typically be run on the result of the communicate() method
    of a subprocess.Popen object.
    """
    stderr = re.sub(br"\[\d+ refs\]\r?\n?$", b"", stderr).strip()
    return stderr


def check_free_after_iterating(test, iter, cls, args=()):
    class A(cls):
        def __del__(self):
            done[0] = True
            try:
                next(it)
            except StopIteration:
                pass

    done = [False]
    it = iter(A(*args))
    # Issue 26494: Shouldn't crash
    test.assertRaises(StopIteration, next, it)
    # The sequence should be deallocated just after the end of iterating
    gc_collect()
    test.assertTrue(done[0])

filename:/usr/lib/python2.7/__future__.py
__doc__
"""Record of phased-in incompatible language changes.

filename:/usr/lib/python2.7/toaiff.py
__doc__
"""Convert "arbitrary" sound files to AIFF (Apple and SGI's audio format).

Input may be compressed.
Uncompressed file type may be AIFF, WAV, VOC, 8SVX, NeXT/Sun, and others.
An exception is raised if the file is not of a recognized type.
Returned filename is either the input filename or a temporary filename;
in the latter case the caller must ensure that it is removed.
Other temporary files used are removed by the function.
"""

filename:/usr/lib/python2.7/rfc822.py
__doc__
"""RFC 2822 message manipulation.

Note: This is only a very rough sketch of a full RFC-822 parser; in particular
the tokenizing of addresses does not adhere to all the quoting rules.

Note: RFC 2822 is a long awaited update to RFC 822.  This module should
conform to RFC 2822, and is thus mis-named (it's not worth renaming it).  Some
effort at RFC 2822 updates have been made, but a thorough audit has not been
performed.  Consider any RFC 2822 non-conformance to be a bug.

    RFC 2822: http://www.faqs.org/rfcs/rfc2822.html
    RFC 822 : http://www.faqs.org/rfcs/rfc822.html (obsolete)

Directions for use:

To create a Message object: first open a file, e.g.:

  fp = open(file, 'r')

You can use any other legal way of getting an open file object, e.g. use
sys.stdin or call os.popen().  Then pass the open file object to the Message()
constructor:

  m = Message(fp)

This class can work with any input object that supports a readline method.  If
the input object has seek and tell capability, the rewindbody method will
work; also illegal lines will be pushed back onto the input stream.  If the
input object lacks seek but has an `unread' method that can push back a line
of input, Message will use that to push back illegal lines.  Thus this class
can be used to parse messages coming from a buffered stream.

The optional `seekable' argument is provided as a workaround for certain stdio
libraries in which tell() discards buffered data before discovering that the
lseek() system call doesn't work.  For maximum portability, you should set the
seekable argument to zero to prevent that initial \code{tell} when passing in
an unseekable object such as a file object created from a socket object.  If
it is 1 on entry -- which it is by default -- the tell() method of the open
file object is called once; if this raises an exception, seekable is reset to
0.  For other nonzero values of seekable, this test is not made.

To get the text of a particular header there are several methods:

  str = m.getheader(name)
  str = m.getrawheader(name)

where name is the name of the header, e.g. 'Subject'.  The difference is that
getheader() strips the leading and trailing whitespace, while getrawheader()
doesn't.  Both functions retain embedded whitespace (including newlines)
exactly as they are specified in the header, and leave the case of the text
unchanged.

For addresses and address lists there are functions

  realname, mailaddress = m.getaddr(name)
  list = m.getaddrlist(name)

where the latter returns a list of (realname, mailaddr) tuples.

There is also a method

  time = m.getdate(name)

which parses a Date-like field and returns a time-compatible tuple,
i.e. a tuple such as returned by time.localtime() or accepted by
time.mktime().

See the class definition for lower level access methods.

There are also some utility functions here.
"""

filename:/usr/lib/python2.7/token.py
__doc__
"""Token constants (from "token.h")."""

#  This file is automatically generated; please don't muck it up!
#
#  To update the symbols in this file, 'cd' to the top directory of
#  the python source tree after building the interpreter and run:
#
#    ./python Lib/token.py

#--start constants--
ENDMARKER = 0
NAME = 1
NUMBER = 2
STRING = 3
NEWLINE = 4
INDENT = 5
DEDENT = 6
LPAR = 7
RPAR = 8
LSQB = 9
RSQB = 10
COLON = 11
COMMA = 12
SEMI = 13
PLUS = 14
MINUS = 15
STAR = 16
SLASH = 17
VBAR = 18
AMPER = 19
LESS = 20
GREATER = 21
EQUAL = 22
DOT = 23
PERCENT = 24
BACKQUOTE = 25
LBRACE = 26
RBRACE = 27
EQEQUAL = 28
NOTEQUAL = 29
LESSEQUAL = 30
GREATEREQUAL = 31
TILDE = 32
CIRCUMFLEX = 33
LEFTSHIFT = 34
RIGHTSHIFT = 35
DOUBLESTAR = 36
PLUSEQUAL = 37
MINEQUAL = 38
STAREQUAL = 39
SLASHEQUAL = 40
PERCENTEQUAL = 41
AMPEREQUAL = 42
VBAREQUAL = 43
CIRCUMFLEXEQUAL = 44
LEFTSHIFTEQUAL = 45
RIGHTSHIFTEQUAL = 46
DOUBLESTAREQUAL = 47
DOUBLESLASH = 48
DOUBLESLASHEQUAL = 49
AT = 50
OP = 51
ERRORTOKEN = 52
N_TOKENS = 53
NT_OFFSET = 256
#--end constants--

tok_name = {}
for _name, _value in globals().items():
    if type(_value) is type(0):
        tok_name[_value] = _name
del _name, _value


def ISTERMINAL(x):
    return x < NT_OFFSET

def ISNONTERMINAL(x):
    return x >= NT_OFFSET

def ISEOF(x):
    return x == ENDMARKER


def main():
    import re
    import sys
    args = sys.argv[1:]
    inFileName = args and args[0] or "Include/token.h"
    outFileName = "Lib/token.py"
    if len(args) > 1:
        outFileName = args[1]
    try:
        fp = open(inFileName)
    except IOError, err:
        sys.stdout.write("I/O error: %s\n" % str(err))
        sys.exit(1)
    lines = fp.read().split("\n")
    fp.close()
    prog = re.compile(
        "#define[ \t][ \t]*([A-Z0-9][A-Z0-9_]*)[ \t][ \t]*([0-9][0-9]*)",
        re.IGNORECASE)
    tokens = {}
    for line in lines:
        match = prog.match(line)
        if match:
            name, val = match.group(1, 2)
            val = int(val)
            tokens[val] = name          # reverse so we can sort them...
    keys = tokens.keys()
    keys.sort()
    # load the output skeleton from the target:
    try:
        fp = open(outFileName)
    except IOError, err:
        sys.stderr.write("I/O error: %s\n" % str(err))
        sys.exit(2)
    format = fp.read().split("\n")
    fp.close()
    try:
        start = format.index("#--start constants--") + 1
        end = format.index("#--end constants--")
    except ValueError:
        sys.stderr.write("target does not contain format markers")
        sys.exit(3)
    lines = []
    for val in keys:
        lines.append("%s = %d" % (tokens[val], val))
    format[start:end] = lines
    try:
        fp = open(outFileName, 'w')
    except IOError, err:
        sys.stderr.write("I/O error: %s\n" % str(err))
        sys.exit(4)
    fp.write("\n".join(format))
    fp.close()


if __name__ == "__main__":
    main()

filename:/usr/lib/python2.7/gzip.py
__doc__
"""Functions that read and write gzipped files.

filename:/usr/lib/python2.7/nturl2path.py
__doc__
"""Convert a NT pathname to a file URL and vice versa."""

def url2pathname(url):
    """OS-specific conversion from a relative URL of the 'file' scheme
    to a file system path; not recommended for general use."""
    # e.g.
    #   ///C|/foo/bar/spam.foo
    # and
    #   ///C:/foo/bar/spam.foo
    # become
    #   C:\foo\bar\spam.foo
    import string, urllib
    # Windows itself uses ":" even in URLs.
    url = url.replace(':', '|')
    if not '|' in url:
        # No drive specifier, just convert slashes
        if url[:4] == '////':
            # path is something like ////host/path/on/remote/host
            # convert this to \\host\path\on\remote\host
            # (notice halving of slashes at the start of the path)
            url = url[2:]
        components = url.split('/')
        # make sure not to convert quoted slashes :-)
        return urllib.unquote('\\'.join(components))
    comp = url.split('|')
    if len(comp) != 2 or comp[0][-1] not in string.ascii_letters:
        error = 'Bad URL: ' + url
        raise IOError, error
    drive = comp[0][-1].upper()
    path = drive + ':'
    components = comp[1].split('/')
    for comp in components:
        if comp:
            path = path + '\\' + urllib.unquote(comp)
    # Issue #11474: url like '/C|/' should convert into 'C:\\'
    if path.endswith(':') and url.endswith('/'):
        path += '\\'
    return path

def pathname2url(p):
    """OS-specific conversion from a file system path to a relative URL
    of the 'file' scheme; not recommended for general use."""
    # e.g.
    #   C:\foo\bar\spam.foo
    # becomes
    #   ///C:/foo/bar/spam.foo
    import urllib
    if not ':' in p:
        # No drive specifier, just convert slashes and quote the name
        if p[:2] == '\\\\':
        # path is something like \\host\path\on\remote\host
        # convert this to ////host/path/on/remote/host
        # (notice doubling of slashes at the start of the path)
            p = '\\\\' + p
        components = p.split('\\')
        return urllib.quote('/'.join(components))
    comp = p.split(':')
    if len(comp) != 2 or len(comp[0]) > 1:
        error = 'Bad path: ' + p
        raise IOError, error

    drive = urllib.quote(comp[0].upper())
    components = comp[1].split('\\')
    path = '///' + drive + ':'
    for comp in components:
        if comp:
            path = path + '/' + urllib.quote(comp)
    return path

filename:/usr/lib/python2.7/ihooks.py
__doc__
"""Import hook support.

filename:/usr/lib/python2.7/_threading_local.py
__doc__
"""Thread-local objects.

(Note that this module provides a Python version of the threading.local
 class.  Depending on the version of Python you're using, there may be a
 faster one available.  You should always import the `local` class from
 `threading`.)

Thread-local objects support the management of thread-local data.
If you have data that you want to be local to a thread, simply create
a thread-local object and use its attributes:

  >>> mydata = local()
  >>> mydata.number = 42
  >>> mydata.number
  42

You can also access the local-object's dictionary:

  >>> mydata.__dict__
  {'number': 42}
  >>> mydata.__dict__.setdefault('widgets', [])
  []
  >>> mydata.widgets
  []

What's important about thread-local objects is that their data are
local to a thread. If we access the data in a different thread:

  >>> log = []
  >>> def f():
  ...     items = mydata.__dict__.items()
  ...     items.sort()
  ...     log.append(items)
  ...     mydata.number = 11
  ...     log.append(mydata.number)

  >>> import threading
  >>> thread = threading.Thread(target=f)
  >>> thread.start()
  >>> thread.join()
  >>> log
  [[], 11]

we get different data.  Furthermore, changes made in the other thread
don't affect data seen in this thread:

  >>> mydata.number
  42

Of course, values you get from a local object, including a __dict__
attribute, are for whatever thread was current at the time the
attribute was read.  For that reason, you generally don't want to save
these values across threads, as they apply only to the thread they
came from.

You can create custom local objects by subclassing the local class:

  >>> class MyLocal(local):
  ...     number = 2
  ...     initialized = False
  ...     def __init__(self, **kw):
  ...         if self.initialized:
  ...             raise SystemError('__init__ called too many times')
  ...         self.initialized = True
  ...         self.__dict__.update(kw)
  ...     def squared(self):
  ...         return self.number ** 2

This can be useful to support default values, methods and
initialization.  Note that if you define an __init__ method, it will be
called each time the local object is used in a separate thread.  This
is necessary to initialize each thread's dictionary.

Now if we create a local object:

  >>> mydata = MyLocal(color='red')

Now we have a default number:

  >>> mydata.number
  2

an initial color:

  >>> mydata.color
  'red'
  >>> del mydata.color

And a method that operates on the data:

  >>> mydata.squared()
  4

As before, we can access the data in a separate thread:

  >>> log = []
  >>> thread = threading.Thread(target=f)
  >>> thread.start()
  >>> thread.join()
  >>> log
  [[('color', 'red'), ('initialized', True)], 11]

without affecting this thread's data:

  >>> mydata.number
  2
  >>> mydata.color
  Traceback (most recent call last):
  ...
  AttributeError: 'MyLocal' object has no attribute 'color'

Note that subclasses can define slots, but they are not thread
local. They are shared across threads:

  >>> class MyLocal(local):
  ...     __slots__ = 'number'

  >>> mydata = MyLocal()
  >>> mydata.number = 42
  >>> mydata.color = 'red'

So, the separate thread:

  >>> thread = threading.Thread(target=f)
  >>> thread.start()
  >>> thread.join()

affects what we see:

  >>> mydata.number
  11

>>> del mydata
"""

filename:/usr/lib/python2.7/unittest/__init__.py
__doc__
"""
Python unit testing framework, based on Erich Gamma's JUnit and Kent Beck's
Smalltalk testing framework.

This module contains the core framework classes that form the basis of
specific test cases and suites (TestCase, TestSuite etc.), and also a
text-based utility class for running the tests and reporting the results
 (TextTestRunner).

Simple usage:

    import unittest

    class IntegerArithmeticTestCase(unittest.TestCase):
        def testAdd(self):  ## test method names begin 'test*'
            self.assertEqual((1 + 2), 3)
            self.assertEqual(0 + 1, 1)
        def testMultiply(self):
            self.assertEqual((0 * 10), 0)
            self.assertEqual((5 * 8), 40)

    if __name__ == '__main__':
        unittest.main()

Further information is available in the bundled documentation, and from

  http://docs.python.org/library/unittest.html

Copyright (c) 1999-2003 Steve Purcell
Copyright (c) 2003-2010 Python Software Foundation
This module is free software, and you may redistribute it and/or modify
it under the same terms as Python itself, so long as this copyright message
and disclaimer are retained in their original form.

IN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF
THIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

THE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS,
AND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,
SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
"""

filename:/usr/lib/python2.7/unittest/util.py
__doc__
"""Various utility functions."""
from collections import namedtuple, OrderedDict


__unittest = True

_MAX_LENGTH = 80
def safe_repr(obj, short=False):
    try:
        result = repr(obj)
    except Exception:
        result = object.__repr__(obj)
    if not short or len(result) < _MAX_LENGTH:
        return result
    return result[:_MAX_LENGTH] + ' [truncated]...'


def strclass(cls):
    return "%s.%s" % (cls.__module__, cls.__name__)

def sorted_list_difference(expected, actual):
    """Finds elements in only one or the other of two, sorted input lists.

    Returns a two-element tuple of lists.    The first list contains those
    elements in the "expected" list but not in the "actual" list, and the
    second contains those elements in the "actual" list but not in the
    "expected" list.    Duplicate elements in either input list are ignored.
    """
    i = j = 0
    missing = []
    unexpected = []
    while True:
        try:
            e = expected[i]
            a = actual[j]
            if e < a:
                missing.append(e)
                i += 1
                while expected[i] == e:
                    i += 1
            elif e > a:
                unexpected.append(a)
                j += 1
                while actual[j] == a:
                    j += 1
            else:
                i += 1
                try:
                    while expected[i] == e:
                        i += 1
                finally:
                    j += 1
                    while actual[j] == a:
                        j += 1
        except IndexError:
            missing.extend(expected[i:])
            unexpected.extend(actual[j:])
            break
    return missing, unexpected


def unorderable_list_difference(expected, actual, ignore_duplicate=False):
    """Same behavior as sorted_list_difference but
    for lists of unorderable items (like dicts).

    As it does a linear search per item (remove) it
    has O(n*n) performance.
    """
    missing = []
    unexpected = []
    while expected:
        item = expected.pop()
        try:
            actual.remove(item)
        except ValueError:
            missing.append(item)
        if ignore_duplicate:
            for lst in expected, actual:
                try:
                    while True:
                        lst.remove(item)
                except ValueError:
                    pass
    if ignore_duplicate:
        while actual:
            item = actual.pop()
            unexpected.append(item)
            try:
                while True:
                    actual.remove(item)
            except ValueError:
                pass
        return missing, unexpected

    # anything left in actual is unexpected
    return missing, actual

_Mismatch = namedtuple('Mismatch', 'actual expected value')

def _count_diff_all_purpose(actual, expected):
    'Returns list of (cnt_act, cnt_exp, elem) triples where the counts differ'
    # elements need not be hashable
    s, t = list(actual), list(expected)
    m, n = len(s), len(t)
    NULL = object()
    result = []
    for i, elem in enumerate(s):
        if elem is NULL:
            continue
        cnt_s = cnt_t = 0
        for j in range(i, m):
            if s[j] == elem:
                cnt_s += 1
                s[j] = NULL
        for j, other_elem in enumerate(t):
            if other_elem == elem:
                cnt_t += 1
                t[j] = NULL
        if cnt_s != cnt_t:
            diff = _Mismatch(cnt_s, cnt_t, elem)
            result.append(diff)

    for i, elem in enumerate(t):
        if elem is NULL:
            continue
        cnt_t = 0
        for j in range(i, n):
            if t[j] == elem:
                cnt_t += 1
                t[j] = NULL
        diff = _Mismatch(0, cnt_t, elem)
        result.append(diff)
    return result

def _ordered_count(iterable):
    'Return dict of element counts, in the order they were first seen'
    c = OrderedDict()
    for elem in iterable:
        c[elem] = c.get(elem, 0) + 1
    return c

def _count_diff_hashable(actual, expected):
    'Returns list of (cnt_act, cnt_exp, elem) triples where the counts differ'
    # elements must be hashable
    s, t = _ordered_count(actual), _ordered_count(expected)
    result = []
    for elem, cnt_s in s.items():
        cnt_t = t.get(elem, 0)
        if cnt_s != cnt_t:
            diff = _Mismatch(cnt_s, cnt_t, elem)
            result.append(diff)
    for elem, cnt_t in t.items():
        if elem not in s:
            diff = _Mismatch(0, cnt_t, elem)
            result.append(diff)
    return result

filename:/usr/lib/python2.7/unittest/runner.py
__doc__
"""Running tests"""

filename:/usr/lib/python2.7/unittest/case.py
__doc__
"""Test case implementation"""

import collections
import sys
import functools
import difflib
import pprint
import re
import types
import warnings

from . import result
from .util import (
    strclass, safe_repr, unorderable_list_difference,
    _count_diff_all_purpose, _count_diff_hashable
)


__unittest = True


DIFF_OMITTED = ('\nDiff is %s characters long. '
                 'Set self.maxDiff to None to see it.')

class SkipTest(Exception):
    """
    Raise this exception in a test to skip it.

    Usually you can use TestCase.skipTest() or one of the skipping decorators
    instead of raising this directly.
    """
    pass

class _ExpectedFailure(Exception):
    """
    Raise this when a test is expected to fail.

    This is an implementation detail.
    """

    def __init__(self, exc_info):
        super(_ExpectedFailure, self).__init__()
        self.exc_info = exc_info

class _UnexpectedSuccess(Exception):
    """
    The test was supposed to fail, but it didn't!
    """
    pass

def _id(obj):
    return obj

def skip(reason):
    """
    Unconditionally skip a test.
    """
    def decorator(test_item):
        if not isinstance(test_item, (type, types.ClassType)):
            @functools.wraps(test_item)
            def skip_wrapper(*args, **kwargs):
                raise SkipTest(reason)
            test_item = skip_wrapper

        test_item.__unittest_skip__ = True
        test_item.__unittest_skip_why__ = reason
        return test_item
    return decorator

def skipIf(condition, reason):
    """
    Skip a test if the condition is true.
    """
    if condition:
        return skip(reason)
    return _id

def skipUnless(condition, reason):
    """
    Skip a test unless the condition is true.
    """
    if not condition:
        return skip(reason)
    return _id


def expectedFailure(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        try:
            func(*args, **kwargs)
        except Exception:
            raise _ExpectedFailure(sys.exc_info())
        raise _UnexpectedSuccess
    return wrapper


class _AssertRaisesContext(object):
    """A context manager used to implement TestCase.assertRaises* methods."""

    def __init__(self, expected, test_case, expected_regexp=None):
        self.expected = expected
        self.failureException = test_case.failureException
        self.expected_regexp = expected_regexp

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, tb):
        if exc_type is None:
            try:
                exc_name = self.expected.__name__
            except AttributeError:
                exc_name = str(self.expected)
            raise self.failureException(
                "{0} not raised".format(exc_name))
        if not issubclass(exc_type, self.expected):
            # let unexpected exceptions pass through
            return False
        self.exception = exc_value # store for later retrieval
        if self.expected_regexp is None:
            return True

        expected_regexp = self.expected_regexp
        if not expected_regexp.search(str(exc_value)):
            raise self.failureException('"%s" does not match "%s"' %
                     (expected_regexp.pattern, str(exc_value)))
        return True


class TestCase(object):
    """A class whose instances are single test cases.

    By default, the test code itself should be placed in a method named
    'runTest'.

    If the fixture may be used for many test cases, create as
    many test methods as are needed. When instantiating such a TestCase
    subclass, specify in the constructor arguments the name of the test method
    that the instance is to execute.

    Test authors should subclass TestCase for their own tests. Construction
    and deconstruction of the test's environment ('fixture') can be
    implemented by overriding the 'setUp' and 'tearDown' methods respectively.

    If it is necessary to override the __init__ method, the base class
    __init__ method must always be called. It is important that subclasses
    should not change the signature of their __init__ method, since instances
    of the classes are instantiated automatically by parts of the framework
    in order to be run.

    When subclassing TestCase, you can set these attributes:
    * failureException: determines which exception will be raised when
        the instance's assertion methods fail; test methods raising this
        exception will be deemed to have 'failed' rather than 'errored'.
    * longMessage: determines whether long messages (including repr of
        objects used in assert methods) will be printed on failure in *addition*
        to any explicit message passed.
    * maxDiff: sets the maximum length of a diff in failure messages
        by assert methods using difflib. It is looked up as an instance
        attribute so can be configured by individual tests if required.
    """

    failureException = AssertionError

    longMessage = False

    maxDiff = 80*8

    # If a string is longer than _diffThreshold, use normal comparison instead
    # of difflib.  See #11763.
    _diffThreshold = 2**16

    # Attribute used by TestSuite for classSetUp

    _classSetupFailed = False

    def __init__(self, methodName='runTest'):
        """Create an instance of the class that will use the named test
           method when executed. Raises a ValueError if the instance does
           not have a method with the specified name.
        """
        self._testMethodName = methodName
        self._resultForDoCleanups = None
        try:
            testMethod = getattr(self, methodName)
        except AttributeError:
            raise ValueError("no such test method in %s: %s" %
                  (self.__class__, methodName))
        self._testMethodDoc = testMethod.__doc__
        self._cleanups = []

        # Map types to custom assertEqual functions that will compare
        # instances of said type in more detail to generate a more useful
        # error message.
        self._type_equality_funcs = {}
        self.addTypeEqualityFunc(dict, 'assertDictEqual')
        self.addTypeEqualityFunc(list, 'assertListEqual')
        self.addTypeEqualityFunc(tuple, 'assertTupleEqual')
        self.addTypeEqualityFunc(set, 'assertSetEqual')
        self.addTypeEqualityFunc(frozenset, 'assertSetEqual')
        try:
            self.addTypeEqualityFunc(unicode, 'assertMultiLineEqual')
        except NameError:
            # No unicode support in this build
            pass

    def addTypeEqualityFunc(self, typeobj, function):
        """Add a type specific assertEqual style function to compare a type.

        This method is for use by TestCase subclasses that need to register
        their own type equality functions to provide nicer error messages.

        Args:
            typeobj: The data type to call this function on when both values
                    are of the same type in assertEqual().
            function: The callable taking two arguments and an optional
                    msg= argument that raises self.failureException with a
                    useful error message when the two arguments are not equal.
        """
        self._type_equality_funcs[typeobj] = function

    def addCleanup(self, function, *args, **kwargs):
        """Add a function, with arguments, to be called when the test is
        completed. Functions added are called on a LIFO basis and are
        called after tearDown on test failure or success.

        Cleanup items are called even if setUp fails (unlike tearDown)."""
        self._cleanups.append((function, args, kwargs))

    def setUp(self):
        "Hook method for setting up the test fixture before exercising it."
        pass

    def tearDown(self):
        "Hook method for deconstructing the test fixture after testing it."
        pass

    @classmethod
    def setUpClass(cls):
        "Hook method for setting up class fixture before running tests in the class."

    @classmethod
    def tearDownClass(cls):
        "Hook method for deconstructing the class fixture after running all tests in the class."

    def countTestCases(self):
        return 1

    def defaultTestResult(self):
        return result.TestResult()

    def shortDescription(self):
        """Returns a one-line description of the test, or None if no
        description has been provided.

        The default implementation of this method returns the first line of
        the specified test method's docstring.
        """
        doc = self._testMethodDoc
        return doc and doc.split("\n")[0].strip() or None


    def id(self):
        return "%s.%s" % (strclass(self.__class__), self._testMethodName)

    def __eq__(self, other):
        if type(self) is not type(other):
            return NotImplemented

        return self._testMethodName == other._testMethodName

    def __ne__(self, other):
        return not self == other

    def __hash__(self):
        return hash((type(self), self._testMethodName))

    def __str__(self):
        return "%s (%s)" % (self._testMethodName, strclass(self.__class__))

    def __repr__(self):
        return "<%s testMethod=%s>" % \
               (strclass(self.__class__), self._testMethodName)

    def _addSkip(self, result, reason):
        addSkip = getattr(result, 'addSkip', None)
        if addSkip is not None:
            addSkip(self, reason)
        else:
            warnings.warn("TestResult has no addSkip method, skips not reported",
                          RuntimeWarning, 2)
            result.addSuccess(self)

    def run(self, result=None):
        orig_result = result
        if result is None:
            result = self.defaultTestResult()
            startTestRun = getattr(result, 'startTestRun', None)
            if startTestRun is not None:
                startTestRun()

        self._resultForDoCleanups = result
        result.startTest(self)

        testMethod = getattr(self, self._testMethodName)
        if (getattr(self.__class__, "__unittest_skip__", False) or
            getattr(testMethod, "__unittest_skip__", False)):
            # If the class or method was skipped.
            try:
                skip_why = (getattr(self.__class__, '__unittest_skip_why__', '')
                            or getattr(testMethod, '__unittest_skip_why__', ''))
                self._addSkip(result, skip_why)
            finally:
                result.stopTest(self)
            return
        try:
            success = False
            try:
                self.setUp()
            except SkipTest as e:
                self._addSkip(result, str(e))
            except KeyboardInterrupt:
                raise
            except:
                result.addError(self, sys.exc_info())
            else:
                try:
                    testMethod()
                except KeyboardInterrupt:
                    raise
                except self.failureException:
                    result.addFailure(self, sys.exc_info())
                except _ExpectedFailure as e:
                    addExpectedFailure = getattr(result, 'addExpectedFailure', None)
                    if addExpectedFailure is not None:
                        addExpectedFailure(self, e.exc_info)
                    else:
                        warnings.warn("TestResult has no addExpectedFailure method, reporting as passes",
                                      RuntimeWarning)
                        result.addSuccess(self)
                except _UnexpectedSuccess:
                    addUnexpectedSuccess = getattr(result, 'addUnexpectedSuccess', None)
                    if addUnexpectedSuccess is not None:
                        addUnexpectedSuccess(self)
                    else:
                        warnings.warn("TestResult has no addUnexpectedSuccess method, reporting as failures",
                                      RuntimeWarning)
                        result.addFailure(self, sys.exc_info())
                except SkipTest as e:
                    self._addSkip(result, str(e))
                except:
                    result.addError(self, sys.exc_info())
                else:
                    success = True

                try:
                    self.tearDown()
                except KeyboardInterrupt:
                    raise
                except:
                    result.addError(self, sys.exc_info())
                    success = False

            cleanUpSuccess = self.doCleanups()
            success = success and cleanUpSuccess
            if success:
                result.addSuccess(self)
        finally:
            result.stopTest(self)
            if orig_result is None:
                stopTestRun = getattr(result, 'stopTestRun', None)
                if stopTestRun is not None:
                    stopTestRun()

    def doCleanups(self):
        """Execute all cleanup functions. Normally called for you after
        tearDown."""
        result = self._resultForDoCleanups
        ok = True
        while self._cleanups:
            function, args, kwargs = self._cleanups.pop(-1)
            try:
                function(*args, **kwargs)
            except KeyboardInterrupt:
                raise
            except:
                ok = False
                result.addError(self, sys.exc_info())
        return ok

    def __call__(self, *args, **kwds):
        return self.run(*args, **kwds)

    def debug(self):
        """Run the test without collecting errors in a TestResult"""
        self.setUp()
        getattr(self, self._testMethodName)()
        self.tearDown()
        while self._cleanups:
            function, args, kwargs = self._cleanups.pop(-1)
            function(*args, **kwargs)

    def skipTest(self, reason):
        """Skip this test."""
        raise SkipTest(reason)

    def fail(self, msg=None):
        """Fail immediately, with the given message."""
        raise self.failureException(msg)

    def assertFalse(self, expr, msg=None):
        """Check that the expression is false."""
        if expr:
            msg = self._formatMessage(msg, "%s is not false" % safe_repr(expr))
            raise self.failureException(msg)

    def assertTrue(self, expr, msg=None):
        """Check that the expression is true."""
        if not expr:
            msg = self._formatMessage(msg, "%s is not true" % safe_repr(expr))
            raise self.failureException(msg)

    def _formatMessage(self, msg, standardMsg):
        """Honour the longMessage attribute when generating failure messages.
        If longMessage is False this means:
        * Use only an explicit message if it is provided
        * Otherwise use the standard message for the assert

        If longMessage is True:
        * Use the standard message
        * If an explicit message is provided, plus ' : ' and the explicit message
        """
        if not self.longMessage:
            return msg or standardMsg
        if msg is None:
            return standardMsg
        try:
            # don't switch to '{}' formatting in Python 2.X
            # it changes the way unicode input is handled
            return '%s : %s' % (standardMsg, msg)
        except UnicodeDecodeError:
            return  '%s : %s' % (safe_repr(standardMsg), safe_repr(msg))


    def assertRaises(self, excClass, callableObj=None, *args, **kwargs):
        """Fail unless an exception of class excClass is raised
           by callableObj when invoked with arguments args and keyword
           arguments kwargs. If a different type of exception is
           raised, it will not be caught, and the test case will be
           deemed to have suffered an error, exactly as for an
           unexpected exception.

           If called with callableObj omitted or None, will return a
           context object used like this::

                with self.assertRaises(SomeException):
                    do_something()

           The context manager keeps a reference to the exception as
           the 'exception' attribute. This allows you to inspect the
           exception after the assertion::

               with self.assertRaises(SomeException) as cm:
                   do_something()
               the_exception = cm.exception
               self.assertEqual(the_exception.error_code, 3)
        """
        context = _AssertRaisesContext(excClass, self)
        if callableObj is None:
            return context
        with context:
            callableObj(*args, **kwargs)

    def _getAssertEqualityFunc(self, first, second):
        """Get a detailed comparison function for the types of the two args.

        Returns: A callable accepting (first, second, msg=None) that will
        raise a failure exception if first != second with a useful human
        readable error message for those types.
        """
        #
        # NOTE(gregory.p.smith): I considered isinstance(first, type(second))
        # and vice versa.  I opted for the conservative approach in case
        # subclasses are not intended to be compared in detail to their super
        # class instances using a type equality func.  This means testing
        # subtypes won't automagically use the detailed comparison.  Callers
        # should use their type specific assertSpamEqual method to compare
        # subclasses if the detailed comparison is desired and appropriate.
        # See the discussion in http://bugs.python.org/issue2578.
        #
        if type(first) is type(second):
            asserter = self._type_equality_funcs.get(type(first))
            if asserter is not None:
                if isinstance(asserter, basestring):
                    asserter = getattr(self, asserter)
                return asserter

        return self._baseAssertEqual

    def _baseAssertEqual(self, first, second, msg=None):
        """The default assertEqual implementation, not type specific."""
        if not first == second:
            standardMsg = '%s != %s' % (safe_repr(first), safe_repr(second))
            msg = self._formatMessage(msg, standardMsg)
            raise self.failureException(msg)

    def assertEqual(self, first, second, msg=None):
        """Fail if the two objects are unequal as determined by the '=='
           operator.
        """
        assertion_func = self._getAssertEqualityFunc(first, second)
        assertion_func(first, second, msg=msg)

    def assertNotEqual(self, first, second, msg=None):
        """Fail if the two objects are equal as determined by the '!='
           operator.
        """
        if not first != second:
            msg = self._formatMessage(msg, '%s == %s' % (safe_repr(first),
                                                          safe_repr(second)))
            raise self.failureException(msg)


    def assertAlmostEqual(self, first, second, places=None, msg=None, delta=None):
        """Fail if the two objects are unequal as determined by their
           difference rounded to the given number of decimal places
           (default 7) and comparing to zero, or by comparing that the
           between the two objects is more than the given delta.

           Note that decimal places (from zero) are usually not the same
           as significant digits (measured from the most signficant digit).

           If the two objects compare equal then they will automatically
           compare almost equal.
        """
        if first == second:
            # shortcut
            return
        if delta is not None and places is not None:
            raise TypeError("specify delta or places not both")

        if delta is not None:
            if abs(first - second) <= delta:
                return

            standardMsg = '%s != %s within %s delta' % (safe_repr(first),
                                                        safe_repr(second),
                                                        safe_repr(delta))
        else:
            if places is None:
                places = 7

            if round(abs(second-first), places) == 0:
                return

            standardMsg = '%s != %s within %r places' % (safe_repr(first),
                                                          safe_repr(second),
                                                          places)
        msg = self._formatMessage(msg, standardMsg)
        raise self.failureException(msg)

    def assertNotAlmostEqual(self, first, second, places=None, msg=None, delta=None):
        """Fail if the two objects are equal as determined by their
           difference rounded to the given number of decimal places
           (default 7) and comparing to zero, or by comparing that the
           between the two objects is less than the given delta.

           Note that decimal places (from zero) are usually not the same
           as significant digits (measured from the most signficant digit).

           Objects that are equal automatically fail.
        """
        if delta is not None and places is not None:
            raise TypeError("specify delta or places not both")
        if delta is not None:
            if not (first == second) and abs(first - second) > delta:
                return
            standardMsg = '%s == %s within %s delta' % (safe_repr(first),
                                                        safe_repr(second),
                                                        safe_repr(delta))
        else:
            if places is None:
                places = 7
            if not (first == second) and round(abs(second-first), places) != 0:
                return
            standardMsg = '%s == %s within %r places' % (safe_repr(first),
                                                         safe_repr(second),
                                                         places)

        msg = self._formatMessage(msg, standardMsg)
        raise self.failureException(msg)

    # Synonyms for assertion methods

    # The plurals are undocumented.  Keep them that way to discourage use.
    # Do not add more.  Do not remove.
    # Going through a deprecation cycle on these would annoy many people.
    assertEquals = assertEqual
    assertNotEquals = assertNotEqual
    assertAlmostEquals = assertAlmostEqual
    assertNotAlmostEquals = assertNotAlmostEqual
    assert_ = assertTrue

    # These fail* assertion method names are pending deprecation and will
    # be a DeprecationWarning in 3.2; http://bugs.python.org/issue2578
    def _deprecate(original_func):
        def deprecated_func(*args, **kwargs):
            warnings.warn(
                'Please use {0} instead.'.format(original_func.__name__),
                PendingDeprecationWarning, 2)
            return original_func(*args, **kwargs)
        return deprecated_func

    failUnlessEqual = _deprecate(assertEqual)
    failIfEqual = _deprecate(assertNotEqual)
    failUnlessAlmostEqual = _deprecate(assertAlmostEqual)
    failIfAlmostEqual = _deprecate(assertNotAlmostEqual)
    failUnless = _deprecate(assertTrue)
    failUnlessRaises = _deprecate(assertRaises)
    failIf = _deprecate(assertFalse)

    def assertSequenceEqual(self, seq1, seq2, msg=None, seq_type=None):
        """An equality assertion for ordered sequences (like lists and tuples).

        For the purposes of this function, a valid ordered sequence type is one
        which can be indexed, has a length, and has an equality operator.

        Args:
            seq1: The first sequence to compare.
            seq2: The second sequence to compare.
            seq_type: The expected datatype of the sequences, or None if no
                    datatype should be enforced.
            msg: Optional message to use on failure instead of a list of
                    differences.
        """
        if seq_type is not None:
            seq_type_name = seq_type.__name__
            if not isinstance(seq1, seq_type):
                raise self.failureException('First sequence is not a %s: %s'
                                        % (seq_type_name, safe_repr(seq1)))
            if not isinstance(seq2, seq_type):
                raise self.failureException('Second sequence is not a %s: %s'
                                        % (seq_type_name, safe_repr(seq2)))
        else:
            seq_type_name = "sequence"

        differing = None
        try:
            len1 = len(seq1)
        except (TypeError, NotImplementedError):
            differing = 'First %s has no length.    Non-sequence?' % (
                    seq_type_name)

        if differing is None:
            try:
                len2 = len(seq2)
            except (TypeError, NotImplementedError):
                differing = 'Second %s has no length.    Non-sequence?' % (
                        seq_type_name)

        if differing is None:
            if seq1 == seq2:
                return

            seq1_repr = safe_repr(seq1)
            seq2_repr = safe_repr(seq2)
            if len(seq1_repr) > 30:
                seq1_repr = seq1_repr[:30] + '...'
            if len(seq2_repr) > 30:
                seq2_repr = seq2_repr[:30] + '...'
            elements = (seq_type_name.capitalize(), seq1_repr, seq2_repr)
            differing = '%ss differ: %s != %s\n' % elements

            for i in xrange(min(len1, len2)):
                try:
                    item1 = seq1[i]
                except (TypeError, IndexError, NotImplementedError):
                    differing += ('\nUnable to index element %d of first %s\n' %
                                 (i, seq_type_name))
                    break

                try:
                    item2 = seq2[i]
                except (TypeError, IndexError, NotImplementedError):
                    differing += ('\nUnable to index element %d of second %s\n' %
                                 (i, seq_type_name))
                    break

                if item1 != item2:
                    differing += ('\nFirst differing element %d:\n%s\n%s\n' %
                                 (i, safe_repr(item1), safe_repr(item2)))
                    break
            else:
                if (len1 == len2 and seq_type is None and
                    type(seq1) != type(seq2)):
                    # The sequences are the same, but have differing types.
                    return

            if len1 > len2:
                differing += ('\nFirst %s contains %d additional '
                             'elements.\n' % (seq_type_name, len1 - len2))
                try:
                    differing += ('First extra element %d:\n%s\n' %
                                  (len2, safe_repr(seq1[len2])))
                except (TypeError, IndexError, NotImplementedError):
                    differing += ('Unable to index element %d '
                                  'of first %s\n' % (len2, seq_type_name))
            elif len1 < len2:
                differing += ('\nSecond %s contains %d additional '
                             'elements.\n' % (seq_type_name, len2 - len1))
                try:
                    differing += ('First extra element %d:\n%s\n' %
                                  (len1, safe_repr(seq2[len1])))
                except (TypeError, IndexError, NotImplementedError):
                    differing += ('Unable to index element %d '
                                  'of second %s\n' % (len1, seq_type_name))
        standardMsg = differing
        diffMsg = '\n' + '\n'.join(
            difflib.ndiff(pprint.pformat(seq1).splitlines(),
                          pprint.pformat(seq2).splitlines()))
        standardMsg = self._truncateMessage(standardMsg, diffMsg)
        msg = self._formatMessage(msg, standardMsg)
        self.fail(msg)

    def _truncateMessage(self, message, diff):
        max_diff = self.maxDiff
        if max_diff is None or len(diff) <= max_diff:
            return message + diff
        return message + (DIFF_OMITTED % len(diff))

    def assertListEqual(self, list1, list2, msg=None):
        """A list-specific equality assertion.

        Args:
            list1: The first list to compare.
            list2: The second list to compare.
            msg: Optional message to use on failure instead of a list of
                    differences.

        """
        self.assertSequenceEqual(list1, list2, msg, seq_type=list)

    def assertTupleEqual(self, tuple1, tuple2, msg=None):
        """A tuple-specific equality assertion.

        Args:
            tuple1: The first tuple to compare.
            tuple2: The second tuple to compare.
            msg: Optional message to use on failure instead of a list of
                    differences.
        """
        self.assertSequenceEqual(tuple1, tuple2, msg, seq_type=tuple)

    def assertSetEqual(self, set1, set2, msg=None):
        """A set-specific equality assertion.

        Args:
            set1: The first set to compare.
            set2: The second set to compare.
            msg: Optional message to use on failure instead of a list of
                    differences.

        assertSetEqual uses ducktyping to support different types of sets, and
        is optimized for sets specifically (parameters must support a
        difference method).
        """
        try:
            difference1 = set1.difference(set2)
        except TypeError, e:
            self.fail('invalid type when attempting set difference: %s' % e)
        except AttributeError, e:
            self.fail('first argument does not support set difference: %s' % e)

        try:
            difference2 = set2.difference(set1)
        except TypeError, e:
            self.fail('invalid type when attempting set difference: %s' % e)
        except AttributeError, e:
            self.fail('second argument does not support set difference: %s' % e)

        if not (difference1 or difference2):
            return

        lines = []
        if difference1:
            lines.append('Items in the first set but not the second:')
            for item in difference1:
                lines.append(repr(item))
        if difference2:
            lines.append('Items in the second set but not the first:')
            for item in difference2:
                lines.append(repr(item))

        standardMsg = '\n'.join(lines)
        self.fail(self._formatMessage(msg, standardMsg))

    def assertIn(self, member, container, msg=None):
        """Just like self.assertTrue(a in b), but with a nicer default message."""
        if member not in container:
            standardMsg = '%s not found in %s' % (safe_repr(member),
                                                  safe_repr(container))
            self.fail(self._formatMessage(msg, standardMsg))

    def assertNotIn(self, member, container, msg=None):
        """Just like self.assertTrue(a not in b), but with a nicer default message."""
        if member in container:
            standardMsg = '%s unexpectedly found in %s' % (safe_repr(member),
                                                        safe_repr(container))
            self.fail(self._formatMessage(msg, standardMsg))

    def assertIs(self, expr1, expr2, msg=None):
        """Just like self.assertTrue(a is b), but with a nicer default message."""
        if expr1 is not expr2:
            standardMsg = '%s is not %s' % (safe_repr(expr1),
                                             safe_repr(expr2))
            self.fail(self._formatMessage(msg, standardMsg))

    def assertIsNot(self, expr1, expr2, msg=None):
        """Just like self.assertTrue(a is not b), but with a nicer default message."""
        if expr1 is expr2:
            standardMsg = 'unexpectedly identical: %s' % (safe_repr(expr1),)
            self.fail(self._formatMessage(msg, standardMsg))

    def assertDictEqual(self, d1, d2, msg=None):
        self.assertIsInstance(d1, dict, 'First argument is not a dictionary')
        self.assertIsInstance(d2, dict, 'Second argument is not a dictionary')

        if d1 != d2:
            standardMsg = '%s != %s' % (safe_repr(d1, True), safe_repr(d2, True))
            diff = ('\n' + '\n'.join(difflib.ndiff(
                           pprint.pformat(d1).splitlines(),
                           pprint.pformat(d2).splitlines())))
            standardMsg = self._truncateMessage(standardMsg, diff)
            self.fail(self._formatMessage(msg, standardMsg))

    def assertDictContainsSubset(self, expected, actual, msg=None):
        """Checks whether actual is a superset of expected."""
        missing = []
        mismatched = []
        for key, value in expected.iteritems():
            if key not in actual:
                missing.append(key)
            elif value != actual[key]:
                mismatched.append('%s, expected: %s, actual: %s' %
                                  (safe_repr(key), safe_repr(value),
                                   safe_repr(actual[key])))

        if not (missing or mismatched):
            return

        standardMsg = ''
        if missing:
            standardMsg = 'Missing: %s' % ','.join(safe_repr(m) for m in
                                                    missing)
        if mismatched:
            if standardMsg:
                standardMsg += '; '
            standardMsg += 'Mismatched values: %s' % ','.join(mismatched)

        self.fail(self._formatMessage(msg, standardMsg))

    def assertItemsEqual(self, expected_seq, actual_seq, msg=None):
        """An unordered sequence specific comparison. It asserts that
        actual_seq and expected_seq have the same element counts.
        Equivalent to::

            self.assertEqual(Counter(iter(actual_seq)),
                             Counter(iter(expected_seq)))

        Asserts that each element has the same count in both sequences.
        Example:
            - [0, 1, 1] and [1, 0, 1] compare equal.
            - [0, 0, 1] and [0, 1] compare unequal.
        """
        first_seq, second_seq = list(expected_seq), list(actual_seq)
        with warnings.catch_warnings():
            if sys.py3kwarning:
                # Silence Py3k warning raised during the sorting
                for _msg in ["(code|dict|type) inequality comparisons",
                             "builtin_function_or_method order comparisons",
                             "comparing unequal types"]:
                    warnings.filterwarnings("ignore", _msg, DeprecationWarning)
            try:
                first = collections.Counter(first_seq)
                second = collections.Counter(second_seq)
            except TypeError:
                # Handle case with unhashable elements
                differences = _count_diff_all_purpose(first_seq, second_seq)
            else:
                if first == second:
                    return
                differences = _count_diff_hashable(first_seq, second_seq)

        if differences:
            standardMsg = 'Element counts were not equal:\n'
            lines = ['First has %d, Second has %d:  %r' % diff for diff in differences]
            diffMsg = '\n'.join(lines)
            standardMsg = self._truncateMessage(standardMsg, diffMsg)
            msg = self._formatMessage(msg, standardMsg)
            self.fail(msg)

    def assertMultiLineEqual(self, first, second, msg=None):
        """Assert that two multi-line strings are equal."""
        self.assertIsInstance(first, basestring,
                'First argument is not a string')
        self.assertIsInstance(second, basestring,
                'Second argument is not a string')

        if first != second:
            # don't use difflib if the strings are too long
            if (len(first) > self._diffThreshold or
                len(second) > self._diffThreshold):
                self._baseAssertEqual(first, second, msg)
            firstlines = first.splitlines(True)
            secondlines = second.splitlines(True)
            if len(firstlines) == 1 and first.strip('\r\n') == first:
                firstlines = [first + '\n']
                secondlines = [second + '\n']
            standardMsg = '%s != %s' % (safe_repr(first, True),
                                        safe_repr(second, True))
            diff = '\n' + ''.join(difflib.ndiff(firstlines, secondlines))
            standardMsg = self._truncateMessage(standardMsg, diff)
            self.fail(self._formatMessage(msg, standardMsg))

    def assertLess(self, a, b, msg=None):
        """Just like self.assertTrue(a < b), but with a nicer default message."""
        if not a < b:
            standardMsg = '%s not less than %s' % (safe_repr(a), safe_repr(b))
            self.fail(self._formatMessage(msg, standardMsg))

    def assertLessEqual(self, a, b, msg=None):
        """Just like self.assertTrue(a <= b), but with a nicer default message."""
        if not a <= b:
            standardMsg = '%s not less than or equal to %s' % (safe_repr(a), safe_repr(b))
            self.fail(self._formatMessage(msg, standardMsg))

    def assertGreater(self, a, b, msg=None):
        """Just like self.assertTrue(a > b), but with a nicer default message."""
        if not a > b:
            standardMsg = '%s not greater than %s' % (safe_repr(a), safe_repr(b))
            self.fail(self._formatMessage(msg, standardMsg))

    def assertGreaterEqual(self, a, b, msg=None):
        """Just like self.assertTrue(a >= b), but with a nicer default message."""
        if not a >= b:
            standardMsg = '%s not greater than or equal to %s' % (safe_repr(a), safe_repr(b))
            self.fail(self._formatMessage(msg, standardMsg))

    def assertIsNone(self, obj, msg=None):
        """Same as self.assertTrue(obj is None), with a nicer default message."""
        if obj is not None:
            standardMsg = '%s is not None' % (safe_repr(obj),)
            self.fail(self._formatMessage(msg, standardMsg))

    def assertIsNotNone(self, obj, msg=None):
        """Included for symmetry with assertIsNone."""
        if obj is None:
            standardMsg = 'unexpectedly None'
            self.fail(self._formatMessage(msg, standardMsg))

    def assertIsInstance(self, obj, cls, msg=None):
        """Same as self.assertTrue(isinstance(obj, cls)), with a nicer
        default message."""
        if not isinstance(obj, cls):
            standardMsg = '%s is not an instance of %r' % (safe_repr(obj), cls)
            self.fail(self._formatMessage(msg, standardMsg))

    def assertNotIsInstance(self, obj, cls, msg=None):
        """Included for symmetry with assertIsInstance."""
        if isinstance(obj, cls):
            standardMsg = '%s is an instance of %r' % (safe_repr(obj), cls)
            self.fail(self._formatMessage(msg, standardMsg))

    def assertRaisesRegexp(self, expected_exception, expected_regexp,
                           callable_obj=None, *args, **kwargs):
        """Asserts that the message in a raised exception matches a regexp.

        Args:
            expected_exception: Exception class expected to be raised.
            expected_regexp: Regexp (re pattern object or string) expected
                    to be found in error message.
            callable_obj: Function to be called.
            args: Extra args.
            kwargs: Extra kwargs.
        """
        if expected_regexp is not None:
            expected_regexp = re.compile(expected_regexp)
        context = _AssertRaisesContext(expected_exception, self, expected_regexp)
        if callable_obj is None:
            return context
        with context:
            callable_obj(*args, **kwargs)

    def assertRegexpMatches(self, text, expected_regexp, msg=None):
        """Fail the test unless the text matches the regular expression."""
        if isinstance(expected_regexp, basestring):
            expected_regexp = re.compile(expected_regexp)
        if not expected_regexp.search(text):
            msg = msg or "Regexp didn't match"
            msg = '%s: %r not found in %r' % (msg, expected_regexp.pattern, text)
            raise self.failureException(msg)

    def assertNotRegexpMatches(self, text, unexpected_regexp, msg=None):
        """Fail the test if the text matches the regular expression."""
        if isinstance(unexpected_regexp, basestring):
            unexpected_regexp = re.compile(unexpected_regexp)
        match = unexpected_regexp.search(text)
        if match:
            msg = msg or "Regexp matched"
            msg = '%s: %r matches %r in %r' % (msg,
                                               text[match.start():match.end()],
                                               unexpected_regexp.pattern,
                                               text)
            raise self.failureException(msg)


class FunctionTestCase(TestCase):
    """A test case that wraps a test function.

    This is useful for slipping pre-existing test functions into the
    unittest framework. Optionally, set-up and tidy-up functions can be
    supplied. As with TestCase, the tidy-up ('tearDown') function will
    always be called if the set-up ('setUp') function ran successfully.
    """

    def __init__(self, testFunc, setUp=None, tearDown=None, description=None):
        super(FunctionTestCase, self).__init__()
        self._setUpFunc = setUp
        self._tearDownFunc = tearDown
        self._testFunc = testFunc
        self._description = description

    def setUp(self):
        if self._setUpFunc is not None:
            self._setUpFunc()

    def tearDown(self):
        if self._tearDownFunc is not None:
            self._tearDownFunc()

    def runTest(self):
        self._testFunc()

    def id(self):
        return self._testFunc.__name__

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return NotImplemented

        return self._setUpFunc == other._setUpFunc and \
               self._tearDownFunc == other._tearDownFunc and \
               self._testFunc == other._testFunc and \
               self._description == other._description

    def __ne__(self, other):
        return not self == other

    def __hash__(self):
        return hash((type(self), self._setUpFunc, self._tearDownFunc,
                     self._testFunc, self._description))

    def __str__(self):
        return "%s (%s)" % (strclass(self.__class__),
                            self._testFunc.__name__)

    def __repr__(self):
        return "<%s tec=%s>" % (strclass(self.__class__),
                                     self._testFunc)

    def shortDescription(self):
        if self._description is not None:
            return self._description
        doc = self._testFunc.__doc__
        return doc and doc.split("\n")[0].strip() or None

filename:/usr/lib/python2.7/unittest/loader.py
__doc__
"""Loading unittests."""

filename:/usr/lib/python2.7/unittest/suite.py
__doc__
"""TestSuite"""

import sys

from . import case
from . import util

__unittest = True


def _call_if_exists(parent, attr):
    func = getattr(parent, attr, lambda: None)
    func()


class BaseTestSuite(object):
    """A simple test suite that doesn't provide class or module shared fixtures.
    """
    def __init__(self, tests=()):
        self._tests = []
        self.addTests(tests)

    def __repr__(self):
        return "<%s tests=%s>" % (util.strclass(self.__class__), list(self))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return NotImplemented
        return list(self) == list(other)

    def __ne__(self, other):
        return not self == other

    # Can't guarantee hash invariant, so flag as unhashable
    __hash__ = None

    def __iter__(self):
        return iter(self._tests)

    def countTestCases(self):
        cases = 0
        for test in self:
            cases += test.countTestCases()
        return cases

    def addTest(self, test):
        # sanity checks
        if not hasattr(test, '__call__'):
            raise TypeError("{} is not callable".format(repr(test)))
        if isinstance(test, type) and issubclass(test,
                                                 (case.TestCase, TestSuite)):
            raise TypeError("TestCases and TestSuites must be instantiated "
                            "before passing them to addTest()")
        self._tests.append(test)

    def addTests(self, tests):
        if isinstance(tests, basestring):
            raise TypeError("tests must be an iterable of tests, not a string")
        for test in tests:
            self.addTest(test)

    def run(self, result):
        for test in self:
            if result.shouldStop:
                break
            test(result)
        return result

    def __call__(self, *args, **kwds):
        return self.run(*args, **kwds)

    def debug(self):
        """Run the tests without collecting errors in a TestResult"""
        for test in self:
            test.debug()


class TestSuite(BaseTestSuite):
    """A test suite is a composite test consisting of a number of TestCases.

    For use, create an instance of TestSuite, then add test case instances.
    When all tests have been added, the suite can be passed to a test
    runner, such as TextTestRunner. It will run the individual test cases
    in the order in which they were added, aggregating the results. When
    subclassing, do not forget to call the base class constructor.
    """

    def run(self, result, debug=False):
        topLevel = False
        if getattr(result, '_testRunEntered', False) is False:
            result._testRunEntered = topLevel = True

        for test in self:
            if result.shouldStop:
                break

            if _isnotsuite(test):
                self._tearDownPreviousClass(test, result)
                self._handleModuleFixture(test, result)
                self._handleClassSetUp(test, result)
                result._previousTestClass = test.__class__

                if (getattr(test.__class__, '_classSetupFailed', False) or
                    getattr(result, '_moduleSetUpFailed', False)):
                    continue

            if not debug:
                test(result)
            else:
                test.debug()

        if topLevel:
            self._tearDownPreviousClass(None, result)
            self._handleModuleTearDown(result)
            result._testRunEntered = False
        return result

    def debug(self):
        """Run the tests without collecting errors in a TestResult"""
        debug = _DebugResult()
        self.run(debug, True)

    ################################

    def _handleClassSetUp(self, test, result):
        previousClass = getattr(result, '_previousTestClass', None)
        currentClass = test.__class__
        if currentClass == previousClass:
            return
        if result._moduleSetUpFailed:
            return
        if getattr(currentClass, "__unittest_skip__", False):
            return

        try:
            currentClass._classSetupFailed = False
        except TypeError:
            # test may actually be a function
            # so its class will be a builtin-type
            pass

        setUpClass = getattr(currentClass, 'setUpClass', None)
        if setUpClass is not None:
            _call_if_exists(result, '_setupStdout')
            try:
                setUpClass()
            except Exception as e:
                if isinstance(result, _DebugResult):
                    raise
                currentClass._classSetupFailed = True
                className = util.strclass(currentClass)
                errorName = 'setUpClass (%s)' % className
                self._addClassOrModuleLevelException(result, e, errorName)
            finally:
                _call_if_exists(result, '_restoreStdout')

    def _get_previous_module(self, result):
        previousModule = None
        previousClass = getattr(result, '_previousTestClass', None)
        if previousClass is not None:
            previousModule = previousClass.__module__
        return previousModule


    def _handleModuleFixture(self, test, result):
        previousModule = self._get_previous_module(result)
        currentModule = test.__class__.__module__
        if currentModule == previousModule:
            return

        self._handleModuleTearDown(result)

        result._moduleSetUpFailed = False
        try:
            module = sys.modules[currentModule]
        except KeyError:
            return
        setUpModule = getattr(module, 'setUpModule', None)
        if setUpModule is not None:
            _call_if_exists(result, '_setupStdout')
            try:
                setUpModule()
            except Exception, e:
                if isinstance(result, _DebugResult):
                    raise
                result._moduleSetUpFailed = True
                errorName = 'setUpModule (%s)' % currentModule
                self._addClassOrModuleLevelException(result, e, errorName)
            finally:
                _call_if_exists(result, '_restoreStdout')

    def _addClassOrModuleLevelException(self, result, exception, errorName):
        error = _ErrorHolder(errorName)
        addSkip = getattr(result, 'addSkip', None)
        if addSkip is not None and isinstance(exception, case.SkipTest):
            addSkip(error, str(exception))
        else:
            result.addError(error, sys.exc_info())

    def _handleModuleTearDown(self, result):
        previousModule = self._get_previous_module(result)
        if previousModule is None:
            return
        if result._moduleSetUpFailed:
            return

        try:
            module = sys.modules[previousModule]
        except KeyError:
            return

        tearDownModule = getattr(module, 'tearDownModule', None)
        if tearDownModule is not None:
            _call_if_exists(result, '_setupStdout')
            try:
                tearDownModule()
            except Exception as e:
                if isinstance(result, _DebugResult):
                    raise
                errorName = 'tearDownModule (%s)' % previousModule
                self._addClassOrModuleLevelException(result, e, errorName)
            finally:
                _call_if_exists(result, '_restoreStdout')

    def _tearDownPreviousClass(self, test, result):
        previousClass = getattr(result, '_previousTestClass', None)
        currentClass = test.__class__
        if currentClass == previousClass:
            return
        if getattr(previousClass, '_classSetupFailed', False):
            return
        if getattr(result, '_moduleSetUpFailed', False):
            return
        if getattr(previousClass, "__unittest_skip__", False):
            return

        tearDownClass = getattr(previousClass, 'tearDownClass', None)
        if tearDownClass is not None:
            _call_if_exists(result, '_setupStdout')
            try:
                tearDownClass()
            except Exception, e:
                if isinstance(result, _DebugResult):
                    raise
                className = util.strclass(previousClass)
                errorName = 'tearDownClass (%s)' % className
                self._addClassOrModuleLevelException(result, e, errorName)
            finally:
                _call_if_exists(result, '_restoreStdout')


class _ErrorHolder(object):
    """
    Placeholder for a TestCase inside a result. As far as a TestResult
    is concerned, this looks exactly like a unit test. Used to insert
    arbitrary errors into a test suite run.
    """
    # Inspired by the ErrorHolder from Twisted:
    # http://twistedmatrix.com/trac/browser/trunk/twisted/trial/runner.py

    # attribute used by TestResult._exc_info_to_string
    failureException = None

    def __init__(self, description):
        self.description = description

    def id(self):
        return self.description

    def shortDescription(self):
        return None

    def __repr__(self):
        return "<ErrorHolder description=%r>" % (self.description,)

    def __str__(self):
        return self.id()

    def run(self, result):
        # could call result.addError(...) - but this test-like object
        # shouldn't be run anyway
        pass

    def __call__(self, result):
        return self.run(result)

    def countTestCases(self):
        return 0

def _isnotsuite(test):
    "A crude way to tell apart testcases and suites with duck-typing"
    try:
        iter(test)
    except TypeError:
        return True
    return False


class _DebugResult(object):
    "Used by the TestSuite to hold previous class when running in debug."
    _previousTestClass = None
    _moduleSetUpFailed = False
    shouldStop = False

filename:/usr/lib/python2.7/unittest/signals.py
__doc__
import signal
import weakref

from functools import wraps

__unittest = True


class _InterruptHandler(object):
    def __init__(self, default_handler):
        self.called = False
        self.original_handler = default_handler
        if isinstance(default_handler, int):
            if default_handler == signal.SIG_DFL:
                # Pretend it's signal.default_int_handler instead.
                default_handler = signal.default_int_handler
            elif default_handler == signal.SIG_IGN:
                # Not quite the same thing as SIG_IGN, but the closest we
                # can make it: do nothing.
                def default_handler(unused_signum, unused_frame):
                    pass
            else:
                raise TypeError("expected SIGINT signal handler to be "
                                "signal.SIG_IGN, signal.SIG_DFL, or a "
                                "callable object")
        self.default_handler = default_handler

    def __call__(self, signum, frame):
        installed_handler = signal.getsignal(signal.SIGINT)
        if installed_handler is not self:
            # if we aren't the installed handler, then delegate immediately
            # to the default handler
            self.default_handler(signum, frame)

        if self.called:
            self.default_handler(signum, frame)
        self.called = True
        for result in _results.keys():
            result.stop()

_results = weakref.WeakKeyDictionary()
def registerResult(result):
    _results[result] = 1

def removeResult(result):
    return bool(_results.pop(result, None))

_interrupt_handler = None
def installHandler():
    global _interrupt_handler
    if _interrupt_handler is None:
        default_handler = signal.getsignal(signal.SIGINT)
        _interrupt_handler = _InterruptHandler(default_handler)
        signal.signal(signal.SIGINT, _interrupt_handler)


def removeHandler(method=None):
    if method is not None:
        @wraps(method)
        def inner(*args, **kwargs):
            initial = signal.getsignal(signal.SIGINT)
            removeHandler()
            try:
                return method(*args, **kwargs)
            finally:
                signal.signal(signal.SIGINT, initial)
        return inner

    global _interrupt_handler
    if _interrupt_handler is not None:
        signal.signal(signal.SIGINT, _interrupt_handler.original_handler)

filename:/usr/lib/python2.7/unittest/__main__.py
__doc__
"""Main entry point"""

filename:/usr/lib/python2.7/unittest/result.py
__doc__
"""Test result object"""

import os
import sys
import traceback

from StringIO import StringIO

from . import util
from functools import wraps

__unittest = True

def failfast(method):
    @wraps(method)
    def inner(self, *args, **kw):
        if getattr(self, 'failfast', False):
            self.stop()
        return method(self, *args, **kw)
    return inner

STDOUT_LINE = '\nStdout:\n%s'
STDERR_LINE = '\nStderr:\n%s'


class TestResult(object):
    """Holder for test result information.

    Test results are automatically managed by the TestCase and TestSuite
    classes, and do not need to be explicitly manipulated by writers of tests.

    Each instance holds the total number of tests run, and collections of
    failures and errors that occurred among those test runs. The collections
    contain tuples of (testcase, exceptioninfo), where exceptioninfo is the
    formatted traceback of the error that occurred.
    """
    _previousTestClass = None
    _testRunEntered = False
    _moduleSetUpFailed = False
    def __init__(self, stream=None, descriptions=None, verbosity=None):
        self.failfast = False
        self.failures = []
        self.errors = []
        self.testsRun = 0
        self.skipped = []
        self.expectedFailures = []
        self.unexpectedSuccesses = []
        self.shouldStop = False
        self.buffer = False
        self._stdout_buffer = None
        self._stderr_buffer = None
        self._original_stdout = sys.stdout
        self._original_stderr = sys.stderr
        self._mirrorOutput = False

    def printErrors(self):
        "Called by TestRunner after test run"

    def startTest(self, test):
        "Called when the given test is about to be run"
        self.testsRun += 1
        self._mirrorOutput = False
        self._setupStdout()

    def _setupStdout(self):
        if self.buffer:
            if self._stderr_buffer is None:
                self._stderr_buffer = StringIO()
                self._stdout_buffer = StringIO()
            sys.stdout = self._stdout_buffer
            sys.stderr = self._stderr_buffer

    def startTestRun(self):
        """Called once before any tests are executed.

        See startTest for a method called before each test.
        """

    def stopTest(self, test):
        """Called when the given test has been run"""
        self._restoreStdout()
        self._mirrorOutput = False

    def _restoreStdout(self):
        if self.buffer:
            if self._mirrorOutput:
                output = sys.stdout.getvalue()
                error = sys.stderr.getvalue()
                if output:
                    if not output.endswith('\n'):
                        output += '\n'
                    self._original_stdout.write(STDOUT_LINE % output)
                if error:
                    if not error.endswith('\n'):
                        error += '\n'
                    self._original_stderr.write(STDERR_LINE % error)

            sys.stdout = self._original_stdout
            sys.stderr = self._original_stderr
            self._stdout_buffer.seek(0)
            self._stdout_buffer.truncate()
            self._stderr_buffer.seek(0)
            self._stderr_buffer.truncate()

    def stopTestRun(self):
        """Called once after all tests are executed.

        See stopTest for a method called after each test.
        """

    @failfast
    def addError(self, test, err):
        """Called when an error has occurred. 'err' is a tuple of values as
        returned by sys.exc_info().
        """
        self.errors.append((test, self._exc_info_to_string(err, test)))
        self._mirrorOutput = True

    @failfast
    def addFailure(self, test, err):
        """Called when an error has occurred. 'err' is a tuple of values as
        returned by sys.exc_info()."""
        self.failures.append((test, self._exc_info_to_string(err, test)))
        self._mirrorOutput = True

    def addSuccess(self, test):
        "Called when a test has completed successfully"
        pass

    def addSkip(self, test, reason):
        """Called when a test is skipped."""
        self.skipped.append((test, reason))

    def addExpectedFailure(self, test, err):
        """Called when an expected failure/error occurred."""
        self.expectedFailures.append(
            (test, self._exc_info_to_string(err, test)))

    @failfast
    def addUnexpectedSuccess(self, test):
        """Called when a test was expected to fail, but succeed."""
        self.unexpectedSuccesses.append(test)

    def wasSuccessful(self):
        "Tells whether or not this result was a success"
        return len(self.failures) == len(self.errors) == 0

    def stop(self):
        "Indicates that the tests should be aborted"
        self.shouldStop = True

    def _exc_info_to_string(self, err, test):
        """Converts a sys.exc_info()-style tuple of values into a string."""
        exctype, value, tb = err
        # Skip test runner traceback levels
        while tb and self._is_relevant_tb_level(tb):
            tb = tb.tb_next

        if exctype is test.failureException:
            # Skip assert*() traceback levels
            length = self._count_relevant_tb_levels(tb)
            msgLines = traceback.format_exception(exctype, value, tb, length)
        else:
            msgLines = traceback.format_exception(exctype, value, tb)

        if self.buffer:
            output = sys.stdout.getvalue()
            error = sys.stderr.getvalue()
            if output:
                if not output.endswith('\n'):
                    output += '\n'
                msgLines.append(STDOUT_LINE % output)
            if error:
                if not error.endswith('\n'):
                    error += '\n'
                msgLines.append(STDERR_LINE % error)
        return ''.join(msgLines)


    def _is_relevant_tb_level(self, tb):
        return '__unittest' in tb.tb_frame.f_globals

    def _count_relevant_tb_levels(self, tb):
        length = 0
        while tb and not self._is_relevant_tb_level(tb):
            length += 1
            tb = tb.tb_next
        return length

    def __repr__(self):
        return ("<%s run=%i errors=%i failures=%i>" %
               (util.strclass(self.__class__), self.testsRun, len(self.errors),
                len(self.failures)))

filename:/usr/lib/python2.7/unittest/main.py
__doc__
"""Unittest main program"""

filename:/usr/lib/python2.7/xdrlib.py
__doc__
"""Implements (a subset of) Sun XDR -- eXternal Data Representation.

See: RFC 1014

"""

filename:/usr/lib/python2.7/repr.py
__doc__
"""Redo the builtin repr() (representation) but with limits on most sizes."""

__all__ = ["Repr","repr"]

import __builtin__
from itertools import islice

class Repr:

    def __init__(self):
        self.maxlevel = 6
        self.maxtuple = 6
        self.maxlist = 6
        self.maxarray = 5
        self.maxdict = 4
        self.maxset = 6
        self.maxfrozenset = 6
        self.maxdeque = 6
        self.maxstring = 30
        self.maxlong = 40
        self.maxother = 20

    def repr(self, x):
        return self.repr1(x, self.maxlevel)

    def repr1(self, x, level):
        typename = type(x).__name__
        if ' ' in typename:
            parts = typename.split()
            typename = '_'.join(parts)
        if hasattr(self, 'repr_' + typename):
            return getattr(self, 'repr_' + typename)(x, level)
        else:
            s = __builtin__.repr(x)
            if len(s) > self.maxother:
                i = max(0, (self.maxother-3)//2)
                j = max(0, self.maxother-3-i)
                s = s[:i] + '...' + s[len(s)-j:]
            return s

    def _repr_iterable(self, x, level, left, right, maxiter, trail=''):
        n = len(x)
        if level <= 0 and n:
            s = '...'
        else:
            newlevel = level - 1
            repr1 = self.repr1
            pieces = [repr1(elem, newlevel) for elem in islice(x, maxiter)]
            if n > maxiter:  pieces.append('...')
            s = ', '.join(pieces)
            if n == 1 and trail:  right = trail + right
        return '%s%s%s' % (left, s, right)

    def repr_tuple(self, x, level):
        return self._repr_iterable(x, level, '(', ')', self.maxtuple, ',')

    def repr_list(self, x, level):
        return self._repr_iterable(x, level, '[', ']', self.maxlist)

    def repr_array(self, x, level):
        header = "array('%s', [" % x.typecode
        return self._repr_iterable(x, level, header, '])', self.maxarray)

    def repr_set(self, x, level):
        x = _possibly_sorted(x)
        return self._repr_iterable(x, level, 'set([', '])', self.maxset)

    def repr_frozenset(self, x, level):
        x = _possibly_sorted(x)
        return self._repr_iterable(x, level, 'frozenset([', '])',
                                   self.maxfrozenset)

    def repr_deque(self, x, level):
        return self._repr_iterable(x, level, 'deque([', '])', self.maxdeque)

    def repr_dict(self, x, level):
        n = len(x)
        if n == 0: return '{}'
        if level <= 0: return '{...}'
        newlevel = level - 1
        repr1 = self.repr1
        pieces = []
        for key in islice(_possibly_sorted(x), self.maxdict):
            keyrepr = repr1(key, newlevel)
            valrepr = repr1(x[key], newlevel)
            pieces.append('%s: %s' % (keyrepr, valrepr))
        if n > self.maxdict: pieces.append('...')
        s = ', '.join(pieces)
        return '{%s}' % (s,)

    def repr_str(self, x, level):
        s = __builtin__.repr(x[:self.maxstring])
        if len(s) > self.maxstring:
            i = max(0, (self.maxstring-3)//2)
            j = max(0, self.maxstring-3-i)
            s = __builtin__.repr(x[:i] + x[len(x)-j:])
            s = s[:i] + '...' + s[len(s)-j:]
        return s

    def repr_long(self, x, level):
        s = __builtin__.repr(x) # XXX Hope this isn't too slow...
        if len(s) > self.maxlong:
            i = max(0, (self.maxlong-3)//2)
            j = max(0, self.maxlong-3-i)
            s = s[:i] + '...' + s[len(s)-j:]
        return s

    def repr_instance(self, x, level):
        try:
            s = __builtin__.repr(x)
            # Bugs in x.__repr__() can cause arbitrary
            # exceptions -- then make up something
        except Exception:
            return '<%s instance at %x>' % (x.__class__.__name__, id(x))
        if len(s) > self.maxstring:
            i = max(0, (self.maxstring-3)//2)
            j = max(0, self.maxstring-3-i)
            s = s[:i] + '...' + s[len(s)-j:]
        return s


def _possibly_sorted(x):
    # Since not all sequences of items can be sorted and comparison
    # functions may raise arbitrary exceptions, return an unsorted
    # sequence in that case.
    try:
        return sorted(x)
    except Exception:
        return list(x)

aRepr = Repr()
repr = aRepr.repr

filename:/usr/lib/python2.7/multifile.py
__doc__
"""A readline()-style interface to the parts of a multipart message.

filename:/usr/lib/python2.7/htmllib.py
__doc__
"""HTML 2.0 parser.

See the HTML 2.0 specification:
http://www.w3.org/hypertext/WWW/MarkUp/html-spec/html-spec_toc.html
"""

filename:/usr/lib/python2.7/atexit.py
__doc__
"""
atexit.py - allow programmer to define multiple exit functions to be executed
upon normal program termination.

One public function, register, is defined.
"""

filename:/usr/lib/python2.7/pstats.py
__doc__
"""Class for printing reports on profiled python code."""

# Written by James Roskind
# Based on prior profile module by Sjoerd Mullender...
#   which was hacked somewhat by: Guido van Rossum

# Copyright Disney Enterprises, Inc.  All Rights Reserved.
# Licensed to PSF under a Contributor Agreement
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied.  See the License for the specific language
# governing permissions and limitations under the License.


import sys
import os
import time
import marshal
import re
from functools import cmp_to_key

__all__ = ["Stats"]

class Stats:
    """This class is used for creating reports from data generated by the
    Profile class.  It is a "friend" of that class, and imports data either
    by direct access to members of Profile class, or by reading in a dictionary
    that was emitted (via marshal) from the Profile class.

    The big change from the previous Profiler (in terms of raw functionality)
    is that an "add()" method has been provided to combine Stats from
    several distinct profile runs.  Both the constructor and the add()
    method now take arbitrarily many file names as arguments.

    All the print methods now take an argument that indicates how many lines
    to print.  If the arg is a floating point number between 0 and 1.0, then
    it is taken as a decimal percentage of the available lines to be printed
    (e.g., .1 means print 10% of all available lines).  If it is an integer,
    it is taken to mean the number of lines of data that you wish to have
    printed.

    The sort_stats() method now processes some additional options (i.e., in
    addition to the old -1, 0, 1, or 2).  It takes an arbitrary number of
    quoted strings to select the sort order.  For example sort_stats('time',
    'name') sorts on the major key of 'internal function time', and on the
    minor key of 'the name of the function'.  Look at the two tables in
    sort_stats() and get_sort_arg_defs(self) for more examples.

    All methods return self, so you can string together commands like:
        Stats('foo', 'goo').strip_dirs().sort_stats('calls').\
                            print_stats(5).print_callers(5)
    """

    def __init__(self, *args, **kwds):
        # I can't figure out how to explicitly specify a stream keyword arg
        # with *args:
        #   def __init__(self, *args, stream=sys.stdout): ...
        # so I use **kwds and sqauwk if something unexpected is passed in.
        self.stream = sys.stdout
        if "stream" in kwds:
            self.stream = kwds["stream"]
            del kwds["stream"]
        if kwds:
            keys = kwds.keys()
            keys.sort()
            extras = ", ".join(["%s=%s" % (k, kwds[k]) for k in keys])
            raise ValueError, "unrecognized keyword args: %s" % extras
        if not len(args):
            arg = None
        else:
            arg = args[0]
            args = args[1:]
        self.init(arg)
        self.add(*args)

    def init(self, arg):
        self.all_callees = None  # calc only if needed
        self.files = []
        self.fcn_list = None
        self.total_tt = 0
        self.total_calls = 0
        self.prim_calls = 0
        self.max_name_len = 0
        self.top_level = {}
        self.stats = {}
        self.sort_arg_dict = {}
        self.load_stats(arg)
        trouble = 1
        try:
            self.get_top_level_stats()
            trouble = 0
        finally:
            if trouble:
                print >> self.stream, "Invalid timing data",
                if self.files: print >> self.stream, self.files[-1],
                print >> self.stream

    def load_stats(self, arg):
        if not arg:  self.stats = {}
        elif isinstance(arg, basestring):
            f = open(arg, 'rb')
            self.stats = marshal.load(f)
            f.close()
            try:
                file_stats = os.stat(arg)
                arg = time.ctime(file_stats.st_mtime) + "    " + arg
            except:  # in case this is not unix
                pass
            self.files = [ arg ]
        elif hasattr(arg, 'create_stats'):
            arg.create_stats()
            self.stats = arg.stats
            arg.stats = {}
        if not self.stats:
            raise TypeError("Cannot create or construct a %r object from %r"
                            % (self.__class__, arg))
        return

    def get_top_level_stats(self):
        for func, (cc, nc, tt, ct, callers) in self.stats.items():
            self.total_calls += nc
            self.prim_calls  += cc
            self.total_tt    += tt
            if ("jprofile", 0, "profiler") in callers:
                self.top_level[func] = None
            if len(func_std_string(func)) > self.max_name_len:
                self.max_name_len = len(func_std_string(func))

    def add(self, *arg_list):
        if not arg_list: return self
        if len(arg_list) > 1: self.add(*arg_list[1:])
        other = arg_list[0]
        if type(self) != type(other) or self.__class__ != other.__class__:
            other = Stats(other)
        self.files += other.files
        self.total_calls += other.total_calls
        self.prim_calls += other.prim_calls
        self.total_tt += other.total_tt
        for func in other.top_level:
            self.top_level[func] = None

        if self.max_name_len < other.max_name_len:
            self.max_name_len = other.max_name_len

        self.fcn_list = None

        for func, stat in other.stats.iteritems():
            if func in self.stats:
                old_func_stat = self.stats[func]
            else:
                old_func_stat = (0, 0, 0, 0, {},)
            self.stats[func] = add_func_stats(old_func_stat, stat)
        return self

    def dump_stats(self, filename):
        """Write the profile data to a file we know how to load back."""
        f = file(filename, 'wb')
        try:
            marshal.dump(self.stats, f)
        finally:
            f.close()

    # list the tuple indices and directions for sorting,
    # along with some printable description
    sort_arg_dict_default = {
              "calls"     : (((1,-1),              ), "call count"),
              "ncalls"    : (((1,-1),              ), "call count"),
              "cumtime"   : (((3,-1),              ), "cumulative time"),
              "cumulative": (((3,-1),              ), "cumulative time"),
              "file"      : (((4, 1),              ), "file name"),
              "filename"  : (((4, 1),              ), "file name"),
              "line"      : (((5, 1),              ), "line number"),
              "module"    : (((4, 1),              ), "file name"),
              "name"      : (((6, 1),              ), "function name"),
              "nfl"       : (((6, 1),(4, 1),(5, 1),), "name/file/line"),
              "pcalls"    : (((0,-1),              ), "primitive call count"),
              "stdname"   : (((7, 1),              ), "standard name"),
              "time"      : (((2,-1),              ), "internal time"),
              "tottime"   : (((2,-1),              ), "internal time"),
              }

    def get_sort_arg_defs(self):
        """Expand all abbreviations that are unique."""
        if not self.sort_arg_dict:
            self.sort_arg_dict = dict = {}
            bad_list = {}
            for word, tup in self.sort_arg_dict_default.iteritems():
                fragment = word
                while fragment:
                    if not fragment:
                        break
                    if fragment in dict:
                        bad_list[fragment] = 0
                        break
                    dict[fragment] = tup
                    fragment = fragment[:-1]
            for word in bad_list:
                del dict[word]
        return self.sort_arg_dict

    def sort_stats(self, *field):
        if not field:
            self.fcn_list = 0
            return self
        if len(field) == 1 and isinstance(field[0], (int, long)):
            # Be compatible with old profiler
            field = [ {-1: "stdname",
                       0:  "calls",
                       1:  "time",
                       2:  "cumulative"}[field[0]] ]

        sort_arg_defs = self.get_sort_arg_defs()
        sort_tuple = ()
        self.sort_type = ""
        connector = ""
        for word in field:
            sort_tuple = sort_tuple + sort_arg_defs[word][0]
            self.sort_type += connector + sort_arg_defs[word][1]
            connector = ", "

        stats_list = []
        for func, (cc, nc, tt, ct, callers) in self.stats.iteritems():
            stats_list.append((cc, nc, tt, ct) + func +
                              (func_std_string(func), func))

        stats_list.sort(key=cmp_to_key(TupleComp(sort_tuple).compare))

        self.fcn_list = fcn_list = []
        for tuple in stats_list:
            fcn_list.append(tuple[-1])
        return self

    def reverse_order(self):
        if self.fcn_list:
            self.fcn_list.reverse()
        return self

    def strip_dirs(self):
        oldstats = self.stats
        self.stats = newstats = {}
        max_name_len = 0
        for func, (cc, nc, tt, ct, callers) in oldstats.iteritems():
            newfunc = func_strip_path(func)
            if len(func_std_string(newfunc)) > max_name_len:
                max_name_len = len(func_std_string(newfunc))
            newcallers = {}
            for func2, caller in callers.iteritems():
                newcallers[func_strip_path(func2)] = caller

            if newfunc in newstats:
                newstats[newfunc] = add_func_stats(
                                        newstats[newfunc],
                                        (cc, nc, tt, ct, newcallers))
            else:
                newstats[newfunc] = (cc, nc, tt, ct, newcallers)
        old_top = self.top_level
        self.top_level = new_top = {}
        for func in old_top:
            new_top[func_strip_path(func)] = None

        self.max_name_len = max_name_len

        self.fcn_list = None
        self.all_callees = None
        return self

    def calc_callees(self):
        if self.all_callees: return
        self.all_callees = all_callees = {}
        for func, (cc, nc, tt, ct, callers) in self.stats.iteritems():
            if not func in all_callees:
                all_callees[func] = {}
            for func2, caller in callers.iteritems():
                if not func2 in all_callees:
                    all_callees[func2] = {}
                all_callees[func2][func]  = caller
        return

    #******************************************************************
    # The following functions support actual printing of reports
    #******************************************************************

    # Optional "amount" is either a line count, or a percentage of lines.

    def eval_print_amount(self, sel, list, msg):
        new_list = list
        if isinstance(sel, basestring):
            try:
                rex = re.compile(sel)
            except re.error:
                msg += "   <Invalid regular expression %r>\n" % sel
                return new_list, msg
            new_list = []
            for func in list:
                if rex.search(func_std_string(func)):
                    new_list.append(func)
        else:
            count = len(list)
            if isinstance(sel, float) and 0.0 <= sel < 1.0:
                count = int(count * sel + .5)
                new_list = list[:count]
            elif isinstance(sel, (int, long)) and 0 <= sel < count:
                count = sel
                new_list = list[:count]
        if len(list) != len(new_list):
            msg += "   List reduced from %r to %r due to restriction <%r>\n" % (
                len(list), len(new_list), sel)

        return new_list, msg

    def get_print_list(self, sel_list):
        width = self.max_name_len
        if self.fcn_list:
            stat_list = self.fcn_list[:]
            msg = "   Ordered by: " + self.sort_type + '\n'
        else:
            stat_list = self.stats.keys()
            msg = "   Random listing order was used\n"

        for selection in sel_list:
            stat_list, msg = self.eval_print_amount(selection, stat_list, msg)

        count = len(stat_list)

        if not stat_list:
            return 0, stat_list
        print >> self.stream, msg
        if count < len(self.stats):
            width = 0
            for func in stat_list:
                if  len(func_std_string(func)) > width:
                    width = len(func_std_string(func))
        return width+2, stat_list

    def print_stats(self, *amount):
        for filename in self.files:
            print >> self.stream, filename
        if self.files: print >> self.stream
        indent = ' ' * 8
        for func in self.top_level:
            print >> self.stream, indent, func_get_function_name(func)

        print >> self.stream, indent, self.total_calls, "function calls",
        if self.total_calls != self.prim_calls:
            print >> self.stream, "(%d primitive calls)" % self.prim_calls,
        print >> self.stream, "in %.3f seconds" % self.total_tt
        print >> self.stream
        width, list = self.get_print_list(amount)
        if list:
            self.print_title()
            for func in list:
                self.print_line(func)
            print >> self.stream
            print >> self.stream
        return self

    def print_callees(self, *amount):
        width, list = self.get_print_list(amount)
        if list:
            self.calc_callees()

            self.print_call_heading(width, "called...")
            for func in list:
                if func in self.all_callees:
                    self.print_call_line(width, func, self.all_callees[func])
                else:
                    self.print_call_line(width, func, {})
            print >> self.stream
            print >> self.stream
        return self

    def print_callers(self, *amount):
        width, list = self.get_print_list(amount)
        if list:
            self.print_call_heading(width, "was called by...")
            for func in list:
                cc, nc, tt, ct, callers = self.stats[func]
                self.print_call_line(width, func, callers, "<-")
            print >> self.stream
            print >> self.stream
        return self

    def print_call_heading(self, name_size, column_title):
        print >> self.stream, "Function ".ljust(name_size) + column_title
        # print sub-header only if we have new-style callers
        subheader = False
        for cc, nc, tt, ct, callers in self.stats.itervalues():
            if callers:
                value = callers.itervalues().next()
                subheader = isinstance(value, tuple)
                break
        if subheader:
            print >> self.stream, " "*name_size + "    ncalls  tottime  cumtime"

    def print_call_line(self, name_size, source, call_dict, arrow="->"):
        print >> self.stream, func_std_string(source).ljust(name_size) + arrow,
        if not call_dict:
            print >> self.stream
            return
        clist = call_dict.keys()
        clist.sort()
        indent = ""
        for func in clist:
            name = func_std_string(func)
            value = call_dict[func]
            if isinstance(value, tuple):
                nc, cc, tt, ct = value
                if nc != cc:
                    substats = '%d/%d' % (nc, cc)
                else:
                    substats = '%d' % (nc,)
                substats = '%s %s %s  %s' % (substats.rjust(7+2*len(indent)),
                                             f8(tt), f8(ct), name)
                left_width = name_size + 1
            else:
                substats = '%s(%r) %s' % (name, value, f8(self.stats[func][3]))
                left_width = name_size + 3
            print >> self.stream, indent*left_width + substats
            indent = " "

    def print_title(self):
        print >> self.stream, '   ncalls  tottime  percall  cumtime  percall',
        print >> self.stream, 'filename:lineno(function)'

    def print_line(self, func):  # hack : should print percentages
        cc, nc, tt, ct, callers = self.stats[func]
        c = str(nc)
        if nc != cc:
            c = c + '/' + str(cc)
        print >> self.stream, c.rjust(9),
        print >> self.stream, f8(tt),
        if nc == 0:
            print >> self.stream, ' '*8,
        else:
            print >> self.stream, f8(float(tt)/nc),
        print >> self.stream, f8(ct),
        if cc == 0:
            print >> self.stream, ' '*8,
        else:
            print >> self.stream, f8(float(ct)/cc),
        print >> self.stream, func_std_string(func)

class TupleComp:
    """This class provides a generic function for comparing any two tuples.
    Each instance records a list of tuple-indices (from most significant
    to least significant), and sort direction (ascending or decending) for
    each tuple-index.  The compare functions can then be used as the function
    argument to the system sort() function when a list of tuples need to be
    sorted in the instances order."""

    def __init__(self, comp_select_list):
        self.comp_select_list = comp_select_list

    def compare (self, left, right):
        for index, direction in self.comp_select_list:
            l = left[index]
            r = right[index]
            if l < r:
                return -direction
            if l > r:
                return direction
        return 0

#**************************************************************************
# func_name is a triple (file:string, line:int, name:string)

def func_strip_path(func_name):
    filename, line, name = func_name
    return os.path.basename(filename), line, name

def func_get_function_name(func):
    return func[2]

def func_std_string(func_name): # match what old profile produced
    if func_name[:2] == ('~', 0):
        # special case for built-in functions
        name = func_name[2]
        if name.startswith('<') and name.endswith('>'):
            return '{%s}' % name[1:-1]
        else:
            return name
    else:
        return "%s:%d(%s)" % func_name

#**************************************************************************
# The following functions combine statists for pairs functions.
# The bulk of the processing involves correctly handling "call" lists,
# such as callers and callees.
#**************************************************************************

def add_func_stats(target, source):
    """Add together all the stats for two profile entries."""
    cc, nc, tt, ct, callers = source
    t_cc, t_nc, t_tt, t_ct, t_callers = target
    return (cc+t_cc, nc+t_nc, tt+t_tt, ct+t_ct,
              add_callers(t_callers, callers))

def add_callers(target, source):
    """Combine two caller lists in a single list."""
    new_callers = {}
    for func, caller in target.iteritems():
        new_callers[func] = caller
    for func, caller in source.iteritems():
        if func in new_callers:
            if isinstance(caller, tuple):
                # format used by cProfile
                new_callers[func] = tuple([i[0] + i[1] for i in
                                           zip(caller, new_callers[func])])
            else:
                # format used by profile
                new_callers[func] += caller
        else:
            new_callers[func] = caller
    return new_callers

def count_calls(callers):
    """Sum the caller statistics to get total number of calls received."""
    nc = 0
    for calls in callers.itervalues():
        nc += calls
    return nc

#**************************************************************************
# The following functions support printing of reports
#**************************************************************************

def f8(x):
    return "%8.3f" % x

#**************************************************************************
# Statistics browser added by ESR, April 2001
#**************************************************************************

if __name__ == '__main__':
    import cmd
    try:
        import readline
    except ImportError:
        pass

    class ProfileBrowser(cmd.Cmd):
        def __init__(self, profile=None):
            cmd.Cmd.__init__(self)
            self.prompt = "% "
            self.stats = None
            self.stream = sys.stdout
            if profile is not None:
                self.do_read(profile)

        def generic(self, fn, line):
            args = line.split()
            processed = []
            for term in args:
                try:
                    processed.append(int(term))
                    continue
                except ValueError:
                    pass
                try:
                    frac = float(term)
                    if frac > 1 or frac < 0:
                        print >> self.stream, "Fraction argument must be in [0, 1]"
                        continue
                    processed.append(frac)
                    continue
                except ValueError:
                    pass
                processed.append(term)
            if self.stats:
                getattr(self.stats, fn)(*processed)
            else:
                print >> self.stream, "No statistics object is loaded."
            return 0
        def generic_help(self):
            print >> self.stream, "Arguments may be:"
            print >> self.stream, "* An integer maximum number of entries to print."
            print >> self.stream, "* A decimal fractional number between 0 and 1, controlling"
            print >> self.stream, "  what fraction of selected entries to print."
            print >> self.stream, "* A regular expression; only entries with function names"
            print >> self.stream, "  that match it are printed."

        def do_add(self, line):
            if self.stats:
                self.stats.add(line)
            else:
                print >> self.stream, "No statistics object is loaded."
            return 0
        def help_add(self):
            print >> self.stream, "Add profile info from given file to current statistics object."

        def do_callees(self, line):
            return self.generic('print_callees', line)
        def help_callees(self):
            print >> self.stream, "Print callees statistics from the current stat object."
            self.generic_help()

        def do_callers(self, line):
            return self.generic('print_callers', line)
        def help_callers(self):
            print >> self.stream, "Print callers statistics from the current stat object."
            self.generic_help()

        def do_EOF(self, line):
            print >> self.stream, ""
            return 1
        def help_EOF(self):
            print >> self.stream, "Leave the profile brower."

        def do_quit(self, line):
            return 1
        def help_quit(self):
            print >> self.stream, "Leave the profile brower."

        def do_read(self, line):
            if line:
                try:
                    self.stats = Stats(line)
                except IOError, args:
                    print >> self.stream, args[1]
                    return
                except Exception as err:
                    print >> self.stream, err.__class__.__name__ + ':', err
                    return
                self.prompt = line + "% "
            elif len(self.prompt) > 2:
                line = self.prompt[:-2]
                self.do_read(line)
            else:
                print >> self.stream, "No statistics object is current -- cannot reload."
            return 0
        def help_read(self):
            print >> self.stream, "Read in profile data from a specified file."
            print >> self.stream, "Without argument, reload the current file."

        def do_reverse(self, line):
            if self.stats:
                self.stats.reverse_order()
            else:
                print >> self.stream, "No statistics object is loaded."
            return 0
        def help_reverse(self):
            print >> self.stream, "Reverse the sort order of the profiling report."

        def do_sort(self, line):
            if not self.stats:
                print >> self.stream, "No statistics object is loaded."
                return
            abbrevs = self.stats.get_sort_arg_defs()
            if line and all((x in abbrevs) for x in line.split()):
                self.stats.sort_stats(*line.split())
            else:
                print >> self.stream, "Valid sort keys (unique prefixes are accepted):"
                for (key, value) in Stats.sort_arg_dict_default.iteritems():
                    print >> self.stream, "%s -- %s" % (key, value[1])
            return 0
        def help_sort(self):
            print >> self.stream, "Sort profile data according to specified keys."
            print >> self.stream, "(Typing `sort' without arguments lists valid keys.)"
        def complete_sort(self, text, *args):
            return [a for a in Stats.sort_arg_dict_default if a.startswith(text)]

        def do_stats(self, line):
            return self.generic('print_stats', line)
        def help_stats(self):
            print >> self.stream, "Print statistics from the current stat object."
            self.generic_help()

        def do_strip(self, line):
            if self.stats:
                self.stats.strip_dirs()
            else:
                print >> self.stream, "No statistics object is loaded."
        def help_strip(self):
            print >> self.stream, "Strip leading path information from filenames in the report."

        def help_help(self):
            print >> self.stream, "Show help for a given command."

        def postcmd(self, stop, line):
            if stop:
                return stop
            return None

    import sys
    if len(sys.argv) > 1:
        initprofile = sys.argv[1]
    else:
        initprofile = None
    try:
        browser = ProfileBrowser(initprofile)
        print >> browser.stream, "Welcome to the profile statistics browser."
        browser.cmdloop()
        print >> browser.stream, "Goodbye."
    except KeyboardInterrupt:
        pass

# That's all, folks.

filename:/usr/lib/python2.7/dbhash.py
__doc__
"""Provide a (g)dbm-compatible interface to bsddb.hashopen."""

filename:/usr/lib/python2.7/xmllib.py
__doc__
"""A parser for XML, using the derived class as static DTD."""

# Author: Sjoerd Mullender.

import re
import string

import warnings
warnings.warn("The xmllib module is obsolete.  Use xml.sax instead.",
              DeprecationWarning, 2)
del warnings

version = '0.3'

class Error(RuntimeError):
    pass

# Regular expressions used for parsing

_S = '[ \t\r\n]+'                       # white space
_opS = '[ \t\r\n]*'                     # optional white space
_Name = '[a-zA-Z_:][-a-zA-Z0-9._:]*'    # valid XML name
_QStr = "(?:'[^']*'|\"[^\"]*\")"        # quoted XML string
illegal = re.compile('[^\t\r\n -\176\240-\377]') # illegal chars in content
interesting = re.compile('[]&<]')

amp = re.compile('&')
ref = re.compile('&(' + _Name + '|#[0-9]+|#x[0-9a-fA-F]+)[^-a-zA-Z0-9._:]')
entityref = re.compile('&(?P<name>' + _Name + ')[^-a-zA-Z0-9._:]')
charref = re.compile('&#(?P<char>[0-9]+[^0-9]|x[0-9a-fA-F]+[^0-9a-fA-F])')
space = re.compile(_S + '$')
newline = re.compile('\n')

attrfind = re.compile(
    _S + '(?P<name>' + _Name + ')'
    '(' + _opS + '=' + _opS +
    '(?P<value>'+_QStr+'|[-a-zA-Z0-9.:+*%?!\(\)_#=~]+))?')
starttagopen = re.compile('<' + _Name)
starttagend = re.compile(_opS + '(?P<slash>/?)>')
starttagmatch = re.compile('<(?P<tagname>'+_Name+')'
                      '(?P<attrs>(?:'+attrfind.pattern+')*)'+
                      starttagend.pattern)
endtagopen = re.compile('</')
endbracket = re.compile(_opS + '>')
endbracketfind = re.compile('(?:[^>\'"]|'+_QStr+')*>')
tagfind = re.compile(_Name)
cdataopen = re.compile(r'<!\[CDATA\[')
cdataclose = re.compile(r'\]\]>')
# this matches one of the following:
# SYSTEM SystemLiteral
# PUBLIC PubidLiteral SystemLiteral
_SystemLiteral = '(?P<%s>'+_QStr+')'
_PublicLiteral = '(?P<%s>"[-\'\(\)+,./:=?;!*#@$_%% \n\ra-zA-Z0-9]*"|' \
                        "'[-\(\)+,./:=?;!*#@$_%% \n\ra-zA-Z0-9]*')"
_ExternalId = '(?:SYSTEM|' \
                 'PUBLIC'+_S+_PublicLiteral%'pubid'+ \
              ')'+_S+_SystemLiteral%'syslit'
doctype = re.compile('<!DOCTYPE'+_S+'(?P<name>'+_Name+')'
                     '(?:'+_S+_ExternalId+')?'+_opS)
xmldecl = re.compile('<\?xml'+_S+
                     'version'+_opS+'='+_opS+'(?P<version>'+_QStr+')'+
                     '(?:'+_S+'encoding'+_opS+'='+_opS+
                        "(?P<encoding>'[A-Za-z][-A-Za-z0-9._]*'|"
                        '"[A-Za-z][-A-Za-z0-9._]*"))?'
                     '(?:'+_S+'standalone'+_opS+'='+_opS+
                        '(?P<standalone>\'(?:yes|no)\'|"(?:yes|no)"))?'+
                     _opS+'\?>')
procopen = re.compile(r'<\?(?P<proc>' + _Name + ')' + _opS)
procclose = re.compile(_opS + r'\?>')
commentopen = re.compile('<!--')
commentclose = re.compile('-->')
doubledash = re.compile('--')
attrtrans = string.maketrans(' \r\n\t', '    ')

# definitions for XML namespaces
_NCName = '[a-zA-Z_][-a-zA-Z0-9._]*'    # XML Name, minus the ":"
ncname = re.compile(_NCName + '$')
qname = re.compile('(?:(?P<prefix>' + _NCName + '):)?' # optional prefix
                   '(?P<local>' + _NCName + ')$')

xmlns = re.compile('xmlns(?::(?P<ncname>'+_NCName+'))?$')

# XML parser base class -- find tags and call handler functions.
# Usage: p = XMLParser(); p.feed(data); ...; p.close().
# The dtd is defined by deriving a class which defines methods with
# special names to handle tags: start_foo and end_foo to handle <foo>
# and </foo>, respectively.  The data between tags is passed to the
# parser by calling self.handle_data() with some data as argument (the
# data may be split up in arbitrary chunks).

class XMLParser:
    attributes = {}                     # default, to be overridden
    elements = {}                       # default, to be overridden

    # parsing options, settable using keyword args in __init__
    __accept_unquoted_attributes = 0
    __accept_missing_endtag_name = 0
    __map_case = 0
    __accept_utf8 = 0
    __translate_attribute_references = 1

    # Interface -- initialize and reset this instance
    def __init__(self, **kw):
        self.__fixed = 0
        if 'accept_unquoted_attributes' in kw:
            self.__accept_unquoted_attributes = kw['accept_unquoted_attributes']
        if 'accept_missing_endtag_name' in kw:
            self.__accept_missing_endtag_name = kw['accept_missing_endtag_name']
        if 'map_case' in kw:
            self.__map_case = kw['map_case']
        if 'accept_utf8' in kw:
            self.__accept_utf8 = kw['accept_utf8']
        if 'translate_attribute_references' in kw:
            self.__translate_attribute_references = kw['translate_attribute_references']
        self.reset()

    def __fixelements(self):
        self.__fixed = 1
        self.elements = {}
        self.__fixdict(self.__dict__)
        self.__fixclass(self.__class__)

    def __fixclass(self, kl):
        self.__fixdict(kl.__dict__)
        for k in kl.__bases__:
            self.__fixclass(k)

    def __fixdict(self, dict):
        for key in dict.keys():
            if key[:6] == 'start_':
                tag = key[6:]
                start, end = self.elements.get(tag, (None, None))
                if start is None:
                    self.elements[tag] = getattr(self, key), end
            elif key[:4] == 'end_':
                tag = key[4:]
                start, end = self.elements.get(tag, (None, None))
                if end is None:
                    self.elements[tag] = start, getattr(self, key)

    # Interface -- reset this instance.  Loses all unprocessed data
    def reset(self):
        self.rawdata = ''
        self.stack = []
        self.nomoretags = 0
        self.literal = 0
        self.lineno = 1
        self.__at_start = 1
        self.__seen_doctype = None
        self.__seen_starttag = 0
        self.__use_namespaces = 0
        self.__namespaces = {'xml':None}   # xml is implicitly declared
        # backward compatibility hack: if elements not overridden,
        # fill it in ourselves
        if self.elements is XMLParser.elements:
            self.__fixelements()

    # For derived classes only -- enter literal mode (CDATA) till EOF
    def setnomoretags(self):
        self.nomoretags = self.literal = 1

    # For derived classes only -- enter literal mode (CDATA)
    def setliteral(self, *args):
        self.literal = 1

    # Interface -- feed some data to the parser.  Call this as
    # often as you want, with as little or as much text as you
    # want (may include '\n').  (This just saves the text, all the
    # processing is done by goahead().)
    def feed(self, data):
        self.rawdata = self.rawdata + data
        self.goahead(0)

    # Interface -- handle the remaining data
    def close(self):
        self.goahead(1)
        if self.__fixed:
            self.__fixed = 0
            # remove self.elements so that we don't leak
            del self.elements

    # Interface -- translate references
    def translate_references(self, data, all = 1):
        if not self.__translate_attribute_references:
            return data
        i = 0
        while 1:
            res = amp.search(data, i)
            if res is None:
                return data
            s = res.start(0)
            res = ref.match(data, s)
            if res is None:
                self.syntax_error("bogus `&'")
                i = s+1
                continue
            i = res.end(0)
            str = res.group(1)
            rescan = 0
            if str[0] == '#':
                if str[1] == 'x':
                    str = chr(int(str[2:], 16))
                else:
                    str = chr(int(str[1:]))
                if data[i - 1] != ';':
                    self.syntax_error("`;' missing after char reference")
                    i = i-1
            elif all:
                if str in self.entitydefs:
                    str = self.entitydefs[str]
                    rescan = 1
                elif data[i - 1] != ';':
                    self.syntax_error("bogus `&'")
                    i = s + 1 # just past the &
                    continue
                else:
                    self.syntax_error("reference to unknown entity `&%s;'" % str)
                    str = '&' + str + ';'
            elif data[i - 1] != ';':
                self.syntax_error("bogus `&'")
                i = s + 1 # just past the &
                continue

            # when we get here, str contains the translated text and i points
            # to the end of the string that is to be replaced
            data = data[:s] + str + data[i:]
            if rescan:
                i = s
            else:
                i = s + len(str)

    # Interface - return a dictionary of all namespaces currently valid
    def getnamespace(self):
        nsdict = {}
        for t, d, nst in self.stack:
            nsdict.update(d)
        return nsdict

    # Internal -- handle data as far as reasonable.  May leave state
    # and data to be processed by a subsequent call.  If 'end' is
    # true, force handling all data as if followed by EOF marker.
    def goahead(self, end):
        rawdata = self.rawdata
        i = 0
        n = len(rawdata)
        while i < n:
            if i > 0:
                self.__at_start = 0
            if self.nomoretags:
                data = rawdata[i:n]
                self.handle_data(data)
                self.lineno = self.lineno + data.count('\n')
                i = n
                break
            res = interesting.search(rawdata, i)
            if res:
                j = res.start(0)
            else:
                j = n
            if i < j:
                data = rawdata[i:j]
                if self.__at_start and space.match(data) is None:
                    self.syntax_error('illegal data at start of file')
                self.__at_start = 0
                if not self.stack and space.match(data) is None:
                    self.syntax_error('data not in content')
                if not self.__accept_utf8 and illegal.search(data):
                    self.syntax_error('illegal character in content')
                self.handle_data(data)
                self.lineno = self.lineno + data.count('\n')
            i = j
            if i == n: break
            if rawdata[i] == '<':
                if starttagopen.match(rawdata, i):
                    if self.literal:
                        data = rawdata[i]
                        self.handle_data(data)
                        self.lineno = self.lineno + data.count('\n')
                        i = i+1
                        continue
                    k = self.parse_starttag(i)
                    if k < 0: break
                    self.__seen_starttag = 1
                    self.lineno = self.lineno + rawdata[i:k].count('\n')
                    i = k
                    continue
                if endtagopen.match(rawdata, i):
                    k = self.parse_endtag(i)
                    if k < 0: break
                    self.lineno = self.lineno + rawdata[i:k].count('\n')
                    i =  k
                    continue
                if commentopen.match(rawdata, i):
                    if self.literal:
                        data = rawdata[i]
                        self.handle_data(data)
                        self.lineno = self.lineno + data.count('\n')
                        i = i+1
                        continue
                    k = self.parse_comment(i)
                    if k < 0: break
                    self.lineno = self.lineno + rawdata[i:k].count('\n')
                    i = k
                    continue
                if cdataopen.match(rawdata, i):
                    k = self.parse_cdata(i)
                    if k < 0: break
                    self.lineno = self.lineno + rawdata[i:k].count('\n')
                    i = k
                    continue
                res = xmldecl.match(rawdata, i)
                if res:
                    if not self.__at_start:
                        self.syntax_error("<?xml?> declaration not at start of document")
                    version, encoding, standalone = res.group('version',
                                                              'encoding',
                                                              'standalone')
                    if version[1:-1] != '1.0':
                        raise Error('only XML version 1.0 supported')
                    if encoding: encoding = encoding[1:-1]
                    if standalone: standalone = standalone[1:-1]
                    self.handle_xml(encoding, standalone)
                    i = res.end(0)
                    continue
                res = procopen.match(rawdata, i)
                if res:
                    k = self.parse_proc(i)
                    if k < 0: break
                    self.lineno = self.lineno + rawdata[i:k].count('\n')
                    i = k
                    continue
                res = doctype.match(rawdata, i)
                if res:
                    if self.literal:
                        data = rawdata[i]
                        self.handle_data(data)
                        self.lineno = self.lineno + data.count('\n')
                        i = i+1
                        continue
                    if self.__seen_doctype:
                        self.syntax_error('multiple DOCTYPE elements')
                    if self.__seen_starttag:
                        self.syntax_error('DOCTYPE not at beginning of document')
                    k = self.parse_doctype(res)
                    if k < 0: break
                    self.__seen_doctype = res.group('name')
                    if self.__map_case:
                        self.__seen_doctype = self.__seen_doctype.lower()
                    self.lineno = self.lineno + rawdata[i:k].count('\n')
                    i = k
                    continue
            elif rawdata[i] == '&':
                if self.literal:
                    data = rawdata[i]
                    self.handle_data(data)
                    i = i+1
                    continue
                res = charref.match(rawdata, i)
                if res is not None:
                    i = res.end(0)
                    if rawdata[i-1] != ';':
                        self.syntax_error("`;' missing in charref")
                        i = i-1
                    if not self.stack:
                        self.syntax_error('data not in content')
                    self.handle_charref(res.group('char')[:-1])
                    self.lineno = self.lineno + res.group(0).count('\n')
                    continue
                res = entityref.match(rawdata, i)
                if res is not None:
                    i = res.end(0)
                    if rawdata[i-1] != ';':
                        self.syntax_error("`;' missing in entityref")
                        i = i-1
                    name = res.group('name')
                    if self.__map_case:
                        name = name.lower()
                    if name in self.entitydefs:
                        self.rawdata = rawdata = rawdata[:res.start(0)] + self.entitydefs[name] + rawdata[i:]
                        n = len(rawdata)
                        i = res.start(0)
                    else:
                        self.unknown_entityref(name)
                    self.lineno = self.lineno + res.group(0).count('\n')
                    continue
            elif rawdata[i] == ']':
                if self.literal:
                    data = rawdata[i]
                    self.handle_data(data)
                    i = i+1
                    continue
                if n-i < 3:
                    break
                if cdataclose.match(rawdata, i):
                    self.syntax_error("bogus `]]>'")
                self.handle_data(rawdata[i])
                i = i+1
                continue
            else:
                raise Error('neither < nor & ??')
            # We get here only if incomplete matches but
            # nothing else
            break
        # end while
        if i > 0:
            self.__at_start = 0
        if end and i < n:
            data = rawdata[i]
            self.syntax_error("bogus `%s'" % data)
            if not self.__accept_utf8 and illegal.search(data):
                self.syntax_error('illegal character in content')
            self.handle_data(data)
            self.lineno = self.lineno + data.count('\n')
            self.rawdata = rawdata[i+1:]
            return self.goahead(end)
        self.rawdata = rawdata[i:]
        if end:
            if not self.__seen_starttag:
                self.syntax_error('no elements in file')
            if self.stack:
                self.syntax_error('missing end tags')
                while self.stack:
                    self.finish_endtag(self.stack[-1][0])

    # Internal -- parse comment, return length or -1 if not terminated
    def parse_comment(self, i):
        rawdata = self.rawdata
        if rawdata[i:i+4] != '<!--':
            raise Error('unexpected call to handle_comment')
        res = commentclose.search(rawdata, i+4)
        if res is None:
            return -1
        if doubledash.search(rawdata, i+4, res.start(0)):
            self.syntax_error("`--' inside comment")
        if rawdata[res.start(0)-1] == '-':
            self.syntax_error('comment cannot end in three dashes')
        if not self.__accept_utf8 and \
           illegal.search(rawdata, i+4, res.start(0)):
            self.syntax_error('illegal character in comment')
        self.handle_comment(rawdata[i+4: res.start(0)])
        return res.end(0)

    # Internal -- handle DOCTYPE tag, return length or -1 if not terminated
    def parse_doctype(self, res):
        rawdata = self.rawdata
        n = len(rawdata)
        name = res.group('name')
        if self.__map_case:
            name = name.lower()
        pubid, syslit = res.group('pubid', 'syslit')
        if pubid is not None:
            pubid = pubid[1:-1]         # remove quotes
            pubid = ' '.join(pubid.split()) # normalize
        if syslit is not None: syslit = syslit[1:-1] # remove quotes
        j = k = res.end(0)
        if k >= n:
            return -1
        if rawdata[k] == '[':
            level = 0
            k = k+1
            dq = sq = 0
            while k < n:
                c = rawdata[k]
                if not sq and c == '"':
                    dq = not dq
                elif not dq and c == "'":
                    sq = not sq
                elif sq or dq:
                    pass
                elif level <= 0 and c == ']':
                    res = endbracket.match(rawdata, k+1)
                    if res is None:
                        return -1
                    self.handle_doctype(name, pubid, syslit, rawdata[j+1:k])
                    return res.end(0)
                elif c == '<':
                    level = level + 1
                elif c == '>':
                    level = level - 1
                    if level < 0:
                        self.syntax_error("bogus `>' in DOCTYPE")
                k = k+1
        res = endbracketfind.match(rawdata, k)
        if res is None:
            return -1
        if endbracket.match(rawdata, k) is None:
            self.syntax_error('garbage in DOCTYPE')
        self.handle_doctype(name, pubid, syslit, None)
        return res.end(0)

    # Internal -- handle CDATA tag, return length or -1 if not terminated
    def parse_cdata(self, i):
        rawdata = self.rawdata
        if rawdata[i:i+9] != '<![CDATA[':
            raise Error('unexpected call to parse_cdata')
        res = cdataclose.search(rawdata, i+9)
        if res is None:
            return -1
        if not self.__accept_utf8 and \
           illegal.search(rawdata, i+9, res.start(0)):
            self.syntax_error('illegal character in CDATA')
        if not self.stack:
            self.syntax_error('CDATA not in content')
        self.handle_cdata(rawdata[i+9:res.start(0)])
        return res.end(0)

    __xml_namespace_attributes = {'ns':None, 'src':None, 'prefix':None}
    # Internal -- handle a processing instruction tag
    def parse_proc(self, i):
        rawdata = self.rawdata
        end = procclose.search(rawdata, i)
        if end is None:
            return -1
        j = end.start(0)
        if not self.__accept_utf8 and illegal.search(rawdata, i+2, j):
            self.syntax_error('illegal character in processing instruction')
        res = tagfind.match(rawdata, i+2)
        if res is None:
            raise Error('unexpected call to parse_proc')
        k = res.end(0)
        name = res.group(0)
        if self.__map_case:
            name = name.lower()
        if name == 'xml:namespace':
            self.syntax_error('old-fashioned namespace declaration')
            self.__use_namespaces = -1
            # namespace declaration
            # this must come after the <?xml?> declaration (if any)
            # and before the <!DOCTYPE> (if any).
            if self.__seen_doctype or self.__seen_starttag:
                self.syntax_error('xml:namespace declaration too late in document')
            attrdict, namespace, k = self.parse_attributes(name, k, j)
            if namespace:
                self.syntax_error('namespace declaration inside namespace declaration')
            for attrname in attrdict.keys():
                if not attrname in self.__xml_namespace_attributes:
                    self.syntax_error("unknown attribute `%s' in xml:namespace tag" % attrname)
            if not 'ns' in attrdict or not 'prefix' in attrdict:
                self.syntax_error('xml:namespace without required attributes')
            prefix = attrdict.get('prefix')
            if ncname.match(prefix) is None:
                self.syntax_error('xml:namespace illegal prefix value')
                return end.end(0)
            if prefix in self.__namespaces:
                self.syntax_error('xml:namespace prefix not unique')
            self.__namespaces[prefix] = attrdict['ns']
        else:
            if name.lower() == 'xml':
                self.syntax_error('illegal processing instruction target name')
            self.handle_proc(name, rawdata[k:j])
        return end.end(0)

    # Internal -- parse attributes between i and j
    def parse_attributes(self, tag, i, j):
        rawdata = self.rawdata
        attrdict = {}
        namespace = {}
        while i < j:
            res = attrfind.match(rawdata, i)
            if res is None:
                break
            attrname, attrvalue = res.group('name', 'value')
            if self.__map_case:
                attrname = attrname.lower()
            i = res.end(0)
            if attrvalue is None:
                self.syntax_error("no value specified for attribute `%s'" % attrname)
                attrvalue = attrname
            elif attrvalue[:1] == "'" == attrvalue[-1:] or \
                 attrvalue[:1] == '"' == attrvalue[-1:]:
                attrvalue = attrvalue[1:-1]
            elif not self.__accept_unquoted_attributes:
                self.syntax_error("attribute `%s' value not quoted" % attrname)
            res = xmlns.match(attrname)
            if res is not None:
                # namespace declaration
                ncname = res.group('ncname')
                namespace[ncname or ''] = attrvalue or None
                if not self.__use_namespaces:
                    self.__use_namespaces = len(self.stack)+1
                continue
            if '<' in attrvalue:
                self.syntax_error("`<' illegal in attribute value")
            if attrname in attrdict:
                self.syntax_error("attribute `%s' specified twice" % attrname)
            attrvalue = attrvalue.translate(attrtrans)
            attrdict[attrname] = self.translate_references(attrvalue)
        return attrdict, namespace, i

    # Internal -- handle starttag, return length or -1 if not terminated
    def parse_starttag(self, i):
        rawdata = self.rawdata
        # i points to start of tag
        end = endbracketfind.match(rawdata, i+1)
        if end is None:
            return -1
        tag = starttagmatch.match(rawdata, i)
        if tag is None or tag.end(0) != end.end(0):
            self.syntax_error('garbage in starttag')
            return end.end(0)
        nstag = tagname = tag.group('tagname')
        if self.__map_case:
            nstag = tagname = nstag.lower()
        if not self.__seen_starttag and self.__seen_doctype and \
           tagname != self.__seen_doctype:
            self.syntax_error('starttag does not match DOCTYPE')
        if self.__seen_starttag and not self.stack:
            self.syntax_error('multiple elements on top level')
        k, j = tag.span('attrs')
        attrdict, nsdict, k = self.parse_attributes(tagname, k, j)
        self.stack.append((tagname, nsdict, nstag))
        if self.__use_namespaces:
            res = qname.match(tagname)
        else:
            res = None
        if res is not None:
            prefix, nstag = res.group('prefix', 'local')
            if prefix is None:
                prefix = ''
            ns = None
            for t, d, nst in self.stack:
                if prefix in d:
                    ns = d[prefix]
            if ns is None and prefix != '':
                ns = self.__namespaces.get(prefix)
            if ns is not None:
                nstag = ns + ' ' + nstag
            elif prefix != '':
                nstag = prefix + ':' + nstag # undo split
            self.stack[-1] = tagname, nsdict, nstag
        # translate namespace of attributes
        attrnamemap = {} # map from new name to old name (used for error reporting)
        for key in attrdict.keys():
            attrnamemap[key] = key
        if self.__use_namespaces:
            nattrdict = {}
            for key, val in attrdict.items():
                okey = key
                res = qname.match(key)
                if res is not None:
                    aprefix, key = res.group('prefix', 'local')
                    if self.__map_case:
                        key = key.lower()
                    if aprefix is not None:
                        ans = None
                        for t, d, nst in self.stack:
                            if aprefix in d:
                                ans = d[aprefix]
                        if ans is None:
                            ans = self.__namespaces.get(aprefix)
                        if ans is not None:
                            key = ans + ' ' + key
                        else:
                            key = aprefix + ':' + key
                nattrdict[key] = val
                attrnamemap[key] = okey
            attrdict = nattrdict
        attributes = self.attributes.get(nstag)
        if attributes is not None:
            for key in attrdict.keys():
                if not key in attributes:
                    self.syntax_error("unknown attribute `%s' in tag `%s'" % (attrnamemap[key], tagname))
            for key, val in attributes.items():
                if val is not None and not key in attrdict:
                    attrdict[key] = val
        method = self.elements.get(nstag, (None, None))[0]
        self.finish_starttag(nstag, attrdict, method)
        if tag.group('slash') == '/':
            self.finish_endtag(tagname)
        return tag.end(0)

    # Internal -- parse endtag
    def parse_endtag(self, i):
        rawdata = self.rawdata
        end = endbracketfind.match(rawdata, i+1)
        if end is None:
            return -1
        res = tagfind.match(rawdata, i+2)
        if res is None:
            if self.literal:
                self.handle_data(rawdata[i])
                return i+1
            if not self.__accept_missing_endtag_name:
                self.syntax_error('no name specified in end tag')
            tag = self.stack[-1][0]
            k = i+2
        else:
            tag = res.group(0)
            if self.__map_case:
                tag = tag.lower()
            if self.literal:
                if not self.stack or tag != self.stack[-1][0]:
                    self.handle_data(rawdata[i])
                    return i+1
            k = res.end(0)
        if endbracket.match(rawdata, k) is None:
            self.syntax_error('garbage in end tag')
        self.finish_endtag(tag)
        return end.end(0)

    # Internal -- finish processing of start tag
    def finish_starttag(self, tagname, attrdict, method):
        if method is not None:
            self.handle_starttag(tagname, method, attrdict)
        else:
            self.unknown_starttag(tagname, attrdict)

    # Internal -- finish processing of end tag
    def finish_endtag(self, tag):
        self.literal = 0
        if not tag:
            self.syntax_error('name-less end tag')
            found = len(self.stack) - 1
            if found < 0:
                self.unknown_endtag(tag)
                return
        else:
            found = -1
            for i in range(len(self.stack)):
                if tag == self.stack[i][0]:
                    found = i
            if found == -1:
                self.syntax_error('unopened end tag')
                return
        while len(self.stack) > found:
            if found < len(self.stack) - 1:
                self.syntax_error('missing close tag for %s' % self.stack[-1][2])
            nstag = self.stack[-1][2]
            method = self.elements.get(nstag, (None, None))[1]
            if method is not None:
                self.handle_endtag(nstag, method)
            else:
                self.unknown_endtag(nstag)
            if self.__use_namespaces == len(self.stack):
                self.__use_namespaces = 0
            del self.stack[-1]

    # Overridable -- handle xml processing instruction
    def handle_xml(self, encoding, standalone):
        pass

    # Overridable -- handle DOCTYPE
    def handle_doctype(self, tag, pubid, syslit, data):
        pass

    # Overridable -- handle start tag
    def handle_starttag(self, tag, method, attrs):
        method(attrs)

    # Overridable -- handle end tag
    def handle_endtag(self, tag, method):
        method()

    # Example -- handle character reference, no need to override
    def handle_charref(self, name):
        try:
            if name[0] == 'x':
                n = int(name[1:], 16)
            else:
                n = int(name)
        except ValueError:
            self.unknown_charref(name)
            return
        if not 0 <= n <= 255:
            self.unknown_charref(name)
            return
        self.handle_data(chr(n))

    # Definition of entities -- derived classes may override
    entitydefs = {'lt': '&#60;',        # must use charref
                  'gt': '&#62;',
                  'amp': '&#38;',       # must use charref
                  'quot': '&#34;',
                  'apos': '&#39;',
                  }

    # Example -- handle data, should be overridden
    def handle_data(self, data):
        pass

    # Example -- handle cdata, could be overridden
    def handle_cdata(self, data):
        pass

    # Example -- handle comment, could be overridden
    def handle_comment(self, data):
        pass

    # Example -- handle processing instructions, could be overridden
    def handle_proc(self, name, data):
        pass

    # Example -- handle relatively harmless syntax errors, could be overridden
    def syntax_error(self, message):
        raise Error('Syntax error at line %d: %s' % (self.lineno, message))

    # To be overridden -- handlers for unknown objects
    def unknown_starttag(self, tag, attrs): pass
    def unknown_endtag(self, tag): pass
    def unknown_charref(self, ref): pass
    def unknown_entityref(self, name):
        self.syntax_error("reference to unknown entity `&%s;'" % name)


class TestXMLParser(XMLParser):

    def __init__(self, **kw):
        self.testdata = ""
        XMLParser.__init__(self, **kw)

    def handle_xml(self, encoding, standalone):
        self.flush()
        print 'xml: encoding =',encoding,'standalone =',standalone

    def handle_doctype(self, tag, pubid, syslit, data):
        self.flush()
        print 'DOCTYPE:',tag, repr(data)

    def handle_data(self, data):
        self.testdata = self.testdata + data
        if len(repr(self.testdata)) >= 70:
            self.flush()

    def flush(self):
        data = self.testdata
        if data:
            self.testdata = ""
            print 'data:', repr(data)

    def handle_cdata(self, data):
        self.flush()
        print 'cdata:', repr(data)

    def handle_proc(self, name, data):
        self.flush()
        print 'processing:',name,repr(data)

    def handle_comment(self, data):
        self.flush()
        r = repr(data)
        if len(r) > 68:
            r = r[:32] + '...' + r[-32:]
        print 'comment:', r

    def syntax_error(self, message):
        print 'error at line %d:' % self.lineno, message

    def unknown_starttag(self, tag, attrs):
        self.flush()
        if not attrs:
            print 'start tag: <' + tag + '>'
        else:
            print 'start tag: <' + tag,
            for name, value in attrs.items():
                print name + '=' + '"' + value + '"',
            print '>'

    def unknown_endtag(self, tag):
        self.flush()
        print 'end tag: </' + tag + '>'

    def unknown_entityref(self, ref):
        self.flush()
        print '*** unknown entity ref: &' + ref + ';'

    def unknown_charref(self, ref):
        self.flush()
        print '*** unknown char ref: &#' + ref + ';'

    def close(self):
        XMLParser.close(self)
        self.flush()

def test(args = None):
    import sys, getopt
    from time import time

    if not args:
        args = sys.argv[1:]

    opts, args = getopt.getopt(args, 'st')
    klass = TestXMLParser
    do_time = 0
    for o, a in opts:
        if o == '-s':
            klass = XMLParser
        elif o == '-t':
            do_time = 1

    if args:
        file = args[0]
    else:
        file = 'test.xml'

    if file == '-':
        f = sys.stdin
    else:
        try:
            f = open(file, 'r')
        except IOError, msg:
            print file, ":", msg
            sys.exit(1)

    data = f.read()
    if f is not sys.stdin:
        f.close()

    x = klass()
    t0 = time()
    try:
        if do_time:
            x.feed(data)
            x.close()
        else:
            for c in data:
                x.feed(c)
            x.close()
    except Error, msg:
        t1 = time()
        print msg
        if do_time:
            print 'total time: %g' % (t1-t0)
        sys.exit(1)
    t1 = time()
    if do_time:
        print 'total time: %g' % (t1-t0)


if __name__ == '__main__':
    test()

filename:/usr/lib/python2.7/sunaudio.py
__doc__
"""Interpret sun audio headers."""

filename:/usr/lib/python2.7/contextlib.py
__doc__
"""Utilities for with-statement contexts.  See PEP 343."""

import sys
from functools import wraps
from warnings import warn

__all__ = ["contextmanager", "nested", "closing"]

class GeneratorContextManager(object):
    """Helper for @contextmanager decorator."""

    def __init__(self, gen):
        self.gen = gen

    def __enter__(self):
        try:
            return self.gen.next()
        except StopIteration:
            raise RuntimeError("generator didn't yield")

    def __exit__(self, type, value, traceback):
        if type is None:
            try:
                self.gen.next()
            except StopIteration:
                return
            else:
                raise RuntimeError("generator didn't stop")
        else:
            if value is None:
                # Need to force instantiation so we can reliably
                # tell if we get the same exception back
                value = type()
            try:
                self.gen.throw(type, value, traceback)
                raise RuntimeError("generator didn't stop after throw()")
            except StopIteration, exc:
                # Suppress the exception *unless* it's the same exception that
                # was passed to throw().  This prevents a StopIteration
                # raised inside the "with" statement from being suppressed
                return exc is not value
            except:
                # only re-raise if it's *not* the exception that was
                # passed to throw(), because __exit__() must not raise
                # an exception unless __exit__() itself failed.  But throw()
                # has to raise the exception to signal propagation, so this
                # fixes the impedance mismatch between the throw() protocol
                # and the __exit__() protocol.
                #
                if sys.exc_info()[1] is not value:
                    raise


def contextmanager(func):
    """@contextmanager decorator.

    Typical usage:

        @contextmanager
        def some_generator(<arguments>):
            <setup>
            try:
                yield <value>
            finally:
                <cleanup>

    This makes this:

        with some_generator(<arguments>) as <variable>:
            <body>

    equivalent to this:

        <setup>
        try:
            <variable> = <value>
            <body>
        finally:
            <cleanup>

    """
    @wraps(func)
    def helper(*args, **kwds):
        return GeneratorContextManager(func(*args, **kwds))
    return helper


@contextmanager
def nested(*managers):
    """Combine multiple context managers into a single nested context manager.

   This function has been deprecated in favour of the multiple manager form
   of the with statement.

   The one advantage of this function over the multiple manager form of the
   with statement is that argument unpacking allows it to be
   used with a variable number of context managers as follows:

      with nested(*managers):
          do_something()

    """
    warn("With-statements now directly support multiple context managers",
         DeprecationWarning, 3)
    exits = []
    vars = []
    exc = (None, None, None)
    try:
        for mgr in managers:
            exit = mgr.__exit__
            enter = mgr.__enter__
            vars.append(enter())
            exits.append(exit)
        yield vars
    except:
        exc = sys.exc_info()
    finally:
        while exits:
            exit = exits.pop()
            try:
                if exit(*exc):
                    exc = (None, None, None)
            except:
                exc = sys.exc_info()
        if exc != (None, None, None):
            # Don't rely on sys.exc_info() still containing
            # the right information. Another exception may
            # have been raised and caught by an exit method
            raise exc[0], exc[1], exc[2]


class closing(object):
    """Context to automatically close something at the end of a block.

    Code like this:

        with closing(<module>.open(<arguments>)) as f:
            <block>

    is equivalent to this:

        f = <module>.open(<arguments>)
        try:
            <block>
        finally:
            f.close()

    """
    def __init__(self, thing):
        self.thing = thing
    def __enter__(self):
        return self.thing
    def __exit__(self, *exc_info):
        self.thing.close()

filename:/usr/lib/python2.7/string.pyc
__doc__
Û
/0Xc           @   sñ  d  Z  d Z d Z d Z e e Z e Z e Z e e Z d Z e d d Z	 d Z
 d Z e e e e Z e e e d	 É É Z e d
 É j e É Z [ d d Ñ Z d a d Ñ  Z d d l Z d d4 d Ñ  É  YZ d e f d Ñ  É  YZ d d5 d Ñ  É  YZ e Z e Z  e Z! e Z" d Ñ  Z# d Ñ  Z$ d Ñ  Z% d d Ñ Z& d d Ñ Z' d d Ñ Z( d d d Ñ Z) e) Z* d d d Ñ Z+ d d Ñ Z e Z, d Ñ  Z- d  Ñ  Z. d! Ñ  Z/ d" Ñ  Z0 d# Ñ  Z1 e2 Z3 e4 Z5 e6 Z7 d$ Ñ  Z8 d% d& Ñ Z9 d% d' Ñ Z: d( Ñ  Z; d) Ñ  Z< d* Ñ  Z= d+ Ñ  Z> d, d- Ñ Z? d
 d. Ñ Z@ d/ Ñ  ZA d d0 Ñ ZB y0 d d1 lC m Z m Z m Z m Z e e Z Wn eD k
 r{n Xd2 eE f d3 Ñ  É  YZF d S(6   s˙  A collection of string operations (most are no longer used).

Warning: most of the code you see here isn't normally used nowadays.
Beginning with Python 1.6, many of these functions are implemented as
methods on the standard string object. They used to be implemented by
a built-in module called strop, but strop is now obsolete itself.

Public module variables:

whitespace -- a string containing all characters considered whitespace
lowercase -- a string containing all characters considered lowercase letters
uppercase -- a string containing all characters considered uppercase letters
letters -- a string containing all characters considered letters
digits -- a string containing all characters considered decimal digits
hexdigits -- a string containing all characters considered hexadecimal digits
octdigits -- a string containing all characters considered octal digits
punctuation -- a string containing all characters considered punctuation
printable -- a string containing all characters considered printable

s    	
t   abcdefghijklmnopqrstuvwxyzt   ABCDEFGHIJKLMNOPQRSTUVWXYZt
   0123456789t   abcdeft   ABCDEFt   01234567s    !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~i   t    c         C   s&   | p	 d j  d Ñ  |  j | É DÉ É S(   së  capwords(s [,sep]) -> string

    Split the argument into words using split, capitalize each
    word using capitalize, and join the capitalized words using
    join.  If the optional second argument sep is absent or None,
    runs of whitespace characters are replaced by a single space
    and leading and trailing whitespace are removed, otherwise
    sep is used to split and join the words.

    t    c         s   s   |  ] } | j  É  Vq d  S(   N(   t
   capitalize(   t   .0t   x(    (    s   /usr/lib/python2.7/string.pys	   <genexpr>8   s    (   t   joint   split(   t   st   sep(    (    s   /usr/lib/python2.7/string.pyt   capwords-   s    c         C   sã   t  |  É t  | É k r$ t d Ç n  t s9 t t É a n  t } t t |  É }  x, t t  |  É É D] } | | | |  | <qb Wd j | É S(   s¡   maketrans(frm, to) -> string

    Return a translation table (a string of 256 bytes long)
    suitable for use in string.translate.  The strings frm and to
    must be of the same length.

    s)   maketrans arguments must have same lengthR   (	   t   lent
   ValueErrort   _idmapLt   listt   _idmapt   mapt   ordt   rangeR   (   t   fromstrt   tostrt   Lt   i(    (    s   /usr/lib/python2.7/string.pyt	   maketrans=   s    iˇˇˇˇNt	   _multimapc           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   sá   Helper class for combining multiple mappings.

    Used by .{safe_,}substitute() to combine the mapping and keyword
    arguments.
    c         C   s   | |  _  | |  _ d  S(   N(   t   _primaryt
   _secondary(   t   selft   primaryt	   secondary(    (    s   /usr/lib/python2.7/string.pyt   __init__[   s    	c         C   s/   y |  j  | SWn t k
 r* |  j | SXd  S(   N(   R   t   KeyErrorR   (   R    t   key(    (    s   /usr/lib/python2.7/string.pyt   __getitem___   s    (   t   __name__t
   __module__t   __doc__R#   R&   (    (    (    s   /usr/lib/python2.7/string.pyR   U   s   	t   _TemplateMetaclassc           B   s   e  Z d  Z d Ñ  Z RS(   s/  
    %(delim)s(?:
      (?P<escaped>%(delim)s) |   # Escape sequence of two delimiters
      (?P<named>%(id)s)      |   # delimiter and a Python identifier
      {(?P<braced>%(id)s)}   |   # delimiter and a braced identifier
      (?P<invalid>)              # Other ill-formed delimiter exprs
    )
    c         C   sÅ   t  t |  É j | | | É d | k r4 |  j } n* t j i t j |  j É d 6|  j d 6} t j | t j	 t j
 BÉ |  _ d  S(   Nt   patternt   delimt   id(   t   superR*   R#   R+   t   _ret   escapet	   delimitert	   idpatternt   compilet
   IGNORECASEt   VERBOSE(   t   clst   namet   basest   dctR+   (    (    s   /usr/lib/python2.7/string.pyR#   p   s    	(   R'   R(   R+   R#   (    (    (    s   /usr/lib/python2.7/string.pyR*   f   s   t   Templatec           B   sD   e  Z d  Z e Z d Z d Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 RS(   s.   A string class for supporting $-substitutions.t   $s   [_a-z][_a-z0-9]*c         C   s   | |  _  d  S(   N(   t   template(   R    R<   (    (    s   /usr/lib/python2.7/string.pyR#   É   s    c         C   s}   | j  d É } |  j |  j t É } | s: d } d } n) | t d j | d  É É } t | É } t d | | f É Ç d  S(   Nt   invalidi   R   iˇˇˇˇs.   Invalid placeholder in string: line %d, col %d(   t   startR<   t
   splitlinest   TrueR   R   R   (   R    t   moR   t   linest   colnot   lineno(    (    s   /usr/lib/python2.7/string.pyt   _invalidà   s    	c             s®   |  s t  d É Ç n  |  d |  d â }  t |  É d k rK t  d É Ç n  |  sZ | â  n& | rv t | |  d É â  n
 |  d â  á  á f d Ü  } à j j | à j É S(   Ns>   descriptor 'substitute' of 'Template' object needs an argumenti    i   s   Too many positional argumentsc            sñ   |  j  d É p |  j  d É } | d  k	 r? à  | } d | f S|  j  d É d  k	 r[ à j S|  j  d É d  k	 rÄ à j |  É n  t d à j É Ç d  S(   Nt   namedt   braceds   %st   escapedR=   s#   Unrecognized named group in pattern(   t   groupt   NoneR1   RE   R   R+   (   RA   RF   t   val(   t   mappingR    (    s   /usr/lib/python2.7/string.pyt   convert¢   s    
(   t	   TypeErrorR   R   R+   t   subR<   (   t   argst   kwsRM   (    (   RL   R    s   /usr/lib/python2.7/string.pyt
   substituteî   s    	
c             s®   |  s t  d É Ç n  |  d |  d â }  t |  É d k rK t  d É Ç n  |  sZ | â  n& | rv t | |  d É â  n
 |  d â  á  á f d Ü  } à j j | à j É S(   NsC   descriptor 'safe_substitute' of 'Template' object needs an argumenti    i   s   Too many positional argumentsc            s¨   |  j  d É p |  j  d É } | d  k	 r[ y d à  | f SWq[ t k
 rW |  j  É  SXn  |  j  d É d  k	 rw à j S|  j  d É d  k	 rñ |  j  É  St d à j É Ç d  S(   NRF   RG   s   %sRH   R=   s#   Unrecognized named group in pattern(   RI   RJ   R$   R1   R   R+   (   RA   RF   (   RL   R    (    s   /usr/lib/python2.7/string.pyRM   ¿   s    
(   RN   R   R   R+   RO   R<   (   RP   RQ   RM   (    (   RL   R    s   /usr/lib/python2.7/string.pyt   safe_substitute≤   s    	
(   R'   R(   R)   R*   t   __metaclass__R1   R2   R#   RE   RR   RS   (    (    (    s   /usr/lib/python2.7/string.pyR:   |   s   			c         C   s
   |  j  É  S(   sS   lower(s) -> string

    Return a copy of the string s converted to lowercase.

    (   t   lower(   R   (    (    s   /usr/lib/python2.7/string.pyRU   ﬁ   s    c         C   s
   |  j  É  S(   sS   upper(s) -> string

    Return a copy of the string s converted to uppercase.

    (   t   upper(   R   (    (    s   /usr/lib/python2.7/string.pyRV   Á   s    c         C   s
   |  j  É  S(   sÑ   swapcase(s) -> string

    Return a copy of the string s with upper case characters
    converted to lowercase and vice versa.

    (   t   swapcase(   R   (    (    s   /usr/lib/python2.7/string.pyRW      s    c         C   s   |  j  | É S(   s  strip(s [,chars]) -> string

    Return a copy of the string s with leading and trailing
    whitespace removed.
    If chars is given and not None, remove characters in chars instead.
    If chars is unicode, S will be converted to unicode before stripping.

    (   t   strip(   R   t   chars(    (    s   /usr/lib/python2.7/string.pyRX   ˙   s    	c         C   s   |  j  | É S(   sÆ   lstrip(s [,chars]) -> string

    Return a copy of the string s with leading whitespace removed.
    If chars is given and not None, remove characters in chars instead.

    (   t   lstrip(   R   RY   (    (    s   /usr/lib/python2.7/string.pyRZ     s    c         C   s   |  j  | É S(   sØ   rstrip(s [,chars]) -> string

    Return a copy of the string s with trailing whitespace removed.
    If chars is given and not None, remove characters in chars instead.

    (   t   rstrip(   R   RY   (    (    s   /usr/lib/python2.7/string.pyR[     s    c         C   s   |  j  | | É S(   sr  split(s [,sep [,maxsplit]]) -> list of strings

    Return a list of the words in the string s, using sep as the
    delimiter string.  If maxsplit is given, splits at no more than
    maxsplit places (resulting in at most maxsplit+1 words).  If sep
    is not specified or is None, any whitespace string is a separator.

    (split and splitfields are synonymous)

    (   R   (   R   R   t   maxsplit(    (    s   /usr/lib/python2.7/string.pyR     s    c         C   s   |  j  | | É S(   sW  rsplit(s [,sep [,maxsplit]]) -> list of strings

    Return a list of the words in the string s, using sep as the
    delimiter string, starting at the end of the string and working
    to the front.  If maxsplit is given, at most maxsplit splits are
    done. If sep is not specified or is None, any whitespace string
    is a separator.
    (   t   rsplit(   R   R   R\   (    (    s   /usr/lib/python2.7/string.pyR]   *  s    	R   c         C   s   | j  |  É S(   s÷   join(list [,sep]) -> string

    Return a string composed of the words in list, with
    intervening occurrences of sep.  The default separator is a
    single space.

    (joinfields and join are synonymous)

    (   R   (   t   wordsR   (    (    s   /usr/lib/python2.7/string.pyR   6  s    
c         G   s   |  j  | å  S(   sp   index(s, sub [,start [,end]]) -> int

    Like find but raises ValueError when the substring is not found.

    (   t   index(   R   RP   (    (    s   /usr/lib/python2.7/string.pyR_   D  s    c         G   s   |  j  | å  S(   sr   rindex(s, sub [,start [,end]]) -> int

    Like rfind but raises ValueError when the substring is not found.

    (   t   rindex(   R   RP   (    (    s   /usr/lib/python2.7/string.pyR`   M  s    c         G   s   |  j  | å  S(   s»   count(s, sub[, start[,end]]) -> int

    Return the number of occurrences of substring sub in string
    s[start:end].  Optional arguments start and end are
    interpreted as in slice notation.

    (   t   count(   R   RP   (    (    s   /usr/lib/python2.7/string.pyRa   V  s    c         G   s   |  j  | å  S(   s  find(s, sub [,start [,end]]) -> in

    Return the lowest index in s where substring sub is found,
    such that sub is contained within s[start,end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.

    (   t   find(   R   RP   (    (    s   /usr/lib/python2.7/string.pyRb   a  s    
c         G   s   |  j  | å  S(   s  rfind(s, sub [,start [,end]]) -> int

    Return the highest index in s where substring sub is found,
    such that sub is contained within s[start,end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.

    (   t   rfind(   R   RP   (    (    s   /usr/lib/python2.7/string.pyRc   n  s    
c         C   s
   t  |  É S(   sY   atof(s) -> float

    Return the floating point number represented by the string s.

    (   t   _float(   R   (    (    s   /usr/lib/python2.7/string.pyt   atofÄ  s    i
   c         C   s   t  |  | É S(   ss  atoi(s [,base]) -> int

    Return the integer represented by the string s in the given
    base, which defaults to 10.  The string s must consist of one
    or more digits, possibly preceded by a sign.  If base is 0, it
    is chosen from the leading characters of s, 0 for octal, 0x or
    0X for hexadecimal.  If base is 16, a preceding 0x or 0X is
    accepted.

    (   t   _int(   R   t   base(    (    s   /usr/lib/python2.7/string.pyt   atoiä  s    c         C   s   t  |  | É S(   s≥  atol(s [,base]) -> long

    Return the long integer represented by the string s in the
    given base, which defaults to 10.  The string s must consist
    of one or more digits, possibly preceded by a sign.  If base
    is 0, it is chosen from the leading characters of s, 0 for
    octal, 0x or 0X for hexadecimal.  If base is 16, a preceding
    0x or 0X is accepted.  A trailing L or l is not accepted,
    unless base is 0.

    (   t   _long(   R   Rg   (    (    s   /usr/lib/python2.7/string.pyt   atolô  s    c         G   s   |  j  | | å S(   sı   ljust(s, width[, fillchar]) -> string

    Return a left-justified version of s, in a field of the
    specified width, padded with spaces as needed.  The string is
    never truncated.  If specified the fillchar is used instead of spaces.

    (   t   ljust(   R   t   widthRP   (    (    s   /usr/lib/python2.7/string.pyRk   ©  s    c         G   s   |  j  | | å S(   sˆ   rjust(s, width[, fillchar]) -> string

    Return a right-justified version of s, in a field of the
    specified width, padded with spaces as needed.  The string is
    never truncated.  If specified the fillchar is used instead of spaces.

    (   t   rjust(   R   Rl   RP   (    (    s   /usr/lib/python2.7/string.pyRm   ¥  s    c         G   s   |  j  | | å S(   sÓ   center(s, width[, fillchar]) -> string

    Return a center version of s, in a field of the specified
    width. padded with spaces as needed.  The string is never
    truncated.  If specified the fillchar is used instead of spaces.

    (   t   center(   R   Rl   RP   (    (    s   /usr/lib/python2.7/string.pyRn   ø  s    c         C   s+   t  |  t É s t |  É }  n  |  j | É S(   s°   zfill(x, width) -> string

    Pad a numeric string x with zeros on the left, to fill a field
    of the specified width.  The string x is never truncated.

    (   t
   isinstancet
   basestringt   reprt   zfill(   R
   Rl   (    (    s   /usr/lib/python2.7/string.pyRr   Ã  s    i   c         C   s   |  j  | É S(   s◊   expandtabs(s [,tabsize]) -> string

    Return a copy of the string s with all tab characters replaced
    by the appropriate number of spaces, depending on the current
    column, and the tabsize (default 8).

    (   t
   expandtabs(   R   t   tabsize(    (    s   /usr/lib/python2.7/string.pyRs   Ÿ  s    c         C   s;   | s | d k r" |  j | | É S|  j | |  d  É Sd S(   sg  translate(s,table [,deletions]) -> string

    Return a copy of the string s, where all characters occurring
    in the optional argument deletions are removed, and the
    remaining characters have been mapped through the given
    translation table, which must be a string of length 256.  The
    deletions argument is not allowed for Unicode strings.

    i    N(   RJ   t	   translate(   R   t   tablet	   deletions(    (    s   /usr/lib/python2.7/string.pyRu   ‰  s    
c         C   s
   |  j  É  S(   so   capitalize(s) -> string

    Return a copy of the string s with only its first character
    capitalized.

    (   R   (   R   (    (    s   /usr/lib/python2.7/string.pyR   ˜  s    c         C   s   |  j  | | | É S(   s˜   replace (str, old, new[, maxreplace]) -> string

    Return a copy of string str with all occurrences of substring
    old replaced by new. If the optional argument maxreplace is
    given, only the first maxreplace occurrences are replaced.

    (   t   replace(   R   t   oldt   newt
   maxreplace(    (    s   /usr/lib/python2.7/string.pyRx     s    (   R   t	   lowercaset	   uppercaset
   whitespacet	   Formatterc           B   sY   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 RS(	   c          O   sî   |  s t  d É Ç n  |  d |  d } }  y |  d |  d } }  Wn; t k
 rÄ d | k rq | j d É } qÅ t  d É Ç n X| j | |  | É S(   Ns;   descriptor 'format' of 'Formatter' object needs an argumenti    i   t   format_strings@   format() missing 1 required positional argument: 'format_string'(   RN   t
   IndexErrort   popt   vformat(   RP   t   kwargsR    RÄ   (    (    s   /usr/lib/python2.7/string.pyt   format"  s    c         C   s;   t  É  } |  j | | | | d É } |  j | | | É | S(   Ni   (   t   sett   _vformatt   check_unused_args(   R    RÄ   RP   RÑ   t	   used_argst   result(    (    s   /usr/lib/python2.7/string.pyRÉ   1  s    	c         C   sÎ   | d k  r t  d É Ç n  g  } x∫ |  j | É D]© \ } } }	 }
 | rY | j | É n  | d  k	 r1 |  j | | | É \ } } | j | É |  j | |
 É } |  j |	 | | | | d É }	 | j |  j | |	 É É q1 q1 Wd j	 | É S(   Ni    s   Max string recursion exceededi   R   (
   R   t   parset   appendRJ   t	   get_fieldt   addt   convert_fieldRá   t   format_fieldR   (   R    RÄ   RP   RÑ   Râ   t   recursion_depthRä   t   literal_textt
   field_namet   format_spect
   conversiont   objt   arg_used(    (    s   /usr/lib/python2.7/string.pyRá   7  s     c         C   s)   t  | t t f É r | | S| | Sd  S(   N(   Ro   t   intt   long(   R    R%   RP   RÑ   (    (    s   /usr/lib/python2.7/string.pyt	   get_valueY  s    c         C   s   d  S(   N(    (   R    Râ   RP   RÑ   (    (    s   /usr/lib/python2.7/string.pyRà   `  s    c         C   s   t  | | É S(   N(   RÖ   (   R    t   valueRî   (    (    s   /usr/lib/python2.7/string.pyRê   d  s    c         C   sU   | d  k r | S| d k r& t | É S| d k r< t | É St d j | É É Ç d  S(   NR   t   rs"   Unknown conversion specifier {0!s}(   RJ   t   strRq   R   RÖ   (   R    Rõ   Rï   (    (    s   /usr/lib/python2.7/string.pyRè   h  s    

c         C   s
   | j  É  S(   N(   t   _formatter_parser(   R    RÄ   (    (    s   /usr/lib/python2.7/string.pyRã   z  s    c   	      C   sj   | j  É  \ } } |  j | | | É } x6 | D]. \ } } | rR t | | É } q. | | } q. W| | f S(   N(   t   _formatter_field_name_splitRö   t   getattr(	   R    Rì   RP   RÑ   t   firstt   restRñ   t   is_attrR   (    (    s   /usr/lib/python2.7/string.pyRç   É  s    (   R'   R(   RÖ   RÉ   Rá   Rö   Rà   Rê   Rè   Rã   Rç   (    (    (    s   /usr/lib/python2.7/string.pyR   !  s   			"						(    (    (G   R)   R~   R|   R}   t   letterst   ascii_lowercaset   ascii_uppercaset   ascii_letterst   digitst	   hexdigitst	   octdigitst   punctuationt	   printableR   t   chrt   xranget   lRù   R   R   RJ   R   R   R   t   reR/   R   t   typeR*   R:   R   t   index_errort
   atoi_errort
   atof_errort
   atol_errorRU   RV   RW   RX   RZ   R[   R   t   splitfieldsR]   t
   joinfieldsR_   R`   Ra   Rb   Rc   t   floatRd   Rò   Rf   Rô   Ri   Re   Rh   Rj   Rk   Rm   Rn   Rr   Rs   Ru   R   Rx   t   stropt   ImportErrort   objectR   (    (    (    s   /usr/lib/python2.7/string.pyt   <module>   s|   

	\					

								
					
"
filename:/usr/lib/python2.7/distutils/unixccompiler.py
__doc__
"""distutils.unixccompiler

filename:/usr/lib/python2.7/distutils/versionpredicate.py
__doc__
"""Module for parsing and testing package version predicate strings.
"""

filename:/usr/lib/python2.7/distutils/__init__.py
__doc__
"""distutils

The main package for the Python Module Distribution Utilities.  Normally
used from a setup script as

   from distutils.core import setup

   setup (...)
"""

filename:/usr/lib/python2.7/distutils/archive_util.py
__doc__
"""distutils.archive_util

Utility functions for creating archive files (tarballs, zip files,
that sort of thing)."""

__revision__ = "$Id$"

import os
from warnings import warn
import sys

from distutils.errors import DistutilsExecError
from distutils.spawn import spawn
from distutils.dir_util import mkpath
from distutils import log

try:
    from pwd import getpwnam
except ImportError:
    getpwnam = None

try:
    from grp import getgrnam
except ImportError:
    getgrnam = None

def _get_gid(name):
    """Returns a gid, given a group name."""
    if getgrnam is None or name is None:
        return None
    try:
        result = getgrnam(name)
    except KeyError:
        result = None
    if result is not None:
        return result[2]
    return None

def _get_uid(name):
    """Returns an uid, given a user name."""
    if getpwnam is None or name is None:
        return None
    try:
        result = getpwnam(name)
    except KeyError:
        result = None
    if result is not None:
        return result[2]
    return None

def make_tarball(base_name, base_dir, compress="gzip", verbose=0, dry_run=0,
                 owner=None, group=None):
    """Create a (possibly compressed) tar file from all the files under
    'base_dir'.

    'compress' must be "gzip" (the default), "compress", "bzip2", or None.
    (compress will be deprecated in Python 3.2)

    'owner' and 'group' can be used to define an owner and a group for the
    archive that is being built. If not provided, the current owner and group
    will be used.

    The output tar file will be named 'base_dir' +  ".tar", possibly plus
    the appropriate compression extension (".gz", ".bz2" or ".Z").

    Returns the output filename.
    """
    tar_compression = {'gzip': 'gz', 'bzip2': 'bz2', None: '', 'compress': ''}
    compress_ext = {'gzip': '.gz', 'bzip2': '.bz2', 'compress': '.Z'}

    # flags for compression program, each element of list will be an argument
    if compress is not None and compress not in compress_ext.keys():
        raise ValueError, \
              ("bad value for 'compress': must be None, 'gzip', 'bzip2' "
               "or 'compress'")

    archive_name = base_name + '.tar'
    if compress != 'compress':
        archive_name += compress_ext.get(compress, '')

    mkpath(os.path.dirname(archive_name), dry_run=dry_run)

    # creating the tarball
    import tarfile  # late import so Python build itself doesn't break

    log.info('Creating tar archive')

    uid = _get_uid(owner)
    gid = _get_gid(group)

    def _set_uid_gid(tarinfo):
        if gid is not None:
            tarinfo.gid = gid
            tarinfo.gname = group
        if uid is not None:
            tarinfo.uid = uid
            tarinfo.uname = owner
        return tarinfo

    if not dry_run:
        tar = tarfile.open(archive_name, 'w|%s' % tar_compression[compress])
        try:
            tar.add(base_dir, filter=_set_uid_gid)
        finally:
            tar.close()

    # compression using `compress`
    if compress == 'compress':
        warn("'compress' will be deprecated.", PendingDeprecationWarning)
        # the option varies depending on the platform
        compressed_name = archive_name + compress_ext[compress]
        if sys.platform == 'win32':
            cmd = [compress, archive_name, compressed_name]
        else:
            cmd = [compress, '-f', archive_name]
        spawn(cmd, dry_run=dry_run)
        return compressed_name

    return archive_name

def make_zipfile(base_name, base_dir, verbose=0, dry_run=0):
    """Create a zip file from all the files under 'base_dir'.

    The output zip file will be named 'base_name' + ".zip".  Uses either the
    "zipfile" Python module (if available) or the InfoZIP "zip" utility
    (if installed and found on the default search path).  If neither tool is
    available, raises DistutilsExecError.  Returns the name of the output zip
    file.
    """
    try:
        import zipfile
    except ImportError:
        zipfile = None

    zip_filename = base_name + ".zip"
    mkpath(os.path.dirname(zip_filename), dry_run=dry_run)

    # If zipfile module is not available, try spawning an external
    # 'zip' command.
    if zipfile is None:
        if verbose:
            zipoptions = "-r"
        else:
            zipoptions = "-rq"

        try:
            spawn(["zip", zipoptions, zip_filename, base_dir],
                  dry_run=dry_run)
        except DistutilsExecError:
            # XXX really should distinguish between "couldn't find
            # external 'zip' command" and "zip failed".
            raise DistutilsExecError, \
                  ("unable to create zip file '%s': "
                   "could neither import the 'zipfile' module nor "
                   "find a standalone zip utility") % zip_filename

    else:
        log.info("creating '%s' and adding '%s' to it",
                 zip_filename, base_dir)

        if not dry_run:
            zip = zipfile.ZipFile(zip_filename, "w",
                                  compression=zipfile.ZIP_DEFLATED)

            for dirpath, dirnames, filenames in os.walk(base_dir):
                for name in filenames:
                    path = os.path.normpath(os.path.join(dirpath, name))
                    if os.path.isfile(path):
                        zip.write(path, path)
                        log.info("adding '%s'" % path)
            zip.close()

    return zip_filename

ARCHIVE_FORMATS = {
    'gztar': (make_tarball, [('compress', 'gzip')], "gzip'ed tar-file"),
    'bztar': (make_tarball, [('compress', 'bzip2')], "bzip2'ed tar-file"),
    'ztar':  (make_tarball, [('compress', 'compress')], "compressed tar file"),
    'tar':   (make_tarball, [('compress', None)], "uncompressed tar file"),
    'zip':   (make_zipfile, [],"ZIP file")
    }

def check_archive_formats(formats):
    """Returns the first format from the 'format' list that is unknown.

    If all formats are known, returns None
    """
    for format in formats:
        if format not in ARCHIVE_FORMATS:
            return format
    return None

def make_archive(base_name, format, root_dir=None, base_dir=None, verbose=0,
                 dry_run=0, owner=None, group=None):
    """Create an archive file (eg. zip or tar).

    'base_name' is the name of the file to create, minus any format-specific
    extension; 'format' is the archive format: one of "zip", "tar", "ztar",
    or "gztar".

    'root_dir' is a directory that will be the root directory of the
    archive; ie. we typically chdir into 'root_dir' before creating the
    archive.  'base_dir' is the directory where we start archiving from;
    ie. 'base_dir' will be the common prefix of all files and
    directories in the archive.  'root_dir' and 'base_dir' both default
    to the current directory.  Returns the name of the archive file.

    'owner' and 'group' are used when creating a tar archive. By default,
    uses the current owner and group.
    """
    save_cwd = os.getcwd()
    if root_dir is not None:
        log.debug("changing into '%s'", root_dir)
        base_name = os.path.abspath(base_name)
        if not dry_run:
            os.chdir(root_dir)

    if base_dir is None:
        base_dir = os.curdir

    kwargs = {'dry_run': dry_run}

    try:
        format_info = ARCHIVE_FORMATS[format]
    except KeyError:
        raise ValueError, "unknown archive format '%s'" % format

    func = format_info[0]
    for arg, val in format_info[1]:
        kwargs[arg] = val

    if format != 'zip':
        kwargs['owner'] = owner
        kwargs['group'] = group

    try:
        filename = func(base_name, base_dir, **kwargs)
    finally:
        if root_dir is not None:
            log.debug("changing back to '%s'", save_cwd)
            os.chdir(save_cwd)

    return filename

filename:/usr/lib/python2.7/distutils/errors.py
__doc__
"""distutils.errors

filename:/usr/lib/python2.7/distutils/cygwinccompiler.py
__doc__
"""distutils.cygwinccompiler

Provides the CygwinCCompiler class, a subclass of UnixCCompiler that
handles the Cygwin port of the GNU C compiler to Windows.  It also contains
the Mingw32CCompiler class which handles the mingw32 port of GCC (same as
cygwin in no-cygwin mode).
"""

filename:/usr/lib/python2.7/distutils/util.py
__doc__
"""distutils.util

Miscellaneous utility functions -- anything that doesn't fit into
one of the other *util.py modules.
"""

filename:/usr/lib/python2.7/distutils/emxccompiler.py
__doc__
"""distutils.emxccompiler

Provides the EMXCCompiler class, a subclass of UnixCCompiler that
handles the EMX port of the GNU C compiler to OS/2.
"""

filename:/usr/lib/python2.7/distutils/dep_util.py
__doc__
"""distutils.dep_util

Utility functions for simple, timestamp-based dependency of files
and groups of files; also, function based entirely on such
timestamp dependency analysis."""

__revision__ = "$Id$"

import os
from stat import ST_MTIME
from distutils.errors import DistutilsFileError

def newer(source, target):
    """Tells if the target is newer than the source.

    Return true if 'source' exists and is more recently modified than
    'target', or if 'source' exists and 'target' doesn't.

    Return false if both exist and 'target' is the same age or younger
    than 'source'. Raise DistutilsFileError if 'source' does not exist.

    Note that this test is not very accurate: files created in the same second
    will have the same "age".
    """
    if not os.path.exists(source):
        raise DistutilsFileError("file '%s' does not exist" %
                                 os.path.abspath(source))
    if not os.path.exists(target):
        return True

    return os.stat(source)[ST_MTIME] > os.stat(target)[ST_MTIME]

def newer_pairwise(sources, targets):
    """Walk two filename lists in parallel, testing if each source is newer
    than its corresponding target.  Return a pair of lists (sources,
    targets) where source is newer than target, according to the semantics
    of 'newer()'.
    """
    if len(sources) != len(targets):
        raise ValueError, "'sources' and 'targets' must be same length"

    # build a pair of lists (sources, targets) where  source is newer
    n_sources = []
    n_targets = []
    for source, target in zip(sources, targets):
        if newer(source, target):
            n_sources.append(source)
            n_targets.append(target)

    return n_sources, n_targets

def newer_group(sources, target, missing='error'):
    """Return true if 'target' is out-of-date with respect to any file
    listed in 'sources'.

    In other words, if 'target' exists and is newer
    than every file in 'sources', return false; otherwise return true.
    'missing' controls what we do when a source file is missing; the
    default ("error") is to blow up with an OSError from inside 'stat()';
    if it is "ignore", we silently drop any missing source files; if it is
    "newer", any missing source files make us assume that 'target' is
    out-of-date (this is handy in "dry-run" mode: it'll make you pretend to
    carry out commands that wouldn't work because inputs are missing, but
    that doesn't matter because you're not actually going to run the
    commands).
    """
    # If the target doesn't even exist, then it's definitely out-of-date.
    if not os.path.exists(target):
        return True

    # Otherwise we have to find out the hard way: if *any* source file
    # is more recent than 'target', then 'target' is out-of-date and
    # we can immediately return true.  If we fall through to the end
    # of the loop, then 'target' is up-to-date and we return false.
    target_mtime = os.stat(target)[ST_MTIME]

    for source in sources:
        if not os.path.exists(source):
            if missing == 'error':      # blow up when we stat() the file
                pass
            elif missing == 'ignore':   # missing source dropped from
                continue                #  target's dependency list
            elif missing == 'newer':    # missing source means target is
                return True             #  out-of-date

        if os.stat(source)[ST_MTIME] > target_mtime:
            return True

    return False

filename:/usr/lib/python2.7/distutils/dist.py
__doc__
"""distutils.dist

filename:/usr/lib/python2.7/distutils/fancy_getopt.py
__doc__
"""distutils.fancy_getopt

Wrapper around the standard getopt module that provides the following
additional features:
  * short and long options are tied together
  * options have help strings, so fancy_getopt could potentially
    create a complete usage summary
  * options set attributes of a passed-in object
"""

filename:/usr/lib/python2.7/distutils/text_file.py
__doc__
"""text_file

provides the TextFile class, which gives an interface to text files
that (optionally) takes care of stripping comments, ignoring blank
lines, and joining lines with backslashes."""

__revision__ = "$Id$"

import sys


class TextFile:

    """Provides a file-like object that takes care of all the things you
       commonly want to do when processing a text file that has some
       line-by-line syntax: strip comments (as long as "#" is your
       comment character), skip blank lines, join adjacent lines by
       escaping the newline (ie. backslash at end of line), strip
       leading and/or trailing whitespace.  All of these are optional
       and independently controllable.

       Provides a 'warn()' method so you can generate warning messages that
       report physical line number, even if the logical line in question
       spans multiple physical lines.  Also provides 'unreadline()' for
       implementing line-at-a-time lookahead.

       Constructor is called as:

           TextFile (filename=None, file=None, **options)

       It bombs (RuntimeError) if both 'filename' and 'file' are None;
       'filename' should be a string, and 'file' a file object (or
       something that provides 'readline()' and 'close()' methods).  It is
       recommended that you supply at least 'filename', so that TextFile
       can include it in warning messages.  If 'file' is not supplied,
       TextFile creates its own using the 'open()' builtin.

       The options are all boolean, and affect the value returned by
       'readline()':
         strip_comments [default: true]
           strip from "#" to end-of-line, as well as any whitespace
           leading up to the "#" -- unless it is escaped by a backslash
         lstrip_ws [default: false]
           strip leading whitespace from each line before returning it
         rstrip_ws [default: true]
           strip trailing whitespace (including line terminator!) from
           each line before returning it
         skip_blanks [default: true}
           skip lines that are empty *after* stripping comments and
           whitespace.  (If both lstrip_ws and rstrip_ws are false,
           then some lines may consist of solely whitespace: these will
           *not* be skipped, even if 'skip_blanks' is true.)
         join_lines [default: false]
           if a backslash is the last non-newline character on a line
           after stripping comments and whitespace, join the following line
           to it to form one "logical line"; if N consecutive lines end
           with a backslash, then N+1 physical lines will be joined to
           form one logical line.
         collapse_join [default: false]
           strip leading whitespace from lines that are joined to their
           predecessor; only matters if (join_lines and not lstrip_ws)

       Note that since 'rstrip_ws' can strip the trailing newline, the
       semantics of 'readline()' must differ from those of the builtin file
       object's 'readline()' method!  In particular, 'readline()' returns
       None for end-of-file: an empty string might just be a blank line (or
       an all-whitespace line), if 'rstrip_ws' is true but 'skip_blanks' is
       not."""

    default_options = { 'strip_comments': 1,
                        'skip_blanks':    1,
                        'lstrip_ws':      0,
                        'rstrip_ws':      1,
                        'join_lines':     0,
                        'collapse_join':  0,
                      }

    def __init__ (self, filename=None, file=None, **options):
        """Construct a new TextFile object.  At least one of 'filename'
           (a string) and 'file' (a file-like object) must be supplied.
           They keyword argument options are described above and affect
           the values returned by 'readline()'."""

        if filename is None and file is None:
            raise RuntimeError, \
                  "you must supply either or both of 'filename' and 'file'"

        # set values for all options -- either from client option hash
        # or fallback to default_options
        for opt in self.default_options.keys():
            if opt in options:
                setattr (self, opt, options[opt])

            else:
                setattr (self, opt, self.default_options[opt])

        # sanity check client option hash
        for opt in options.keys():
            if opt not in self.default_options:
                raise KeyError, "invalid TextFile option '%s'" % opt

        if file is None:
            self.open (filename)
        else:
            self.filename = filename
            self.file = file
            self.current_line = 0       # assuming that file is at BOF!

        # 'linebuf' is a stack of lines that will be emptied before we
        # actually read from the file; it's only populated by an
        # 'unreadline()' operation
        self.linebuf = []


    def open (self, filename):
        """Open a new file named 'filename'.  This overrides both the
           'filename' and 'file' arguments to the constructor."""

        self.filename = filename
        self.file = open (self.filename, 'r')
        self.current_line = 0


    def close (self):
        """Close the current file and forget everything we know about it
           (filename, current line number)."""
        file = self.file
        self.file = None
        self.filename = None
        self.current_line = None
        file.close()


    def gen_error (self, msg, line=None):
        outmsg = []
        if line is None:
            line = self.current_line
        outmsg.append(self.filename + ", ")
        if isinstance(line, (list, tuple)):
            outmsg.append("lines %d-%d: " % tuple (line))
        else:
            outmsg.append("line %d: " % line)
        outmsg.append(str(msg))
        return ''.join(outmsg)


    def error (self, msg, line=None):
        raise ValueError, "error: " + self.gen_error(msg, line)

    def warn (self, msg, line=None):
        """Print (to stderr) a warning message tied to the current logical
           line in the current file.  If the current logical line in the
           file spans multiple physical lines, the warning refers to the
           whole range, eg. "lines 3-5".  If 'line' supplied, it overrides
           the current line number; it may be a list or tuple to indicate a
           range of physical lines, or an integer for a single physical
           line."""
        sys.stderr.write("warning: " + self.gen_error(msg, line) + "\n")


    def readline (self):
        """Read and return a single logical line from the current file (or
           from an internal buffer if lines have previously been "unread"
           with 'unreadline()').  If the 'join_lines' option is true, this
           may involve reading multiple physical lines concatenated into a
           single string.  Updates the current line number, so calling
           'warn()' after 'readline()' emits a warning about the physical
           line(s) just read.  Returns None on end-of-file, since the empty
           string can occur if 'rstrip_ws' is true but 'strip_blanks' is
           not."""

        # If any "unread" lines waiting in 'linebuf', return the top
        # one.  (We don't actually buffer read-ahead data -- lines only
        # get put in 'linebuf' if the client explicitly does an
        # 'unreadline()'.
        if self.linebuf:
            line = self.linebuf[-1]
            del self.linebuf[-1]
            return line

        buildup_line = ''

        while 1:
            # read the line, make it None if EOF
            line = self.file.readline()
            if line == '': line = None

            if self.strip_comments and line:

                # Look for the first "#" in the line.  If none, never
                # mind.  If we find one and it's the first character, or
                # is not preceded by "\", then it starts a comment --
                # strip the comment, strip whitespace before it, and
                # carry on.  Otherwise, it's just an escaped "#", so
                # unescape it (and any other escaped "#"'s that might be
                # lurking in there) and otherwise leave the line alone.

                pos = line.find("#")
                if pos == -1:           # no "#" -- no comments
                    pass

                # It's definitely a comment -- either "#" is the first
                # character, or it's elsewhere and unescaped.
                elif pos == 0 or line[pos-1] != "\\":
                    # Have to preserve the trailing newline, because it's
                    # the job of a later step (rstrip_ws) to remove it --
                    # and if rstrip_ws is false, we'd better preserve it!
                    # (NB. this means that if the final line is all comment
                    # and has no trailing newline, we will think that it's
                    # EOF; I think that's OK.)
                    eol = (line[-1] == '\n') and '\n' or ''
                    line = line[0:pos] + eol

                    # If all that's left is whitespace, then skip line
                    # *now*, before we try to join it to 'buildup_line' --
                    # that way constructs like
                    #   hello \\
                    #   # comment that should be ignored
                    #   there
                    # result in "hello there".
                    if line.strip() == "":
                        continue

                else:                   # it's an escaped "#"
                    line = line.replace("\\#", "#")


            # did previous line end with a backslash? then accumulate
            if self.join_lines and buildup_line:
                # oops: end of file
                if line is None:
                    self.warn ("continuation line immediately precedes "
                               "end-of-file")
                    return buildup_line

                if self.collapse_join:
                    line = line.lstrip()
                line = buildup_line + line

                # careful: pay attention to line number when incrementing it
                if isinstance(self.current_line, list):
                    self.current_line[1] = self.current_line[1] + 1
                else:
                    self.current_line = [self.current_line,
                                         self.current_line+1]
            # just an ordinary line, read it as usual
            else:
                if line is None:        # eof
                    return None

                # still have to be careful about incrementing the line number!
                if isinstance(self.current_line, list):
                    self.current_line = self.current_line[1] + 1
                else:
                    self.current_line = self.current_line + 1


            # strip whitespace however the client wants (leading and
            # trailing, or one or the other, or neither)
            if self.lstrip_ws and self.rstrip_ws:
                line = line.strip()
            elif self.lstrip_ws:
                line = line.lstrip()
            elif self.rstrip_ws:
                line = line.rstrip()

            # blank line (whether we rstrip'ed or not)? skip to next line
            # if appropriate
            if (line == '' or line == '\n') and self.skip_blanks:
                continue

            if self.join_lines:
                if line[-1] == '\\':
                    buildup_line = line[:-1]
                    continue

                if line[-2:] == '\\\n':
                    buildup_line = line[0:-2] + '\n'
                    continue

            # well, I guess there's some actual content there: return it
            return line

    # readline ()


    def readlines (self):
        """Read and return the list of all logical lines remaining in the
           current file."""

        lines = []
        while 1:
            line = self.readline()
            if line is None:
                return lines
            lines.append (line)


    def unreadline (self, line):
        """Push 'line' (a string) onto an internal buffer that will be
           checked by future 'readline()' calls.  Handy for implementing
           a parser with line-at-a-time lookahead."""

        self.linebuf.append (line)

filename:/usr/lib/python2.7/distutils/filelist.py
__doc__
"""distutils.filelist

filename:/usr/lib/python2.7/distutils/sysconfig.py
__doc__
"""Provide access to Python's configuration information.  The specific
configuration variables available depend heavily on the platform and
configuration.  The values may be retrieved using
get_config_var(name), and the list of variables is available via
get_config_vars().keys().  Additional convenience functions are also
available.

Written by:   Fred L. Drake, Jr.
Email:        <fdrake@acm.org>
"""

filename:/usr/lib/python2.7/distutils/cmd.py
__doc__
"""distutils.cmd

Provides the Command class, the base class for the command classes
in the distutils.command package.
"""

filename:/usr/lib/python2.7/distutils/command/__init__.py
__doc__
"""distutils.command

Package containing implementation of all the standard Distutils
commands."""

__revision__ = "$Id$"

__all__ = ['build',
           'build_py',
           'build_ext',
           'build_clib',
           'build_scripts',
           'clean',
           'install',
           'install_lib',
           'install_headers',
           'install_scripts',
           'install_data',
           'sdist',
           'register',
           'bdist',
           'bdist_dumb',
           'bdist_rpm',
           'bdist_wininst',
           'upload',
           'check',
           # These two are reserved for future use:
           #'bdist_sdux',
           #'bdist_pkgtool',
           # Note:
           # bdist_packager is not included because it only provides
           # an abstract base class
          ]

filename:/usr/lib/python2.7/distutils/command/bdist_msi.py
__doc__
# -*- coding: iso-8859-1 -*-
# Copyright (C) 2005, 2006 Martin von Lˆwis
# Licensed to PSF under a Contributor Agreement.
# The bdist_wininst command proper
# based on bdist_wininst
"""

filename:/usr/lib/python2.7/distutils/command/install.py
__doc__
"""distutils.command.install

Implements the Distutils 'install' command."""

from distutils import log

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id$"

import sys, os, string
from types import *
from distutils.core import Command
from distutils.debug import DEBUG
from distutils.sysconfig import get_config_vars
from distutils.errors import DistutilsPlatformError
from distutils.file_util import write_file
from distutils.util import convert_path, subst_vars, change_root
from distutils.util import get_platform
from distutils.errors import DistutilsOptionError
from site import USER_BASE
from site import USER_SITE


if sys.version < "2.2":
    WINDOWS_SCHEME = {
        'purelib': '$base',
        'platlib': '$base',
        'headers': '$base/Include/$dist_name',
        'scripts': '$base/Scripts',
        'data'   : '$base',
    }
else:
    WINDOWS_SCHEME = {
        'purelib': '$base/Lib/site-packages',
        'platlib': '$base/Lib/site-packages',
        'headers': '$base/Include/$dist_name',
        'scripts': '$base/Scripts',
        'data'   : '$base',
    }

INSTALL_SCHEMES = {
    'unix_prefix': {
        'purelib': '$base/lib/python$py_version_short/site-packages',
        'platlib': '$platbase/lib/python$py_version_short/site-packages',
        'headers': '$base/include/python$py_version_short/$dist_name',
        'scripts': '$base/bin',
        'data'   : '$base',
        },
    'unix_local': {
        'purelib': '$base/local/lib/python$py_version_short/dist-packages',
        'platlib': '$platbase/local/lib/python$py_version_short/dist-packages',
        'headers': '$base/local/include/python$py_version_short/$dist_name',
        'scripts': '$base/local/bin',
        'data'   : '$base/local',
        },
    'deb_system': {
        'purelib': '$base/lib/python$py_version_short/dist-packages',
        'platlib': '$platbase/lib/python$py_version_short/dist-packages',
        'headers': '$base/include/python$py_version_short/$dist_name',
        'scripts': '$base/bin',
        'data'   : '$base',
        },
    'unix_home': {
        'purelib': '$base/lib/python',
        'platlib': '$base/lib/python',
        'headers': '$base/include/python/$dist_name',
        'scripts': '$base/bin',
        'data'   : '$base',
        },
    'unix_user': {
        'purelib': '$usersite',
        'platlib': '$usersite',
        'headers': '$userbase/include/python$py_version_short/$dist_name',
        'scripts': '$userbase/bin',
        'data'   : '$userbase',
        },
    'nt': WINDOWS_SCHEME,
    'nt_user': {
        'purelib': '$usersite',
        'platlib': '$usersite',
        'headers': '$userbase/Python$py_version_nodot/Include/$dist_name',
        'scripts': '$userbase/Scripts',
        'data'   : '$userbase',
        },
    'os2': {
        'purelib': '$base/Lib/site-packages',
        'platlib': '$base/Lib/site-packages',
        'headers': '$base/Include/$dist_name',
        'scripts': '$base/Scripts',
        'data'   : '$base',
        },
    'os2_home': {
        'purelib': '$usersite',
        'platlib': '$usersite',
        'headers': '$userbase/include/python$py_version_short/$dist_name',
        'scripts': '$userbase/bin',
        'data'   : '$userbase',
        },
    }

# The keys to an installation scheme; if any new types of files are to be
# installed, be sure to add an entry to every installation scheme above,
# and to SCHEME_KEYS here.
SCHEME_KEYS = ('purelib', 'platlib', 'headers', 'scripts', 'data')


class install (Command):

    description = "install everything from build directory"

    user_options = [
        # Select installation scheme and set base director(y|ies)
        ('prefix=', None,
         "installation prefix"),
        ('exec-prefix=', None,
         "(Unix only) prefix for platform-specific files"),
        ('home=', None,
         "(Unix only) home directory to install under"),
        ('user', None,
         "install in user site-package '%s'" % USER_SITE),

        # Or, just set the base director(y|ies)
        ('install-base=', None,
         "base installation directory (instead of --prefix or --home)"),
        ('install-platbase=', None,
         "base installation directory for platform-specific files " +
         "(instead of --exec-prefix or --home)"),
        ('root=', None,
         "install everything relative to this alternate root directory"),

        # Or, explicitly set the installation scheme
        ('install-purelib=', None,
         "installation directory for pure Python module distributions"),
        ('install-platlib=', None,
         "installation directory for non-pure module distributions"),
        ('install-lib=', None,
         "installation directory for all module distributions " +
         "(overrides --install-purelib and --install-platlib)"),

        ('install-headers=', None,
         "installation directory for C/C++ headers"),
        ('install-scripts=', None,
         "installation directory for Python scripts"),
        ('install-data=', None,
         "installation directory for data files"),

        # Byte-compilation options -- see install_lib.py for details, as
        # these are duplicated from there (but only install_lib does
        # anything with them).
        ('compile', 'c', "compile .py to .pyc [default]"),
        ('no-compile', None, "don't compile .py files"),
        ('optimize=', 'O',
         "also compile with optimization: -O1 for \"python -O\", "
         "-O2 for \"python -OO\", and -O0 to disable [default: -O0]"),

        # Miscellaneous control options
        ('force', 'f',
         "force installation (overwrite any existing files)"),
        ('skip-build', None,
         "skip rebuilding everything (for testing/debugging)"),

        # Where to install documentation (eventually!)
        #('doc-format=', None, "format of documentation to generate"),
        #('install-man=', None, "directory for Unix man pages"),
        #('install-html=', None, "directory for HTML documentation"),
        #('install-info=', None, "directory for GNU info files"),

        ('record=', None,
         "filename in which to record list of installed files"),

        ('install-layout=', None,
         "installation layout to choose (known values: deb, unix)"),
        ]

    boolean_options = ['compile', 'force', 'skip-build', 'user']
    negative_opt = {'no-compile' : 'compile'}


    def initialize_options (self):

        # High-level options: these select both an installation base
        # and scheme.
        self.prefix = None
        self.exec_prefix = None
        self.home = None
        self.user = 0
        self.prefix_option = None

        # These select only the installation base; it's up to the user to
        # specify the installation scheme (currently, that means supplying
        # the --install-{platlib,purelib,scripts,data} options).
        self.install_base = None
        self.install_platbase = None
        self.root = None

        # These options are the actual installation directories; if not
        # supplied by the user, they are filled in using the installation
        # scheme implied by prefix/exec-prefix/home and the contents of
        # that installation scheme.
        self.install_purelib = None     # for pure module distributions
        self.install_platlib = None     # non-pure (dists w/ extensions)
        self.install_headers = None     # for C/C++ headers
        self.install_lib = None         # set to either purelib or platlib
        self.install_scripts = None
        self.install_data = None
        self.install_userbase = USER_BASE
        self.install_usersite = USER_SITE

        # enable custom installation, known values: deb
        self.install_layout = None

        self.compile = None
        self.optimize = None

        # These two are for putting non-packagized distributions into their
        # own directory and creating a .pth file if it makes sense.
        # 'extra_path' comes from the setup file; 'install_path_file' can
        # be turned off if it makes no sense to install a .pth file.  (But
        # better to install it uselessly than to guess wrong and not
        # install it when it's necessary and would be used!)  Currently,
        # 'install_path_file' is always true unless some outsider meddles
        # with it.
        self.extra_path = None
        self.install_path_file = 1

        # 'force' forces installation, even if target files are not
        # out-of-date.  'skip_build' skips running the "build" command,
        # handy if you know it's not necessary.  'warn_dir' (which is *not*
        # a user option, it's just there so the bdist_* commands can turn
        # it off) determines whether we warn about installing to a
        # directory not in sys.path.
        self.force = 0
        self.skip_build = 0
        self.warn_dir = 1

        # These are only here as a conduit from the 'build' command to the
        # 'install_*' commands that do the real work.  ('build_base' isn't
        # actually used anywhere, but it might be useful in future.)  They
        # are not user options, because if the user told the install
        # command where the build directory is, that wouldn't affect the
        # build command.
        self.build_base = None
        self.build_lib = None

        # Not defined yet because we don't know anything about
        # documentation yet.
        #self.install_man = None
        #self.install_html = None
        #self.install_info = None

        self.record = None


    # -- Option finalizing methods -------------------------------------
    # (This is rather more involved than for most commands,
    # because this is where the policy for installing third-
    # party Python modules on various platforms given a wide
    # array of user input is decided.  Yes, it's quite complex!)

    def finalize_options (self):

        # This method (and its pliant slaves, like 'finalize_unix()',
        # 'finalize_other()', and 'select_scheme()') is where the default
        # installation directories for modules, extension modules, and
        # anything else we care to install from a Python module
        # distribution.  Thus, this code makes a pretty important policy
        # statement about how third-party stuff is added to a Python
        # installation!  Note that the actual work of installation is done
        # by the relatively simple 'install_*' commands; they just take
        # their orders from the installation directory options determined
        # here.

        # Check for errors/inconsistencies in the options; first, stuff
        # that's wrong on any platform.

        if ((self.prefix or self.exec_prefix or self.home) and
            (self.install_base or self.install_platbase)):
            raise DistutilsOptionError, \
                  ("must supply either prefix/exec-prefix/home or " +
                   "install-base/install-platbase -- not both")

        if self.home and (self.prefix or self.exec_prefix):
            raise DistutilsOptionError, \
                  "must supply either home or prefix/exec-prefix -- not both"

        if self.user and (self.prefix or self.exec_prefix or self.home or
                self.install_base or self.install_platbase):
            raise DistutilsOptionError("can't combine user with prefix, "
                                       "exec_prefix/home, or install_(plat)base")

        # Next, stuff that's wrong (or dubious) only on certain platforms.
        if os.name != "posix":
            if self.exec_prefix:
                self.warn("exec-prefix option ignored on this platform")
                self.exec_prefix = None

        # Now the interesting logic -- so interesting that we farm it out
        # to other methods.  The goal of these methods is to set the final
        # values for the install_{lib,scripts,data,...}  options, using as
        # input a heady brew of prefix, exec_prefix, home, install_base,
        # install_platbase, user-supplied versions of
        # install_{purelib,platlib,lib,scripts,data,...}, and the
        # INSTALL_SCHEME dictionary above.  Phew!

        self.dump_dirs("pre-finalize_{unix,other}")

        if os.name == 'posix':
            self.finalize_unix()
        else:
            self.finalize_other()

        self.dump_dirs("post-finalize_{unix,other}()")

        # Expand configuration variables, tilde, etc. in self.install_base
        # and self.install_platbase -- that way, we can use $base or
        # $platbase in the other installation directories and not worry
        # about needing recursive variable expansion (shudder).

        py_version = (string.split(sys.version))[0]
        (prefix, exec_prefix) = get_config_vars('prefix', 'exec_prefix')
        self.config_vars = {'dist_name': self.distribution.get_name(),
                            'dist_version': self.distribution.get_version(),
                            'dist_fullname': self.distribution.get_fullname(),
                            'py_version': py_version,
                            'py_version_short': py_version[0:3],
                            'py_version_nodot': py_version[0] + py_version[2],
                            'sys_prefix': prefix,
                            'prefix': prefix,
                            'sys_exec_prefix': exec_prefix,
                            'exec_prefix': exec_prefix,
                            'userbase': self.install_userbase,
                            'usersite': self.install_usersite,
                           }
        self.expand_basedirs()

        self.dump_dirs("post-expand_basedirs()")

        # Now define config vars for the base directories so we can expand
        # everything else.
        self.config_vars['base'] = self.install_base
        self.config_vars['platbase'] = self.install_platbase

        if DEBUG:
            from pprint import pprint
            print "config vars:"
            pprint(self.config_vars)

        # Expand "~" and configuration variables in the installation
        # directories.
        self.expand_dirs()

        self.dump_dirs("post-expand_dirs()")

        # Create directories in the home dir:
        if self.user:
            self.create_home_path()

        # Pick the actual directory to install all modules to: either
        # install_purelib or install_platlib, depending on whether this
        # module distribution is pure or not.  Of course, if the user
        # already specified install_lib, use their selection.
        if self.install_lib is None:
            if self.distribution.ext_modules: # has extensions: non-pure
                self.install_lib = self.install_platlib
            else:
                self.install_lib = self.install_purelib


        # Convert directories from Unix /-separated syntax to the local
        # convention.
        self.convert_paths('lib', 'purelib', 'platlib',
                           'scripts', 'data', 'headers',
                           'userbase', 'usersite')

        # Well, we're not actually fully completely finalized yet: we still
        # have to deal with 'extra_path', which is the hack for allowing
        # non-packagized module distributions (hello, Numerical Python!) to
        # get their own directories.
        self.handle_extra_path()
        self.install_libbase = self.install_lib # needed for .pth file
        self.install_lib = os.path.join(self.install_lib, self.extra_dirs)

        # If a new root directory was supplied, make all the installation
        # dirs relative to it.
        if self.root is not None:
            self.change_roots('libbase', 'lib', 'purelib', 'platlib',
                              'scripts', 'data', 'headers')

        self.dump_dirs("after prepending root")

        # Find out the build directories, ie. where to install from.
        self.set_undefined_options('build',
                                   ('build_base', 'build_base'),
                                   ('build_lib', 'build_lib'))

        # Punt on doc directories for now -- after all, we're punting on
        # documentation completely!

    # finalize_options ()


    def dump_dirs (self, msg):
        if DEBUG:
            from distutils.fancy_getopt import longopt_xlate
            print msg + ":"
            for opt in self.user_options:
                opt_name = opt[0]
                if opt_name[-1] == "=":
                    opt_name = opt_name[0:-1]
                if opt_name in self.negative_opt:
                    opt_name = string.translate(self.negative_opt[opt_name],
                                                longopt_xlate)
                    val = not getattr(self, opt_name)
                else:
                    opt_name = string.translate(opt_name, longopt_xlate)
                    val = getattr(self, opt_name)
                print "  %s: %s" % (opt_name, val)


    def finalize_unix (self):

        if self.install_base is not None or self.install_platbase is not None:
            if ((self.install_lib is None and
                 self.install_purelib is None and
                 self.install_platlib is None) or
                self.install_headers is None or
                self.install_scripts is None or
                self.install_data is None):
                raise DistutilsOptionError, \
                      ("install-base or install-platbase supplied, but "
                      "installation scheme is incomplete")
            return

        if self.user:
            if self.install_userbase is None:
                raise DistutilsPlatformError(
                    "User base directory is not specified")
            self.install_base = self.install_platbase = self.install_userbase
            self.select_scheme("unix_user")
        elif self.home is not None:
            self.install_base = self.install_platbase = self.home
            self.select_scheme("unix_home")
        else:
            self.prefix_option = self.prefix
            if self.prefix is None:
                if self.exec_prefix is not None:
                    raise DistutilsOptionError, \
                          "must not supply exec-prefix without prefix"

                self.prefix = os.path.normpath(sys.prefix)
                self.exec_prefix = os.path.normpath(sys.exec_prefix)

            else:
                if self.exec_prefix is None:
                    self.exec_prefix = self.prefix

            self.install_base = self.prefix
            self.install_platbase = self.exec_prefix
            if self.install_layout:
                if self.install_layout.lower() in ['deb']:
                    self.select_scheme("deb_system")
                elif self.install_layout.lower() in ['posix', 'unix']:
                    self.select_scheme("unix_prefix")
                else:
                    raise DistutilsOptionError(
                        "unknown value for --install-layout")
            elif (self.prefix_option and os.path.normpath(self.prefix) != '/usr/local') \
                    or 'PYTHONUSERBASE' in os.environ \
                    or 'real_prefix' in sys.__dict__:
                self.select_scheme("unix_prefix")
            else:
                if os.path.normpath(self.prefix) == '/usr/local':
                    self.select_scheme("deb_system")
                else:
                    self.select_scheme("unix_local")

    # finalize_unix ()


    def finalize_other (self):          # Windows and Mac OS for now

        if self.user:
            if self.install_userbase is None:
                raise DistutilsPlatformError(
                    "User base directory is not specified")
            self.install_base = self.install_platbase = self.install_userbase
            self.select_scheme(os.name + "_user")
        elif self.home is not None:
            self.install_base = self.install_platbase = self.home
            self.select_scheme("unix_home")
        else:
            if self.prefix is None:
                self.prefix = os.path.normpath(sys.prefix)

            self.install_base = self.install_platbase = self.prefix
            try:
                self.select_scheme(os.name)
            except KeyError:
                raise DistutilsPlatformError, \
                      "I don't know how to install stuff on '%s'" % os.name

    # finalize_other ()


    def select_scheme (self, name):
        # it's the caller's problem if they supply a bad name!
        scheme = INSTALL_SCHEMES[name]
        for key in SCHEME_KEYS:
            attrname = 'install_' + key
            if getattr(self, attrname) is None:
                setattr(self, attrname, scheme[key])


    def _expand_attrs (self, attrs):
        for attr in attrs:
            val = getattr(self, attr)
            if val is not None:
                if os.name == 'posix' or os.name == 'nt':
                    val = os.path.expanduser(val)
                val = subst_vars(val, self.config_vars)
                setattr(self, attr, val)


    def expand_basedirs (self):
        self._expand_attrs(['install_base',
                            'install_platbase',
                            'root'])

    def expand_dirs (self):
        self._expand_attrs(['install_purelib',
                            'install_platlib',
                            'install_lib',
                            'install_headers',
                            'install_scripts',
                            'install_data',])


    def convert_paths (self, *names):
        for name in names:
            attr = "install_" + name
            setattr(self, attr, convert_path(getattr(self, attr)))


    def handle_extra_path (self):

        if self.extra_path is None:
            self.extra_path = self.distribution.extra_path

        if self.extra_path is not None:
            if type(self.extra_path) is StringType:
                self.extra_path = string.split(self.extra_path, ',')

            if len(self.extra_path) == 1:
                path_file = extra_dirs = self.extra_path[0]
            elif len(self.extra_path) == 2:
                (path_file, extra_dirs) = self.extra_path
            else:
                raise DistutilsOptionError, \
                      ("'extra_path' option must be a list, tuple, or "
                      "comma-separated string with 1 or 2 elements")

            # convert to local form in case Unix notation used (as it
            # should be in setup scripts)
            extra_dirs = convert_path(extra_dirs)

        else:
            path_file = None
            extra_dirs = ''

        # XXX should we warn if path_file and not extra_dirs? (in which
        # case the path file would be harmless but pointless)
        self.path_file = path_file
        self.extra_dirs = extra_dirs

    # handle_extra_path ()


    def change_roots (self, *names):
        for name in names:
            attr = "install_" + name
            setattr(self, attr, change_root(self.root, getattr(self, attr)))

    def create_home_path(self):
        """Create directories under ~
        """
        if not self.user:
            return
        home = convert_path(os.path.expanduser("~"))
        for name, path in self.config_vars.iteritems():
            if path.startswith(home) and not os.path.isdir(path):
                self.debug_print("os.makedirs('%s', 0700)" % path)
                os.makedirs(path, 0700)

    # -- Command execution methods -------------------------------------

    def run (self):

        # Obviously have to build before we can install
        if not self.skip_build:
            self.run_command('build')
            # If we built for any other platform, we can't install.
            build_plat = self.distribution.get_command_obj('build').plat_name
            # check warn_dir - it is a clue that the 'install' is happening
            # internally, and not to sys.path, so we don't check the platform
            # matches what we are running.
            if self.warn_dir and build_plat != get_platform():
                raise DistutilsPlatformError("Can't install when "
                                             "cross-compiling")

        # Run all sub-commands (at least those that need to be run)
        for cmd_name in self.get_sub_commands():
            self.run_command(cmd_name)

        if self.path_file:
            self.create_path_file()

        # write list of installed files, if requested.
        if self.record:
            outputs = self.get_outputs()
            if self.root:               # strip any package prefix
                root_len = len(self.root)
                for counter in xrange(len(outputs)):
                    outputs[counter] = outputs[counter][root_len:]
            self.execute(write_file,
                         (self.record, outputs),
                         "writing list of installed files to '%s'" %
                         self.record)

        sys_path = map(os.path.normpath, sys.path)
        sys_path = map(os.path.normcase, sys_path)
        install_lib = os.path.normcase(os.path.normpath(self.install_lib))
        if (self.warn_dir and
            not (self.path_file and self.install_path_file) and
            install_lib not in sys_path):
            log.debug(("modules installed to '%s', which is not in "
                       "Python's module search path (sys.path) -- "
                       "you'll have to change the search path yourself"),
                       self.install_lib)

    # run ()

    def create_path_file (self):
        filename = os.path.join(self.install_libbase,
                                self.path_file + ".pth")
        if self.install_path_file:
            self.execute(write_file,
                         (filename, [self.extra_dirs]),
                         "creating %s" % filename)
        else:
            self.warn("path file '%s' not created" % filename)


    # -- Reporting methods ---------------------------------------------

    def get_outputs (self):
        # Assemble the outputs of all the sub-commands.
        outputs = []
        for cmd_name in self.get_sub_commands():
            cmd = self.get_finalized_command(cmd_name)
            # Add the contents of cmd.get_outputs(), ensuring
            # that outputs doesn't contain duplicate entries
            for filename in cmd.get_outputs():
                if filename not in outputs:
                    outputs.append(filename)

        if self.path_file and self.install_path_file:
            outputs.append(os.path.join(self.install_libbase,
                                        self.path_file + ".pth"))

        return outputs

    def get_inputs (self):
        # XXX gee, this looks familiar ;-(
        inputs = []
        for cmd_name in self.get_sub_commands():
            cmd = self.get_finalized_command(cmd_name)
            inputs.extend(cmd.get_inputs())

        return inputs


    # -- Predicates for sub-command list -------------------------------

    def has_lib (self):
        """Return true if the current distribution has any Python
        modules to install."""
        return (self.distribution.has_pure_modules() or
                self.distribution.has_ext_modules())

    def has_headers (self):
        return self.distribution.has_headers()

    def has_scripts (self):
        return self.distribution.has_scripts()

    def has_data (self):
        return self.distribution.has_data_files()


    # 'sub_commands': a list of commands this command might have to run to
    # get its work done.  See cmd.py for more info.
    sub_commands = [('install_lib',     has_lib),
                    ('install_headers', has_headers),
                    ('install_scripts', has_scripts),
                    ('install_data',    has_data),
                    ('install_egg_info', lambda self:True),
                   ]

# class install

filename:/usr/lib/python2.7/distutils/command/install_data.py
__doc__
"""distutils.command.install_data

filename:/usr/lib/python2.7/distutils/command/upload.py
__doc__
"""distutils.command.upload

Implements the Distutils 'upload' subcommand (upload package to PyPI)."""
import os
import socket
import platform
from urllib2 import urlopen, Request, HTTPError
from base64 import standard_b64encode
import urlparse
import cStringIO as StringIO
from hashlib import md5

from distutils.errors import DistutilsError, DistutilsOptionError
from distutils.core import PyPIRCCommand
from distutils.spawn import spawn
from distutils import log

class upload(PyPIRCCommand):

    description = "upload binary package to PyPI"

    user_options = PyPIRCCommand.user_options + [
        ('sign', 's',
         'sign files to upload using gpg'),
        ('identity=', 'i', 'GPG identity used to sign files'),
        ]

    boolean_options = PyPIRCCommand.boolean_options + ['sign']

    def initialize_options(self):
        PyPIRCCommand.initialize_options(self)
        self.username = ''
        self.password = ''
        self.show_response = 0
        self.sign = False
        self.identity = None

    def finalize_options(self):
        PyPIRCCommand.finalize_options(self)
        if self.identity and not self.sign:
            raise DistutilsOptionError(
                "Must use --sign for --identity to have meaning"
            )
        config = self._read_pypirc()
        if config != {}:
            self.username = config['username']
            self.password = config['password']
            self.repository = config['repository']
            self.realm = config['realm']

        # getting the password from the distribution
        # if previously set by the register command
        if not self.password and self.distribution.password:
            self.password = self.distribution.password

    def run(self):
        if not self.distribution.dist_files:
            raise DistutilsOptionError("No dist file created in earlier command")
        for command, pyversion, filename in self.distribution.dist_files:
            self.upload_file(command, pyversion, filename)

    def upload_file(self, command, pyversion, filename):
        # Makes sure the repository URL is compliant
        schema, netloc, url, params, query, fragments = \
            urlparse.urlparse(self.repository)
        if params or query or fragments:
            raise AssertionError("Incompatible url %s" % self.repository)

        if schema not in ('http', 'https'):
            raise AssertionError("unsupported schema " + schema)

        # Sign if requested
        if self.sign:
            gpg_args = ["gpg", "--detach-sign", "-a", filename]
            if self.identity:
                gpg_args[2:2] = ["--local-user", self.identity]
            spawn(gpg_args,
                  dry_run=self.dry_run)

        # Fill in the data - send all the meta-data in case we need to
        # register a new release
        f = open(filename,'rb')
        try:
            content = f.read()
        finally:
            f.close()
        meta = self.distribution.metadata
        data = {
            # action
            ':action': 'file_upload',
            'protcol_version': '1',

            # identify release
            'name': meta.get_name(),
            'version': meta.get_version(),

            # file content
            'content': (os.path.basename(filename),content),
            'filetype': command,
            'pyversion': pyversion,
            'md5_digest': md5(content).hexdigest(),

            # additional meta-data
            'metadata_version' : '1.0',
            'summary': meta.get_description(),
            'home_page': meta.get_url(),
            'author': meta.get_contact(),
            'author_email': meta.get_contact_email(),
            'license': meta.get_licence(),
            'description': meta.get_long_description(),
            'keywords': meta.get_keywords(),
            'platform': meta.get_platforms(),
            'classifiers': meta.get_classifiers(),
            'download_url': meta.get_download_url(),
            # PEP 314
            'provides': meta.get_provides(),
            'requires': meta.get_requires(),
            'obsoletes': meta.get_obsoletes(),
            }
        comment = ''
        if command == 'bdist_rpm':
            dist, version, id = platform.dist()
            if dist:
                comment = 'built for %s %s' % (dist, version)
        elif command == 'bdist_dumb':
            comment = 'built for %s' % platform.platform(terse=1)
        data['comment'] = comment

        if self.sign:
            data['gpg_signature'] = (os.path.basename(filename) + ".asc",
                                     open(filename+".asc").read())

        # set up the authentication
        auth = "Basic " + standard_b64encode(self.username + ":" +
                                             self.password)

        # Build up the MIME payload for the POST data
        boundary = '--------------GHSKFJDLGDS7543FJKLFHRE75642756743254'
        sep_boundary = '\r\n--' + boundary
        end_boundary = sep_boundary + '--\r\n'
        body = StringIO.StringIO()
        for key, value in data.items():
            # handle multiple entries for the same name
            if not isinstance(value, list):
                value = [value]
            for value in value:
                if isinstance(value, tuple):
                    fn = ';filename="%s"' % value[0]
                    value = value[1]
                else:
                    fn = ""

                body.write(sep_boundary)
                body.write('\r\nContent-Disposition: form-data; name="%s"' % key)
                body.write(fn)
                body.write("\r\n\r\n")
                body.write(value)
                if value and value[-1] == '\r':
                    body.write('\n')  # write an extra newline (lurve Macs)
        body.write(end_boundary)
        body = body.getvalue()

        self.announce("Submitting %s to %s" % (filename, self.repository), log.INFO)

        # build the Request
        headers = {'Content-type':
                        'multipart/form-data; boundary=%s' % boundary,
                   'Content-length': str(len(body)),
                   'Authorization': auth}

        request = Request(self.repository, data=body,
                          headers=headers)
        # send the data
        try:
            result = urlopen(request)
            status = result.getcode()
            reason = result.msg
            if self.show_response:
                msg = '\n'.join(('-' * 75, result.read(), '-' * 75))
                self.announce(msg, log.INFO)
        except socket.error, e:
            self.announce(str(e), log.ERROR)
            raise
        except HTTPError, e:
            status = e.code
            reason = e.msg

        if status == 200:
            self.announce('Server response (%s): %s' % (status, reason),
                          log.INFO)
        else:
            msg = 'Upload failed (%s): %s' % (status, reason)
            self.announce(msg, log.ERROR)
            raise DistutilsError(msg)

filename:/usr/lib/python2.7/distutils/command/bdist_rpm.py
__doc__
"""distutils.command.bdist_rpm

filename:/usr/lib/python2.7/distutils/command/build_clib.py
__doc__
"""distutils.command.build_clib

Implements the Distutils 'build_clib' command, to build a C/C++ library
that is included in the module distribution and needed by an extension
module."""

__revision__ = "$Id$"


# XXX this module has *lots* of code ripped-off quite transparently from
# build_ext.py -- not surprisingly really, as the work required to build
# a static library from a collection of C source files is not really all
# that different from what's required to build a shared object file from
# a collection of C source files.  Nevertheless, I haven't done the
# necessary refactoring to account for the overlap in code between the
# two modules, mainly because a number of subtle details changed in the
# cut 'n paste.  Sigh.

import os
from distutils.core import Command
from distutils.errors import DistutilsSetupError
from distutils.sysconfig import customize_compiler
from distutils import log

def show_compilers():
    from distutils.ccompiler import show_compilers
    show_compilers()


class build_clib(Command):

    description = "build C/C++ libraries used by Python extensions"

    user_options = [
        ('build-clib=', 'b',
         "directory to build C/C++ libraries to"),
        ('build-temp=', 't',
         "directory to put temporary build by-products"),
        ('debug', 'g',
         "compile with debugging information"),
        ('force', 'f',
         "forcibly build everything (ignore file timestamps)"),
        ('compiler=', 'c',
         "specify the compiler type"),
        ]

    boolean_options = ['debug', 'force']

    help_options = [
        ('help-compiler', None,
         "list available compilers", show_compilers),
        ]

    def initialize_options(self):
        self.build_clib = None
        self.build_temp = None

        # List of libraries to build
        self.libraries = None

        # Compilation options for all libraries
        self.include_dirs = None
        self.define = None
        self.undef = None
        self.debug = None
        self.force = 0
        self.compiler = None


    def finalize_options(self):
        # This might be confusing: both build-clib and build-temp default
        # to build-temp as defined by the "build" command.  This is because
        # I think that C libraries are really just temporary build
        # by-products, at least from the point of view of building Python
        # extensions -- but I want to keep my options open.
        self.set_undefined_options('build',
                                   ('build_temp', 'build_clib'),
                                   ('build_temp', 'build_temp'),
                                   ('compiler', 'compiler'),
                                   ('debug', 'debug'),
                                   ('force', 'force'))

        self.libraries = self.distribution.libraries
        if self.libraries:
            self.check_library_list(self.libraries)

        if self.include_dirs is None:
            self.include_dirs = self.distribution.include_dirs or []
        if isinstance(self.include_dirs, str):
            self.include_dirs = self.include_dirs.split(os.pathsep)

        # XXX same as for build_ext -- what about 'self.define' and
        # 'self.undef' ?

    def run(self):
        if not self.libraries:
            return

        # Yech -- this is cut 'n pasted from build_ext.py!
        from distutils.ccompiler import new_compiler
        self.compiler = new_compiler(compiler=self.compiler,
                                     dry_run=self.dry_run,
                                     force=self.force)
        customize_compiler(self.compiler)

        if self.include_dirs is not None:
            self.compiler.set_include_dirs(self.include_dirs)
        if self.define is not None:
            # 'define' option is a list of (name,value) tuples
            for (name,value) in self.define:
                self.compiler.define_macro(name, value)
        if self.undef is not None:
            for macro in self.undef:
                self.compiler.undefine_macro(macro)

        self.build_libraries(self.libraries)


    def check_library_list(self, libraries):
        """Ensure that the list of libraries is valid.

        `library` is presumably provided as a command option 'libraries'.
        This method checks that it is a list of 2-tuples, where the tuples
        are (library_name, build_info_dict).

        Raise DistutilsSetupError if the structure is invalid anywhere;
        just returns otherwise.
        """
        if not isinstance(libraries, list):
            raise DistutilsSetupError, \
                  "'libraries' option must be a list of tuples"

        for lib in libraries:
            if not isinstance(lib, tuple) and len(lib) != 2:
                raise DistutilsSetupError, \
                      "each element of 'libraries' must a 2-tuple"

            name, build_info = lib

            if not isinstance(name, str):
                raise DistutilsSetupError, \
                      "first element of each tuple in 'libraries' " + \
                      "must be a string (the library name)"
            if '/' in name or (os.sep != '/' and os.sep in name):
                raise DistutilsSetupError, \
                      ("bad library name '%s': " +
                       "may not contain directory separators") % \
                      lib[0]

            if not isinstance(build_info, dict):
                raise DistutilsSetupError, \
                      "second element of each tuple in 'libraries' " + \
                      "must be a dictionary (build info)"

    def get_library_names(self):
        # Assume the library list is valid -- 'check_library_list()' is
        # called from 'finalize_options()', so it should be!
        if not self.libraries:
            return None

        lib_names = []
        for (lib_name, build_info) in self.libraries:
            lib_names.append(lib_name)
        return lib_names


    def get_source_files(self):
        self.check_library_list(self.libraries)
        filenames = []
        for (lib_name, build_info) in self.libraries:
            sources = build_info.get('sources')
            if sources is None or not isinstance(sources, (list, tuple)):
                raise DistutilsSetupError, \
                      ("in 'libraries' option (library '%s'), "
                       "'sources' must be present and must be "
                       "a list of source filenames") % lib_name

            filenames.extend(sources)
        return filenames

    def build_libraries(self, libraries):
        for (lib_name, build_info) in libraries:
            sources = build_info.get('sources')
            if sources is None or not isinstance(sources, (list, tuple)):
                raise DistutilsSetupError, \
                      ("in 'libraries' option (library '%s'), " +
                       "'sources' must be present and must be " +
                       "a list of source filenames") % lib_name
            sources = list(sources)

            log.info("building '%s' library", lib_name)

            # First, compile the source code to object files in the library
            # directory.  (This should probably change to putting object
            # files in a temporary build directory.)
            macros = build_info.get('macros')
            include_dirs = build_info.get('include_dirs')
            objects = self.compiler.compile(sources,
                                            output_dir=self.build_temp,
                                            macros=macros,
                                            include_dirs=include_dirs,
                                            debug=self.debug)

            # Now "link" the object files together into a static library.
            # (On Unix at least, this isn't really linking -- it just
            # builds an archive.  Whatever.)
            self.compiler.create_static_lib(objects, lib_name,
                                            output_dir=self.build_clib,
                                            debug=self.debug)

filename:/usr/lib/python2.7/distutils/command/command_template
__doc__
"""distutils.command.x

filename:/usr/lib/python2.7/distutils/command/clean.py
__doc__
"""distutils.command.clean

Implements the Distutils 'clean' command."""

# contributed by Bastian Kleineidam <calvin@cs.uni-sb.de>, added 2000-03-18

__revision__ = "$Id$"

import os
from distutils.core import Command
from distutils.dir_util import remove_tree
from distutils import log

class clean(Command):

    description = "clean up temporary files from 'build' command"
    user_options = [
        ('build-base=', 'b',
         "base build directory (default: 'build.build-base')"),
        ('build-lib=', None,
         "build directory for all modules (default: 'build.build-lib')"),
        ('build-temp=', 't',
         "temporary build directory (default: 'build.build-temp')"),
        ('build-scripts=', None,
         "build directory for scripts (default: 'build.build-scripts')"),
        ('bdist-base=', None,
         "temporary directory for built distributions"),
        ('all', 'a',
         "remove all build output, not just temporary by-products")
    ]

    boolean_options = ['all']

    def initialize_options(self):
        self.build_base = None
        self.build_lib = None
        self.build_temp = None
        self.build_scripts = None
        self.bdist_base = None
        self.all = None

    def finalize_options(self):
        self.set_undefined_options('build',
                                   ('build_base', 'build_base'),
                                   ('build_lib', 'build_lib'),
                                   ('build_scripts', 'build_scripts'),
                                   ('build_temp', 'build_temp'))
        self.set_undefined_options('bdist',
                                   ('bdist_base', 'bdist_base'))

    def run(self):
        # remove the build/temp.<plat> directory (unless it's already
        # gone)
        if os.path.exists(self.build_temp):
            remove_tree(self.build_temp, dry_run=self.dry_run)
        else:
            log.debug("'%s' does not exist -- can't clean it",
                      self.build_temp)

        if self.all:
            # remove build directories
            for directory in (self.build_lib,
                              self.bdist_base,
                              self.build_scripts):
                if os.path.exists(directory):
                    remove_tree(directory, dry_run=self.dry_run)
                else:
                    log.warn("'%s' does not exist -- can't clean it",
                             directory)

        # just for the heck of it, try to remove the base build directory:
        # we might have emptied it right now, but if not we don't care
        if not self.dry_run:
            try:
                os.rmdir(self.build_base)
                log.info("removing '%s'", self.build_base)
            except OSError:
                pass

# class clean

filename:/usr/lib/python2.7/distutils/command/bdist.py
__doc__
"""distutils.command.bdist

filename:/usr/lib/python2.7/distutils/command/install_scripts.py
__doc__
"""distutils.command.install_scripts

Implements the Distutils 'install_scripts' command, for installing
Python scripts."""

# contributed by Bastian Kleineidam

__revision__ = "$Id$"

import os
from distutils.core import Command
from distutils import log
from stat import ST_MODE

class install_scripts (Command):

    description = "install scripts (Python or otherwise)"

    user_options = [
        ('install-dir=', 'd', "directory to install scripts to"),
        ('build-dir=','b', "build directory (where to install from)"),
        ('force', 'f', "force installation (overwrite existing files)"),
        ('skip-build', None, "skip the build steps"),
    ]

    boolean_options = ['force', 'skip-build']


    def initialize_options (self):
        self.install_dir = None
        self.force = 0
        self.build_dir = None
        self.skip_build = None

    def finalize_options (self):
        self.set_undefined_options('build', ('build_scripts', 'build_dir'))
        self.set_undefined_options('install',
                                   ('install_scripts', 'install_dir'),
                                   ('force', 'force'),
                                   ('skip_build', 'skip_build'),
                                  )

    def run (self):
        if not self.skip_build:
            self.run_command('build_scripts')
        self.outfiles = self.copy_tree(self.build_dir, self.install_dir)
        if os.name == 'posix':
            # Set the executable bits (owner, group, and world) on
            # all the scripts we just installed.
            for file in self.get_outputs():
                if self.dry_run:
                    log.info("changing mode of %s", file)
                else:
                    mode = ((os.stat(file)[ST_MODE]) | 0555) & 07777
                    log.info("changing mode of %s to %o", file, mode)
                    os.chmod(file, mode)

    def get_inputs (self):
        return self.distribution.scripts or []

    def get_outputs(self):
        return self.outfiles or []

# class install_scripts

filename:/usr/lib/python2.7/distutils/command/bdist_wininst.py
__doc__
"""distutils.command.bdist_wininst

filename:/usr/lib/python2.7/distutils/command/build_scripts.py
__doc__
"""distutils.command.build_scripts

Implements the Distutils 'build_scripts' command."""

__revision__ = "$Id$"

import os, re
from stat import ST_MODE
from distutils.core import Command
from distutils.dep_util import newer
from distutils.util import convert_path
from distutils import log

# check if Python is called on the first line with this expression
first_line_re = re.compile('^#!.*python[0-9.]*([ \t].*)?$')

class build_scripts (Command):

    description = "\"build\" scripts (copy and fixup #! line)"

    user_options = [
        ('build-dir=', 'd', "directory to \"build\" (copy) to"),
        ('force', 'f', "forcibly build everything (ignore file timestamps"),
        ('executable=', 'e', "specify final destination interpreter path"),
        ]

    boolean_options = ['force']


    def initialize_options (self):
        self.build_dir = None
        self.scripts = None
        self.force = None
        self.executable = None
        self.outfiles = None

    def finalize_options (self):
        self.set_undefined_options('build',
                                   ('build_scripts', 'build_dir'),
                                   ('force', 'force'),
                                   ('executable', 'executable'))
        self.scripts = self.distribution.scripts

    def get_source_files(self):
        return self.scripts

    def run (self):
        if not self.scripts:
            return
        self.copy_scripts()


    def copy_scripts (self):
        """Copy each script listed in 'self.scripts'; if it's marked as a
        Python script in the Unix way (first line matches 'first_line_re',
        ie. starts with "\#!" and contains "python"), then adjust the first
        line to refer to the current Python interpreter as we copy.
        """
        _sysconfig = __import__('sysconfig')
        self.mkpath(self.build_dir)
        outfiles = []
        for script in self.scripts:
            adjust = 0
            script = convert_path(script)
            outfile = os.path.join(self.build_dir, os.path.basename(script))
            outfiles.append(outfile)

            if not self.force and not newer(script, outfile):
                log.debug("not copying %s (up-to-date)", script)
                continue

            # Always open the file, but ignore failures in dry-run mode --
            # that way, we'll get accurate feedback if we can read the
            # script.
            try:
                f = open(script, "r")
            except IOError:
                if not self.dry_run:
                    raise
                f = None
            else:
                first_line = f.readline()
                if not first_line:
                    self.warn("%s is an empty file (skipping)" % script)
                    continue

                match = first_line_re.match(first_line)
                if match:
                    adjust = 1
                    post_interp = match.group(1) or ''

            if adjust:
                log.info("copying and adjusting %s -> %s", script,
                         self.build_dir)
                if not self.dry_run:
                    outf = open(outfile, "w")
                    if not _sysconfig.is_python_build():
                        outf.write("#!%s%s\n" %
                                   (self.executable,
                                    post_interp))
                    else:
                        outf.write("#!%s%s\n" %
                                   (os.path.join(
                            _sysconfig.get_config_var("BINDIR"),
                           "python%s%s" % (_sysconfig.get_config_var("VERSION"),
                                           _sysconfig.get_config_var("EXE"))),
                                    post_interp))
                    outf.writelines(f.readlines())
                    outf.close()
                if f:
                    f.close()
            else:
                if f:
                    f.close()
                self.copy_file(script, outfile)

        if os.name == 'posix':
            for file in outfiles:
                if self.dry_run:
                    log.info("changing mode of %s", file)
                else:
                    oldmode = os.stat(file)[ST_MODE] & 07777
                    newmode = (oldmode | 0555) & 07777
                    if newmode != oldmode:
                        log.info("changing mode of %s from %o to %o",
                                 file, oldmode, newmode)
                        os.chmod(file, newmode)

    # copy_scripts ()

# class build_scripts

filename:/usr/lib/python2.7/distutils/command/build_py.py
__doc__
"""distutils.command.build_py

filename:/usr/lib/python2.7/distutils/command/install_headers.py
__doc__
"""distutils.command.install_headers

Implements the Distutils 'install_headers' command, to install C/C++ header
files to the Python include directory."""

__revision__ = "$Id$"

from distutils.core import Command


# XXX force is never used
class install_headers(Command):

    description = "install C/C++ header files"

    user_options = [('install-dir=', 'd',
                     "directory to install header files to"),
                    ('force', 'f',
                     "force installation (overwrite existing files)"),
                   ]

    boolean_options = ['force']

    def initialize_options(self):
        self.install_dir = None
        self.force = 0
        self.outfiles = []

    def finalize_options(self):
        self.set_undefined_options('install',
                                   ('install_headers', 'install_dir'),
                                   ('force', 'force'))


    def run(self):
        headers = self.distribution.headers
        if not headers:
            return

        self.mkpath(self.install_dir)
        for header in headers:
            (out, _) = self.copy_file(header, self.install_dir)
            self.outfiles.append(out)

    def get_inputs(self):
        return self.distribution.headers or []

    def get_outputs(self):
        return self.outfiles

# class install_headers

filename:/usr/lib/python2.7/distutils/command/sdist.py
__doc__
"""distutils.command.sdist

filename:/usr/lib/python2.7/distutils/command/build_ext.py
__doc__
"""distutils.command.build_ext

Implements the Distutils 'build_ext' command, for building extension
modules (currently limited to C extensions, should accommodate C++
extensions ASAP)."""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id$"

import sys, os, string, re
from types import *
from site import USER_BASE, USER_SITE
from distutils.core import Command
from distutils.errors import *
from distutils.sysconfig import customize_compiler, get_python_version
from distutils.dep_util import newer_group
from distutils.extension import Extension
from distutils.util import get_platform
from distutils import log

if os.name == 'nt':
    from distutils.msvccompiler import get_build_version
    MSVC_VERSION = int(get_build_version())

# An extension name is just a dot-separated list of Python NAMEs (ie.
# the same as a fully-qualified module name).
extension_name_re = re.compile \
    (r'^[a-zA-Z_][a-zA-Z_0-9]*(\.[a-zA-Z_][a-zA-Z_0-9]*)*$')


def show_compilers ():
    from distutils.ccompiler import show_compilers
    show_compilers()


class build_ext (Command):

    description = "build C/C++ extensions (compile/link to build directory)"

    # XXX thoughts on how to deal with complex command-line options like
    # these, i.e. how to make it so fancy_getopt can suck them off the
    # command line and make it look like setup.py defined the appropriate
    # lists of tuples of what-have-you.
    #   - each command needs a callback to process its command-line options
    #   - Command.__init__() needs access to its share of the whole
    #     command line (must ultimately come from
    #     Distribution.parse_command_line())
    #   - it then calls the current command class' option-parsing
    #     callback to deal with weird options like -D, which have to
    #     parse the option text and churn out some custom data
    #     structure
    #   - that data structure (in this case, a list of 2-tuples)
    #     will then be present in the command object by the time
    #     we get to finalize_options() (i.e. the constructor
    #     takes care of both command-line and client options
    #     in between initialize_options() and finalize_options())

    sep_by = " (separated by '%s')" % os.pathsep
    user_options = [
        ('build-lib=', 'b',
         "directory for compiled extension modules"),
        ('build-temp=', 't',
         "directory for temporary files (build by-products)"),
        ('plat-name=', 'p',
         "platform name to cross-compile for, if supported "
         "(default: %s)" % get_platform()),
        ('inplace', 'i',
         "ignore build-lib and put compiled extensions into the source " +
         "directory alongside your pure Python modules"),
        ('include-dirs=', 'I',
         "list of directories to search for header files" + sep_by),
        ('define=', 'D',
         "C preprocessor macros to define"),
        ('undef=', 'U',
         "C preprocessor macros to undefine"),
        ('libraries=', 'l',
         "external C libraries to link with"),
        ('library-dirs=', 'L',
         "directories to search for external C libraries" + sep_by),
        ('rpath=', 'R',
         "directories to search for shared C libraries at runtime"),
        ('link-objects=', 'O',
         "extra explicit link objects to include in the link"),
        ('debug', 'g',
         "compile/link with debugging information"),
        ('force', 'f',
         "forcibly build everything (ignore file timestamps)"),
        ('compiler=', 'c',
         "specify the compiler type"),
        ('swig-cpp', None,
         "make SWIG create C++ files (default is C)"),
        ('swig-opts=', None,
         "list of SWIG command line options"),
        ('swig=', None,
         "path to the SWIG executable"),
        ('user', None,
         "add user include, library and rpath"),
        ]

    boolean_options = ['inplace', 'debug', 'force', 'swig-cpp', 'user']

    help_options = [
        ('help-compiler', None,
         "list available compilers", show_compilers),
        ]

    def initialize_options (self):
        self.extensions = None
        self.build_lib = None
        self.plat_name = None
        self.build_temp = None
        self.inplace = 0
        self.package = None

        self.include_dirs = None
        self.define = None
        self.undef = None
        self.libraries = None
        self.library_dirs = None
        self.rpath = None
        self.link_objects = None
        self.debug = None
        self.force = None
        self.compiler = None
        self.swig = None
        self.swig_cpp = None
        self.swig_opts = None
        self.user = None

    def finalize_options(self):
        from distutils import sysconfig

        self.set_undefined_options('build',
                                   ('build_lib', 'build_lib'),
                                   ('build_temp', 'build_temp'),
                                   ('compiler', 'compiler'),
                                   ('debug', 'debug'),
                                   ('force', 'force'),
                                   ('plat_name', 'plat_name'),
                                   )

        if self.package is None:
            self.package = self.distribution.ext_package

        self.extensions = self.distribution.ext_modules

        # Make sure Python's include directories (for Python.h, pyconfig.h,
        # etc.) are in the include search path.
        py_include = sysconfig.get_python_inc()
        plat_py_include = sysconfig.get_python_inc(plat_specific=1)
        if self.include_dirs is None:
            self.include_dirs = self.distribution.include_dirs or []
        if isinstance(self.include_dirs, str):
            self.include_dirs = self.include_dirs.split(os.pathsep)

        # Put the Python "system" include dir at the end, so that
        # any local include dirs take precedence.
        self.include_dirs.append(py_include)
        if plat_py_include != py_include:
            self.include_dirs.append(plat_py_include)

        self.ensure_string_list('libraries')

        # Life is easier if we're not forever checking for None, so
        # simplify these options to empty lists if unset
        if self.libraries is None:
            self.libraries = []
        if self.library_dirs is None:
            self.library_dirs = []
        elif type(self.library_dirs) is StringType:
            self.library_dirs = string.split(self.library_dirs, os.pathsep)

        if self.rpath is None:
            self.rpath = []
        elif type(self.rpath) is StringType:
            self.rpath = string.split(self.rpath, os.pathsep)

        # for extensions under windows use different directories
        # for Release and Debug builds.
        # also Python's library directory must be appended to library_dirs
        if os.name == 'nt':
            # the 'libs' directory is for binary installs - we assume that
            # must be the *native* platform.  But we don't really support
            # cross-compiling via a binary install anyway, so we let it go.
            self.library_dirs.append(os.path.join(sys.exec_prefix, 'libs'))
            if self.debug:
                self.build_temp = os.path.join(self.build_temp, "Debug")
            else:
                self.build_temp = os.path.join(self.build_temp, "Release")

            # Append the source distribution include and library directories,
            # this allows distutils on windows to work in the source tree
            self.include_dirs.append(os.path.join(sys.exec_prefix, 'PC'))
            if MSVC_VERSION == 9:
                # Use the .lib files for the correct architecture
                if self.plat_name == 'win32':
                    suffix = ''
                else:
                    # win-amd64 or win-ia64
                    suffix = self.plat_name[4:]
                # We could have been built in one of two places; add both
                for d in ('PCbuild',), ('PC', 'VS9.0'):
                    new_lib = os.path.join(sys.exec_prefix, *d)
                    if suffix:
                        new_lib = os.path.join(new_lib, suffix)
                    self.library_dirs.append(new_lib)

            elif MSVC_VERSION == 8:
                self.library_dirs.append(os.path.join(sys.exec_prefix,
                                         'PC', 'VS8.0'))
            elif MSVC_VERSION == 7:
                self.library_dirs.append(os.path.join(sys.exec_prefix,
                                         'PC', 'VS7.1'))
            else:
                self.library_dirs.append(os.path.join(sys.exec_prefix,
                                         'PC', 'VC6'))

        # OS/2 (EMX) doesn't support Debug vs Release builds, but has the
        # import libraries in its "Config" subdirectory
        if os.name == 'os2':
            self.library_dirs.append(os.path.join(sys.exec_prefix, 'Config'))

        # for extensions under Cygwin and AtheOS Python's library directory must be
        # appended to library_dirs
        if sys.platform[:6] == 'cygwin' or sys.platform[:6] == 'atheos':
            if sys.executable.startswith(os.path.join(sys.exec_prefix, "bin")):
                # building third party extensions
                self.library_dirs.append(os.path.join(sys.prefix, "lib",
                                                      "python" + get_python_version(),
                                                      "config"))
            else:
                # building python standard extensions
                self.library_dirs.append('.')

        # For building extensions with a shared Python library,
        # Python's library directory must be appended to library_dirs
        # See Issues: #1600860, #4366
        if False and (sysconfig.get_config_var('Py_ENABLE_SHARED')):
            if not sysconfig.python_build:
                # building third party extensions
                self.library_dirs.append(sysconfig.get_config_var('LIBDIR'))
            else:
                # building python standard extensions
                self.library_dirs.append('.')

        # The argument parsing will result in self.define being a string, but
        # it has to be a list of 2-tuples.  All the preprocessor symbols
        # specified by the 'define' option will be set to '1'.  Multiple
        # symbols can be separated with commas.

        if self.define:
            defines = self.define.split(',')
            self.define = map(lambda symbol: (symbol, '1'), defines)

        # The option for macros to undefine is also a string from the
        # option parsing, but has to be a list.  Multiple symbols can also
        # be separated with commas here.
        if self.undef:
            self.undef = self.undef.split(',')

        if self.swig_opts is None:
            self.swig_opts = []
        else:
            self.swig_opts = self.swig_opts.split(' ')

        # Finally add the user include and library directories if requested
        if self.user:
            user_include = os.path.join(USER_BASE, "include")
            user_lib = os.path.join(USER_BASE, "lib")
            if os.path.isdir(user_include):
                self.include_dirs.append(user_include)
            if os.path.isdir(user_lib):
                self.library_dirs.append(user_lib)
                self.rpath.append(user_lib)

    def run(self):
        from distutils.ccompiler import new_compiler

        # 'self.extensions', as supplied by setup.py, is a list of
        # Extension instances.  See the documentation for Extension (in
        # distutils.extension) for details.
        #
        # For backwards compatibility with Distutils 0.8.2 and earlier, we
        # also allow the 'extensions' list to be a list of tuples:
        #    (ext_name, build_info)
        # where build_info is a dictionary containing everything that
        # Extension instances do except the name, with a few things being
        # differently named.  We convert these 2-tuples to Extension
        # instances as needed.

        if not self.extensions:
            return

        # If we were asked to build any C/C++ libraries, make sure that the
        # directory where we put them is in the library search path for
        # linking extensions.
        if self.distribution.has_c_libraries():
            build_clib = self.get_finalized_command('build_clib')
            self.libraries.extend(build_clib.get_library_names() or [])
            self.library_dirs.append(build_clib.build_clib)

        # Setup the CCompiler object that we'll use to do all the
        # compiling and linking
        self.compiler = new_compiler(compiler=self.compiler,
                                     verbose=self.verbose,
                                     dry_run=self.dry_run,
                                     force=self.force)
        customize_compiler(self.compiler)
        # If we are cross-compiling, init the compiler now (if we are not
        # cross-compiling, init would not hurt, but people may rely on
        # late initialization of compiler even if they shouldn't...)
        if os.name == 'nt' and self.plat_name != get_platform():
            self.compiler.initialize(self.plat_name)

        # And make sure that any compile/link-related options (which might
        # come from the command-line or from the setup script) are set in
        # that CCompiler object -- that way, they automatically apply to
        # all compiling and linking done here.
        if self.include_dirs is not None:
            self.compiler.set_include_dirs(self.include_dirs)
        if self.define is not None:
            # 'define' option is a list of (name,value) tuples
            for (name, value) in self.define:
                self.compiler.define_macro(name, value)
        if self.undef is not None:
            for macro in self.undef:
                self.compiler.undefine_macro(macro)
        if self.libraries is not None:
            self.compiler.set_libraries(self.libraries)
        if self.library_dirs is not None:
            self.compiler.set_library_dirs(self.library_dirs)
        if self.rpath is not None:
            self.compiler.set_runtime_library_dirs(self.rpath)
        if self.link_objects is not None:
            self.compiler.set_link_objects(self.link_objects)

        # Now actually compile and link everything.
        self.build_extensions()

    def check_extensions_list(self, extensions):
        """Ensure that the list of extensions (presumably provided as a
        command option 'extensions') is valid, i.e. it is a list of
        Extension objects.  We also support the old-style list of 2-tuples,
        where the tuples are (ext_name, build_info), which are converted to
        Extension instances here.

        Raise DistutilsSetupError if the structure is invalid anywhere;
        just returns otherwise.
        """
        if not isinstance(extensions, list):
            raise DistutilsSetupError, \
                  "'ext_modules' option must be a list of Extension instances"

        for i, ext in enumerate(extensions):
            if isinstance(ext, Extension):
                continue                # OK! (assume type-checking done
                                        # by Extension constructor)

            if not isinstance(ext, tuple) or len(ext) != 2:
                raise DistutilsSetupError, \
                      ("each element of 'ext_modules' option must be an "
                       "Extension instance or 2-tuple")

            ext_name, build_info = ext

            log.warn(("old-style (ext_name, build_info) tuple found in "
                      "ext_modules for extension '%s'"
                      "-- please convert to Extension instance" % ext_name))

            if not (isinstance(ext_name, str) and
                    extension_name_re.match(ext_name)):
                raise DistutilsSetupError, \
                      ("first element of each tuple in 'ext_modules' "
                       "must be the extension name (a string)")

            if not isinstance(build_info, dict):
                raise DistutilsSetupError, \
                      ("second element of each tuple in 'ext_modules' "
                       "must be a dictionary (build info)")

            # OK, the (ext_name, build_info) dict is type-safe: convert it
            # to an Extension instance.
            ext = Extension(ext_name, build_info['sources'])

            # Easy stuff: one-to-one mapping from dict elements to
            # instance attributes.
            for key in ('include_dirs', 'library_dirs', 'libraries',
                        'extra_objects', 'extra_compile_args',
                        'extra_link_args'):
                val = build_info.get(key)
                if val is not None:
                    setattr(ext, key, val)

            # Medium-easy stuff: same syntax/semantics, different names.
            ext.runtime_library_dirs = build_info.get('rpath')
            if 'def_file' in build_info:
                log.warn("'def_file' element of build info dict "
                         "no longer supported")

            # Non-trivial stuff: 'macros' split into 'define_macros'
            # and 'undef_macros'.
            macros = build_info.get('macros')
            if macros:
                ext.define_macros = []
                ext.undef_macros = []
                for macro in macros:
                    if not (isinstance(macro, tuple) and len(macro) in (1, 2)):
                        raise DistutilsSetupError, \
                              ("'macros' element of build info dict "
                               "must be 1- or 2-tuple")
                    if len(macro) == 1:
                        ext.undef_macros.append(macro[0])
                    elif len(macro) == 2:
                        ext.define_macros.append(macro)

            extensions[i] = ext

    def get_source_files(self):
        self.check_extensions_list(self.extensions)
        filenames = []

        # Wouldn't it be neat if we knew the names of header files too...
        for ext in self.extensions:
            filenames.extend(ext.sources)

        return filenames

    def get_outputs(self):
        # Sanity check the 'extensions' list -- can't assume this is being
        # done in the same run as a 'build_extensions()' call (in fact, we
        # can probably assume that it *isn't*!).
        self.check_extensions_list(self.extensions)

        # And build the list of output (built) filenames.  Note that this
        # ignores the 'inplace' flag, and assumes everything goes in the
        # "build" tree.
        outputs = []
        for ext in self.extensions:
            outputs.append(self.get_ext_fullpath(ext.name))
        return outputs

    def build_extensions(self):
        # First, sanity-check the 'extensions' list
        self.check_extensions_list(self.extensions)

        for ext in self.extensions:
            self.build_extension(ext)

    def build_extension(self, ext):
        sources = ext.sources
        if sources is None or type(sources) not in (ListType, TupleType):
            raise DistutilsSetupError, \
                  ("in 'ext_modules' option (extension '%s'), " +
                   "'sources' must be present and must be " +
                   "a list of source filenames") % ext.name
        sources = list(sources)

        ext_path = self.get_ext_fullpath(ext.name)
        depends = sources + ext.depends
        if not (self.force or newer_group(depends, ext_path, 'newer')):
            log.debug("skipping '%s' extension (up-to-date)", ext.name)
            return
        else:
            log.info("building '%s' extension", ext.name)

        # First, scan the sources for SWIG definition files (.i), run
        # SWIG on 'em to create .c files, and modify the sources list
        # accordingly.
        sources = self.swig_sources(sources, ext)

        # Next, compile the source code to object files.

        # XXX not honouring 'define_macros' or 'undef_macros' -- the
        # CCompiler API needs to change to accommodate this, and I
        # want to do one thing at a time!

        # Two possible sources for extra compiler arguments:
        #   - 'extra_compile_args' in Extension object
        #   - CFLAGS environment variable (not particularly
        #     elegant, but people seem to expect it and I
        #     guess it's useful)
        # The environment variable should take precedence, and
        # any sensible compiler will give precedence to later
        # command line args.  Hence we combine them in order:
        extra_args = ext.extra_compile_args or []

        macros = ext.define_macros[:]
        for undef in ext.undef_macros:
            macros.append((undef,))

        objects = self.compiler.compile(sources,
                                         output_dir=self.build_temp,
                                         macros=macros,
                                         include_dirs=ext.include_dirs,
                                         debug=self.debug,
                                         extra_postargs=extra_args,
                                         depends=ext.depends)

        # XXX -- this is a Vile HACK!
        #
        # The setup.py script for Python on Unix needs to be able to
        # get this list so it can perform all the clean up needed to
        # avoid keeping object files around when cleaning out a failed
        # build of an extension module.  Since Distutils does not
        # track dependencies, we have to get rid of intermediates to
        # ensure all the intermediates will be properly re-built.
        #
        self._built_objects = objects[:]

        # Now link the object files together into a "shared object" --
        # of course, first we have to figure out all the other things
        # that go into the mix.
        if ext.extra_objects:
            objects.extend(ext.extra_objects)
        extra_args = ext.extra_link_args or []

        # Detect target language, if not provided
        language = ext.language or self.compiler.detect_language(sources)

        self.compiler.link_shared_object(
            objects, ext_path,
            libraries=self.get_libraries(ext),
            library_dirs=ext.library_dirs,
            runtime_library_dirs=ext.runtime_library_dirs,
            extra_postargs=extra_args,
            export_symbols=self.get_export_symbols(ext),
            debug=self.debug,
            build_temp=self.build_temp,
            target_lang=language)


    def swig_sources (self, sources, extension):

        """Walk the list of source files in 'sources', looking for SWIG
        interface (.i) files.  Run SWIG on all that are found, and
        return a modified 'sources' list with SWIG source files replaced
        by the generated C (or C++) files.
        """

        new_sources = []
        swig_sources = []
        swig_targets = {}

        # XXX this drops generated C/C++ files into the source tree, which
        # is fine for developers who want to distribute the generated
        # source -- but there should be an option to put SWIG output in
        # the temp dir.

        if self.swig_cpp:
            log.warn("--swig-cpp is deprecated - use --swig-opts=-c++")

        if self.swig_cpp or ('-c++' in self.swig_opts) or \
           ('-c++' in extension.swig_opts):
            target_ext = '.cpp'
        else:
            target_ext = '.c'

        for source in sources:
            (base, ext) = os.path.splitext(source)
            if ext == ".i":             # SWIG interface file
                new_sources.append(base + '_wrap' + target_ext)
                swig_sources.append(source)
                swig_targets[source] = new_sources[-1]
            else:
                new_sources.append(source)

        if not swig_sources:
            return new_sources

        swig = self.swig or self.find_swig()
        swig_cmd = [swig, "-python"]
        swig_cmd.extend(self.swig_opts)
        if self.swig_cpp:
            swig_cmd.append("-c++")

        # Do not override commandline arguments
        if not self.swig_opts:
            for o in extension.swig_opts:
                swig_cmd.append(o)

        for source in swig_sources:
            target = swig_targets[source]
            log.info("swigging %s to %s", source, target)
            self.spawn(swig_cmd + ["-o", target, source])

        return new_sources

    # swig_sources ()

    def find_swig (self):
        """Return the name of the SWIG executable.  On Unix, this is
        just "swig" -- it should be in the PATH.  Tries a bit harder on
        Windows.
        """

        if os.name == "posix":
            return "swig"
        elif os.name == "nt":

            # Look for SWIG in its standard installation directory on
            # Windows (or so I presume!).  If we find it there, great;
            # if not, act like Unix and assume it's in the PATH.
            for vers in ("1.3", "1.2", "1.1"):
                fn = os.path.join("c:\\swig%s" % vers, "swig.exe")
                if os.path.isfile(fn):
                    return fn
            else:
                return "swig.exe"

        elif os.name == "os2":
            # assume swig available in the PATH.
            return "swig.exe"

        else:
            raise DistutilsPlatformError, \
                  ("I don't know how to find (much less run) SWIG "
                   "on platform '%s'") % os.name

    # find_swig ()

    # -- Name generators -----------------------------------------------
    # (extension names, filenames, whatever)
    def get_ext_fullpath(self, ext_name):
        """Returns the path of the filename for a given extension.

        The file is located in `build_lib` or directly in the package
        (inplace option).
        """
        # makes sure the extension name is only using dots
        all_dots = string.maketrans('/'+os.sep, '..')
        ext_name = ext_name.translate(all_dots)

        fullname = self.get_ext_fullname(ext_name)
        modpath = fullname.split('.')
        filename = self.get_ext_filename(ext_name)
        filename = os.path.split(filename)[-1]

        if not self.inplace:
            # no further work needed
            # returning :
            #   build_dir/package/path/filename
            filename = os.path.join(*modpath[:-1]+[filename])
            return os.path.join(self.build_lib, filename)

        # the inplace option requires to find the package directory
        # using the build_py command for that
        package = '.'.join(modpath[0:-1])
        build_py = self.get_finalized_command('build_py')
        package_dir = os.path.abspath(build_py.get_package_dir(package))

        # returning
        #   package_dir/filename
        return os.path.join(package_dir, filename)

    def get_ext_fullname(self, ext_name):
        """Returns the fullname of a given extension name.

        Adds the `package.` prefix"""
        if self.package is None:
            return ext_name
        else:
            return self.package + '.' + ext_name

    def get_ext_filename(self, ext_name):
        r"""Convert the name of an extension (eg. "foo.bar") into the name
        of the file from which it will be loaded (eg. "foo/bar.so", or
        "foo\bar.pyd").
        """
        from distutils.sysconfig import get_config_var
        ext_path = string.split(ext_name, '.')
        # OS/2 has an 8 character module (extension) limit :-(
        if os.name == "os2":
            ext_path[len(ext_path) - 1] = ext_path[len(ext_path) - 1][:8]
        # extensions in debug_mode are named 'module_d.pyd' under windows
        so_ext = get_config_var('SO')
        if os.name == 'nt' and self.debug:
            return os.path.join(*ext_path) + '_d' + so_ext
        return os.path.join(*ext_path) + so_ext

    def get_export_symbols (self, ext):
        """Return the list of symbols that a shared extension has to
        export.  This either uses 'ext.export_symbols' or, if it's not
        provided, "init" + module_name.  Only relevant on Windows, where
        the .pyd file (DLL) must export the module "init" function.
        """
        initfunc_name = "init" + ext.name.split('.')[-1]
        if initfunc_name not in ext.export_symbols:
            ext.export_symbols.append(initfunc_name)
        return ext.export_symbols

    def get_libraries (self, ext):
        """Return the list of libraries to link against when building a
        shared extension.  On most platforms, this is just 'ext.libraries';
        on Windows and OS/2, we add the Python library (eg. python20.dll).
        """
        # The python library is always needed on Windows.  For MSVC, this
        # is redundant, since the library is mentioned in a pragma in
        # pyconfig.h that MSVC groks.  The other Windows compilers all seem
        # to need it mentioned explicitly, though, so that's what we do.
        # Append '_d' to the python import library on debug builds.
        if sys.platform == "win32":
            from distutils.msvccompiler import MSVCCompiler
            if not isinstance(self.compiler, MSVCCompiler):
                template = "python%d%d"
                if self.debug:
                    template = template + '_d'
                pythonlib = (template %
                       (sys.hexversion >> 24, (sys.hexversion >> 16) & 0xff))
                # don't extend ext.libraries, it may be shared with other
                # extensions, it is a reference to the original list
                return ext.libraries + [pythonlib]
            else:
                return ext.libraries
        elif sys.platform == "os2emx":
            # EMX/GCC requires the python library explicitly, and I
            # believe VACPP does as well (though not confirmed) - AIM Apr01
            template = "python%d%d"
            # debug versions of the main DLL aren't supported, at least
            # not at this time - AIM Apr01
            #if self.debug:
            #    template = template + '_d'
            pythonlib = (template %
                   (sys.hexversion >> 24, (sys.hexversion >> 16) & 0xff))
            # don't extend ext.libraries, it may be shared with other
            # extensions, it is a reference to the original list
            return ext.libraries + [pythonlib]
        elif sys.platform[:6] == "cygwin":
            template = "python%d.%d"
            pythonlib = (template %
                   (sys.hexversion >> 24, (sys.hexversion >> 16) & 0xff))
            # don't extend ext.libraries, it may be shared with other
            # extensions, it is a reference to the original list
            return ext.libraries + [pythonlib]
        elif sys.platform[:6] == "atheos":
            from distutils import sysconfig

            template = "python%d.%d"
            pythonlib = (template %
                   (sys.hexversion >> 24, (sys.hexversion >> 16) & 0xff))
            # Get SHLIBS from Makefile
            extra = []
            for lib in sysconfig.get_config_var('SHLIBS').split():
                if lib.startswith('-l'):
                    extra.append(lib[2:])
                else:
                    extra.append(lib)
            # don't extend ext.libraries, it may be shared with other
            # extensions, it is a reference to the original list
            return ext.libraries + [pythonlib, "m"] + extra

        elif sys.platform == 'darwin':
            # Don't use the default code below
            return ext.libraries
        elif sys.platform[:3] == 'aix':
            # Don't use the default code below
            return ext.libraries
        else:
            from distutils import sysconfig
            if False and sysconfig.get_config_var('Py_ENABLE_SHARED'):
                template = "python%d.%d"
                pythonlib = (template %
                             (sys.hexversion >> 24, (sys.hexversion >> 16) & 0xff))
                return ext.libraries + [pythonlib]
            else:
                return ext.libraries

# class build_ext

filename:/usr/lib/python2.7/distutils/command/register.py
__doc__
"""distutils.command.register

filename:/usr/lib/python2.7/distutils/command/install_lib.py
__doc__
"""distutils.command.install_lib

Implements the Distutils 'install_lib' command
(install all Python modules)."""

__revision__ = "$Id$"

import os
import sys

from distutils.core import Command
from distutils.errors import DistutilsOptionError


# Extension for Python source files.
if hasattr(os, 'extsep'):
    PYTHON_SOURCE_EXTENSION = os.extsep + "py"
else:
    PYTHON_SOURCE_EXTENSION = ".py"

class install_lib(Command):

    description = "install all Python modules (extensions and pure Python)"

    # The byte-compilation options are a tad confusing.  Here are the
    # possible scenarios:
    #   1) no compilation at all (--no-compile --no-optimize)
    #   2) compile .pyc only (--compile --no-optimize; default)
    #   3) compile .pyc and "level 1" .pyo (--compile --optimize)
    #   4) compile "level 1" .pyo only (--no-compile --optimize)
    #   5) compile .pyc and "level 2" .pyo (--compile --optimize-more)
    #   6) compile "level 2" .pyo only (--no-compile --optimize-more)
    #
    # The UI for this is two option, 'compile' and 'optimize'.
    # 'compile' is strictly boolean, and only decides whether to
    # generate .pyc files.  'optimize' is three-way (0, 1, or 2), and
    # decides both whether to generate .pyo files and what level of
    # optimization to use.

    user_options = [
        ('install-dir=', 'd', "directory to install to"),
        ('build-dir=','b', "build directory (where to install from)"),
        ('force', 'f', "force installation (overwrite existing files)"),
        ('compile', 'c', "compile .py to .pyc [default]"),
        ('no-compile', None, "don't compile .py files"),
        ('optimize=', 'O',
         "also compile with optimization: -O1 for \"python -O\", "
         "-O2 for \"python -OO\", and -O0 to disable [default: -O0]"),
        ('skip-build', None, "skip the build steps"),
        ]

    boolean_options = ['force', 'compile', 'skip-build']
    negative_opt = {'no-compile' : 'compile'}

    def initialize_options(self):
        # let the 'install' command dictate our installation directory
        self.install_dir = None
        self.build_dir = None
        self.force = 0
        self.compile = None
        self.optimize = None
        self.skip_build = None

    def finalize_options(self):
        # Get all the information we need to install pure Python modules
        # from the umbrella 'install' command -- build (source) directory,
        # install (target) directory, and whether to compile .py files.
        self.set_undefined_options('install',
                                   ('build_lib', 'build_dir'),
                                   ('install_lib', 'install_dir'),
                                   ('force', 'force'),
                                   ('compile', 'compile'),
                                   ('optimize', 'optimize'),
                                   ('skip_build', 'skip_build'),
                                  )

        if self.compile is None:
            self.compile = 1
        if self.optimize is None:
            self.optimize = 0

        if not isinstance(self.optimize, int):
            try:
                self.optimize = int(self.optimize)
                if self.optimize not in (0, 1, 2):
                    raise AssertionError
            except (ValueError, AssertionError):
                raise DistutilsOptionError, "optimize must be 0, 1, or 2"

    def run(self):
        # Make sure we have built everything we need first
        self.build()

        # Install everything: simply dump the entire contents of the build
        # directory to the installation directory (that's the beauty of
        # having a build directory!)
        outfiles = self.install()

        # (Optionally) compile .py to .pyc
        if outfiles is not None and self.distribution.has_pure_modules():
            self.byte_compile(outfiles)

    # -- Top-level worker functions ------------------------------------
    # (called from 'run()')

    def build(self):
        if not self.skip_build:
            if self.distribution.has_pure_modules():
                self.run_command('build_py')
            if self.distribution.has_ext_modules():
                self.run_command('build_ext')

    def install(self):
        if os.path.isdir(self.build_dir):
            outfiles = self.copy_tree(self.build_dir, self.install_dir)
        else:
            self.warn("'%s' does not exist -- no Python modules to install" %
                      self.build_dir)
            return
        return outfiles

    def byte_compile(self, files):
        if sys.dont_write_bytecode:
            self.warn('byte-compiling is disabled, skipping.')
            return

        from distutils.util import byte_compile

        # Get the "--root" directory supplied to the "install" command,
        # and use it as a prefix to strip off the purported filename
        # encoded in bytecode files.  This is far from complete, but it
        # should at least generate usable bytecode in RPM distributions.
        install_root = self.get_finalized_command('install').root

        if self.compile:
            byte_compile(files, optimize=0,
                         force=self.force, prefix=install_root,
                         dry_run=self.dry_run)
        if self.optimize > 0:
            byte_compile(files, optimize=self.optimize,
                         force=self.force, prefix=install_root,
                         verbose=self.verbose, dry_run=self.dry_run)


    # -- Utility methods -----------------------------------------------

    def _mutate_outputs(self, has_any, build_cmd, cmd_option, output_dir):
        if not has_any:
            return []

        build_cmd = self.get_finalized_command(build_cmd)
        build_files = build_cmd.get_outputs()
        build_dir = getattr(build_cmd, cmd_option)

        prefix_len = len(build_dir) + len(os.sep)
        outputs = []
        for file in build_files:
            outputs.append(os.path.join(output_dir, file[prefix_len:]))

        return outputs

    def _bytecode_filenames(self, py_filenames):
        bytecode_files = []
        for py_file in py_filenames:
            # Since build_py handles package data installation, the
            # list of outputs can contain more than just .py files.
            # Make sure we only report bytecode for the .py files.
            ext = os.path.splitext(os.path.normcase(py_file))[1]
            if ext != PYTHON_SOURCE_EXTENSION:
                continue
            if self.compile:
                bytecode_files.append(py_file + "c")
            if self.optimize > 0:
                bytecode_files.append(py_file + "o")

        return bytecode_files


    # -- External interface --------------------------------------------
    # (called by outsiders)

    def get_outputs(self):
        """Return the list of files that would be installed if this command
        were actually run.  Not affected by the "dry-run" flag or whether
        modules have actually been built yet.
        """
        pure_outputs = \
            self._mutate_outputs(self.distribution.has_pure_modules(),
                                 'build_py', 'build_lib',
                                 self.install_dir)
        if self.compile:
            bytecode_outputs = self._bytecode_filenames(pure_outputs)
        else:
            bytecode_outputs = []

        ext_outputs = \
            self._mutate_outputs(self.distribution.has_ext_modules(),
                                 'build_ext', 'build_lib',
                                 self.install_dir)

        return pure_outputs + bytecode_outputs + ext_outputs

    def get_inputs(self):
        """Get the list of files that are input to this command, ie. the
        files that get installed as they are named in the build tree.
        The files in this list correspond one-to-one to the output
        filenames returned by 'get_outputs()'.
        """
        inputs = []

        if self.distribution.has_pure_modules():
            build_py = self.get_finalized_command('build_py')
            inputs.extend(build_py.get_outputs())

        if self.distribution.has_ext_modules():
            build_ext = self.get_finalized_command('build_ext')
            inputs.extend(build_ext.get_outputs())

        return inputs

filename:/usr/lib/python2.7/distutils/command/build.py
__doc__
"""distutils.command.build

filename:/usr/lib/python2.7/distutils/command/config.py
__doc__
"""distutils.command.config

Implements the Distutils 'config' command, a (mostly) empty command class
that exists mainly to be sub-classed by specific module distributions and
applications.  The idea is that while every "config" command is different,
at least they're all named the same, and users always see "config" in the
list of standard commands.  Also, this is a good place to put common
configure-like tasks: "try to compile this C code", or "figure out where
this header file lives".
"""

filename:/usr/lib/python2.7/distutils/command/install_egg_info.py
__doc__
"""distutils.command.install_egg_info

Implements the Distutils 'install_egg_info' command, for installing
a package's PKG-INFO metadata."""


from distutils.cmd import Command
from distutils import log, dir_util
import os, sys, re

class install_egg_info(Command):
    """Install an .egg-info file for the package"""

    description = "Install package's PKG-INFO metadata as an .egg-info file"
    user_options = [
        ('install-dir=', 'd', "directory to install to"),
        ('install-layout', None, "custom installation layout"),
    ]

    def initialize_options(self):
        self.install_dir = None
        self.install_layout = None
        self.prefix_option = None

    def finalize_options(self):
        self.set_undefined_options('install_lib',('install_dir','install_dir'))
        self.set_undefined_options('install',('install_layout','install_layout'))
        self.set_undefined_options('install',('prefix_option','prefix_option'))
        if self.install_layout:
            basename = "%s-%s.egg-info" % (
                to_filename(safe_name(self.distribution.get_name())),
                to_filename(safe_version(self.distribution.get_version()))
                )
            if not self.install_layout.lower() in ['deb']:
                raise DistutilsOptionError(
                    "unknown value for --install-layout")
        elif self.prefix_option or 'real_prefix' in sys.__dict__:
            basename = "%s-%s-py%s.egg-info" % (
                to_filename(safe_name(self.distribution.get_name())),
                to_filename(safe_version(self.distribution.get_version())),
                sys.version[:3]
                )
        else:
            basename = "%s-%s.egg-info" % (
                to_filename(safe_name(self.distribution.get_name())),
                to_filename(safe_version(self.distribution.get_version()))
                )
        self.target = os.path.join(self.install_dir, basename)
        self.outputs = [self.target]

    def run(self):
        target = self.target
        if os.path.isdir(target) and not os.path.islink(target):
            dir_util.remove_tree(target, dry_run=self.dry_run)
        elif os.path.exists(target):
            self.execute(os.unlink,(self.target,),"Removing "+target)
        elif not os.path.isdir(self.install_dir):
            self.execute(os.makedirs, (self.install_dir,),
                         "Creating "+self.install_dir)
        log.info("Writing %s", target)
        if not self.dry_run:
            f = open(target, 'w')
            self.distribution.metadata.write_pkg_file(f)
            f.close()

    def get_outputs(self):
        return self.outputs


# The following routines are taken from setuptools' pkg_resources module and
# can be replaced by importing them from pkg_resources once it is included
# in the stdlib.

def safe_name(name):
    """Convert an arbitrary string to a standard distribution name

    Any runs of non-alphanumeric/. characters are replaced with a single '-'.
    """
    return re.sub('[^A-Za-z0-9.]+', '-', name)


def safe_version(version):
    """Convert an arbitrary string to a standard version string

    Spaces become dots, and all other non-alphanumeric characters become
    dashes, with runs of multiple dashes condensed to a single dash.
    """
    version = version.replace(' ','.')
    return re.sub('[^A-Za-z0-9.]+', '-', version)


def to_filename(name):
    """Convert a project or version name to its filename-escaped form

    Any '-' characters are currently replaced with '_'.
    """
    return name.replace('-','_')

filename:/usr/lib/python2.7/distutils/command/bdist_dumb.py
__doc__
"""distutils.command.bdist_dumb

filename:/usr/lib/python2.7/distutils/command/check.py
__doc__
"""distutils.command.check

Implements the Distutils 'check' command.
"""

filename:/usr/lib/python2.7/distutils/msvc9compiler.py
__doc__
"""distutils.msvc9compiler

Contains MSVCCompiler, an implementation of the abstract CCompiler class
for the Microsoft Visual Studio 2008.

The module is compatible with VS 2005 and VS 2008. You can find legacy support
for older versions of VS in distutils.msvccompiler.
"""

filename:/usr/lib/python2.7/distutils/dir_util.py
__doc__
"""distutils.dir_util

Utility functions for manipulating directories and directory trees."""

__revision__ = "$Id$"

import os
import errno
from distutils.errors import DistutilsFileError, DistutilsInternalError
from distutils import log

# cache for by mkpath() -- in addition to cheapening redundant calls,
# eliminates redundant "creating /foo/bar/baz" messages in dry-run mode
_path_created = {}

# I don't use os.makedirs because a) it's new to Python 1.5.2, and
# b) it blows up if the directory already exists (I want to silently
# succeed in that case).
def mkpath(name, mode=0777, verbose=1, dry_run=0):
    """Create a directory and any missing ancestor directories.

    If the directory already exists (or if 'name' is the empty string, which
    means the current directory, which of course exists), then do nothing.
    Raise DistutilsFileError if unable to create some directory along the way
    (eg. some sub-path exists, but is a file rather than a directory).
    If 'verbose' is true, print a one-line summary of each mkdir to stdout.
    Return the list of directories actually created.
    """

    global _path_created

    # Detect a common bug -- name is None
    if not isinstance(name, basestring):
        raise DistutilsInternalError, \
              "mkpath: 'name' must be a string (got %r)" % (name,)

    # XXX what's the better way to handle verbosity? print as we create
    # each directory in the path (the current behaviour), or only announce
    # the creation of the whole path? (quite easy to do the latter since
    # we're not using a recursive algorithm)

    name = os.path.normpath(name)
    created_dirs = []
    if os.path.isdir(name) or name == '':
        return created_dirs
    if _path_created.get(os.path.abspath(name)):
        return created_dirs

    (head, tail) = os.path.split(name)
    tails = [tail]                      # stack of lone dirs to create

    while head and tail and not os.path.isdir(head):
        (head, tail) = os.path.split(head)
        tails.insert(0, tail)          # push next higher dir onto stack

    # now 'head' contains the deepest directory that already exists
    # (that is, the child of 'head' in 'name' is the highest directory
    # that does *not* exist)
    for d in tails:
        #print "head = %s, d = %s: " % (head, d),
        head = os.path.join(head, d)
        abs_head = os.path.abspath(head)

        if _path_created.get(abs_head):
            continue

        if verbose >= 1:
            log.info("creating %s", head)

        if not dry_run:
            try:
                os.mkdir(head, mode)
            except OSError, exc:
                if not (exc.errno == errno.EEXIST and os.path.isdir(head)):
                    raise DistutilsFileError(
                          "could not create '%s': %s" % (head, exc.args[-1]))
            created_dirs.append(head)

        _path_created[abs_head] = 1
    return created_dirs

def create_tree(base_dir, files, mode=0777, verbose=1, dry_run=0):
    """Create all the empty directories under 'base_dir' needed to put 'files'
    there.

    'base_dir' is just the name of a directory which doesn't necessarily
    exist yet; 'files' is a list of filenames to be interpreted relative to
    'base_dir'.  'base_dir' + the directory portion of every file in 'files'
    will be created if it doesn't already exist.  'mode', 'verbose' and
    'dry_run' flags are as for 'mkpath()'.
    """
    # First get the list of directories to create
    need_dir = {}
    for file in files:
        need_dir[os.path.join(base_dir, os.path.dirname(file))] = 1
    need_dirs = need_dir.keys()
    need_dirs.sort()

    # Now create them
    for dir in need_dirs:
        mkpath(dir, mode, verbose=verbose, dry_run=dry_run)

def copy_tree(src, dst, preserve_mode=1, preserve_times=1,
              preserve_symlinks=0, update=0, verbose=1, dry_run=0):
    """Copy an entire directory tree 'src' to a new location 'dst'.

    Both 'src' and 'dst' must be directory names.  If 'src' is not a
    directory, raise DistutilsFileError.  If 'dst' does not exist, it is
    created with 'mkpath()'.  The end result of the copy is that every
    file in 'src' is copied to 'dst', and directories under 'src' are
    recursively copied to 'dst'.  Return the list of files that were
    copied or might have been copied, using their output name.  The
    return value is unaffected by 'update' or 'dry_run': it is simply
    the list of all files under 'src', with the names changed to be
    under 'dst'.

    'preserve_mode' and 'preserve_times' are the same as for
    'copy_file'; note that they only apply to regular files, not to
    directories.  If 'preserve_symlinks' is true, symlinks will be
    copied as symlinks (on platforms that support them!); otherwise
    (the default), the destination of the symlink will be copied.
    'update' and 'verbose' are the same as for 'copy_file'.
    """
    from distutils.file_util import copy_file

    if not dry_run and not os.path.isdir(src):
        raise DistutilsFileError, \
              "cannot copy tree '%s': not a directory" % src
    try:
        names = os.listdir(src)
    except os.error, (errno, errstr):
        if dry_run:
            names = []
        else:
            raise DistutilsFileError, \
                  "error listing files in '%s': %s" % (src, errstr)

    if not dry_run:
        mkpath(dst, verbose=verbose)

    outputs = []

    for n in names:
        src_name = os.path.join(src, n)
        dst_name = os.path.join(dst, n)

        if n.startswith('.nfs'):
            # skip NFS rename files
            continue

        if preserve_symlinks and os.path.islink(src_name):
            link_dest = os.readlink(src_name)
            if verbose >= 1:
                log.info("linking %s -> %s", dst_name, link_dest)
            if not dry_run:
                os.symlink(link_dest, dst_name)
            outputs.append(dst_name)

        elif os.path.isdir(src_name):
            outputs.extend(
                copy_tree(src_name, dst_name, preserve_mode,
                          preserve_times, preserve_symlinks, update,
                          verbose=verbose, dry_run=dry_run))
        else:
            copy_file(src_name, dst_name, preserve_mode,
                      preserve_times, update, verbose=verbose,
                      dry_run=dry_run)
            outputs.append(dst_name)

    return outputs

def _build_cmdtuple(path, cmdtuples):
    """Helper for remove_tree()."""
    for f in os.listdir(path):
        real_f = os.path.join(path,f)
        if os.path.isdir(real_f) and not os.path.islink(real_f):
            _build_cmdtuple(real_f, cmdtuples)
        else:
            cmdtuples.append((os.remove, real_f))
    cmdtuples.append((os.rmdir, path))

def remove_tree(directory, verbose=1, dry_run=0):
    """Recursively remove an entire directory tree.

    Any errors are ignored (apart from being reported to stdout if 'verbose'
    is true).
    """
    global _path_created

    if verbose >= 1:
        log.info("removing '%s' (and everything under it)", directory)
    if dry_run:
        return
    cmdtuples = []
    _build_cmdtuple(directory, cmdtuples)
    for cmd in cmdtuples:
        try:
            cmd[0](cmd[1])
            # remove dir from cache if it's already there
            abspath = os.path.abspath(cmd[1])
            if abspath in _path_created:
                del _path_created[abspath]
        except (IOError, OSError), exc:
            log.warn("error removing %s: %s", directory, exc)

def ensure_relative(path):
    """Take the full path 'path', and make it a relative path.

    This is useful to make 'path' the second argument to os.path.join().
    """
    drive, path = os.path.splitdrive(path)
    if path[0:1] == os.sep:
        path = drive + path[1:]
    return path

filename:/usr/lib/python2.7/distutils/debug.py
__doc__
import os

__revision__ = "$Id$"

# If DISTUTILS_DEBUG is anything other than the empty string, we run in
# debug mode.
DEBUG = os.environ.get('DISTUTILS_DEBUG')

filename:/usr/lib/python2.7/distutils/msvccompiler.py
__doc__
"""distutils.msvccompiler

filename:/usr/lib/python2.7/distutils/file_util.py
__doc__
"""distutils.file_util

Utility functions for operating on single files.
"""

filename:/usr/lib/python2.7/distutils/core.py
__doc__
"""distutils.core

The only module that needs to be imported to use the Distutils; provides
the 'setup' function (which is to be called from the setup script).  Also
indirectly provides the Distribution and Command classes, although they are
really defined in distutils.dist and distutils.cmd.
"""

filename:/usr/lib/python2.7/distutils/extension.py
__doc__
"""distutils.extension

Provides the Extension class, used to describe C/C++ extension
modules in setup scripts."""

__revision__ = "$Id$"

import os, string, sys
from types import *

try:
    import warnings
except ImportError:
    warnings = None

# This class is really only used by the "build_ext" command, so it might
# make sense to put it in distutils.command.build_ext.  However, that
# module is already big enough, and I want to make this class a bit more
# complex to simplify some common cases ("foo" module in "foo.c") and do
# better error-checking ("foo.c" actually exists).
#
# Also, putting this in build_ext.py means every setup script would have to
# import that large-ish module (indirectly, through distutils.core) in
# order to do anything.

class Extension:
    """Just a collection of attributes that describes an extension
    module and everything needed to build it (hopefully in a portable
    way, but there are hooks that let you be as unportable as you need).

    Instance attributes:
      name : string
        the full name of the extension, including any packages -- ie.
        *not* a filename or pathname, but Python dotted name
      sources : [string]
        list of source filenames, relative to the distribution root
        (where the setup script lives), in Unix form (slash-separated)
        for portability.  Source files may be C, C++, SWIG (.i),
        platform-specific resource files, or whatever else is recognized
        by the "build_ext" command as source for a Python extension.
      include_dirs : [string]
        list of directories to search for C/C++ header files (in Unix
        form for portability)
      define_macros : [(name : string, value : string|None)]
        list of macros to define; each macro is defined using a 2-tuple,
        where 'value' is either the string to define it to or None to
        define it without a particular value (equivalent of "#define
        FOO" in source or -DFOO on Unix C compiler command line)
      undef_macros : [string]
        list of macros to undefine explicitly
      library_dirs : [string]
        list of directories to search for C/C++ libraries at link time
      libraries : [string]
        list of library names (not filenames or paths) to link against
      runtime_library_dirs : [string]
        list of directories to search for C/C++ libraries at run time
        (for shared extensions, this is when the extension is loaded)
      extra_objects : [string]
        list of extra files to link with (eg. object files not implied
        by 'sources', static library that must be explicitly specified,
        binary resource files, etc.)
      extra_compile_args : [string]
        any extra platform- and compiler-specific information to use
        when compiling the source files in 'sources'.  For platforms and
        compilers where "command line" makes sense, this is typically a
        list of command-line arguments, but for other platforms it could
        be anything.
      extra_link_args : [string]
        any extra platform- and compiler-specific information to use
        when linking object files together to create the extension (or
        to create a new static Python interpreter).  Similar
        interpretation as for 'extra_compile_args'.
      export_symbols : [string]
        list of symbols to be exported from a shared extension.  Not
        used on all platforms, and not generally necessary for Python
        extensions, which typically export exactly one symbol: "init" +
        extension_name.
      swig_opts : [string]
        any extra options to pass to SWIG if a source file has the .i
        extension.
      depends : [string]
        list of files that the extension depends on
      language : string
        extension language (i.e. "c", "c++", "objc"). Will be detected
        from the source extensions if not provided.
    """

    # When adding arguments to this constructor, be sure to update
    # setup_keywords in core.py.
    def __init__ (self, name, sources,
                  include_dirs=None,
                  define_macros=None,
                  undef_macros=None,
                  library_dirs=None,
                  libraries=None,
                  runtime_library_dirs=None,
                  extra_objects=None,
                  extra_compile_args=None,
                  extra_link_args=None,
                  export_symbols=None,
                  swig_opts = None,
                  depends=None,
                  language=None,
                  **kw                      # To catch unknown keywords
                 ):
        assert type(name) is StringType, "'name' must be a string"
        assert (type(sources) is ListType and
                map(type, sources) == [StringType]*len(sources)), \
                "'sources' must be a list of strings"

        self.name = name
        self.sources = sources
        self.include_dirs = include_dirs or []
        self.define_macros = define_macros or []
        self.undef_macros = undef_macros or []
        self.library_dirs = library_dirs or []
        self.libraries = libraries or []
        self.runtime_library_dirs = runtime_library_dirs or []
        self.extra_objects = extra_objects or []
        self.extra_compile_args = extra_compile_args or []
        self.extra_link_args = extra_link_args or []
        self.export_symbols = export_symbols or []
        self.swig_opts = swig_opts or []
        self.depends = depends or []
        self.language = language

        # If there are unknown keyword options, warn about them
        if len(kw):
            L = kw.keys() ; L.sort()
            L = map(repr, L)
            msg = "Unknown Extension options: " + string.join(L, ', ')
            if warnings is not None:
                warnings.warn(msg)
            else:
                sys.stderr.write(msg + '\n')
# class Extension


def read_setup_file (filename):
    from distutils.sysconfig import \
         parse_makefile, expand_makefile_vars, _variable_rx
    from distutils.text_file import TextFile
    from distutils.util import split_quoted

    # First pass over the file to gather "VAR = VALUE" assignments.
    vars = parse_makefile(filename)

    # Second pass to gobble up the real content: lines of the form
    #   <module> ... [<sourcefile> ...] [<cpparg> ...] [<library> ...]
    file = TextFile(filename,
                    strip_comments=1, skip_blanks=1, join_lines=1,
                    lstrip_ws=1, rstrip_ws=1)
    try:
        extensions = []

        while 1:
            line = file.readline()
            if line is None:                # eof
                break
            if _variable_rx.match(line):    # VAR=VALUE, handled in first pass
                continue

                if line[0] == line[-1] == "*":
                    file.warn("'%s' lines not handled yet" % line)
                    continue

            #print "original line: " + line
            line = expand_makefile_vars(line, vars)
            words = split_quoted(line)
            #print "expanded line: " + line

            # NB. this parses a slightly different syntax than the old
            # makesetup script: here, there must be exactly one extension per
            # line, and it must be the first word of the line.  I have no idea
            # why the old syntax supported multiple extensions per line, as
            # they all wind up being the same.

            module = words[0]
            ext = Extension(module, [])
            append_next_word = None

            for word in words[1:]:
                if append_next_word is not None:
                    append_next_word.append(word)
                    append_next_word = None
                    continue

                suffix = os.path.splitext(word)[1]
                switch = word[0:2] ; value = word[2:]

                if suffix in (".c", ".cc", ".cpp", ".cxx", ".c++", ".m", ".mm"):
                    # hmm, should we do something about C vs. C++ sources?
                    # or leave it up to the CCompiler implementation to
                    # worry about?
                    ext.sources.append(word)
                elif switch == "-I":
                    ext.include_dirs.append(value)
                elif switch == "-D":
                    equals = string.find(value, "=")
                    if equals == -1:        # bare "-DFOO" -- no value
                        ext.define_macros.append((value, None))
                    else:                   # "-DFOO=blah"
                        ext.define_macros.append((value[0:equals],
                                                  value[equals+2:]))
                elif switch == "-U":
                    ext.undef_macros.append(value)
                elif switch == "-C":        # only here 'cause makesetup has it!
                    ext.extra_compile_args.append(word)
                elif switch == "-l":
                    ext.libraries.append(value)
                elif switch == "-L":
                    ext.library_dirs.append(value)
                elif switch == "-R":
                    ext.runtime_library_dirs.append(value)
                elif word == "-rpath":
                    append_next_word = ext.runtime_library_dirs
                elif word == "-Xlinker":
                    append_next_word = ext.extra_link_args
                elif word == "-Xcompiler":
                    append_next_word = ext.extra_compile_args
                elif switch == "-u":
                    ext.extra_link_args.append(word)
                    if not value:
                        append_next_word = ext.extra_link_args
                elif word == "-Xcompiler":
                    append_next_word = ext.extra_compile_args
                elif switch == "-u":
                    ext.extra_link_args.append(word)
                    if not value:
                        append_next_word = ext.extra_link_args
                elif suffix in (".a", ".so", ".sl", ".o", ".dylib"):
                    # NB. a really faithful emulation of makesetup would
                    # append a .o file to extra_objects only if it
                    # had a slash in it; otherwise, it would s/.o/.c/
                    # and append it to sources.  Hmmmm.
                    ext.extra_objects.append(word)
                else:
                    file.warn("unrecognized argument '%s'" % word)

            extensions.append(ext)
    finally:
        file.close()

        #print "module:", module
        #print "source files:", source_files
        #print "cpp args:", cpp_args
        #print "lib args:", library_args

        #extensions[module] = { 'sources': source_files,
        #                       'cpp_args': cpp_args,
        #                       'lib_args': library_args }

    return extensions

# read_setup_file ()

filename:/usr/lib/python2.7/distutils/README
__doc__
This directory contains the Distutils package.

There's a full documentation available at:

    http://docs.python.org/distutils/

The Distutils-SIG web page is also a good starting point:

    http://www.python.org/sigs/distutils-sig/

WARNING : Distutils must remain compatible with 2.3

$Id$

filename:/usr/lib/python2.7/distutils/config.py
__doc__
"""distutils.pypirc

filename:/usr/lib/python2.7/distutils/ccompiler.py
__doc__
"""distutils.ccompiler

Contains CCompiler, an abstract base class that defines the interface
for the Distutils compiler abstraction model."""

__revision__ = "$Id$"

import sys
import os
import re

from distutils.errors import (CompileError, LinkError, UnknownFileError,
                              DistutilsPlatformError, DistutilsModuleError)
from distutils.spawn import spawn
from distutils.file_util import move_file
from distutils.dir_util import mkpath
from distutils.dep_util import newer_group
from distutils.util import split_quoted, execute
from distutils import log
# following import is for backward compatibility
from distutils.sysconfig import customize_compiler

class CCompiler:
    """Abstract base class to define the interface that must be implemented
    by real compiler classes.  Also has some utility methods used by
    several compiler classes.

    The basic idea behind a compiler abstraction class is that each
    instance can be used for all the compile/link steps in building a
    single project.  Thus, attributes common to all of those compile and
    link steps -- include directories, macros to define, libraries to link
    against, etc. -- are attributes of the compiler instance.  To allow for
    variability in how individual files are treated, most of those
    attributes may be varied on a per-compilation or per-link basis.
    """

    # 'compiler_type' is a class attribute that identifies this class.  It
    # keeps code that wants to know what kind of compiler it's dealing with
    # from having to import all possible compiler classes just to do an
    # 'isinstance'.  In concrete CCompiler subclasses, 'compiler_type'
    # should really, really be one of the keys of the 'compiler_class'
    # dictionary (see below -- used by the 'new_compiler()' factory
    # function) -- authors of new compiler interface classes are
    # responsible for updating 'compiler_class'!
    compiler_type = None

    # XXX things not handled by this compiler abstraction model:
    #   * client can't provide additional options for a compiler,
    #     e.g. warning, optimization, debugging flags.  Perhaps this
    #     should be the domain of concrete compiler abstraction classes
    #     (UnixCCompiler, MSVCCompiler, etc.) -- or perhaps the base
    #     class should have methods for the common ones.
    #   * can't completely override the include or library searchg
    #     path, ie. no "cc -I -Idir1 -Idir2" or "cc -L -Ldir1 -Ldir2".
    #     I'm not sure how widely supported this is even by Unix
    #     compilers, much less on other platforms.  And I'm even less
    #     sure how useful it is; maybe for cross-compiling, but
    #     support for that is a ways off.  (And anyways, cross
    #     compilers probably have a dedicated binary with the
    #     right paths compiled in.  I hope.)
    #   * can't do really freaky things with the library list/library
    #     dirs, e.g. "-Ldir1 -lfoo -Ldir2 -lfoo" to link against
    #     different versions of libfoo.a in different locations.  I
    #     think this is useless without the ability to null out the
    #     library search path anyways.


    # Subclasses that rely on the standard filename generation methods
    # implemented below should override these; see the comment near
    # those methods ('object_filenames()' et. al.) for details:
    src_extensions = None               # list of strings
    obj_extension = None                # string
    static_lib_extension = None
    shared_lib_extension = None         # string
    static_lib_format = None            # format string
    shared_lib_format = None            # prob. same as static_lib_format
    exe_extension = None                # string

    # Default language settings. language_map is used to detect a source
    # file or Extension target language, checking source filenames.
    # language_order is used to detect the language precedence, when deciding
    # what language to use when mixing source types. For example, if some
    # extension has two files with ".c" extension, and one with ".cpp", it
    # is still linked as c++.
    language_map = {".c"   : "c",
                    ".cc"  : "c++",
                    ".cpp" : "c++",
                    ".cxx" : "c++",
                    ".m"   : "objc",
                   }
    language_order = ["c++", "objc", "c"]

    def __init__ (self, verbose=0, dry_run=0, force=0):
        self.dry_run = dry_run
        self.force = force
        self.verbose = verbose

        # 'output_dir': a common output directory for object, library,
        # shared object, and shared library files
        self.output_dir = None

        # 'macros': a list of macro definitions (or undefinitions).  A
        # macro definition is a 2-tuple (name, value), where the value is
        # either a string or None (no explicit value).  A macro
        # undefinition is a 1-tuple (name,).
        self.macros = []

        # 'include_dirs': a list of directories to search for include files
        self.include_dirs = []

        # 'libraries': a list of libraries to include in any link
        # (library names, not filenames: eg. "foo" not "libfoo.a")
        self.libraries = []

        # 'library_dirs': a list of directories to search for libraries
        self.library_dirs = []

        # 'runtime_library_dirs': a list of directories to search for
        # shared libraries/objects at runtime
        self.runtime_library_dirs = []

        # 'objects': a list of object files (or similar, such as explicitly
        # named library files) to include on any link
        self.objects = []

        for key in self.executables.keys():
            self.set_executable(key, self.executables[key])

    def set_executables(self, **args):
        """Define the executables (and options for them) that will be run
        to perform the various stages of compilation.  The exact set of
        executables that may be specified here depends on the compiler
        class (via the 'executables' class attribute), but most will have:
          compiler      the C/C++ compiler
          linker_so     linker used to create shared objects and libraries
          linker_exe    linker used to create binary executables
          archiver      static library creator

        On platforms with a command-line (Unix, DOS/Windows), each of these
        is a string that will be split into executable name and (optional)
        list of arguments.  (Splitting the string is done similarly to how
        Unix shells operate: words are delimited by spaces, but quotes and
        backslashes can override this.  See
        'distutils.util.split_quoted()'.)
        """

        # Note that some CCompiler implementation classes will define class
        # attributes 'cpp', 'cc', etc. with hard-coded executable names;
        # this is appropriate when a compiler class is for exactly one
        # compiler/OS combination (eg. MSVCCompiler).  Other compiler
        # classes (UnixCCompiler, in particular) are driven by information
        # discovered at run-time, since there are many different ways to do
        # basically the same things with Unix C compilers.

        for key in args.keys():
            if key not in self.executables:
                raise ValueError, \
                      "unknown executable '%s' for class %s" % \
                      (key, self.__class__.__name__)
            self.set_executable(key, args[key])

    def set_executable(self, key, value):
        if isinstance(value, str):
            setattr(self, key, split_quoted(value))
        else:
            setattr(self, key, value)

    def _find_macro(self, name):
        i = 0
        for defn in self.macros:
            if defn[0] == name:
                return i
            i = i + 1
        return None

    def _check_macro_definitions(self, definitions):
        """Ensures that every element of 'definitions' is a valid macro
        definition, ie. either (name,value) 2-tuple or a (name,) tuple.  Do
        nothing if all definitions are OK, raise TypeError otherwise.
        """
        for defn in definitions:
            if not (isinstance(defn, tuple) and
                    (len (defn) == 1 or
                     (len (defn) == 2 and
                      (isinstance(defn[1], str) or defn[1] is None))) and
                    isinstance(defn[0], str)):
                raise TypeError, \
                      ("invalid macro definition '%s': " % defn) + \
                      "must be tuple (string,), (string, string), or " + \
                      "(string, None)"


    # -- Bookkeeping methods -------------------------------------------

    def define_macro(self, name, value=None):
        """Define a preprocessor macro for all compilations driven by this
        compiler object.  The optional parameter 'value' should be a
        string; if it is not supplied, then the macro will be defined
        without an explicit value and the exact outcome depends on the
        compiler used (XXX true? does ANSI say anything about this?)
        """
        # Delete from the list of macro definitions/undefinitions if
        # already there (so that this one will take precedence).
        i = self._find_macro (name)
        if i is not None:
            del self.macros[i]

        defn = (name, value)
        self.macros.append (defn)

    def undefine_macro(self, name):
        """Undefine a preprocessor macro for all compilations driven by
        this compiler object.  If the same macro is defined by
        'define_macro()' and undefined by 'undefine_macro()' the last call
        takes precedence (including multiple redefinitions or
        undefinitions).  If the macro is redefined/undefined on a
        per-compilation basis (ie. in the call to 'compile()'), then that
        takes precedence.
        """
        # Delete from the list of macro definitions/undefinitions if
        # already there (so that this one will take precedence).
        i = self._find_macro (name)
        if i is not None:
            del self.macros[i]

        undefn = (name,)
        self.macros.append (undefn)

    def add_include_dir(self, dir):
        """Add 'dir' to the list of directories that will be searched for
        header files.  The compiler is instructed to search directories in
        the order in which they are supplied by successive calls to
        'add_include_dir()'.
        """
        self.include_dirs.append (dir)

    def set_include_dirs(self, dirs):
        """Set the list of directories that will be searched to 'dirs' (a
        list of strings).  Overrides any preceding calls to
        'add_include_dir()'; subsequence calls to 'add_include_dir()' add
        to the list passed to 'set_include_dirs()'.  This does not affect
        any list of standard include directories that the compiler may
        search by default.
        """
        self.include_dirs = dirs[:]

    def add_library(self, libname):
        """Add 'libname' to the list of libraries that will be included in
        all links driven by this compiler object.  Note that 'libname'
        should *not* be the name of a file containing a library, but the
        name of the library itself: the actual filename will be inferred by
        the linker, the compiler, or the compiler class (depending on the
        platform).

        The linker will be instructed to link against libraries in the
        order they were supplied to 'add_library()' and/or
        'set_libraries()'.  It is perfectly valid to duplicate library
        names; the linker will be instructed to link against libraries as
        many times as they are mentioned.
        """
        self.libraries.append (libname)

    def set_libraries(self, libnames):
        """Set the list of libraries to be included in all links driven by
        this compiler object to 'libnames' (a list of strings).  This does
        not affect any standard system libraries that the linker may
        include by default.
        """
        self.libraries = libnames[:]


    def add_library_dir(self, dir):
        """Add 'dir' to the list of directories that will be searched for
        libraries specified to 'add_library()' and 'set_libraries()'.  The
        linker will be instructed to search for libraries in the order they
        are supplied to 'add_library_dir()' and/or 'set_library_dirs()'.
        """
        self.library_dirs.append(dir)

    def set_library_dirs(self, dirs):
        """Set the list of library search directories to 'dirs' (a list of
        strings).  This does not affect any standard library search path
        that the linker may search by default.
        """
        self.library_dirs = dirs[:]

    def add_runtime_library_dir(self, dir):
        """Add 'dir' to the list of directories that will be searched for
        shared libraries at runtime.
        """
        self.runtime_library_dirs.append(dir)

    def set_runtime_library_dirs(self, dirs):
        """Set the list of directories to search for shared libraries at
        runtime to 'dirs' (a list of strings).  This does not affect any
        standard search path that the runtime linker may search by
        default.
        """
        self.runtime_library_dirs = dirs[:]

    def add_link_object(self, object):
        """Add 'object' to the list of object files (or analogues, such as
        explicitly named library files or the output of "resource
        compilers") to be included in every link driven by this compiler
        object.
        """
        self.objects.append(object)

    def set_link_objects(self, objects):
        """Set the list of object files (or analogues) to be included in
        every link to 'objects'.  This does not affect any standard object
        files that the linker may include by default (such as system
        libraries).
        """
        self.objects = objects[:]


    # -- Private utility methods --------------------------------------
    # (here for the convenience of subclasses)

    # Helper method to prep compiler in subclass compile() methods

    def _setup_compile(self, outdir, macros, incdirs, sources, depends,
                       extra):
        """Process arguments and decide which source files to compile."""
        if outdir is None:
            outdir = self.output_dir
        elif not isinstance(outdir, str):
            raise TypeError, "'output_dir' must be a string or None"

        if macros is None:
            macros = self.macros
        elif isinstance(macros, list):
            macros = macros + (self.macros or [])
        else:
            raise TypeError, "'macros' (if supplied) must be a list of tuples"

        if incdirs is None:
            incdirs = self.include_dirs
        elif isinstance(incdirs, (list, tuple)):
            incdirs = list(incdirs) + (self.include_dirs or [])
        else:
            raise TypeError, \
                  "'include_dirs' (if supplied) must be a list of strings"

        if extra is None:
            extra = []

        # Get the list of expected output (object) files
        objects = self.object_filenames(sources,
                                        strip_dir=0,
                                        output_dir=outdir)
        assert len(objects) == len(sources)

        pp_opts = gen_preprocess_options(macros, incdirs)

        build = {}
        for i in range(len(sources)):
            src = sources[i]
            obj = objects[i]
            ext = os.path.splitext(src)[1]
            self.mkpath(os.path.dirname(obj))
            build[obj] = (src, ext)

        return macros, objects, extra, pp_opts, build

    def _get_cc_args(self, pp_opts, debug, before):
        # works for unixccompiler, emxccompiler, cygwinccompiler
        cc_args = pp_opts + ['-c']
        if debug:
            cc_args[:0] = ['-g']
        if before:
            cc_args[:0] = before
        return cc_args

    def _fix_compile_args(self, output_dir, macros, include_dirs):
        """Typecheck and fix-up some of the arguments to the 'compile()'
        method, and return fixed-up values.  Specifically: if 'output_dir'
        is None, replaces it with 'self.output_dir'; ensures that 'macros'
        is a list, and augments it with 'self.macros'; ensures that
        'include_dirs' is a list, and augments it with 'self.include_dirs'.
        Guarantees that the returned values are of the correct type,
        i.e. for 'output_dir' either string or None, and for 'macros' and
        'include_dirs' either list or None.
        """
        if output_dir is None:
            output_dir = self.output_dir
        elif not isinstance(output_dir, str):
            raise TypeError, "'output_dir' must be a string or None"

        if macros is None:
            macros = self.macros
        elif isinstance(macros, list):
            macros = macros + (self.macros or [])
        else:
            raise TypeError, "'macros' (if supplied) must be a list of tuples"

        if include_dirs is None:
            include_dirs = self.include_dirs
        elif isinstance(include_dirs, (list, tuple)):
            include_dirs = list (include_dirs) + (self.include_dirs or [])
        else:
            raise TypeError, \
                  "'include_dirs' (if supplied) must be a list of strings"

        return output_dir, macros, include_dirs

    def _fix_object_args(self, objects, output_dir):
        """Typecheck and fix up some arguments supplied to various methods.
        Specifically: ensure that 'objects' is a list; if output_dir is
        None, replace with self.output_dir.  Return fixed versions of
        'objects' and 'output_dir'.
        """
        if not isinstance(objects, (list, tuple)):
            raise TypeError, \
                  "'objects' must be a list or tuple of strings"
        objects = list (objects)

        if output_dir is None:
            output_dir = self.output_dir
        elif not isinstance(output_dir, str):
            raise TypeError, "'output_dir' must be a string or None"

        return (objects, output_dir)

    def _fix_lib_args(self, libraries, library_dirs, runtime_library_dirs):
        """Typecheck and fix up some of the arguments supplied to the
        'link_*' methods.  Specifically: ensure that all arguments are
        lists, and augment them with their permanent versions
        (eg. 'self.libraries' augments 'libraries').  Return a tuple with
        fixed versions of all arguments.
        """
        if libraries is None:
            libraries = self.libraries
        elif isinstance(libraries, (list, tuple)):
            libraries = list (libraries) + (self.libraries or [])
        else:
            raise TypeError, \
                  "'libraries' (if supplied) must be a list of strings"

        if library_dirs is None:
            library_dirs = self.library_dirs
        elif isinstance(library_dirs, (list, tuple)):
            library_dirs = list (library_dirs) + (self.library_dirs or [])
        else:
            raise TypeError, \
                  "'library_dirs' (if supplied) must be a list of strings"

        if runtime_library_dirs is None:
            runtime_library_dirs = self.runtime_library_dirs
        elif isinstance(runtime_library_dirs, (list, tuple)):
            runtime_library_dirs = (list (runtime_library_dirs) +
                                    (self.runtime_library_dirs or []))
        else:
            raise TypeError, \
                  "'runtime_library_dirs' (if supplied) " + \
                  "must be a list of strings"

        return (libraries, library_dirs, runtime_library_dirs)

    def _need_link(self, objects, output_file):
        """Return true if we need to relink the files listed in 'objects'
        to recreate 'output_file'.
        """
        if self.force:
            return 1
        else:
            if self.dry_run:
                newer = newer_group (objects, output_file, missing='newer')
            else:
                newer = newer_group (objects, output_file)
            return newer

    def detect_language(self, sources):
        """Detect the language of a given file, or list of files. Uses
        language_map, and language_order to do the job.
        """
        if not isinstance(sources, list):
            sources = [sources]
        lang = None
        index = len(self.language_order)
        for source in sources:
            base, ext = os.path.splitext(source)
            extlang = self.language_map.get(ext)
            try:
                extindex = self.language_order.index(extlang)
                if extindex < index:
                    lang = extlang
                    index = extindex
            except ValueError:
                pass
        return lang

    # -- Worker methods ------------------------------------------------
    # (must be implemented by subclasses)

    def preprocess(self, source, output_file=None, macros=None,
                   include_dirs=None, extra_preargs=None, extra_postargs=None):
        """Preprocess a single C/C++ source file, named in 'source'.
        Output will be written to file named 'output_file', or stdout if
        'output_file' not supplied.  'macros' is a list of macro
        definitions as for 'compile()', which will augment the macros set
        with 'define_macro()' and 'undefine_macro()'.  'include_dirs' is a
        list of directory names that will be added to the default list.

        Raises PreprocessError on failure.
        """
        pass

    def compile(self, sources, output_dir=None, macros=None,
                include_dirs=None, debug=0, extra_preargs=None,
                extra_postargs=None, depends=None):
        """Compile one or more source files.

        'sources' must be a list of filenames, most likely C/C++
        files, but in reality anything that can be handled by a
        particular compiler and compiler class (eg. MSVCCompiler can
        handle resource files in 'sources').  Return a list of object
        filenames, one per source filename in 'sources'.  Depending on
        the implementation, not all source files will necessarily be
        compiled, but all corresponding object filenames will be
        returned.

        If 'output_dir' is given, object files will be put under it, while
        retaining their original path component.  That is, "foo/bar.c"
        normally compiles to "foo/bar.o" (for a Unix implementation); if
        'output_dir' is "build", then it would compile to
        "build/foo/bar.o".

        'macros', if given, must be a list of macro definitions.  A macro
        definition is either a (name, value) 2-tuple or a (name,) 1-tuple.
        The former defines a macro; if the value is None, the macro is
        defined without an explicit value.  The 1-tuple case undefines a
        macro.  Later definitions/redefinitions/ undefinitions take
        precedence.

        'include_dirs', if given, must be a list of strings, the
        directories to add to the default include file search path for this
        compilation only.

        'debug' is a boolean; if true, the compiler will be instructed to
        output debug symbols in (or alongside) the object file(s).

        'extra_preargs' and 'extra_postargs' are implementation- dependent.
        On platforms that have the notion of a command-line (e.g. Unix,
        DOS/Windows), they are most likely lists of strings: extra
        command-line arguments to prepand/append to the compiler command
        line.  On other platforms, consult the implementation class
        documentation.  In any event, they are intended as an escape hatch
        for those occasions when the abstract compiler framework doesn't
        cut the mustard.

        'depends', if given, is a list of filenames that all targets
        depend on.  If a source file is older than any file in
        depends, then the source file will be recompiled.  This
        supports dependency tracking, but only at a coarse
        granularity.

        Raises CompileError on failure.
        """
        # A concrete compiler class can either override this method
        # entirely or implement _compile().

        macros, objects, extra_postargs, pp_opts, build = \
                self._setup_compile(output_dir, macros, include_dirs, sources,
                                    depends, extra_postargs)
        cc_args = self._get_cc_args(pp_opts, debug, extra_preargs)

        for obj in objects:
            try:
                src, ext = build[obj]
            except KeyError:
                continue
            self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)

        # Return *all* object filenames, not just the ones we just built.
        return objects

    def _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):
        """Compile 'src' to product 'obj'."""

        # A concrete compiler class that does not override compile()
        # should implement _compile().
        pass

    def create_static_lib(self, objects, output_libname, output_dir=None,
                          debug=0, target_lang=None):
        """Link a bunch of stuff together to create a static library file.
        The "bunch of stuff" consists of the list of object files supplied
        as 'objects', the extra object files supplied to
        'add_link_object()' and/or 'set_link_objects()', the libraries
        supplied to 'add_library()' and/or 'set_libraries()', and the
        libraries supplied as 'libraries' (if any).

        'output_libname' should be a library name, not a filename; the
        filename will be inferred from the library name.  'output_dir' is
        the directory where the library file will be put.

        'debug' is a boolean; if true, debugging information will be
        included in the library (note that on most platforms, it is the
        compile step where this matters: the 'debug' flag is included here
        just for consistency).

        'target_lang' is the target language for which the given objects
        are being compiled. This allows specific linkage time treatment of
        certain languages.

        Raises LibError on failure.
        """
        pass

    # values for target_desc parameter in link()
    SHARED_OBJECT = "shared_object"
    SHARED_LIBRARY = "shared_library"
    EXECUTABLE = "executable"

    def link(self, target_desc, objects, output_filename, output_dir=None,
             libraries=None, library_dirs=None, runtime_library_dirs=None,
             export_symbols=None, debug=0, extra_preargs=None,
             extra_postargs=None, build_temp=None, target_lang=None):
        """Link a bunch of stuff together to create an executable or
        shared library file.

        The "bunch of stuff" consists of the list of object files supplied
        as 'objects'.  'output_filename' should be a filename.  If
        'output_dir' is supplied, 'output_filename' is relative to it
        (i.e. 'output_filename' can provide directory components if
        needed).

        'libraries' is a list of libraries to link against.  These are
        library names, not filenames, since they're translated into
        filenames in a platform-specific way (eg. "foo" becomes "libfoo.a"
        on Unix and "foo.lib" on DOS/Windows).  However, they can include a
        directory component, which means the linker will look in that
        specific directory rather than searching all the normal locations.

        'library_dirs', if supplied, should be a list of directories to
        search for libraries that were specified as bare library names
        (ie. no directory component).  These are on top of the system
        default and those supplied to 'add_library_dir()' and/or
        'set_library_dirs()'.  'runtime_library_dirs' is a list of
        directories that will be embedded into the shared library and used
        to search for other shared libraries that *it* depends on at
        run-time.  (This may only be relevant on Unix.)

        'export_symbols' is a list of symbols that the shared library will
        export.  (This appears to be relevant only on Windows.)

        'debug' is as for 'compile()' and 'create_static_lib()', with the
        slight distinction that it actually matters on most platforms (as
        opposed to 'create_static_lib()', which includes a 'debug' flag
        mostly for form's sake).

        'extra_preargs' and 'extra_postargs' are as for 'compile()' (except
        of course that they supply command-line arguments for the
        particular linker being used).

        'target_lang' is the target language for which the given objects
        are being compiled. This allows specific linkage time treatment of
        certain languages.

        Raises LinkError on failure.
        """
        raise NotImplementedError


    # Old 'link_*()' methods, rewritten to use the new 'link()' method.

    def link_shared_lib(self, objects, output_libname, output_dir=None,
                        libraries=None, library_dirs=None,
                        runtime_library_dirs=None, export_symbols=None,
                        debug=0, extra_preargs=None, extra_postargs=None,
                        build_temp=None, target_lang=None):
        self.link(CCompiler.SHARED_LIBRARY, objects,
                  self.library_filename(output_libname, lib_type='shared'),
                  output_dir,
                  libraries, library_dirs, runtime_library_dirs,
                  export_symbols, debug,
                  extra_preargs, extra_postargs, build_temp, target_lang)


    def link_shared_object(self, objects, output_filename, output_dir=None,
                           libraries=None, library_dirs=None,
                           runtime_library_dirs=None, export_symbols=None,
                           debug=0, extra_preargs=None, extra_postargs=None,
                           build_temp=None, target_lang=None):
        self.link(CCompiler.SHARED_OBJECT, objects,
                  output_filename, output_dir,
                  libraries, library_dirs, runtime_library_dirs,
                  export_symbols, debug,
                  extra_preargs, extra_postargs, build_temp, target_lang)

    def link_executable(self, objects, output_progname, output_dir=None,
                        libraries=None, library_dirs=None,
                        runtime_library_dirs=None, debug=0, extra_preargs=None,
                        extra_postargs=None, target_lang=None):
        self.link(CCompiler.EXECUTABLE, objects,
                  self.executable_filename(output_progname), output_dir,
                  libraries, library_dirs, runtime_library_dirs, None,
                  debug, extra_preargs, extra_postargs, None, target_lang)


    # -- Miscellaneous methods -----------------------------------------
    # These are all used by the 'gen_lib_options() function; there is
    # no appropriate default implementation so subclasses should
    # implement all of these.

    def library_dir_option(self, dir):
        """Return the compiler option to add 'dir' to the list of
        directories searched for libraries.
        """
        raise NotImplementedError

    def runtime_library_dir_option(self, dir):
        """Return the compiler option to add 'dir' to the list of
        directories searched for runtime libraries.
        """
        raise NotImplementedError

    def library_option(self, lib):
        """Return the compiler option to add 'lib' to the list of libraries
        linked into the shared library or executable.
        """
        raise NotImplementedError

    def has_function(self, funcname, includes=None, include_dirs=None,
                     libraries=None, library_dirs=None):
        """Return a boolean indicating whether funcname is supported on
        the current platform.  The optional arguments can be used to
        augment the compilation environment.
        """

        # this can't be included at module scope because it tries to
        # import math which might not be available at that point - maybe
        # the necessary logic should just be inlined?
        import tempfile
        if includes is None:
            includes = []
        if include_dirs is None:
            include_dirs = []
        if libraries is None:
            libraries = []
        if library_dirs is None:
            library_dirs = []
        fd, fname = tempfile.mkstemp(".c", funcname, text=True)
        f = os.fdopen(fd, "w")
        try:
            for incl in includes:
                f.write("""#include "%s"\n""" % incl)
            f.write("""\
main (int argc, char **argv) {
    %s();
}
""" % funcname)

filename:/usr/lib/python2.7/distutils/spawn.py
__doc__
"""distutils.spawn

Provides the 'spawn()' function, a front-end to various platform-
specific functions for launching another program in a sub-process.
Also provides the 'find_executable()' to search the path for a given
executable name.
"""

filename:/usr/lib/python2.7/distutils/bcppcompiler.py
__doc__
"""distutils.bcppcompiler

Contains BorlandCCompiler, an implementation of the abstract CCompiler class
for the Borland C++ compiler.
"""

filename:/usr/lib/python2.7/distutils/log.py
__doc__
"""A simple log mechanism styled after PEP 282."""

# The class here is styled after PEP 282 so that it could later be
# replaced with a standard Python logging implementation.

DEBUG = 1
INFO = 2
WARN = 3
ERROR = 4
FATAL = 5

import sys

class Log:

    def __init__(self, threshold=WARN):
        self.threshold = threshold

    def _log(self, level, msg, args):
        if level not in (DEBUG, INFO, WARN, ERROR, FATAL):
            raise ValueError('%s wrong log level' % str(level))

        if level >= self.threshold:
            if args:
                msg = msg % args
            if level in (WARN, ERROR, FATAL):
                stream = sys.stderr
            else:
                stream = sys.stdout
            stream.write('%s\n' % msg)
            stream.flush()

    def log(self, level, msg, *args):
        self._log(level, msg, args)

    def debug(self, msg, *args):
        self._log(DEBUG, msg, args)

    def info(self, msg, *args):
        self._log(INFO, msg, args)

    def warn(self, msg, *args):
        self._log(WARN, msg, args)

    def error(self, msg, *args):
        self._log(ERROR, msg, args)

    def fatal(self, msg, *args):
        self._log(FATAL, msg, args)

_global_log = Log()
log = _global_log.log
debug = _global_log.debug
info = _global_log.info
warn = _global_log.warn
error = _global_log.error
fatal = _global_log.fatal

def set_threshold(level):
    # return the old threshold for use from tests
    old = _global_log.threshold
    _global_log.threshold = level
    return old

def set_verbosity(v):
    if v <= 0:
        set_threshold(WARN)
    elif v == 1:
        set_threshold(INFO)
    elif v >= 2:
        set_threshold(DEBUG)

filename:/usr/lib/python2.7/mailcap.py
__doc__
"""Mailcap file handling.  See RFC 1524."""

filename:/usr/lib/python2.7/getopt.py
__doc__
"""Parser for command line options.

This module helps scripts to parse the command line arguments in
sys.argv.  It supports the same conventions as the Unix getopt()
function (including the special meanings of arguments of the form `-'
and `--').  Long options similar to those supported by GNU software
may be used as well via an optional third argument.  This module
provides two functions and an exception:

getopt() -- Parse command line options
gnu_getopt() -- Like getopt(), but allow option and non-option arguments
to be intermixed.
GetoptError -- exception (class) raised with 'opt' attribute, which is the
option involved with the exception.
"""

filename:/usr/lib/python2.7/wave.py
__doc__
"""Stuff to parse WAVE files.

Usage.

Reading WAVE files:
      f = wave.open(file, 'r')
where file is either the name of a file or an open file pointer.
The open file pointer must have methods read(), seek(), and close().
When the setpos() and rewind() methods are not used, the seek()
method is not  necessary.

This returns an instance of a class with the following public methods:
      getnchannels()  -- returns number of audio channels (1 for
                         mono, 2 for stereo)
      getsampwidth()  -- returns sample width in bytes
      getframerate()  -- returns sampling frequency
      getnframes()    -- returns number of audio frames
      getcomptype()   -- returns compression type ('NONE' for linear samples)
      getcompname()   -- returns human-readable version of
                         compression type ('not compressed' linear samples)
      getparams()     -- returns a tuple consisting of all of the
                         above in the above order
      getmarkers()    -- returns None (for compatibility with the
                         aifc module)
      getmark(id)     -- raises an error since the mark does not
                         exist (for compatibility with the aifc module)
      readframes(n)   -- returns at most n frames of audio
      rewind()        -- rewind to the beginning of the audio stream
      setpos(pos)     -- seek to the specified position
      tell()          -- return the current position
      close()         -- close the instance (make it unusable)
The position returned by tell() and the position given to setpos()
are compatible and have nothing to do with the actual position in the
file.
The close() method is called automatically when the class instance
is destroyed.

Writing WAVE files:
      f = wave.open(file, 'w')
where file is either the name of a file or an open file pointer.
The open file pointer must have methods write(), tell(), seek(), and
close().

This returns an instance of a class with the following public methods:
      setnchannels(n) -- set the number of channels
      setsampwidth(n) -- set the sample width
      setframerate(n) -- set the frame rate
      setnframes(n)   -- set the number of frames
      setcomptype(type, name)
                      -- set the compression type and the
                         human-readable compression type
      setparams(tuple)
                      -- set all parameters at once
      tell()          -- return current position in output file
      writeframesraw(data)
                      -- write audio frames without pathing up the
                         file header
      writeframes(data)
                      -- write audio frames and patch up the file header
      close()         -- patch up the file header and close the
                         output file
You should set the parameters before the first writeframesraw or
writeframes.  The total number of frames does not need to be set,
but when it is set to the correct value, the header does not have to
be patched up.
It is best to first set all parameters, perhaps possibly the
compression type, and then write audio frames using writeframesraw.
When all frames have been written, either call writeframes('') or
close() to patch up the sizes in the header.
The close() method is called automatically when the class instance
is destroyed.
"""

filename:/usr/lib/python2.7/macpath.py
__doc__
"""Pathname and path-related operations for the Macintosh."""

import os
import warnings
from stat import *
import genericpath
from genericpath import *
from genericpath import _unicode

__all__ = ["normcase","isabs","join","splitdrive","split","splitext",
           "basename","dirname","commonprefix","getsize","getmtime",
           "getatime","getctime", "islink","exists","lexists","isdir","isfile",
           "walk","expanduser","expandvars","normpath","abspath",
           "curdir","pardir","sep","pathsep","defpath","altsep","extsep",
           "devnull","realpath","supports_unicode_filenames"]

# strings representing various path-related bits and pieces
curdir = ':'
pardir = '::'
extsep = '.'
sep = ':'
pathsep = '\n'
defpath = ':'
altsep = None
devnull = 'Dev:Null'

# Normalize the case of a pathname.  Dummy in Posix, but <s>.lower() here.

def normcase(path):
    return path.lower()


def isabs(s):
    """Return true if a path is absolute.
    On the Mac, relative paths begin with a colon,
    but as a special case, paths with no colons at all are also relative.
    Anything else is absolute (the string up to the first colon is the
    volume name)."""

    return ':' in s and s[0] != ':'


def join(s, *p):
    path = s
    for t in p:
        if (not path) or isabs(t):
            path = t
            continue
        if t[:1] == ':':
            t = t[1:]
        if ':' not in path:
            path = ':' + path
        if path[-1:] != ':':
            path = path + ':'
        path = path + t
    return path


def split(s):
    """Split a pathname into two parts: the directory leading up to the final
    bit, and the basename (the filename, without colons, in that directory).
    The result (s, t) is such that join(s, t) yields the original argument."""

    if ':' not in s: return '', s
    colon = 0
    for i in range(len(s)):
        if s[i] == ':': colon = i + 1
    path, file = s[:colon-1], s[colon:]
    if path and not ':' in path:
        path = path + ':'
    return path, file


def splitext(p):
    return genericpath._splitext(p, sep, altsep, extsep)
splitext.__doc__ = genericpath._splitext.__doc__

def splitdrive(p):
    """Split a pathname into a drive specification and the rest of the
    path.  Useful on DOS/Windows/NT; on the Mac, the drive is always
    empty (don't use the volume name -- it doesn't have the same
    syntactic and semantic oddities as DOS drive letters, such as there
    being a separate current directory per drive)."""

    return '', p


# Short interfaces to split()

def dirname(s): return split(s)[0]
def basename(s): return split(s)[1]

def ismount(s):
    if not isabs(s):
        return False
    components = split(s)
    return len(components) == 2 and components[1] == ''

def islink(s):
    """Return true if the pathname refers to a symbolic link."""

    try:
        import Carbon.File
        return Carbon.File.ResolveAliasFile(s, 0)[2]
    except:
        return False

# Is `stat`/`lstat` a meaningful difference on the Mac?  This is safe in any
# case.

def lexists(path):
    """Test whether a path exists.  Returns True for broken symbolic links"""

    try:
        st = os.lstat(path)
    except os.error:
        return False
    return True

def expandvars(path):
    """Dummy to retain interface-compatibility with other operating systems."""
    return path


def expanduser(path):
    """Dummy to retain interface-compatibility with other operating systems."""
    return path

class norm_error(Exception):
    """Path cannot be normalized"""

def normpath(s):
    """Normalize a pathname.  Will return the same result for
    equivalent paths."""

    if ":" not in s:
        return ":"+s

    comps = s.split(":")
    i = 1
    while i < len(comps)-1:
        if comps[i] == "" and comps[i-1] != "":
            if i > 1:
                del comps[i-1:i+1]
                i = i - 1
            else:
                # best way to handle this is to raise an exception
                raise norm_error, 'Cannot use :: immediately after volume name'
        else:
            i = i + 1

    s = ":".join(comps)

    # remove trailing ":" except for ":" and "Volume:"
    if s[-1] == ":" and len(comps) > 2 and s != ":"*len(s):
        s = s[:-1]
    return s


def walk(top, func, arg):
    """Directory tree walk with callback function.

    For each directory in the directory tree rooted at top (including top
    itself, but excluding '.' and '..'), call func(arg, dirname, fnames).
    dirname is the name of the directory, and fnames a list of the names of
    the files and subdirectories in dirname (excluding '.' and '..').  func
    may modify the fnames list in-place (e.g. via del or slice assignment),
    and walk will only recurse into the subdirectories whose names remain in
    fnames; this can be used to implement a filter, or to impose a specific
    order of visiting.  No semantics are defined for, or required of, arg,
    beyond that arg is always passed to func.  It can be used, e.g., to pass
    a filename pattern, or a mutable object designed to accumulate
    statistics.  Passing None for arg is common."""
    warnings.warnpy3k("In 3.x, os.path.walk is removed in favor of os.walk.",
                      stacklevel=2)
    try:
        names = os.listdir(top)
    except os.error:
        return
    func(arg, top, names)
    for name in names:
        name = join(top, name)
        if isdir(name) and not islink(name):
            walk(name, func, arg)


def abspath(path):
    """Return an absolute path."""
    if not isabs(path):
        if isinstance(path, _unicode):
            cwd = os.getcwdu()
        else:
            cwd = os.getcwd()
        path = join(cwd, path)
    return normpath(path)

# realpath is a no-op on systems without islink support
def realpath(path):
    path = abspath(path)
    try:
        import Carbon.File
    except ImportError:
        return path
    if not path:
        return path
    components = path.split(':')
    path = components[0] + ':'
    for c in components[1:]:
        path = join(path, c)
        try:
            path = Carbon.File.FSResolveAliasFile(path, 1)[0].as_pathname()
        except Carbon.File.Error:
            pass
    return path

supports_unicode_filenames = True

filename:/usr/lib/python2.7/stringprep.py
__doc__
# This file is generated by mkstringprep.py. DO NOT EDIT.
"""Library that exposes various tables found in the StringPrep RFC 3454.

filename:/usr/lib/python2.7/statvfs.py
__doc__
"""Constants for interpreting the results of os.statvfs() and os.fstatvfs()."""
from warnings import warnpy3k
warnpy3k("the statvfs module has been removed in Python 3.0", stacklevel=2)
del warnpy3k

# Indices for statvfs struct members in the tuple returned by
# os.statvfs() and os.fstatvfs().

F_BSIZE   = 0           # Preferred file system block size
F_FRSIZE  = 1           # Fundamental file system block size
F_BLOCKS  = 2           # Total number of file system blocks (FRSIZE)
F_BFREE   = 3           # Total number of free blocks
F_BAVAIL  = 4           # Free blocks available to non-superuser
F_FILES   = 5           # Total number of file nodes
F_FFREE   = 6           # Total number of free file nodes
F_FAVAIL  = 7           # Free nodes available to non-superuser
F_FLAG    = 8           # Flags (see your local statvfs man page)
F_NAMEMAX = 9           # Maximum file name length

filename:/usr/lib/python2.7/urlparse.pyc
__doc__
Û
/0Xc           @   s≈  d  Z  d d l Z d d d d d d d	 d
 g Z d d d d d d d d d d d d d d d d d g Z d d d d d d d d d d d d d d d d d d d d d d  d! g Z d d" d d d d d d d d# d$ d d d d% g Z d d" d& d' d d d d d# d$ g
 Z d d d d d d d d d d# d$ d g Z d d" d d d' d d d d d d d d g Z d( Z	 d) Z
 i  Z d* Ñ  Z d+ e f d, Ñ  É  YZ d d- l m Z d. e d. d/ É e f d0 Ñ  É  YZ d1 e d1 d2 É e f d3 Ñ  É  YZ d e d4 Ñ Z d5 Ñ  Z d6 d7 Ñ Z d e d8 Ñ Z d9 Ñ  Z d: Ñ  Z e d; Ñ Z d< Ñ  Z y e Wn e k
 red= Ñ  Z n
 Xd> Ñ  Z d? Z e  d@ Ñ  e DÉ É Z! e j" dA É Z# dB Ñ  Z$ d6 d6 dC Ñ Z% d6 d6 dD Ñ Z& d S(E   sc  Parse (absolute and relative) URLs.

urlparse module is based upon the following RFC specifications.

RFC 3986 (STD66): "Uniform Resource Identifiers" by T. Berners-Lee, R. Fielding
and L.  Masinter, January 2005.

RFC 2732 : "Format for Literal IPv6 Addresses in URL's by R.Hinden, B.Carpenter
and L.Masinter, December 1999.

RFC 2396:  "Uniform Resource Identifiers (URI)": Generic Syntax by T.
Berners-Lee, R. Fielding, and L. Masinter, August 1998.

RFC 2368: "The mailto URL scheme", by P.Hoffman , L Masinter, J. Zwinski, July 1998.

RFC 1808: "Relative Uniform Resource Locators", by R. Fielding, UC Irvine, June
1995.

RFC 1738: "Uniform Resource Locators (URL)" by T. Berners-Lee, L. Masinter, M.
McCahill, December 1994

RFC 3986 is considered the current standard and any future changes to
urlparse module should conform with it.  The urlparse module is
currently not entirely compliant with this RFC due to defacto
scenarios for parsing, and for backward compatibility purposes, some
parsing quirks from older RFCs are retained. The testcases in
test_urlparse.py provides a good indicator of parsing behavior.

iˇˇˇˇNt   urlparset
   urlunparset   urljoint	   urldefragt   urlsplitt
   urlunsplitt   parse_qst	   parse_qslt   ftpt   httpt   gophert   nntpt   imapt   waist   filet   httpst   shttpt   mmst   prosperot   rtspt   rtsput    t   sftpt   svns   svn+ssht   telnett   snewst   rsynct   nfst   gits   git+ssht   hdlt   sipt   sipst   telt   mailtot   newssA   abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+-.i   c           C   s   t  j É  d S(   s   Clear the parse cache.N(   t   _parse_cachet   clear(    (    (    s   /usr/lib/python2.7/urlparse.pyt   clear_cacheD   s    t   ResultMixinc           B   sJ   e  Z d  Z e d Ñ  É Z e d Ñ  É Z e d Ñ  É Z e d Ñ  É Z RS(   s-   Shared methods for the parsed result objects.c         C   sX   |  j  } d | k rT | j d d É d } d | k rP | j d d É d } n  | Sd  S(   Nt   @i   i    t   :(   t   netloct   rsplitt   splitt   None(   t   selfR)   t   userinfo(    (    s   /usr/lib/python2.7/urlparse.pyt   usernameL   s    	c         C   sR   |  j  } d | k rN | j d d É d } d | k rN | j d d É d Sn  d  S(   NR'   i   i    R(   (   R)   R*   R+   R,   (   R-   R)   R.   (    (    s   /usr/lib/python2.7/urlparse.pyt   passwordV   s    	c         C   sä   |  j  j d É d } d | k rI d | k rI | j d É d d j É  Sd | k rl | j d É d j É  S| d k r| d  S| j É  Sd  S(	   NR'   iˇˇˇˇt   [t   ]i    i   R(   R   (   R)   R+   t   lowerR,   (   R-   R)   (    (    s   /usr/lib/python2.7/urlparse.pyt   hostname_   s    c         C   sÅ   |  j  j d É d j d É d } d | k r} | j d É d } | r} t | d É } d | k on d k n rz | Sq} n  d  S(	   NR'   iˇˇˇˇR2   R(   i   i
   i    iˇˇ  (   R)   R+   t   intR,   (   R-   R)   t   port(    (    s   /usr/lib/python2.7/urlparse.pyR6   k   s    #
(   t   __name__t
   __module__t   __doc__t   propertyR/   R0   R4   R6   (    (    (    s   /usr/lib/python2.7/urlparse.pyR&   I   s
   
	(   t
   namedtuplet   SplitResults!   scheme netloc path query fragmentc           B   s   e  Z d Z d  Ñ  Z RS(   c         C   s
   t  |  É S(   N(   R   (   R-   (    (    s   /usr/lib/python2.7/urlparse.pyt   geturl}   s    (    (   R7   R8   t	   __slots__R=   (    (    (    s   /usr/lib/python2.7/urlparse.pyR<   y   s   t   ParseResults(   scheme netloc path params query fragmentc           B   s   e  Z d Z d  Ñ  Z RS(   c         C   s
   t  |  É S(   N(   R   (   R-   (    (    s   /usr/lib/python2.7/urlparse.pyR=   Ö   s    (    (   R7   R8   R>   R=   (    (    (    s   /usr/lib/python2.7/urlparse.pyR?   Å   s   c         C   ss   t  |  | | É } | \ } } }  } } | t k rT d |  k rT t |  É \ }  } n d } t | | |  | | | É S(   s#  Parse a URL into 6 components:
    <scheme>://<netloc>/<path>;<params>?<query>#<fragment>
    Return a 6-tuple: (scheme, netloc, path, params, query, fragment).
    Note that we don't break the components up in smaller bits
    (e.g. netloc is a single string) and we don't expand % escapes.t   ;R   (   R   t   uses_paramst   _splitparamsR?   (   t   urlt   schemet   allow_fragmentst   tupleR)   t   queryt   fragmentt   params(    (    s   /usr/lib/python2.7/urlparse.pyR    â   s    c         C   se   d |  k r@ |  j  d |  j d É É } | d k  rO |  d f Sn |  j  d É } |  |  |  | d f S(   Nt   /R@   i    R   i   (   t   findt   rfind(   RC   t   i(    (    s   /usr/lib/python2.7/urlparse.pyRB   ó   s    i    c         C   sb   t  |  É } x> d D]6 } |  j | | É } | d k r t | | É } q q W|  | | !|  | f S(   Ns   /?#i    (   t   lenRK   t   min(   RC   t   startt   delimt   ct   wdelim(    (    s   /usr/lib/python2.7/urlparse.pyt   _splitnetloc†   s    c         C   sÎ  t  | É } |  | | t |  É t | É f } t j | d É } | rI | St t É t k re t É  n  d } } } |  j d É } | d k r
|  |  d k rù|  |  j	 É  } |  | d }  |  d  d k r#t
 |  d É \ } }  d | k r˘ d	 | k sd	 | k r#d | k r#t d
 É Ç q#n  | rPd |  k rP|  j d d É \ }  } n  d |  k rw|  j d d É \ }  } n  t | | |  | | É }	 |	 t | <|	 Sxj |  |  D] }
 |
 t k r®Pq®q®W|  | d } | sÌt d Ñ  | DÉ É r
|  |  j	 É  | } }  q
n  |  d  d k rqt
 |  d É \ } }  d | k rGd	 | k s_d	 | k rqd | k rqt d
 É Ç qqn  | rûd |  k rû|  j d d É \ }  } n  d |  k r≈|  j d d É \ }  } n  t | | |  | | É }	 |	 t | <|	 S(   s  Parse a URL into 5 components:
    <scheme>://<netloc>/<path>?<query>#<fragment>
    Return a 5-tuple: (scheme, netloc, path, query, fragment).
    Note that we don't break the components up in smaller bits
    (e.g. netloc is a single string) and we don't expand % escapes.R   R(   i    R	   i   i   s   //R1   R2   s   Invalid IPv6 URLt   #t   ?c         s   s   |  ] } | d  k Vq d S(   t
   0123456789N(    (   t   .0RR   (    (    s   /usr/lib/python2.7/urlparse.pys	   <genexpr>Œ   s    N(   t   boolt   typeR#   t   getR,   RN   t   MAX_CACHE_SIZER%   RK   R3   RT   t
   ValueErrorR+   R<   t   scheme_charst   any(   RC   RD   RE   t   keyt   cachedR)   RG   RH   RM   t   vRR   t   rest(    (    s   /usr/lib/python2.7/urlparse.pyR   ®   sV    !


c         C   sJ   |  \ } } } } } } | r1 d | | f } n  t  | | | | | f É S(   s˙   Put a parsed URL back together again.  This may result in a
    slightly different, but equivalent URL, if the URL that was parsed
    originally had redundant delimiters, e.g. a ? with an empty query
    (the draft states that these are equivalent).s   %s;%s(   R   (   t   dataRD   R)   RC   RI   RG   RH   (    (    s   /usr/lib/python2.7/urlparse.pyR   ﬂ   s    c         C   s¿   |  \ } } } } } | s= | rw | t  k rw | d  d k rw | r` | d  d k r` d | } n  d | pl d | } n  | ré | d | } n  | r• | d | } n  | rº | d | } n  | S(	   sk  Combine the elements of a tuple as returned by urlsplit() into a
    complete URL as a string. The data argument can be any five-item iterable.
    This may result in a slightly different, but equivalent URL, if the URL that
    was parsed originally had unnecessary delimiters (for example, a ? with an
    empty query; the RFC states that these are equivalent).i   s   //i   RJ   R   R(   RV   RU   (   t   uses_netloc(   Rd   RD   R)   RC   RG   RH   (    (    s   /usr/lib/python2.7/urlparse.pyR   È   s    ( c         C   sh  |  s
 | S| s |  St  |  d | É \ } } } } } } t  | | | É \ }	 }
 } } } } |	 | k st |	 t k rx | S|	 t k rØ |
 r¶ t |	 |
 | | | | f É S| }
 n  | d  d k r€ t |	 |
 | | | | f É S| r | r | } | } | s| } n  t |	 |
 | | | | f É S| j d É d  | j d É } | d d k r]d | d <n  x d | k r|| j d É q`Wxr d } t | É d } xU | | k  rÏ| | d k rﬂ| | d d	 k rﬂ| | d | d 5Pn  | d } qôWPqÄW| d d g k rd | d <n2 t | É d k rC| d d k rCd g | d )n  t |	 |
 d j | É | | | f É S(
   sa   Join a base URL and a possibly relative URL to form an absolute
    interpretation of the latter.R   i   RJ   iˇˇˇˇt   .s   ..i   i˛ˇˇˇ(   R   s   ..(   R    t   uses_relativeRe   R   R+   t   removeRN   t   join(   t   baseRC   RE   t   bschemet   bnetloct   bpatht   bparamst   bqueryt	   bfragmentRD   R)   t   pathRI   RG   RH   t   segmentsRM   t   n(    (    s   /usr/lib/python2.7/urlparse.pyR   ˚   sX    $$		 "c         C   s`   d |  k rR t  |  É \ } } } } } } t | | | | | d f É } | | f S|  d f Sd S(   sø   Removes any existing fragment from URL.

    Returns a tuple of the defragmented URL and the fragment.  If
    the URL contained no fragments, the second element is the
    empty string.
    RU   R   N(   R    R   (   RC   t   sRs   t   pt   at   qt   fragt   defrag(    (    s   /usr/lib/python2.7/urlparse.pyR   /  s
    
c         C   s   d S(   Ni    (    (   t   x(    (    s   /usr/lib/python2.7/urlparse.pyt   _is_unicode@  s    c         C   s   t  |  t É S(   N(   t
   isinstancet   unicode(   Rz   (    (    s   /usr/lib/python2.7/urlparse.pyR{   C  s    t   0123456789ABCDEFabcdefc         c   s?   |  ]5 } t  D]( } | | t t | | d  É É f Vq q d S(   i   N(   t   _hexdigt   chrR5   (   RX   Rv   t   b(    (    s   /usr/lib/python2.7/urlparse.pys	   <genexpr>L  s   s   ([ -]+)c         C   sO  t  |  É r¶ d |  k r |  St j |  É } | d g } | j } xU t d t | É d É D]; } | t t | | É É j d É É | | | d É qZ Wd j	 | É S|  j d É } t | É d k rÀ |  S| d g } | j } x^ | d D]R } y$ | t
 | d  É | | d É WqÏ t k
 r=| d É | | É qÏ XqÏ Wd j	 | É S(   s"   unquote('abc%20def') -> 'abc def'.t   %i    i   i   t   latin1R   (   R{   t   _asciireR+   t   appendt   rangeRN   t   unquotet   strt   decodeRi   t	   _hextochrt   KeyError(   Rt   t   bitst   resRÖ   RM   t   item(    (    s   /usr/lib/python2.7/urlparse.pyRá   P  s.    	#	
c         C   sZ   i  } xM t  |  | | É D]9 \ } } | | k rE | | j | É q | g | | <q W| S(   s≤  Parse a query given as a string argument.

        Arguments:

        qs: percent-encoded query string to be parsed

        keep_blank_values: flag indicating whether blank values in
            percent-encoded queries should be treated as blank strings.
            A true value indicates that blanks should be retained as
            blank strings.  The default false value indicates that
            blank values are to be ignored and treated as if they were
            not included.

        strict_parsing: flag indicating what to do with parsing errors.
            If false (the default), errors are silently ignored.
            If true, errors raise a ValueError exception.
    (   R   RÖ   (   t   qst   keep_blank_valuest   strict_parsingt   dictt   namet   value(    (    s   /usr/lib/python2.7/urlparse.pyR   l  s    c         C   s$  g  |  j  d É D]" } | j  d É D] } | ^ q# q } g  } xﬂ | D]◊ } | r_ | r_ qE n  | j  d d É } t | É d k r∏ | rú t d | f Ç n  | rE | j d É q∏ qE n  t | d É sŒ | rE t | d j d	 d
 É É }	 t | d j d	 d
 É É }
 | j |	 |
 f É qE qE W| S(   s¶  Parse a query given as a string argument.

    Arguments:

    qs: percent-encoded query string to be parsed

    keep_blank_values: flag indicating whether blank values in
        percent-encoded queries should be treated as blank strings.  A
        true value indicates that blanks should be retained as blank
        strings.  The default false value indicates that blank values
        are to be ignored and treated as if they were  not included.

    strict_parsing: flag indicating what to do with parsing errors. If
        false (the default), errors are silently ignored. If true,
        errors raise a ValueError exception.

    Returns a list, as G-d intended.
    t   &R@   t   =i   i   s   bad query field: %rR   i    t   +t    (   R+   RN   R]   RÖ   Rá   t   replace(   Rè   Rê   Rë   t   s1t   s2t   pairst   rt
   name_valuet   nvRì   Rî   (    (    s   /usr/lib/python2.7/urlparse.pyR   Ü  s"    8('   R9   t   ret   __all__Rg   Re   RA   t   non_hierarchicalt
   uses_queryt   uses_fragmentR^   R\   R#   R%   t   objectR&   t   collectionsR;   R<   R?   t   TrueR    RB   RT   R   R   R   R   R   R}   t	   NameErrorR{   R   Rí   Rä   t   compileRÑ   Rá   R   R   (    (    (    s   /usr/lib/python2.7/urlparse.pyt   <module>   sb   	.""		7	
	4				
filename:/usr/lib/python2.7/weakref.py
__doc__
"""Weak reference support for Python.

filename:/usr/lib/python2.7/shutil.py
__doc__
"""Utility functions for copying and archiving files and directory trees.

XXX The functions here don't copy the resource fork or other metadata on Mac.

"""

filename:/usr/lib/python2.7/calendar.py
__doc__
"""Calendar printing functions

Note when comparing these calendars to the ones printed by cal(1): By
default, these calendars have Monday as the first day of the week, and
Sunday as the last (the European convention). Use setfirstweekday() to
set the first day of the week (0=Monday, 6=Sunday)."""

import sys
import datetime
import locale as _locale

__all__ = ["IllegalMonthError", "IllegalWeekdayError", "setfirstweekday",
           "firstweekday", "isleap", "leapdays", "weekday", "monthrange",
           "monthcalendar", "prmonth", "month", "prcal", "calendar",
           "timegm", "month_name", "month_abbr", "day_name", "day_abbr"]

# Exception raised for bad input (with string parameter for details)
error = ValueError

# Exceptions raised for bad input
class IllegalMonthError(ValueError):
    def __init__(self, month):
        self.month = month
    def __str__(self):
        return "bad month number %r; must be 1-12" % self.month


class IllegalWeekdayError(ValueError):
    def __init__(self, weekday):
        self.weekday = weekday
    def __str__(self):
        return "bad weekday number %r; must be 0 (Monday) to 6 (Sunday)" % self.weekday


# Constants for months referenced later
January = 1
February = 2

# Number of days per month (except for February in leap years)
mdays = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

# This module used to have hard-coded lists of day and month names, as
# English strings.  The classes following emulate a read-only version of
# that, but supply localized names.  Note that the values are computed
# fresh on each call, in case the user changes locale between calls.

class _localized_month:

    _months = [datetime.date(2001, i+1, 1).strftime for i in range(12)]
    _months.insert(0, lambda x: "")

    def __init__(self, format):
        self.format = format

    def __getitem__(self, i):
        funcs = self._months[i]
        if isinstance(i, slice):
            return [f(self.format) for f in funcs]
        else:
            return funcs(self.format)

    def __len__(self):
        return 13


class _localized_day:

    # January 1, 2001, was a Monday.
    _days = [datetime.date(2001, 1, i+1).strftime for i in range(7)]

    def __init__(self, format):
        self.format = format

    def __getitem__(self, i):
        funcs = self._days[i]
        if isinstance(i, slice):
            return [f(self.format) for f in funcs]
        else:
            return funcs(self.format)

    def __len__(self):
        return 7


# Full and abbreviated names of weekdays
day_name = _localized_day('%A')
day_abbr = _localized_day('%a')

# Full and abbreviated names of months (1-based arrays!!!)
month_name = _localized_month('%B')
month_abbr = _localized_month('%b')

# Constants for weekdays
(MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY) = range(7)


def isleap(year):
    """Return True for leap years, False for non-leap years."""
    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)


def leapdays(y1, y2):
    """Return number of leap years in range [y1, y2).
       Assume y1 <= y2."""
    y1 -= 1
    y2 -= 1
    return (y2//4 - y1//4) - (y2//100 - y1//100) + (y2//400 - y1//400)


def weekday(year, month, day):
    """Return weekday (0-6 ~ Mon-Sun) for year (1970-...), month (1-12),
       day (1-31)."""
    return datetime.date(year, month, day).weekday()


def monthrange(year, month):
    """Return weekday (0-6 ~ Mon-Sun) and number of days (28-31) for
       year, month."""
    if not 1 <= month <= 12:
        raise IllegalMonthError(month)
    day1 = weekday(year, month, 1)
    ndays = mdays[month] + (month == February and isleap(year))
    return day1, ndays


class Calendar(object):
    """
    Base calendar class. This class doesn't do any formatting. It simply
    provides data to subclasses.
    """

    def __init__(self, firstweekday=0):
        self.firstweekday = firstweekday # 0 = Monday, 6 = Sunday

    def getfirstweekday(self):
        return self._firstweekday % 7

    def setfirstweekday(self, firstweekday):
        self._firstweekday = firstweekday

    firstweekday = property(getfirstweekday, setfirstweekday)

    def iterweekdays(self):
        """
        Return an iterator for one week of weekday numbers starting with the
        configured first one.
        """
        for i in range(self.firstweekday, self.firstweekday + 7):
            yield i%7

    def itermonthdates(self, year, month):
        """
        Return an iterator for one month. The iterator will yield datetime.date
        values and will always iterate through complete weeks, so it will yield
        dates outside the specified month.
        """
        date = datetime.date(year, month, 1)
        # Go back to the beginning of the week
        days = (date.weekday() - self.firstweekday) % 7
        date -= datetime.timedelta(days=days)
        oneday = datetime.timedelta(days=1)
        while True:
            yield date
            try:
                date += oneday
            except OverflowError:
                # Adding one day could fail after datetime.MAXYEAR
                break
            if date.month != month and date.weekday() == self.firstweekday:
                break

    def itermonthdays2(self, year, month):
        """
        Like itermonthdates(), but will yield (day number, weekday number)
        tuples. For days outside the specified month the day number is 0.
        """
        for date in self.itermonthdates(year, month):
            if date.month != month:
                yield (0, date.weekday())
            else:
                yield (date.day, date.weekday())

    def itermonthdays(self, year, month):
        """
        Like itermonthdates(), but will yield day numbers. For days outside
        the specified month the day number is 0.
        """
        for date in self.itermonthdates(year, month):
            if date.month != month:
                yield 0
            else:
                yield date.day

    def monthdatescalendar(self, year, month):
        """
        Return a matrix (list of lists) representing a month's calendar.
        Each row represents a week; week entries are datetime.date values.
        """
        dates = list(self.itermonthdates(year, month))
        return [ dates[i:i+7] for i in range(0, len(dates), 7) ]

    def monthdays2calendar(self, year, month):
        """
        Return a matrix representing a month's calendar.
        Each row represents a week; week entries are
        (day number, weekday number) tuples. Day numbers outside this month
        are zero.
        """
        days = list(self.itermonthdays2(year, month))
        return [ days[i:i+7] for i in range(0, len(days), 7) ]

    def monthdayscalendar(self, year, month):
        """
        Return a matrix representing a month's calendar.
        Each row represents a week; days outside this month are zero.
        """
        days = list(self.itermonthdays(year, month))
        return [ days[i:i+7] for i in range(0, len(days), 7) ]

    def yeardatescalendar(self, year, width=3):
        """
        Return the data for the specified year ready for formatting. The return
        value is a list of month rows. Each month row contains up to width months.
        Each month contains between 4 and 6 weeks and each week contains 1-7
        days. Days are datetime.date objects.
        """
        months = [
            self.monthdatescalendar(year, i)
            for i in range(January, January+12)
        ]
        return [months[i:i+width] for i in range(0, len(months), width) ]

    def yeardays2calendar(self, year, width=3):
        """
        Return the data for the specified year ready for formatting (similar to
        yeardatescalendar()). Entries in the week lists are
        (day number, weekday number) tuples. Day numbers outside this month are
        zero.
        """
        months = [
            self.monthdays2calendar(year, i)
            for i in range(January, January+12)
        ]
        return [months[i:i+width] for i in range(0, len(months), width) ]

    def yeardayscalendar(self, year, width=3):
        """
        Return the data for the specified year ready for formatting (similar to
        yeardatescalendar()). Entries in the week lists are day numbers.
        Day numbers outside this month are zero.
        """
        months = [
            self.monthdayscalendar(year, i)
            for i in range(January, January+12)
        ]
        return [months[i:i+width] for i in range(0, len(months), width) ]


class TextCalendar(Calendar):
    """
    Subclass of Calendar that outputs a calendar as a simple plain text
    similar to the UNIX program cal.
    """

    def prweek(self, theweek, width):
        """
        Print a single week (no newline).
        """
        print self.formatweek(theweek, width),

    def formatday(self, day, weekday, width):
        """
        Returns a formatted day.
        """
        if day == 0:
            s = ''
        else:
            s = '%2i' % day             # right-align single-digit days
        return s.center(width)

    def formatweek(self, theweek, width):
        """
        Returns a single week in a string (no newline).
        """
        return ' '.join(self.formatday(d, wd, width) for (d, wd) in theweek)

    def formatweekday(self, day, width):
        """
        Returns a formatted week day name.
        """
        if width >= 9:
            names = day_name
        else:
            names = day_abbr
        return names[day][:width].center(width)

    def formatweekheader(self, width):
        """
        Return a header for a week.
        """
        return ' '.join(self.formatweekday(i, width) for i in self.iterweekdays())

    def formatmonthname(self, theyear, themonth, width, withyear=True):
        """
        Return a formatted month name.
        """
        s = month_name[themonth]
        if withyear:
            s = "%s %r" % (s, theyear)
        return s.center(width)

    def prmonth(self, theyear, themonth, w=0, l=0):
        """
        Print a month's calendar.
        """
        print self.formatmonth(theyear, themonth, w, l),

    def formatmonth(self, theyear, themonth, w=0, l=0):
        """
        Return a month's calendar string (multi-line).
        """
        w = max(2, w)
        l = max(1, l)
        s = self.formatmonthname(theyear, themonth, 7 * (w + 1) - 1)
        s = s.rstrip()
        s += '\n' * l
        s += self.formatweekheader(w).rstrip()
        s += '\n' * l
        for week in self.monthdays2calendar(theyear, themonth):
            s += self.formatweek(week, w).rstrip()
            s += '\n' * l
        return s

    def formatyear(self, theyear, w=2, l=1, c=6, m=3):
        """
        Returns a year's calendar as a multi-line string.
        """
        w = max(2, w)
        l = max(1, l)
        c = max(2, c)
        colwidth = (w + 1) * 7 - 1
        v = []
        a = v.append
        a(repr(theyear).center(colwidth*m+c*(m-1)).rstrip())
        a('\n'*l)
        header = self.formatweekheader(w)
        for (i, row) in enumerate(self.yeardays2calendar(theyear, m)):
            # months in this row
            months = range(m*i+1, min(m*(i+1)+1, 13))
            a('\n'*l)
            names = (self.formatmonthname(theyear, k, colwidth, False)
                     for k in months)
            a(formatstring(names, colwidth, c).rstrip())
            a('\n'*l)
            headers = (header for k in months)
            a(formatstring(headers, colwidth, c).rstrip())
            a('\n'*l)
            # max number of weeks for this row
            height = max(len(cal) for cal in row)
            for j in range(height):
                weeks = []
                for cal in row:
                    if j >= len(cal):
                        weeks.append('')
                    else:
                        weeks.append(self.formatweek(cal[j], w))
                a(formatstring(weeks, colwidth, c).rstrip())
                a('\n' * l)
        return ''.join(v)

    def pryear(self, theyear, w=0, l=0, c=6, m=3):
        """Print a year's calendar."""
        print self.formatyear(theyear, w, l, c, m)


class HTMLCalendar(Calendar):
    """
    This calendar returns complete HTML pages.
    """

    # CSS classes for the day <td>s
    cssclasses = ["mon", "tue", "wed", "thu", "fri", "sat", "sun"]

    def formatday(self, day, weekday):
        """
        Return a day as a table cell.
        """
        if day == 0:
            return '<td class="noday">&nbsp;</td>' # day outside month
        else:
            return '<td class="%s">%d</td>' % (self.cssclasses[weekday], day)

    def formatweek(self, theweek):
        """
        Return a complete week as a table row.
        """
        s = ''.join(self.formatday(d, wd) for (d, wd) in theweek)
        return '<tr>%s</tr>' % s

    def formatweekday(self, day):
        """
        Return a weekday name as a table header.
        """
        return '<th class="%s">%s</th>' % (self.cssclasses[day], day_abbr[day])

    def formatweekheader(self):
        """
        Return a header for a week as a table row.
        """
        s = ''.join(self.formatweekday(i) for i in self.iterweekdays())
        return '<tr>%s</tr>' % s

    def formatmonthname(self, theyear, themonth, withyear=True):
        """
        Return a month name as a table row.
        """
        if withyear:
            s = '%s %s' % (month_name[themonth], theyear)
        else:
            s = '%s' % month_name[themonth]
        return '<tr><th colspan="7" class="month">%s</th></tr>' % s

    def formatmonth(self, theyear, themonth, withyear=True):
        """
        Return a formatted month as a table.
        """
        v = []
        a = v.append
        a('<table border="0" cellpadding="0" cellspacing="0" class="month">')
        a('\n')
        a(self.formatmonthname(theyear, themonth, withyear=withyear))
        a('\n')
        a(self.formatweekheader())
        a('\n')
        for week in self.monthdays2calendar(theyear, themonth):
            a(self.formatweek(week))
            a('\n')
        a('</table>')
        a('\n')
        return ''.join(v)

    def formatyear(self, theyear, width=3):
        """
        Return a formatted year as a table of tables.
        """
        v = []
        a = v.append
        width = max(width, 1)
        a('<table border="0" cellpadding="0" cellspacing="0" class="year">')
        a('\n')
        a('<tr><th colspan="%d" class="year">%s</th></tr>' % (width, theyear))
        for i in range(January, January+12, width):
            # months in this row
            months = range(i, min(i+width, 13))
            a('<tr>')
            for m in months:
                a('<td>')
                a(self.formatmonth(theyear, m, withyear=False))
                a('</td>')
            a('</tr>')
        a('</table>')
        return ''.join(v)

    def formatyearpage(self, theyear, width=3, css='calendar.css', encoding=None):
        """
        Return a formatted year as a complete HTML page.
        """
        if encoding is None:
            encoding = sys.getdefaultencoding()
        v = []
        a = v.append
        a('<?xml version="1.0" encoding="%s"?>\n' % encoding)
        a('<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">\n')
        a('<html>\n')
        a('<head>\n')
        a('<meta http-equiv="Content-Type" content="text/html; charset=%s" />\n' % encoding)
        if css is not None:
            a('<link rel="stylesheet" type="text/css" href="%s" />\n' % css)
        a('<title>Calendar for %d</title>\n' % theyear)
        a('</head>\n')
        a('<body>\n')
        a(self.formatyear(theyear, width))
        a('</body>\n')
        a('</html>\n')
        return ''.join(v).encode(encoding, "xmlcharrefreplace")


class TimeEncoding:
    def __init__(self, locale):
        self.locale = locale

    def __enter__(self):
        self.oldlocale = _locale.getlocale(_locale.LC_TIME)
        _locale.setlocale(_locale.LC_TIME, self.locale)
        return _locale.getlocale(_locale.LC_TIME)[1]

    def __exit__(self, *args):
        _locale.setlocale(_locale.LC_TIME, self.oldlocale)


class LocaleTextCalendar(TextCalendar):
    """
    This class can be passed a locale name in the constructor and will return
    month and weekday names in the specified locale. If this locale includes
    an encoding all strings containing month and weekday names will be returned
    as unicode.
    """

    def __init__(self, firstweekday=0, locale=None):
        TextCalendar.__init__(self, firstweekday)
        if locale is None:
            locale = _locale.getdefaultlocale()
        self.locale = locale

    def formatweekday(self, day, width):
        with TimeEncoding(self.locale) as encoding:
            if width >= 9:
                names = day_name
            else:
                names = day_abbr
            name = names[day]
            if encoding is not None:
                name = name.decode(encoding)
            return name[:width].center(width)

    def formatmonthname(self, theyear, themonth, width, withyear=True):
        with TimeEncoding(self.locale) as encoding:
            s = month_name[themonth]
            if encoding is not None:
                s = s.decode(encoding)
            if withyear:
                s = "%s %r" % (s, theyear)
            return s.center(width)


class LocaleHTMLCalendar(HTMLCalendar):
    """
    This class can be passed a locale name in the constructor and will return
    month and weekday names in the specified locale. If this locale includes
    an encoding all strings containing month and weekday names will be returned
    as unicode.
    """
    def __init__(self, firstweekday=0, locale=None):
        HTMLCalendar.__init__(self, firstweekday)
        if locale is None:
            locale = _locale.getdefaultlocale()
        self.locale = locale

    def formatweekday(self, day):
        with TimeEncoding(self.locale) as encoding:
            s = day_abbr[day]
            if encoding is not None:
                s = s.decode(encoding)
            return '<th class="%s">%s</th>' % (self.cssclasses[day], s)

    def formatmonthname(self, theyear, themonth, withyear=True):
        with TimeEncoding(self.locale) as encoding:
            s = month_name[themonth]
            if encoding is not None:
                s = s.decode(encoding)
            if withyear:
                s = '%s %s' % (s, theyear)
            return '<tr><th colspan="7" class="month">%s</th></tr>' % s


# Support for old module level interface
c = TextCalendar()

firstweekday = c.getfirstweekday

def setfirstweekday(firstweekday):
    try:
        firstweekday.__index__
    except AttributeError:
        raise IllegalWeekdayError(firstweekday)
    if not MONDAY <= firstweekday <= SUNDAY:
        raise IllegalWeekdayError(firstweekday)
    c.firstweekday = firstweekday

monthcalendar = c.monthdayscalendar
prweek = c.prweek
week = c.formatweek
weekheader = c.formatweekheader
prmonth = c.prmonth
month = c.formatmonth
calendar = c.formatyear
prcal = c.pryear


# Spacing of month columns for multi-column year calendar
_colwidth = 7*3 - 1         # Amount printed by prweek()
_spacing = 6                # Number of spaces between columns


def format(cols, colwidth=_colwidth, spacing=_spacing):
    """Prints multi-column formatting for year calendars"""
    print formatstring(cols, colwidth, spacing)


def formatstring(cols, colwidth=_colwidth, spacing=_spacing):
    """Returns a string formatted from n strings, centered within n columns."""
    spacing *= ' '
    return spacing.join(c.center(colwidth) for c in cols)


EPOCH = 1970
_EPOCH_ORD = datetime.date(EPOCH, 1, 1).toordinal()


def timegm(tuple):
    """Unrelated but handy function to calculate Unix timestamp from GMT."""
    year, month, day, hour, minute, second = tuple[:6]
    days = datetime.date(year, month, 1).toordinal() - _EPOCH_ORD + day - 1
    hours = days*24 + hour
    minutes = hours*60 + minute
    seconds = minutes*60 + second
    return seconds


def main(args):
    import optparse
    parser = optparse.OptionParser(usage="usage: %prog [options] [year [month]]")
    parser.add_option(
        "-w", "--width",
        dest="width", type="int", default=2,
        help="width of date column (default 2, text only)"
    )
    parser.add_option(
        "-l", "--lines",
        dest="lines", type="int", default=1,
        help="number of lines for each week (default 1, text only)"
    )
    parser.add_option(
        "-s", "--spacing",
        dest="spacing", type="int", default=6,
        help="spacing between months (default 6, text only)"
    )
    parser.add_option(
        "-m", "--months",
        dest="months", type="int", default=3,
        help="months per row (default 3, text only)"
    )
    parser.add_option(
        "-c", "--css",
        dest="css", default="calendar.css",
        help="CSS to use for page (html only)"
    )
    parser.add_option(
        "-L", "--locale",
        dest="locale", default=None,
        help="locale to be used from month and weekday names"
    )
    parser.add_option(
        "-e", "--encoding",
        dest="encoding", default=None,
        help="Encoding to use for output"
    )
    parser.add_option(
        "-t", "--type",
        dest="type", default="text",
        choices=("text", "html"),
        help="output type (text or html)"
    )

    (options, args) = parser.parse_args(args)

    if options.locale and not options.encoding:
        parser.error("if --locale is specified --encoding is required")
        sys.exit(1)

    locale = options.locale, options.encoding

    if options.type == "html":
        if options.locale:
            cal = LocaleHTMLCalendar(locale=locale)
        else:
            cal = HTMLCalendar()
        encoding = options.encoding
        if encoding is None:
            encoding = sys.getdefaultencoding()
        optdict = dict(encoding=encoding, css=options.css)
        if len(args) == 1:
            print cal.formatyearpage(datetime.date.today().year, **optdict)
        elif len(args) == 2:
            print cal.formatyearpage(int(args[1]), **optdict)
        else:
            parser.error("incorrect number of arguments")
            sys.exit(1)
    else:
        if options.locale:
            cal = LocaleTextCalendar(locale=locale)
        else:
            cal = TextCalendar()
        optdict = dict(w=options.width, l=options.lines)
        if len(args) != 3:
            optdict["c"] = options.spacing
            optdict["m"] = options.months
        if len(args) == 1:
            result = cal.formatyear(datetime.date.today().year, **optdict)
        elif len(args) == 2:
            result = cal.formatyear(int(args[1]), **optdict)
        elif len(args) == 3:
            result = cal.formatmonth(int(args[1]), int(args[2]), **optdict)
        else:
            parser.error("incorrect number of arguments")
            sys.exit(1)
        if options.encoding:
            result = result.encode(options.encoding)
        print result


if __name__ == "__main__":
    main(sys.argv)

filename:/usr/lib/python2.7/mimetypes.py
__doc__
"""Guess the MIME type of a file.

filename:/usr/lib/python2.7/rexec.py
__doc__
"""Restricted execution facilities.

The class RExec exports methods r_exec(), r_eval(), r_execfile(), and
r_import(), which correspond roughly to the built-in operations
exec, eval(), execfile() and import, but executing the code in an
environment that only exposes those built-in operations that are
deemed safe.  To this end, a modest collection of 'fake' modules is
created which mimics the standard modules by the same names.  It is a
policy decision which built-in modules and operations are made
available; this module provides a reasonable default, but derived
classes can change the policies e.g. by overriding or extending class
variables like ok_builtin_modules or methods like make_sys().

XXX To do:
- r_open should allow writing tmp dir
- r_exec etc. with explicit globals/locals? (Use rexec("exec ... in ...")?)

"""

filename:/usr/lib/python2.7/_osx_support.py
__doc__
"""Shared OS X support functions."""

import os
import re
import sys

__all__ = [
    'compiler_fixup',
    'customize_config_vars',
    'customize_compiler',
    'get_platform_osx',
]

# configuration variables that may contain universal build flags,
# like "-arch" or "-isdkroot", that may need customization for
# the user environment
_UNIVERSAL_CONFIG_VARS = ('CFLAGS', 'LDFLAGS', 'CPPFLAGS', 'BASECFLAGS',
                            'BLDSHARED', 'LDSHARED', 'CC', 'CXX',
                            'PY_CFLAGS', 'PY_LDFLAGS', 'PY_CPPFLAGS',
                            'PY_CORE_CFLAGS')

# configuration variables that may contain compiler calls
_COMPILER_CONFIG_VARS = ('BLDSHARED', 'LDSHARED', 'CC', 'CXX')

# prefix added to original configuration variable names
_INITPRE = '_OSX_SUPPORT_INITIAL_'


def _find_executable(executable, path=None):
    """Tries to find 'executable' in the directories listed in 'path'.

    A string listing directories separated by 'os.pathsep'; defaults to
    os.environ['PATH'].  Returns the complete filename or None if not found.
    """
    if path is None:
        path = os.environ['PATH']

    paths = path.split(os.pathsep)
    base, ext = os.path.splitext(executable)

    if (sys.platform == 'win32' or os.name == 'os2') and (ext != '.exe'):
        executable = executable + '.exe'

    if not os.path.isfile(executable):
        for p in paths:
            f = os.path.join(p, executable)
            if os.path.isfile(f):
                # the file exists, we have a shot at spawn working
                return f
        return None
    else:
        return executable


def _read_output(commandstring):
    """Output from successful command execution or None"""
    # Similar to os.popen(commandstring, "r").read(),
    # but without actually using os.popen because that
    # function is not usable during python bootstrap.
    # tempfile is also not available then.
    import contextlib
    try:
        import tempfile
        fp = tempfile.NamedTemporaryFile()
    except ImportError:
        fp = open("/tmp/_osx_support.%s"%(
            os.getpid(),), "w+b")

    with contextlib.closing(fp) as fp:
        cmd = "%s 2>/dev/null >'%s'" % (commandstring, fp.name)
        return fp.read().strip() if not os.system(cmd) else None


def _find_build_tool(toolname):
    """Find a build tool on current path or using xcrun"""
    return (_find_executable(toolname)
                or _read_output("/usr/bin/xcrun -find %s" % (toolname,))
                or ''
            )

_SYSTEM_VERSION = None

def _get_system_version():
    """Return the OS X system version as a string"""
    # Reading this plist is a documented way to get the system
    # version (see the documentation for the Gestalt Manager)
    # We avoid using platform.mac_ver to avoid possible bootstrap issues during
    # the build of Python itself (distutils is used to build standard library
    # extensions).

    global _SYSTEM_VERSION

    if _SYSTEM_VERSION is None:
        _SYSTEM_VERSION = ''
        try:
            f = open('/System/Library/CoreServices/SystemVersion.plist')
        except IOError:
            # We're on a plain darwin box, fall back to the default
            # behaviour.
            pass
        else:
            try:
                m = re.search(r'<key>ProductUserVisibleVersion</key>\s*'
                              r'<string>(.*?)</string>', f.read())
            finally:
                f.close()
            if m is not None:
                _SYSTEM_VERSION = '.'.join(m.group(1).split('.')[:2])
            # else: fall back to the default behaviour

    return _SYSTEM_VERSION

def _remove_original_values(_config_vars):
    """Remove original unmodified values for testing"""
    # This is needed for higher-level cross-platform tests of get_platform.
    for k in list(_config_vars):
        if k.startswith(_INITPRE):
            del _config_vars[k]

def _save_modified_value(_config_vars, cv, newvalue):
    """Save modified and original unmodified value of configuration var"""

    oldvalue = _config_vars.get(cv, '')
    if (oldvalue != newvalue) and (_INITPRE + cv not in _config_vars):
        _config_vars[_INITPRE + cv] = oldvalue
    _config_vars[cv] = newvalue

def _supports_universal_builds():
    """Returns True if universal builds are supported on this system"""
    # As an approximation, we assume that if we are running on 10.4 or above,
    # then we are running with an Xcode environment that supports universal
    # builds, in particular -isysroot and -arch arguments to the compiler. This
    # is in support of allowing 10.4 universal builds to run on 10.3.x systems.

    osx_version = _get_system_version()
    if osx_version:
        try:
            osx_version = tuple(int(i) for i in osx_version.split('.'))
        except ValueError:
            osx_version = ''
    return bool(osx_version >= (10, 4)) if osx_version else False


def _find_appropriate_compiler(_config_vars):
    """Find appropriate C compiler for extension module builds"""

    # Issue #13590:
    #    The OSX location for the compiler varies between OSX
    #    (or rather Xcode) releases.  With older releases (up-to 10.5)
    #    the compiler is in /usr/bin, with newer releases the compiler
    #    can only be found inside Xcode.app if the "Command Line Tools"
    #    are not installed.
    #
    #    Furthermore, the compiler that can be used varies between
    #    Xcode releases. Up to Xcode 4 it was possible to use 'gcc-4.2'
    #    as the compiler, after that 'clang' should be used because
    #    gcc-4.2 is either not present, or a copy of 'llvm-gcc' that
    #    miscompiles Python.

    # skip checks if the compiler was overridden with a CC env variable
    if 'CC' in os.environ:
        return _config_vars

    # The CC config var might contain additional arguments.
    # Ignore them while searching.
    cc = oldcc = _config_vars['CC'].split()[0]
    if not _find_executable(cc):
        # Compiler is not found on the shell search PATH.
        # Now search for clang, first on PATH (if the Command LIne
        # Tools have been installed in / or if the user has provided
        # another location via CC).  If not found, try using xcrun
        # to find an uninstalled clang (within a selected Xcode).

        # NOTE: Cannot use subprocess here because of bootstrap
        # issues when building Python itself (and os.popen is
        # implemented on top of subprocess and is therefore not
        # usable as well)

        cc = _find_build_tool('clang')

    elif os.path.basename(cc).startswith('gcc'):
        # Compiler is GCC, check if it is LLVM-GCC
        data = _read_output("'%s' --version"
                             % (cc.replace("'", "'\"'\"'"),))
        if data and 'llvm-gcc' in data:
            # Found LLVM-GCC, fall back to clang
            cc = _find_build_tool('clang')

    if not cc:
        raise SystemError(
               "Cannot locate working compiler")

    if cc != oldcc:
        # Found a replacement compiler.
        # Modify config vars using new compiler, if not already explicitly
        # overridden by an env variable, preserving additional arguments.
        for cv in _COMPILER_CONFIG_VARS:
            if cv in _config_vars and cv not in os.environ:
                cv_split = _config_vars[cv].split()
                cv_split[0] = cc if cv != 'CXX' else cc + '++'
                _save_modified_value(_config_vars, cv, ' '.join(cv_split))

    return _config_vars


def _remove_universal_flags(_config_vars):
    """Remove all universal build arguments from config vars"""

    for cv in _UNIVERSAL_CONFIG_VARS:
        # Do not alter a config var explicitly overridden by env var
        if cv in _config_vars and cv not in os.environ:
            flags = _config_vars[cv]
            flags = re.sub('-arch\s+\w+\s', ' ', flags)
            flags = re.sub('-isysroot [^ \t]*', ' ', flags)
            _save_modified_value(_config_vars, cv, flags)

    return _config_vars


def _remove_unsupported_archs(_config_vars):
    """Remove any unsupported archs from config vars"""
    # Different Xcode releases support different sets for '-arch'
    # flags. In particular, Xcode 4.x no longer supports the
    # PPC architectures.
    #
    # This code automatically removes '-arch ppc' and '-arch ppc64'
    # when these are not supported. That makes it possible to
    # build extensions on OSX 10.7 and later with the prebuilt
    # 32-bit installer on the python.org website.

    # skip checks if the compiler was overridden with a CC env variable
    if 'CC' in os.environ:
        return _config_vars

    if re.search('-arch\s+ppc', _config_vars['CFLAGS']) is not None:
        # NOTE: Cannot use subprocess here because of bootstrap
        # issues when building Python itself
        status = os.system(
            """echo 'int main{};' | """
            """'%s' -c -arch ppc -x c -o /dev/null /dev/null 2>/dev/null"""
            %(_config_vars['CC'].replace("'", "'\"'\"'"),))
        if status:
            # The compile failed for some reason.  Because of differences
            # across Xcode and compiler versions, there is no reliable way
            # to be sure why it failed.  Assume here it was due to lack of
            # PPC support and remove the related '-arch' flags from each
            # config variables not explicitly overridden by an environment
            # variable.  If the error was for some other reason, we hope the
            # failure will show up again when trying to compile an extension
            # module.
            for cv in _UNIVERSAL_CONFIG_VARS:
                if cv in _config_vars and cv not in os.environ:
                    flags = _config_vars[cv]
                    flags = re.sub('-arch\s+ppc\w*\s', ' ', flags)
                    _save_modified_value(_config_vars, cv, flags)

    return _config_vars


def _override_all_archs(_config_vars):
    """Allow override of all archs with ARCHFLAGS env var"""
    # NOTE: This name was introduced by Apple in OSX 10.5 and
    # is used by several scripting languages distributed with
    # that OS release.
    if 'ARCHFLAGS' in os.environ:
        arch = os.environ['ARCHFLAGS']
        for cv in _UNIVERSAL_CONFIG_VARS:
            if cv in _config_vars and '-arch' in _config_vars[cv]:
                flags = _config_vars[cv]
                flags = re.sub('-arch\s+\w+\s', ' ', flags)
                flags = flags + ' ' + arch
                _save_modified_value(_config_vars, cv, flags)

    return _config_vars


def _check_for_unavailable_sdk(_config_vars):
    """Remove references to any SDKs not available"""
    # If we're on OSX 10.5 or later and the user tries to
    # compile an extension using an SDK that is not present
    # on the current machine it is better to not use an SDK
    # than to fail.  This is particularly important with
    # the standalone Command Line Tools alternative to a
    # full-blown Xcode install since the CLT packages do not
    # provide SDKs.  If the SDK is not present, it is assumed
    # that the header files and dev libs have been installed
    # to /usr and /System/Library by either a standalone CLT
    # package or the CLT component within Xcode.
    cflags = _config_vars.get('CFLAGS', '')
    m = re.search(r'-isysroot\s+(\S+)', cflags)
    if m is not None:
        sdk = m.group(1)
        if not os.path.exists(sdk):
            for cv in _UNIVERSAL_CONFIG_VARS:
                # Do not alter a config var explicitly overridden by env var
                if cv in _config_vars and cv not in os.environ:
                    flags = _config_vars[cv]
                    flags = re.sub(r'-isysroot\s+\S+(?:\s|$)', ' ', flags)
                    _save_modified_value(_config_vars, cv, flags)

    return _config_vars


def compiler_fixup(compiler_so, cc_args):
    """
    This function will strip '-isysroot PATH' and '-arch ARCH' from the
    compile flags if the user has specified one them in extra_compile_flags.

    This is needed because '-arch ARCH' adds another architecture to the
    build, without a way to remove an architecture. Furthermore GCC will
    barf if multiple '-isysroot' arguments are present.
    """
    stripArch = stripSysroot = False

    compiler_so = list(compiler_so)

    if not _supports_universal_builds():
        # OSX before 10.4.0, these don't support -arch and -isysroot at
        # all.
        stripArch = stripSysroot = True
    else:
        stripArch = '-arch' in cc_args
        stripSysroot = '-isysroot' in cc_args

    if stripArch or 'ARCHFLAGS' in os.environ:
        while True:
            try:
                index = compiler_so.index('-arch')
                # Strip this argument and the next one:
                del compiler_so[index:index+2]
            except ValueError:
                break

    if 'ARCHFLAGS' in os.environ and not stripArch:
        # User specified different -arch flags in the environ,
        # see also distutils.sysconfig
        compiler_so = compiler_so + os.environ['ARCHFLAGS'].split()

    if stripSysroot:
        while True:
            try:
                index = compiler_so.index('-isysroot')
                # Strip this argument and the next one:
                del compiler_so[index:index+2]
            except ValueError:
                break

    # Check if the SDK that is used during compilation actually exists,
    # the universal build requires the usage of a universal SDK and not all
    # users have that installed by default.
    sysroot = None
    if '-isysroot' in cc_args:
        idx = cc_args.index('-isysroot')
        sysroot = cc_args[idx+1]
    elif '-isysroot' in compiler_so:
        idx = compiler_so.index('-isysroot')
        sysroot = compiler_so[idx+1]

    if sysroot and not os.path.isdir(sysroot):
        from distutils import log
        log.warn("Compiling with an SDK that doesn't seem to exist: %s",
                sysroot)
        log.warn("Please check your Xcode installation")

    return compiler_so


def customize_config_vars(_config_vars):
    """Customize Python build configuration variables.

    Called internally from sysconfig with a mutable mapping
    containing name/value pairs parsed from the configured
    makefile used to build this interpreter.  Returns
    the mapping updated as needed to reflect the environment
    in which the interpreter is running; in the case of
    a Python from a binary installer, the installed
    environment may be very different from the build
    environment, i.e. different OS levels, different
    built tools, different available CPU architectures.

    This customization is performed whenever
    distutils.sysconfig.get_config_vars() is first
    called.  It may be used in environments where no
    compilers are present, i.e. when installing pure
    Python dists.  Customization of compiler paths
    and detection of unavailable archs is deferred
    until the first extension module build is
    requested (in distutils.sysconfig.customize_compiler).

    Currently called from distutils.sysconfig
    """

    if not _supports_universal_builds():
        # On Mac OS X before 10.4, check if -arch and -isysroot
        # are in CFLAGS or LDFLAGS and remove them if they are.
        # This is needed when building extensions on a 10.3 system
        # using a universal build of python.
        _remove_universal_flags(_config_vars)

    # Allow user to override all archs with ARCHFLAGS env var
    _override_all_archs(_config_vars)

    # Remove references to sdks that are not found
    _check_for_unavailable_sdk(_config_vars)

    return _config_vars


def customize_compiler(_config_vars):
    """Customize compiler path and configuration variables.

    This customization is performed when the first
    extension module build is requested
    in distutils.sysconfig.customize_compiler).
    """

    # Find a compiler to use for extension module builds
    _find_appropriate_compiler(_config_vars)

    # Remove ppc arch flags if not supported here
    _remove_unsupported_archs(_config_vars)

    # Allow user to override all archs with ARCHFLAGS env var
    _override_all_archs(_config_vars)

    return _config_vars


def get_platform_osx(_config_vars, osname, release, machine):
    """Filter values for get_platform()"""
    # called from get_platform() in sysconfig and distutils.util
    #
    # For our purposes, we'll assume that the system version from
    # distutils' perspective is what MACOSX_DEPLOYMENT_TARGET is set
    # to. This makes the compatibility story a bit more sane because the
    # machine is going to compile and link as if it were
    # MACOSX_DEPLOYMENT_TARGET.

    macver = _config_vars.get('MACOSX_DEPLOYMENT_TARGET', '')
    macrelease = _get_system_version() or macver
    macver = macver or macrelease

    if macver:
        release = macver
        osname = "macosx"

        # Use the original CFLAGS value, if available, so that we
        # return the same machine type for the platform string.
        # Otherwise, distutils may consider this a cross-compiling
        # case and disallow installs.
        cflags = _config_vars.get(_INITPRE+'CFLAGS',
                                    _config_vars.get('CFLAGS', ''))
        if macrelease:
            try:
                macrelease = tuple(int(i) for i in macrelease.split('.')[0:2])
            except ValueError:
                macrelease = (10, 0)
        else:
            # assume no universal support
            macrelease = (10, 0)

        if (macrelease >= (10, 4)) and '-arch' in cflags.strip():
            # The universal build will build fat binaries, but not on
            # systems before 10.4

            machine = 'fat'

            archs = re.findall('-arch\s+(\S+)', cflags)
            archs = tuple(sorted(set(archs)))

            if len(archs) == 1:
                machine = archs[0]
            elif archs == ('i386', 'ppc'):
                machine = 'fat'
            elif archs == ('i386', 'x86_64'):
                machine = 'intel'
            elif archs == ('i386', 'ppc', 'x86_64'):
                machine = 'fat3'
            elif archs == ('ppc64', 'x86_64'):
                machine = 'fat64'
            elif archs == ('i386', 'ppc', 'ppc64', 'x86_64'):
                machine = 'universal'
            else:
                raise ValueError(
                   "Don't know machine value for archs=%r" % (archs,))

        elif machine == 'i386':
            # On OSX the machine type returned by uname is always the
            # 32-bit variant, even if the executable architecture is
            # the 64-bit variant
            if sys.maxint >= 2**32:
                machine = 'x86_64'

        elif machine in ('PowerPC', 'Power_Macintosh'):
            # Pick a sane name for the PPC architecture.
            # See 'i386' case
            if sys.maxint >= 2**32:
                machine = 'ppc64'
            else:
                machine = 'ppc'

    return (osname, release, machine)

filename:/usr/lib/python2.7/opcode.py
__doc__

"""

filename:/usr/lib/python2.7/sndhdr.py
__doc__
"""Routines to help recognizing sound files.

Function whathdr() recognizes various types of sound file headers.
It understands almost all headers that SOX can decode.

The return tuple contains the following items, in this order:
- file type (as SOX understands it)
- sampling rate (0 if unknown or hard to decode)
- number of channels (0 if unknown or hard to decode)
- number of frames in the file (-1 if unknown or hard to decode)
- number of bits/sample, or 'U' for U-LAW, or 'A' for A-LAW

If the file doesn't have a recognizable type, it returns None.
If the file can't be opened, IOError is raised.

To compute the total time, divide the number of frames by the
sampling rate (a frame contains a sample for each channel).

Function what() calls whathdr().  (It used to also use some
heuristics for raw data, but this doesn't work very well.)

Finally, the function test() is a simple main program that calls
what() for all files mentioned on the argument list.  For directory
arguments it calls what() for all files in that directory.  Default
argument is "." (testing all files in the current directory).  The
option -r tells it to recurse down directories found inside
explicitly given directories.
"""

filename:/usr/lib/python2.7/chunk.py
__doc__
"""Simple class to read IFF chunks.

An IFF chunk (used in formats such as AIFF, TIFF, RMFF (RealMedia File
Format)) has the following structure:

+----------------+
| ID (4 bytes)   |
+----------------+
| size (4 bytes) |
+----------------+
| data           |
| ...            |
+----------------+

The ID is a 4-byte string which identifies the type of chunk.

The size field (a 32-bit value, encoded using big-endian byte order)
gives the size of the whole chunk, including the 8-byte header.

Usually an IFF-type file consists of one or more chunks.  The proposed
usage of the Chunk class defined here is to instantiate an instance at
the start of each chunk and read from the instance until it reaches
the end, after which a new instance can be instantiated.  At the end
of the file, creating a new instance will fail with a EOFError
exception.

Usage:
while True:
    try:
        chunk = Chunk(file)
    except EOFError:
        break
    chunktype = chunk.getname()
    while True:
        data = chunk.read(nbytes)
        if not data:
            pass
        # do something with data

The interface is file-like.  The implemented methods are:
read, close, seek, tell, isatty.
Extra methods are: skip() (called by close, skips to the end of the chunk),
getname() (returns the name (ID) of the chunk)

The __init__ method has one required argument, a file-like object
(including a chunk instance), and one optional argument, a flag which
specifies whether or not chunks are aligned on 2-byte boundaries.  The
default is 1, i.e. aligned.
"""

filename:/usr/lib/python2.7/mhlib.py
__doc__
"""MH interface -- purely object-oriented (well, almost)

Executive summary:

import mhlib

mh = mhlib.MH()         # use default mailbox directory and profile
mh = mhlib.MH(mailbox)  # override mailbox location (default from profile)
mh = mhlib.MH(mailbox, profile) # override mailbox and profile

mh.error(format, ...)   # print error message -- can be overridden
s = mh.getprofile(key)  # profile entry (None if not set)
path = mh.getpath()     # mailbox pathname
name = mh.getcontext()  # name of current folder
mh.setcontext(name)     # set name of current folder

list = mh.listfolders() # names of top-level folders
list = mh.listallfolders() # names of all folders, including subfolders
list = mh.listsubfolders(name) # direct subfolders of given folder
list = mh.listallsubfolders(name) # all subfolders of given folder

mh.makefolder(name)     # create new folder
mh.deletefolder(name)   # delete folder -- must have no subfolders

f = mh.openfolder(name) # new open folder object

f.error(format, ...)    # same as mh.error(format, ...)
path = f.getfullname()  # folder's full pathname
path = f.getsequencesfilename() # full pathname of folder's sequences file
path = f.getmessagefilename(n)  # full pathname of message n in folder

list = f.listmessages() # list of messages in folder (as numbers)
n = f.getcurrent()      # get current message
f.setcurrent(n)         # set current message
list = f.parsesequence(seq)     # parse msgs syntax into list of messages
n = f.getlast()         # get last message (0 if no messagse)
f.setlast(n)            # set last message (internal use only)

dict = f.getsequences() # dictionary of sequences in folder {name: list}
f.putsequences(dict)    # write sequences back to folder

f.createmessage(n, fp)  # add message from file f as number n
f.removemessages(list)  # remove messages in list from folder
f.refilemessages(list, tofolder) # move messages in list to other folder
f.movemessage(n, tofolder, ton)  # move one message to a given destination
f.copymessage(n, tofolder, ton)  # copy one message to a given destination

m = f.openmessage(n)    # new open message object (costs a file descriptor)
m is a derived class of mimetools.Message(rfc822.Message), with:
s = m.getheadertext()   # text of message's headers
s = m.getheadertext(pred) # text of message's headers, filtered by pred
s = m.getbodytext()     # text of message's body, decoded
s = m.getbodytext(0)    # text of message's body, not decoded
"""

filename:/usr/lib/python2.7/runpy.py
__doc__
"""runpy.py - locating and running Python code using the module namespace

Provides support for locating and running Python scripts using the Python
module namespace instead of the native filesystem.

This allows Python code to play nicely with non-filesystem based PEP 302
importers when locating support scripts as well as when importing modules.
"""

filename:/usr/lib/python2.7/glob.py
__doc__
"""Filename globbing utility."""

import sys
import os
import re
import fnmatch

try:
    _unicode = unicode
except NameError:
    # If Python is built without Unicode support, the unicode type
    # will not exist. Fake one.
    class _unicode(object):
        pass

__all__ = ["glob", "iglob"]

def glob(pathname):
    """Return a list of paths matching a pathname pattern.

    The pattern may contain simple shell-style wildcards a la
    fnmatch. However, unlike fnmatch, filenames starting with a
    dot are special cases that are not matched by '*' and '?'
    patterns.

    """
    return list(iglob(pathname))

def iglob(pathname):
    """Return an iterator which yields the paths matching a pathname pattern.

    The pattern may contain simple shell-style wildcards a la
    fnmatch. However, unlike fnmatch, filenames starting with a
    dot are special cases that are not matched by '*' and '?'
    patterns.

    """
    dirname, basename = os.path.split(pathname)
    if not has_magic(pathname):
        if basename:
            if os.path.lexists(pathname):
                yield pathname
        else:
            # Patterns ending with a slash should match only directories
            if os.path.isdir(dirname):
                yield pathname
        return
    if not dirname:
        for name in glob1(os.curdir, basename):
            yield name
        return
    # `os.path.split()` returns the argument itself as a dirname if it is a
    # drive or UNC path.  Prevent an infinite recursion if a drive or UNC path
    # contains magic characters (i.e. r'\\?\C:').
    if dirname != pathname and has_magic(dirname):
        dirs = iglob(dirname)
    else:
        dirs = [dirname]
    if has_magic(basename):
        glob_in_dir = glob1
    else:
        glob_in_dir = glob0
    for dirname in dirs:
        for name in glob_in_dir(dirname, basename):
            yield os.path.join(dirname, name)

# These 2 helper functions non-recursively glob inside a literal directory.
# They return a list of basenames. `glob1` accepts a pattern while `glob0`
# takes a literal basename (so it only has to check for its existence).

def glob1(dirname, pattern):
    if not dirname:
        dirname = os.curdir
    if isinstance(pattern, _unicode) and not isinstance(dirname, unicode):
        dirname = unicode(dirname, sys.getfilesystemencoding() or
                                   sys.getdefaultencoding())
    try:
        names = os.listdir(dirname)
    except os.error:
        return []
    if pattern[0] != '.':
        names = filter(lambda x: x[0] != '.', names)
    return fnmatch.filter(names, pattern)

def glob0(dirname, basename):
    if basename == '':
        # `os.path.split()` returns an empty basename for paths ending with a
        # directory separator.  'q*x/' should match only directories.
        if os.path.isdir(dirname):
            return [basename]
    else:
        if os.path.lexists(os.path.join(dirname, basename)):
            return [basename]
    return []


magic_check = re.compile('[*?[]')

def has_magic(s):
    return magic_check.search(s) is not None

filename:/usr/lib/python2.7/modulefinder.py
__doc__
"""Find modules used by a script, using introspection."""

filename:/usr/lib/python2.7/site.py
__doc__
"""Append module search paths for third-party packages to sys.path.

****************************************************************
* This module is automatically imported during initialization. *
****************************************************************

In earlier versions of Python (up to 1.5a3), scripts or modules that
needed to use site-specific modules would place ``import site''
somewhere near the top of their code.  Because of the automatic
import, this is no longer necessary (but code that does it still
works).

This will append site-specific paths to the module search path.  On
Unix (including Mac OSX), it starts with sys.prefix and
sys.exec_prefix (if different) and appends
lib/python<version>/site-packages as well as lib/site-python.
On other platforms (such as Windows), it tries each of the
prefixes directly, as well as with lib/site-packages appended.  The
resulting directories, if they exist, are appended to sys.path, and
also inspected for path configuration files.

For Debian and derivatives, this sys.path is augmented with directories
for packages distributed within the distribution. Local addons go
into /usr/local/lib/python<version>/dist-packages, Debian addons
install into /usr/{lib,share}/python<version>/dist-packages.
/usr/lib/python<version>/site-packages is not used.

A path configuration file is a file whose name has the form
<package>.pth; its contents are additional directories (one per line)
to be added to sys.path.  Non-existing directories (or
non-directories) are never added to sys.path; no directory is added to
sys.path more than once.  Blank lines and lines beginning with
'#' are skipped. Lines starting with 'import' are executed.

For example, suppose sys.prefix and sys.exec_prefix are set to
/usr/local and there is a directory /usr/local/lib/python2.5/site-packages
with three subdirectories, foo, bar and spam, and two path
configuration files, foo.pth and bar.pth.  Assume foo.pth contains the
following:

  # foo package configuration
  foo
  bar
  bletch

and bar.pth contains:

  # bar package configuration
  bar

Then the following directories are added to sys.path, in this order:

  /usr/local/lib/python2.5/site-packages/bar
  /usr/local/lib/python2.5/site-packages/foo

Note that bletch is omitted because it doesn't exist; bar precedes foo
because bar.pth comes alphabetically before foo.pth; and spam is
omitted because it is not mentioned in either path configuration file.

After these path manipulations, an attempt is made to import a module
named sitecustomize, which can perform arbitrary additional
site-specific customizations.  If this import fails with an
ImportError exception, it is silently ignored.

"""

filename:/usr/lib/python2.7/functools.py
__doc__
"""functools.py - Tools for working with functions and callable objects
"""

filename:/usr/lib/python2.7/poplib.py
__doc__
"""A POP3 client class.

Based on the J. Myers POP3 draft, Jan. 96
"""

filename:/usr/lib/python2.7/lib-tk/SimpleDialog.py
__doc__
"""A simple but flexible modal dialog box."""


from Tkinter import *


class SimpleDialog:

    def __init__(self, master,
                 text='', buttons=[], default=None, cancel=None,
                 title=None, class_=None):
        if class_:
            self.root = Toplevel(master, class_=class_)
        else:
            self.root = Toplevel(master)
        if title:
            self.root.title(title)
            self.root.iconname(title)
        self.message = Message(self.root, text=text, aspect=400)
        self.message.pack(expand=1, fill=BOTH)
        self.frame = Frame(self.root)
        self.frame.pack()
        self.num = default
        self.cancel = cancel
        self.default = default
        self.root.bind('<Return>', self.return_event)
        for num in range(len(buttons)):
            s = buttons[num]
            b = Button(self.frame, text=s,
                       command=(lambda self=self, num=num: self.done(num)))
            if num == default:
                b.config(relief=RIDGE, borderwidth=8)
            b.pack(side=LEFT, fill=BOTH, expand=1)
        self.root.protocol('WM_DELETE_WINDOW', self.wm_delete_window)
        self._set_transient(master)

    def _set_transient(self, master, relx=0.5, rely=0.3):
        widget = self.root
        widget.withdraw() # Remain invisible while we figure out the geometry
        widget.transient(master)
        widget.update_idletasks() # Actualize geometry information
        if master.winfo_ismapped():
            m_width = master.winfo_width()
            m_height = master.winfo_height()
            m_x = master.winfo_rootx()
            m_y = master.winfo_rooty()
        else:
            m_width = master.winfo_screenwidth()
            m_height = master.winfo_screenheight()
            m_x = m_y = 0
        w_width = widget.winfo_reqwidth()
        w_height = widget.winfo_reqheight()
        x = m_x + (m_width - w_width) * relx
        y = m_y + (m_height - w_height) * rely
        if x+w_width > master.winfo_screenwidth():
            x = master.winfo_screenwidth() - w_width
        elif x < 0:
            x = 0
        if y+w_height > master.winfo_screenheight():
            y = master.winfo_screenheight() - w_height
        elif y < 0:
            y = 0
        widget.geometry("+%d+%d" % (x, y))
        widget.deiconify() # Become visible at the desired location

    def go(self):
        self.root.wait_visibility()
        self.root.grab_set()
        self.root.mainloop()
        self.root.destroy()
        return self.num

    def return_event(self, event):
        if self.default is None:
            self.root.bell()
        else:
            self.done(self.default)

    def wm_delete_window(self):
        if self.cancel is None:
            self.root.bell()
        else:
            self.done(self.cancel)

    def done(self, num):
        self.num = num
        self.root.quit()


if __name__ == '__main__':

    def test():
        root = Tk()
        def doit(root=root):
            d = SimpleDialog(root,
                         text="This is a test dialog.  "
                              "Would this have been an actual dialog, "
                              "the buttons below would have been glowing "
                              "in soft pink light.\n"
                              "Do you believe this?",
                         buttons=["Yes", "No", "Cancel"],
                         default=0,
                         cancel=2,
                         title="Test Dialog")
            print d.go()
        t = Button(root, text='Test', command=doit)
        t.pack()
        q = Button(root, text='Quit', command=t.quit)
        q.pack()
        t.mainloop()

    test()

filename:/usr/lib/python2.7/lib-tk/Tkconstants.py
__doc__
# Symbolic constants for Tk

# Booleans
NO=FALSE=OFF=0
YES=TRUE=ON=1

# -anchor and -sticky
N='n'
S='s'
W='w'
E='e'
NW='nw'
SW='sw'
NE='ne'
SE='se'
NS='ns'
EW='ew'
NSEW='nsew'
CENTER='center'

# -fill
NONE='none'
X='x'
Y='y'
BOTH='both'

# -side
LEFT='left'
TOP='top'
RIGHT='right'
BOTTOM='bottom'

# -relief
RAISED='raised'
SUNKEN='sunken'
FLAT='flat'
RIDGE='ridge'
GROOVE='groove'
SOLID = 'solid'

# -orient
HORIZONTAL='horizontal'
VERTICAL='vertical'

# -tabs
NUMERIC='numeric'

# -wrap
CHAR='char'
WORD='word'

# -align
BASELINE='baseline'

# -bordermode
INSIDE='inside'
OUTSIDE='outside'

# Special tags, marks and insert positions
SEL='sel'
SEL_FIRST='sel.first'
SEL_LAST='sel.last'
END='end'
INSERT='insert'
CURRENT='current'
ANCHOR='anchor'
ALL='all' # e.g. Canvas.delete(ALL)

# Text widget and button states
NORMAL='normal'
DISABLED='disabled'
ACTIVE='active'
# Canvas state
HIDDEN='hidden'

# Menu item types
CASCADE='cascade'
CHECKBUTTON='checkbutton'
COMMAND='command'
RADIOBUTTON='radiobutton'
SEPARATOR='separator'

# Selection modes for list boxes
SINGLE='single'
BROWSE='browse'
MULTIPLE='multiple'
EXTENDED='extended'

# Activestyle for list boxes
# NONE='none' is also valid
DOTBOX='dotbox'
UNDERLINE='underline'

# Various canvas styles
PIESLICE='pieslice'
CHORD='chord'
ARC='arc'
FIRST='first'
LAST='last'
BUTT='butt'
PROJECTING='projecting'
ROUND='round'
BEVEL='bevel'
MITER='miter'

# Arguments to xview/yview
MOVETO='moveto'
SCROLL='scroll'
UNITS='units'
PAGES='pages'

filename:/usr/lib/python2.7/lib-tk/tkFileDialog.py
__doc__
#
# Instant Python
# $Id: tkFileDialog.py 36560 2004-07-18 06:16:08Z tim_one $
#
# tk common file dialogues
#
# this module provides interfaces to the native file dialogues
# available in Tk 4.2 and newer, and the directory dialogue available
# in Tk 8.3 and newer.
#
# written by Fredrik Lundh, May 1997.
#

#
# options (all have default values):
#
# - defaultextension: added to filename if not explicitly given
#
# - filetypes: sequence of (label, pattern) tuples.  the same pattern
#   may occur with several patterns.  use "*" as pattern to indicate
#   all files.
#
# - initialdir: initial directory.  preserved by dialog instance.
#
# - initialfile: initial file (ignored by the open dialog).  preserved
#   by dialog instance.
#
# - parent: which window to place the dialog on top of
#
# - title: dialog title
#
# - multiple: if true user may select more than one file
#
# options for the directory chooser:
#
# - initialdir, parent, title: see above
#
# - mustexist: if true, user must pick an existing directory
#
#


from tkCommonDialog import Dialog

class _Dialog(Dialog):

    def _fixoptions(self):
        try:
            # make sure "filetypes" is a tuple
            self.options["filetypes"] = tuple(self.options["filetypes"])
        except KeyError:
            pass

    def _fixresult(self, widget, result):
        if result:
            # keep directory and filename until next time
            import os
            # convert Tcl path objects to strings
            try:
                result = result.string
            except AttributeError:
                # it already is a string
                pass
            path, file = os.path.split(result)
            self.options["initialdir"] = path
            self.options["initialfile"] = file
        self.filename = result # compatibility
        return result


#
# file dialogs

class Open(_Dialog):
    "Ask for a filename to open"

    command = "tk_getOpenFile"

    def _fixresult(self, widget, result):
        if isinstance(result, tuple):
            # multiple results:
            result = tuple([getattr(r, "string", r) for r in result])
            if result:
                import os
                path, file = os.path.split(result[0])
                self.options["initialdir"] = path
                # don't set initialfile or filename, as we have multiple of these
            return result
        if not widget.tk.wantobjects() and "multiple" in self.options:
            # Need to split result explicitly
            return self._fixresult(widget, widget.tk.splitlist(result))
        return _Dialog._fixresult(self, widget, result)

class SaveAs(_Dialog):
    "Ask for a filename to save as"

    command = "tk_getSaveFile"


# the directory dialog has its own _fix routines.
class Directory(Dialog):
    "Ask for a directory"

    command = "tk_chooseDirectory"

    def _fixresult(self, widget, result):
        if result:
            # convert Tcl path objects to strings
            try:
                result = result.string
            except AttributeError:
                # it already is a string
                pass
            # keep directory until next time
            self.options["initialdir"] = result
        self.directory = result # compatibility
        return result

#
# convenience stuff

def askopenfilename(**options):
    "Ask for a filename to open"

    return Open(**options).show()

def asksaveasfilename(**options):
    "Ask for a filename to save as"

    return SaveAs(**options).show()

def askopenfilenames(**options):
    """Ask for multiple filenames to open

    Returns a list of filenames or empty list if
    cancel button selected
    """
    options["multiple"]=1
    return Open(**options).show()

# FIXME: are the following  perhaps a bit too convenient?

def askopenfile(mode = "r", **options):
    "Ask for a filename to open, and returned the opened file"

    filename = Open(**options).show()
    if filename:
        return open(filename, mode)
    return None

def askopenfiles(mode = "r", **options):
    """Ask for multiple filenames and return the open file
    objects

    returns a list of open file objects or an empty list if
    cancel selected
    """

    files = askopenfilenames(**options)
    if files:
        ofiles=[]
        for filename in files:
            ofiles.append(open(filename, mode))
        files=ofiles
    return files


def asksaveasfile(mode = "w", **options):
    "Ask for a filename to save as, and returned the opened file"

    filename = SaveAs(**options).show()
    if filename:
        return open(filename, mode)
    return None

def askdirectory (**options):
    "Ask for a directory, and return the file name"
    return Directory(**options).show()

# --------------------------------------------------------------------
# test stuff

if __name__ == "__main__":
    # Since the file name may contain non-ASCII characters, we need
    # to find an encoding that likely supports the file name, and
    # displays correctly on the terminal.

    # Start off with UTF-8
    enc = "utf-8"
    import sys

    # See whether CODESET is defined
    try:
        import locale
        locale.setlocale(locale.LC_ALL,'')
        enc = locale.nl_langinfo(locale.CODESET)
    except (ImportError, AttributeError):
        pass

    # dialog for openening files

    openfilename=askopenfilename(filetypes=[("all files", "*")])
    try:
        fp=open(openfilename,"r")
        fp.close()
    except:
        print "Could not open File: "
        print sys.exc_info()[1]

    print "open", openfilename.encode(enc)

    # dialog for saving files

    saveasfilename=asksaveasfilename()
    print "saveas", saveasfilename.encode(enc)

filename:/usr/lib/python2.7/lib-tk/tkCommonDialog.py
__doc__
# base class for tk common dialogues
#
# this module provides a base class for accessing the common
# dialogues available in Tk 4.2 and newer.  use tkFileDialog,
# tkColorChooser, and tkMessageBox to access the individual
# dialogs.
#
# written by Fredrik Lundh, May 1997
#

from Tkinter import *

class Dialog:

    command  = None

    def __init__(self, master=None, **options):

        # FIXME: should this be placed on the module level instead?
        if TkVersion < 4.2:
            raise TclError, "this module requires Tk 4.2 or newer"

        self.master  = master
        self.options = options
        if not master and options.get('parent'):
            self.master = options['parent']

    def _fixoptions(self):
        pass # hook

    def _fixresult(self, widget, result):
        return result # hook

    def show(self, **options):

        # update instance options
        for k, v in options.items():
            self.options[k] = v

        self._fixoptions()

        # we need a dummy widget to properly process the options
        # (at least as long as we use Tkinter 1.63)
        w = Frame(self.master)

        try:

            s = w.tk.call(self.command, *w._options(self.options))

            s = self._fixresult(w, s)

        finally:

            try:
                # get rid of the widget
                w.destroy()
            except:
                pass

        return s

filename:/usr/lib/python2.7/lib-tk/turtle.py
__doc__
#
# turtle.py: a Tkinter based turtle graphics module for Python
# Version 1.0.1 - 24. 9. 2009
#
# Copyright (C) 2006 - 2010  Gregor Lingl
# email: glingl@aon.at
#
# This software is provided 'as-is', without any express or implied
# warranty.  In no event will the authors be held liable for any damages
# arising from the use of this software.
#
# Permission is granted to anyone to use this software for any purpose,
# including commercial applications, and to alter it and redistribute it
# freely, subject to the following restrictions:
#
# 1. The origin of this software must not be misrepresented; you must not
#    claim that you wrote the original software. If you use this software
#    in a product, an acknowledgment in the product documentation would be
#    appreciated but is not required.
# 2. Altered source versions must be plainly marked as such, and must not be
#    misrepresented as being the original software.
# 3. This notice may not be removed or altered from any source distribution.


"""

filename:/usr/lib/python2.7/lib-tk/ScrolledText.py
__doc__
"""A ScrolledText widget feels like a text widget but also has a
vertical scroll bar on its right.  (Later, options may be added to
add a horizontal bar as well, to make the bars disappear
automatically when not needed, to move them to the other side of the
window, etc.)

Configuration options are passed to the Text widget.
A Frame widget is inserted between the master and the text, to hold
the Scrollbar widget.
Most methods calls are inherited from the Text widget; Pack, Grid and
Place methods are redirected to the Frame widget however.
"""

filename:/usr/lib/python2.7/lib-tk/Tkinter.py
__doc__
"""Wrapper functions for Tcl/Tk.

Tkinter provides classes which allow the display, positioning and
control of widgets. Toplevel widgets are Tk and Toplevel. Other
widgets are Frame, Label, Entry, Text, Canvas, Button, Radiobutton,
Checkbutton, Scale, Listbox, Scrollbar, OptionMenu, Spinbox
LabelFrame and PanedWindow.

Properties of the widgets are specified with keyword arguments.
Keyword arguments have the same name as the corresponding resource
under Tk.

Widgets are positioned with one of the geometry managers Place, Pack
or Grid. These managers can be called with methods place, pack, grid
available in every Widget.

Actions are bound to events by resources (e.g. keyword argument
command) or with the method bind.

Example (Hello, World):
import Tkinter
from Tkconstants import *
tk = Tkinter.Tk()
frame = Tkinter.Frame(tk, relief=RIDGE, borderwidth=2)
frame.pack(fill=BOTH,expand=1)
label = Tkinter.Label(frame, text="Hello, World")
label.pack(fill=X, expand=1)
button = Tkinter.Button(frame,text="Exit",command=tk.destroy)
button.pack(side=BOTTOM)
tk.mainloop()
"""

filename:/usr/lib/python2.7/lib-tk/FileDialog.py
__doc__
"""File selection dialog classes.

Classes:

- FileDialog
- LoadFileDialog
- SaveFileDialog

"""

filename:/usr/lib/python2.7/lib-tk/Tkdnd.py
__doc__
"""Drag-and-drop support for Tkinter.

This is very preliminary.  I currently only support dnd *within* one
application, between different windows (or within the same window).

I am trying to make this as generic as possible -- not dependent on
the use of a particular widget or icon type, etc.  I also hope that
this will work with Pmw.

To enable an object to be dragged, you must create an event binding
for it that starts the drag-and-drop process. Typically, you should
bind <ButtonPress> to a callback function that you write. The function
should call Tkdnd.dnd_start(source, event), where 'source' is the
object to be dragged, and 'event' is the event that invoked the call
(the argument to your callback function).  Even though this is a class
instantiation, the returned instance should not be stored -- it will
be kept alive automatically for the duration of the drag-and-drop.

When a drag-and-drop is already in process for the Tk interpreter, the
call is *ignored*; this normally averts starting multiple simultaneous
dnd processes, e.g. because different button callbacks all
dnd_start().

The object is *not* necessarily a widget -- it can be any
application-specific object that is meaningful to potential
drag-and-drop targets.

Potential drag-and-drop targets are discovered as follows.  Whenever
the mouse moves, and at the start and end of a drag-and-drop move, the
Tk widget directly under the mouse is inspected.  This is the target
widget (not to be confused with the target object, yet to be
determined).  If there is no target widget, there is no dnd target
object.  If there is a target widget, and it has an attribute
dnd_accept, this should be a function (or any callable object).  The
function is called as dnd_accept(source, event), where 'source' is the
object being dragged (the object passed to dnd_start() above), and
'event' is the most recent event object (generally a <Motion> event;
it can also be <ButtonPress> or <ButtonRelease>).  If the dnd_accept()
function returns something other than None, this is the new dnd target
object.  If dnd_accept() returns None, or if the target widget has no
dnd_accept attribute, the target widget's parent is considered as the
target widget, and the search for a target object is repeated from
there.  If necessary, the search is repeated all the way up to the
root widget.  If none of the target widgets can produce a target
object, there is no target object (the target object is None).

The target object thus produced, if any, is called the new target
object.  It is compared with the old target object (or None, if there
was no old target widget).  There are several cases ('source' is the
source object, and 'event' is the most recent event object):

- Both the old and new target objects are None.  Nothing happens.

- The old and new target objects are the same object.  Its method
dnd_motion(source, event) is called.

- The old target object was None, and the new target object is not
None.  The new target object's method dnd_enter(source, event) is
called.

- The new target object is None, and the old target object is not
None.  The old target object's method dnd_leave(source, event) is
called.

- The old and new target objects differ and neither is None.  The old
target object's method dnd_leave(source, event), and then the new
target object's method dnd_enter(source, event) is called.

Once this is done, the new target object replaces the old one, and the
Tk mainloop proceeds.  The return value of the methods mentioned above
is ignored; if they raise an exception, the normal exception handling
mechanisms take over.

The drag-and-drop processes can end in two ways: a final target object
is selected, or no final target object is selected.  When a final
target object is selected, it will always have been notified of the
potential drop by a call to its dnd_enter() method, as described
above, and possibly one or more calls to its dnd_motion() method; its
dnd_leave() method has not been called since the last call to
dnd_enter().  The target is notified of the drop by a call to its
method dnd_commit(source, event).

If no final target object is selected, and there was an old target
object, its dnd_leave(source, event) method is called to complete the
dnd sequence.

Finally, the source object is notified that the drag-and-drop process
is over, by a call to source.dnd_end(target, event), specifying either
the selected target object, or None if no target object was selected.
The source object can use this to implement the commit action; this is
sometimes simpler than to do it in the target's dnd_commit().  The
target's dnd_commit() method could then simply be aliased to
dnd_leave().

At any time during a dnd sequence, the application can cancel the
sequence by calling the cancel() method on the object returned by
dnd_start().  This will call dnd_leave() if a target is currently
active; it will never call dnd_commit().

"""

filename:/usr/lib/python2.7/lib-tk/ttk.py
__doc__
"""Ttk wrapper.

This module provides classes to allow using Tk themed widget set.

Ttk is based on a revised and enhanced version of
TIP #48 (http://tip.tcl.tk/48) specified style engine.

Its basic idea is to separate, to the extent possible, the code
implementing a widget's behavior from the code implementing its
appearance. Widget class bindings are primarily responsible for
maintaining the widget state and invoking callbacks, all aspects
of the widgets appearance lies at Themes.
"""

filename:/usr/lib/python2.7/code.py
__doc__
"""Utilities needed to emulate Python's interactive interpreter.

"""

filename:/usr/lib/python2.7/HTMLParser.py
__doc__
"""A parser for HTML and XHTML."""

# This file is based on sgmllib.py, but the API is slightly different.

# XXX There should be a way to distinguish between PCDATA (parsed
# character data -- the normal case), RCDATA (replaceable character
# data -- only char and entity references and end tags are special)
# and CDATA (character data -- only end tags are special).


import markupbase
import re

# Regular expressions used for parsing

interesting_normal = re.compile('[&<]')
incomplete = re.compile('&[a-zA-Z#]')

entityref = re.compile('&([a-zA-Z][-.a-zA-Z0-9]*)[^a-zA-Z0-9]')
charref = re.compile('&#(?:[0-9]+|[xX][0-9a-fA-F]+)[^0-9a-fA-F]')

starttagopen = re.compile('<[a-zA-Z]')
piclose = re.compile('>')
commentclose = re.compile(r'--\s*>')

# see http://www.w3.org/TR/html5/tokenization.html#tag-open-state
# and http://www.w3.org/TR/html5/tokenization.html#tag-name-state
# note: if you change tagfind/attrfind remember to update locatestarttagend too
tagfind = re.compile('([a-zA-Z][^\t\n\r\f />\x00]*)(?:\s|/(?!>))*')
# this regex is currently unused, but left for backward compatibility
tagfind_tolerant = re.compile('[a-zA-Z][^\t\n\r\f />\x00]*')

attrfind = re.compile(
    r'((?<=[\'"\s/])[^\s/>][^\s/=>]*)(\s*=+\s*'
    r'(\'[^\']*\'|"[^"]*"|(?![\'"])[^>\s]*))?(?:\s|/(?!>))*')

locatestarttagend = re.compile(r"""
  <[a-zA-Z][^\t\n\r\f />\x00]*       # tag name
  (?:[\s/]*                          # optional whitespace before attribute name
    (?:(?<=['"\s/])[^\s/>][^\s/=>]*  # attribute name
      (?:\s*=+\s*                    # value indicator
        (?:'[^']*'                   # LITA-enclosed value
          |"[^"]*"                   # LIT-enclosed value
          |(?!['"])[^>\s]*           # bare value
         )
       )?(?:\s|/(?!>))*
     )*
   )?
  \s*                                # trailing whitespace
""", re.VERBOSE)

filename:/usr/lib/python2.7/textwrap.py
__doc__
"""Text wrapping and filling.
"""

filename:/usr/lib/python2.7/genericpath.py
__doc__
"""
Path operations common to more than one OS
Do not use directly.  The OS specific modules import the appropriate
functions from this module themselves.
"""

filename:/usr/lib/python2.7/ConfigParser.py
__doc__
"""Configuration file parser.

A setup file consists of sections, lead by a "[section]" header,
and followed by "name: value" entries, with continuations and such in
the style of RFC 822.

The option values can contain format strings which refer to other values in
the same section, or values in a special [DEFAULT] section.

For example:

    something: %(dir)s/whatever

would resolve the "%(dir)s" to the value of dir.  All reference
expansions are done late, on demand.

Intrinsic defaults can be specified by passing them into the
ConfigParser constructor as a dictionary.

class:

ConfigParser -- responsible for parsing a list of
                configuration files, and managing the parsed database.

    methods:

    __init__(defaults=None)
        create the parser and specify a dictionary of intrinsic defaults.  The
        keys must be strings, the values must be appropriate for %()s string
        interpolation.  Note that `__name__' is always an intrinsic default;
        its value is the section's name.

    sections()
        return all the configuration section names, sans DEFAULT

    has_section(section)
        return whether the given section exists

    has_option(section, option)
        return whether the given option exists in the given section

    options(section)
        return list of configuration options for the named section

    read(filenames)
        read and parse the list of named configuration files, given by
        name.  A single filename is also allowed.  Non-existing files
        are ignored.  Return list of successfully read files.

    readfp(fp, filename=None)
        read and parse one configuration file, given as a file object.
        The filename defaults to fp.name; it is only used in error
        messages (if fp has no `name' attribute, the string `<???>' is used).

    get(section, option, raw=False, vars=None)
        return a string value for the named option.  All % interpolations are
        expanded in the return values, based on the defaults passed into the
        constructor and the DEFAULT section.  Additional substitutions may be
        provided using the `vars' argument, which must be a dictionary whose
        contents override any pre-existing defaults.

    getint(section, options)
        like get(), but convert value to an integer

    getfloat(section, options)
        like get(), but convert value to a float

    getboolean(section, options)
        like get(), but convert value to a boolean (currently case
        insensitively defined as 0, false, no, off for False, and 1, true,
        yes, on for True).  Returns False or True.

    items(section, raw=False, vars=None)
        return a list of tuples with (name, value) for each option
        in the section.

    remove_section(section)
        remove the given file section and all its options

    remove_option(section, option)
        remove the given option from the given section

    set(section, option, value)
        set the given option

    write(fp)
        write the configuration state in .ini format
"""

filename:/usr/lib/python2.7/user.py
__doc__
"""Hook to allow user-specified customization code to run.

As a policy, Python doesn't run user-specified code on startup of
Python programs (interactive sessions execute the script specified in
the PYTHONSTARTUP environment variable if it exists).

However, some programs or sites may find it convenient to allow users
to have a standard customization file, which gets run when a program
requests it.  This module implements such a mechanism.  A program
that wishes to use the mechanism must execute the statement

    import user

The user module looks for a file .pythonrc.py in the user's home
directory and if it can be opened, execfile()s it in its own global
namespace.  Errors during this phase are not caught; that's up to the
program that imports the user module, if it wishes.

The user's .pythonrc.py could conceivably test for sys.version if it
wishes to do different things depending on the Python version.

"""

filename:/usr/lib/python2.7/_LWPCookieJar.py
__doc__
"""Load / save to libwww-perl (LWP) format files.

Actually, the format is slightly extended from that used by LWP's
(libwww-perl's) HTTP::Cookies, to avoid losing some RFC 2965 information
not recorded by LWP.

It uses the version string "2.0", though really there isn't an LWP Cookies
2.0 format.  This indicates that there is extra information in here
(domain_dot and # port_spec) while still being compatible with
libwww-perl, I hope.

"""

filename:/usr/lib/python2.7/urlparse.py
__doc__
"""Parse (absolute and relative) URLs.

urlparse module is based upon the following RFC specifications.

RFC 3986 (STD66): "Uniform Resource Identifiers" by T. Berners-Lee, R. Fielding
and L.  Masinter, January 2005.

RFC 2732 : "Format for Literal IPv6 Addresses in URL's by R.Hinden, B.Carpenter
and L.Masinter, December 1999.

RFC 2396:  "Uniform Resource Identifiers (URI)": Generic Syntax by T.
Berners-Lee, R. Fielding, and L. Masinter, August 1998.

RFC 2368: "The mailto URL scheme", by P.Hoffman , L Masinter, J. Zwinski, July 1998.

RFC 1808: "Relative Uniform Resource Locators", by R. Fielding, UC Irvine, June
1995.

RFC 1738: "Uniform Resource Locators (URL)" by T. Berners-Lee, L. Masinter, M.
McCahill, December 1994

RFC 3986 is considered the current standard and any future changes to
urlparse module should conform with it.  The urlparse module is
currently not entirely compliant with this RFC due to defacto
scenarios for parsing, and for backward compatibility purposes, some
parsing quirks from older RFCs are retained. The testcases in
test_urlparse.py provides a good indicator of parsing behavior.

"""

filename:/usr/lib/python2.7/netrc.py
__doc__
"""An object-oriented interface to .netrc files."""

# Module and documentation by Eric S. Raymond, 21 Dec 1998

import os, stat, shlex
if os.name == 'posix':
    import pwd

__all__ = ["netrc", "NetrcParseError"]


class NetrcParseError(Exception):
    """Exception raised on syntax errors in the .netrc file."""
    def __init__(self, msg, filename=None, lineno=None):
        self.filename = filename
        self.lineno = lineno
        self.msg = msg
        Exception.__init__(self, msg)

    def __str__(self):
        return "%s (%s, line %s)" % (self.msg, self.filename, self.lineno)


class netrc:
    def __init__(self, file=None):
        default_netrc = file is None
        if file is None:
            try:
                file = os.path.join(os.environ['HOME'], ".netrc")
            except KeyError:
                raise IOError("Could not find .netrc: $HOME is not set")
        self.hosts = {}
        self.macros = {}
        with open(file) as fp:
            self._parse(file, fp, default_netrc)

    def _parse(self, file, fp, default_netrc):
        lexer = shlex.shlex(fp)
        lexer.wordchars += r"""!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~"""
        lexer.commenters = lexer.commenters.replace('#', '')
        while 1:
            # Look for a machine, default, or macdef top-level keyword
            toplevel = tt = lexer.get_token()
            if not tt:
                break
            elif tt[0] == '#':
                # seek to beginning of comment, in case reading the token put
                # us on a new line, and then skip the rest of the line.
                pos = len(tt) + 1
                lexer.instream.seek(-pos, 1)
                lexer.instream.readline()
                continue
            elif tt == 'machine':
                entryname = lexer.get_token()
            elif tt == 'default':
                entryname = 'default'
            elif tt == 'macdef':                # Just skip to end of macdefs
                entryname = lexer.get_token()
                self.macros[entryname] = []
                lexer.whitespace = ' \t'
                while 1:
                    line = lexer.instream.readline()
                    if not line or line == '\012':
                        lexer.whitespace = ' \t\r\n'
                        break
                    self.macros[entryname].append(line)
                continue
            else:
                raise NetrcParseError(
                    "bad toplevel token %r" % tt, file, lexer.lineno)

            # We're looking at start of an entry for a named machine or default.
            login = ''
            account = password = None
            self.hosts[entryname] = {}
            while 1:
                tt = lexer.get_token()
                if (tt.startswith('#') or
                    tt in {'', 'machine', 'default', 'macdef'}):
                    if password:
                        self.hosts[entryname] = (login, account, password)
                        lexer.push_token(tt)
                        break
                    else:
                        raise NetrcParseError(
                            "malformed %s entry %s terminated by %s"
                            % (toplevel, entryname, repr(tt)),
                            file, lexer.lineno)
                elif tt == 'login' or tt == 'user':
                    login = lexer.get_token()
                elif tt == 'account':
                    account = lexer.get_token()
                elif tt == 'password':
                    if os.name == 'posix' and default_netrc:
                        prop = os.fstat(fp.fileno())
                        if prop.st_uid != os.getuid():
                            try:
                                fowner = pwd.getpwuid(prop.st_uid)[0]
                            except KeyError:
                                fowner = 'uid %s' % prop.st_uid
                            try:
                                user = pwd.getpwuid(os.getuid())[0]
                            except KeyError:
                                user = 'uid %s' % os.getuid()
                            raise NetrcParseError(
                                ("~/.netrc file owner (%s) does not match"
                                 " current user (%s)") % (fowner, user),
                                file, lexer.lineno)
                        if (prop.st_mode & (stat.S_IRWXG | stat.S_IRWXO)):
                            raise NetrcParseError(
                               "~/.netrc access too permissive: access"
                               " permissions must restrict access to only"
                               " the owner", file, lexer.lineno)
                    password = lexer.get_token()
                else:
                    raise NetrcParseError("bad follower token %r" % tt,
                                          file, lexer.lineno)

    def authenticators(self, host):
        """Return a (user, account, password) tuple for given host."""
        if host in self.hosts:
            return self.hosts[host]
        elif 'default' in self.hosts:
            return self.hosts['default']
        else:
            return None

    def __repr__(self):
        """Dump the class data in the format of a .netrc file."""
        rep = ""
        for host in self.hosts.keys():
            attrs = self.hosts[host]
            rep = rep + "machine "+ host + "\n\tlogin " + repr(attrs[0]) + "\n"
            if attrs[1]:
                rep = rep + "account " + repr(attrs[1])
            rep = rep + "\tpassword " + repr(attrs[2]) + "\n"
        for macro in self.macros.keys():
            rep = rep + "macdef " + macro + "\n"
            for line in self.macros[macro]:
                rep = rep + line
            rep = rep + "\n"
        return rep

if __name__ == '__main__':
    print netrc()

filename:/usr/lib/python2.7/struct.py
__doc__
from _struct import *
from _struct import _clearcache
from _struct import __doc__

filename:/usr/lib/python2.7/platform.pyc
__doc__
Û
J0Xc           @   s¿  d  Z  d Z d Z d d l Z d d l Z d d l Z d d l Z y e j Z Wn/ e	 k
 rÄ e j
 dt k rw d	 Z qÅ d
 Z n Xe j d É Z e j d d d d Ñ Z d Ñ  Z e j d É Z e j d É Z e j d É Z du Z d! Ñ  Z e j d" e j É Z e j d# e j É Z e j d$ e j É Z d d d e d% d& Ñ Z d d d e d' Ñ Z d( dv d) Ñ  É  YZ d* d d+ Ñ Z d d, Ñ Z e j d- É Z d d d dw d. Ñ Z  i d/ dx 6d2 dy 6d3 dz 6d5 d{ 6d6 d| 6d8 d} 6d9 d~ 6d: d 6d< dÄ 6d= dÅ 6d? dÇ 6Z! i d3 dÉ 6d@ dÑ 6dA dÖ 6dB dÜ 6dC dá 6dD dà 6Z" dE Ñ  Z# d d d d dF Ñ Z$ d dG Ñ Z% dH Ñ  Z& dI Ñ  Z' dJ Ñ  Z( d dâ d dK Ñ Z) dL Ñ  Z* d d dä dã dM Ñ Z+ dN Ñ  Z, dO Ñ  Z- d dP Ñ Z. e/ e j0 dQ É s e j0 j1 e j0 j2 e j3 e j0 j4 dR Ñ Z5 n e j0 j6 Z5 dS Ñ  Z7 d dT Ñ Z8 d dU Ñ Z9 i då d 6dç d 6dé d 6Z: e j dY É j; Z< e j d d dZ Ñ Z= d a> d[ Ñ  Z? d\ Ñ  Z@ d] Ñ  ZA d^ Ñ  ZB d_ Ñ  ZC d` Ñ  ZD da Ñ  ZE e j db É ZF e j dc É ZG e j dd É ZH e j de É ZI i  ZJ d df Ñ ZK dg Ñ  ZL dh Ñ  ZM di Ñ  ZN dj Ñ  ZO dk Ñ  ZP dl Ñ  ZQ dm Ñ  ZR i  ZS d1 d1 dn Ñ Z
 eT do k rºdp e jU k p}dq e jU k ZV dr e jU k oõds e jU k ZW e
 eW eV É GHe jX d1 É n  d S(è   s8   This module tries to retrieve as much platform-identifying data as
    possible. It makes this information available via function APIs.

    If called from the command line, it prints the platform
    information concatenated as single string to stdout. The output
    format is useable as part of a filename.

s  
    Copyright (c) 1999-2000, Marc-Andre Lemburg; mailto:mal@lemburg.com
    Copyright (c) 2000-2010, eGenix.com Software GmbH; mailto:info@egenix.com

    Permission to use, copy, modify, and distribute this software and its
    documentation for any purpose and without fee or royalty is hereby granted,
    provided that the above copyright notice appear in all copies and that
    both that copyright notice and this permission notice appear in
    supporting documentation or portions thereof, including modifications,
    that you make.

    EGENIX.COM SOFTWARE GMBH DISCLAIMS ALL WARRANTIES WITH REGARD TO
    THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
    FITNESS, IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL,
    INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
    FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
    NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
    WITH THE USE OR PERFORMANCE OF THIS SOFTWARE !

s   1.0.7iˇˇˇˇNt   dost   win32t   win16t   os2t   NULs	   /dev/nullsC   (__libc_init)|(GLIBC_([0-9.]+))|(libc(_\w+)?\.so(?:\.(\d[0-9.]*))?)t    i   c         C   s  t  t j d É r' t j j |  É }  n  t |  d É } | j | É } d } xt j | | É } | sã | j | É } | s Pn  d } qN n  | j É  \ } }	 }
 } } } | rø | rø d } nú |	 r¯ | d k r‡ d } |
 } q[|
 | k r[|
 } q[nc | r[| d k r[d } | r+| | k r+| } n  | rX| t	 | É | k rX| | } qXq[n  | j
 É  } qN W| j É  | | f S(   s   Tries to determine the libc version that the file executable
        (which defaults to the Python interpreter) is linked against.

        Returns a tuple of strings (lib,version) which default to the
        given parameters in case the lookup fails.

        Note that the function has intimate knowledge of how different
        libc versions add symbols to the executable and thus is probably
        only useable for executables compiled using gcc.

        The file is read and scanned in chunks of chunksize bytes.

    t   realpatht   rbi    t   libct   glibc(   t   hasattrt   ost   pathR   t   opent   readt   _libc_searcht   searcht   groupst   lent   endt   close(   t
   executablet   libt   versiont	   chunksizet   ft   binaryt   post   mt   libcinitR	   t   glibcversiont   sot   threadst	   soversion(    (    s   /usr/lib/python2.7/platform.pyt   libc_verè   s@    			
c         C   sË  t  j j d É rƒ t d É j É  } d }  xä | D]Ç } t j | É } t | É d k r1 | \ } } n q1 | d k rà t j | É } q1 | d k r1 t j | d É } | d } q1 q1 W|  | | f St  j j d É rAt d É j É  } xV | D]K } t j | d É }	 t |	 É d k rÔ |	 d d	 k rÔ d	 |	 d
 | f SqÔ Wn  t  j j	 d É r€t  j
 d É }
 xB t t |
 É d
 d d É D]$ } |
 | d  d k r|
 | =qqW|
 r€|
 j É  d }  |
 d d } |  | | f Sn  |  | | f S(   sŸ    Tries some special tricks to get the distribution
        information in case the default method fails.

        Currently supports older SuSE Linux, Caldera OpenLinux and
        Slackware Linux distributions.

    s   /var/adm/inst-log/infot   SuSEi   t   MIN_DIST_VERSIONt
   DIST_IDENTt   -s   /etc/.installedi    t	   OpenLinuxi   s   /usr/lib/setupiˇˇˇˇi   s   slack-version-t	   slackware(   R   R   t   existsR   t	   readlinest   stringt   splitR   t   stript   isdirt   listdirt   ranget   sort(   t   distnameR   t   idt   infot   linet   tvt   tagt   valuet   valuest   pkgt   verfilest   n(    (    s   /usr/lib/python2.7/platform.pyt   _dist_try_harderƒ   s>    	"#
s   (\w+)[-_](release|version)s'   (.+) release ([\d.]+)[^(]*(?:\((.+)\))?s1   ([^0-9]+)(?: release )?([\d.]+)[^(]*(?:\((.+)\))?R#   t   debiant   fedorat   redhatt   centost   mandraket   mandrivat   rocksR(   t	   yellowdogt   gentoot   UnitedLinuxt
   turbolinuxt   Ubuntuc         C   sπ   d } d } t  j |  É } | d  k	 r7 t | j É  É St j |  É } | d  k	 rb t | j É  É St j t j |  É É } | r¨ | d } t	 | É d k r¨ | d } q¨ n  d | | f S(   NR   i    i   (
   t   _lsb_release_versiont   matcht   Nonet   tupleR   t   _release_versionR+   R,   R-   R   (   t	   firstlineR   R3   R   t   l(    (    s   /usr/lib/python2.7/platform.pyt   _parse_release_file
  s    
s   (?:DISTRIB_ID\s*=)\s*(.*)s   (?:DISTRIB_RELEASE\s*=)\s*(.*)s   (?:DISTRIB_CODENAME\s*=)\s*(.*)i   c         C   s
  yÕ t  d d É è∏ } xï | D]ç } t j | É } | rO | j d É j É  } n  t j | É } | r| | j d É j É  }	 n  t j | É } | r | j d É j É  }
 q q W| r∆ |	 r∆ | |	 |
 f SWd QXWn t t f k
 rÊ n Xy t	 j
 d É } Wn t	 j k
 r|  | | f SX| j É  xd | D]L } t j | É } | d k	 r,| j É  \ } } | | k rx| }  Pqxq,q,Wt |  | | É St  d | d É } | j É  } | j É  t | É \ } } } | rﬂ| rﬂ| }  n  | rÓ| } n  | r˝| } n  |  | | f S(   s‰   Tries to determine the name of the Linux OS distribution name.

        The function first looks for a distribution release file in
        /etc and then reverts to _dist_try_harder() in case no
        suitable files are found.

        supported_dists may be given to define the set of Linux
        distributions to look for. It defaults to a list of currently
        supported Linux distributions identified by their release file
        name.

        If full_distribution_name is true (default), the full
        distribution read from the OS is returned. Otherwise the short
        name taken from supported_dists is used.

        Returns a tuple (distname,version,id) which default to the
        args given as parameters.

    s   /etc/lsb-releaset   rUi   Ns   /etcs   /etc/t   r(   R   t   _distributor_id_file_reR   t   groupR-   t   _release_file_ret   _codename_file_ret   EnvironmentErrort   UnboundLocalErrorR   R/   t   errorR1   t   _release_filenameRK   RL   R   R=   t   readlineR   RQ   (   R2   R   R3   t   supported_distst   full_distribution_namet	   etclsbrelR5   R   t   _u_distnamet
   _u_versiont   _u_idt   etct   filet	   _distnamet   dummyR   RO   t   _versiont   _id(    (    s   /usr/lib/python2.7/platform.pyt   linux_distribution)  sP    

			c         C   s   t  |  | | d | d d ÉS(   sQ   Tries to determine the name of the Linux OS distribution name.

        The function first looks for a distribution release file in
        /etc and then reverts to _dist_try_harder() in case no
        suitable files are found.

        Returns a tuple (distname,version,id) which default to the
        args given as parameters.

    R]   R^   i    (   Ri   (   R2   R   R3   R]   (    (    s   /usr/lib/python2.7/platform.pyt   distt  s    t   _popenc           B   sb   e  Z d  Z d Z d Z d Z d Z d d d Ñ Z d Ñ  Z	 d Ñ  Z
 e j e j d Ñ Z e Z RS(   s   Fairly portable (alternative) popen implementation.

        This is mostly needed in case os.popen() is not available, or
        doesn't work as advertised, e.g. in Win9X GUI programs like
        PythonWin or IDLE.

        Writing to the pipe is currently not supported.

    R   RS   c         C   st   | d k r t  d Ç n  d d  l } | j É  |  _ } t j | d | É t | d É |  _ | |  _ | |  _	 d  S(   NRS   s)   popen()-emulation only supports read modeiˇˇˇˇs    > %sR   (
   t
   ValueErrort   tempfilet   mktempt   tmpfileR   t   systemR   t   pipet   bufsizet   mode(   t   selft   cmdRs   Rr   Rm   Ro   (    (    s   /usr/lib/python2.7/platform.pyt   __init__ñ  s    	c         C   s   |  j  j É  S(   N(   Rq   R   (   Rt   (    (    s   /usr/lib/python2.7/platform.pyR   °  s    c         C   s    |  j  d  k	 r |  j j É  Sd  S(   N(   Rr   RL   Rq   R*   (   Rt   (    (    s   /usr/lib/python2.7/platform.pyR*   •  s    c         C   sV   |  j  r |  j  j É  } n d } |  j rR y | |  j É WqR | k
 rN qR Xn  | S(   Niˇ   (   Rq   R   Ro   (   Rt   t   removeRZ   t   rc(    (    s   /usr/lib/python2.7/platform.pyR   ™  s    		N(   t   __name__t
   __module__t   __doc__Ro   RL   Rq   Rr   Rs   Rv   R   R*   R   t   unlinkRZ   R   t   __del__(    (    (    s   /usr/lib/python2.7/platform.pyRk   Ü  s   
		RS   c         C   sÎ   d } t j j d d É d k rQ y d d l } Wn t k
 rD qQ X| j } n  | d k ræ t t d É rµ t j } t j	 d k rª y | d É Wq≤ t j
 k
 rÆ t } q≤ Xqª qæ t } n  | d k r◊ | |  | É S| |  | | É Sd S(   s!    Portable popen() interface.
    t   OSR   t
   Windows_NTiˇˇˇˇNt   popenR   (   RL   R   t   environt   gett	   win32pipet   ImportErrorRÄ   R
   t   syst   platformRZ   Rk   (   Ru   Rs   Rr   RÄ   RÉ   (    (    s   /usr/lib/python2.7/platform.pyRÄ   º  s&    		c         C   s~   t  j |  d É } | r( | j | É n  y t t | É } Wn t k
 rT | } n Xt t | É } t  j | d  d É }  |  S(   så    Normalize the version and build strings and return a single
        version string using the format major.minor.build (or patchlevel).
    t   .i   (   R+   R,   t   appendt   mapt   intRl   t   strt   join(   R   t   buildRP   t   intst   strings(    (    s   /usr/lib/python2.7/platform.pyt   _norm_version›  s    
s'   (?:([\w ]+) ([\w.]+) .*\[.* ([\d.]+)\])c   	      C   s8  t  j | k r |  | | f SxÑ d D]o } y7 t | É } | j É  } | j É  r_ t j d Ç n  Wn. t j k
 r{ } q# q# t k
 rê } q# q# XPq# W|  | | f St j	 | É } t
 j | É } | d k	 r+| j É  \ }  } } | d d k rˇ | d  } n  | d d k r| d  } n  t | É } n  |  | | f S(	   s2   Tries to figure out the OS version used and returns
        a tuple (system,release,version).

        It uses the "ver" shell command for this which is known
        to exists on Windows, DOS and OS/2. XXX Others too ?

        In case this fails, the given parameters are used as
        defaults.

    t   vers   command /c vers
   cmd /c vers   command failediˇˇˇˇRá   (   s   vers   command /c vers
   cmd /c verN(   RÖ   RÜ   RÄ   R   R   R   RZ   t   IOErrorR+   R-   t   _ver_outputRK   RL   R   Rê   (	   Rp   t   releaseR   t   supported_platformsRu   Rq   R4   t   whyR   (    (    s   /usr/lib/python2.7/platform.pyt   _syscmd_ver˚  s0    t   2000i   i    t   XPt
   2003Serveri   t   post2003t   Vistai   t   7t   8s   8.1i   s   post8.1t   10i
   t   post10t
   2008Servert   2008ServerR2t
   2012Servert   2012ServerR2t   post2012ServerR2c            sÒ  |  d k  s$ |  d k r1 | d k  r1 |  | | f Sd d l  m } m } m } m } m } m } d d l m â  m	 }	 d | f á  f d Ü  É  Y}
 | d É } | d	 É } d
 } } x] | | k r| d 9} | | É } | j
 |	 | j É | t | É É } | s∂ |  | | f Sq∂ W| j | d  É } | s8|  | | f S| | É } | j | d  | | É sd| rq|  | | f S| |
 É É  } | j | d | | É | à  É  É É s¥|  | | f S| j j d ?}  | j j d @} | j j d ?} |  | | f S(   Ni   i   iˇˇˇˇ(   t   c_buffert   POINTERt   byreft   create_unicode_buffert	   Structuret   WinDLL(   t   DWORDt   HANDLEt   VS_FIXEDFILEINFOc              sÉ   e  Z d  à  f d à  f d à  f d à  f d à  f d à  f d à  f d à  f d à  f d	 à  f d
 à  f d à  f d à  f g Z RS(   t   dwSignaturet   dwStrucVersiont   dwFileVersionMSt   dwFileVersionLSt   dwProductVersionMSt   dwProductVersionLSt   dwFileFlagsMaskt   dwFileFlagst   dwFileOSt
   dwFileTypet   dwFileSubtypet   dwFileDateMSt   dwFileDateLS(   Ry   Rz   t   _fields_(    (   R¨   (    s   /usr/lib/python2.7/platform.pyRÆ   T  s   												t   kernel32R   iÇ   R   i   iˇˇ  (   t   ctypesR¶   Rß   R®   R©   R™   R´   t   ctypes.wintypesR¨   R≠   t   GetModuleFileNameWt   _handleR   t   GetFileVersionInfoSizeWRL   t   GetFileVersionInfoWt   VerQueryValueWt   contentsR≥   R¥   (   t   majt   minRç   R¶   Rß   R®   R©   R™   R´   R≠   RÆ   RΩ   R   t   name_lent
   actual_lent   namet   sizet	   ver_blockt   pvi(    (   R¨   s   /usr/lib/python2.7/platform.pyt   _get_real_winverL  s:    $.

'c         C   s  y d d l  m } Wn t k
 r4 |  | | | f SXy& d d l m } m } m } m } Wn3 t k
 rê d d l m } m } m } m } n X| É  }	 t	 |	 d  å  \ }
 } } d j
 |
 | | É } t j |
 | f É pı t j |
 d  f É pı |  }  |	 d  |
 | f k r\y d j
 |	 j É } Wq\t k
 rX| d  d	 k rYd
 | d } qYq\Xn  t |	 d d  É d k rßt j |
 | f É p°t j |
 d  f É p°|  }  n  d  } z4 y& | | d É } | | d É d } Wn n XWd  | r˜| | É n  X|  | | | f S(   Niˇˇˇˇ(   t   getwindowsversion(   t	   OpenKeyExt   QueryValueExt   CloseKeyt   HKEY_LOCAL_MACHINEi   s   {0}.{1}.{2}i   s   SP{}i   s   Service Pack t   SPt   products,   SOFTWARE\Microsoft\Windows NT\CurrentVersiont   CurrentTypei    (   RÖ   Rœ   RÑ   t   winregR–   R—   R“   R”   t   _winregRŒ   t   formatt   _WIN32_CLIENT_RELEASESRÇ   RL   t   service_pack_majort   AttributeErrort   getattrt   _WIN32_SERVER_RELEASES(   Rî   R   t   csdt   ptypeRœ   R–   R—   R“   R”   t   winverR∆   R«   Rç   t   key(    (    s   /usr/lib/python2.7/platform.pyt	   win32_verá  sF    &&		 	c         C   s{   d d l  m  } d d  l } g  } | j } xI |  D]A } y | | | É É Wq2 t | j f k
 rr | | É q2 Xq2 W| S(   Niˇˇˇˇ(   t   gestalt(   R‰   t   MacOSRà   t   RuntimeErrort   Error(   t	   selectorst   defaultR‰   RÂ   RP   Rà   t   selector(    (    s   /usr/lib/python2.7/platform.pyt   _mac_ver_lookup∂  s    	c         C   s   t  |  É d S(   Ni   (   t   hex(   t   bcd(    (    s   /usr/lib/python2.7/platform.pyt   _bcd2str√  s    c    
      C   s  y d d l  }  d d l } Wn t k
 r0 d SXt d É \ } } | r» | d @d ?} | d @d ?} | d	 @} | | f d k r¨ t d É \ } } } d | | | f } q» d t | É | | f } n  | r¯ i d d 6d d 6d d
 6j | d É } n  d }	 | |	 | f S(   s„   
        Thanks to Mark R. Levinson for mailing documentation links and
        code examples for this function. Documentation for the
        gestalt() API is available online at:

           http://www.rgaros.nl/gestalt/
    iˇˇˇˇNt   sysvt   sysai ˇ  i   i   i   i   i
   t   sys1t   sys2t   sys3s   %i.%i.%is   %s.%i.%it   68ki   t   PowerPCi   t   i386R   (   s   sysvs   sysa(   i
   i   (   RÒ   RÚ   RÛ   (   R   R   R   (   R‰   RÂ   RÑ   RL   RÎ   RÓ   RÇ   (
   R‰   RÂ   RÔ   R   t   majort   minort   patchRî   t   machinet   versioninfo(    (    s   /usr/lib/python2.7/platform.pyt   _mac_ver_gestalt«  s(    	

c          C   sí   d }  t  j j |  É s d  Sy d d  l } Wn t k
 r@ d  SX| j |  É } | d } d	 } t  j É  d } | d
 k rÖ d } n  | | | f S(   Ns0   /System/Library/CoreServices/SystemVersion.plistiˇˇˇˇt   ProductVersionR   i   t   ppcs   Power MacintoshRı   (   R   R   R   (   s   ppcs   Power Macintosh(   R   R   R)   RL   t   plistlibRÑ   t	   readPlistt   uname(   t   fnRˇ   t   plRî   R˚   R˙   (    (    s   /usr/lib/python2.7/platform.pyt   _mac_ver_xml  s    
	c         C   s?   t  É  } | d k	 r | St É  } | d k	 r2 | S|  | | f S(   s<   Get MacOS version information and return it as tuple (release,
        versioninfo, machine) with versioninfo being a tuple (version,
        dev_stage, non_release_version).

        Entries which cannot be determined are set to the parameter values
        which default to ''. All tuple entries are strings.
    N(   R  RL   R¸   (   Rî   R˚   R˙   R4   (    (    s   /usr/lib/python2.7/platform.pyt   mac_ver  s    		c         C   sP   d d l  m } y' | j |  É } | d  k r2 | S| SWn t k
 rK | SXd  S(   Niˇˇˇˇ(   t   System(   t	   java.langR  t   getPropertyRL   R‹   (   R    RÈ   R  R8   (    (    s   /usr/lib/python2.7/platform.pyt   _java_getprop  s    c         C   sı   y d d l  } Wn t k
 r0 |  | | | f SXt d | É } t d |  É }  | \ } } } t d | É } t d | É } t d | É } | | | f } | \ } }	 }
 t d |
 É }
 t d	 | É } t d
 |	 É }	 | |	 |
 f } |  | | | f S(   sV   Version interface for Jython.

        Returns a tuple (release,vendor,vminfo,osinfo) with vminfo being
        a tuple (vm_name,vm_release,vm_vendor) and osinfo being a
        tuple (os_name,os_version,os_arch).

        Values which cannot be determined are set to the defaults
        given as parameters (which all default to '').

    iˇˇˇˇNs   java.vendors   java.versions   java.vm.names   java.vm.vendors   java.vm.versions   java.os.archs   java.os.names   java.os.version(   R  RÑ   R	  (   Rî   t   vendort   vminfot   osinfot   javat   vm_namet
   vm_releaset	   vm_vendort   os_namet
   os_versiont   os_arch(    (    s   /usr/lib/python2.7/platform.pyt   java_ver)  s"    c         C   s  |  d k r d |  | | f S|  d k rœ | d k  rB |  | | f St  j | d É } | r± y t | d É } Wn t k
 rÅ q± X| d } t | É | d <t  j | d É } n  | d k  r∆ d	 }  qd	 }  nC |  d
 k r˝ d }  | rÙ | d } qd } n |  d k rd }  n  |  | | f S(   s·    Returns (system,release,version) aliased to common
        marketing names used for some systems.

        It also does some reordering of the information in some cases
        where it would otherwise cause confusion.

    t   Rhapsodys   MacOS X Servert   SunOSt   5Rá   i    i   t   6t   Solarist   IRIX64t   IRIXs    (64bit)t   64bitR   R   t   Windows(   s   win32R   (   R+   R,   Rä   Rl   Rã   Rå   (   Rp   Rî   R   RP   R˜   (    (    s   /usr/lib/python2.7/platform.pyt   system_aliasL  s2    	
				c          G   s&  t  j t t  j t t |  É É d É } t  j } | | d d É } | | d d É } | | d d É } | | d d É } | | d d É } | | d d É } | | d	 d É } | | d
 d É } | | d d É } x, | | d d É } | | k r˜ Pn  | } q’ Wx | d d k r!| d  } qW| S(   sq    Helper to format the platform string in a filename
        compatible format e.g. "system-version-machine".
    R&   t    t   _t   /s   \t   :t   ;t   "t   (t   )t   unknownR   s   --iˇˇˇˇ(   R+   Rå   Râ   R-   t   filterR   t   replace(   t   argsRÜ   R)  t   cleaned(    (    s   /usr/lib/python2.7/platform.pyt	   _platformÇ  s,    			
c         C   sO   y d d l  } Wn t k
 r$ |  SXy | j É  SWn | j k
 rJ |  SXd S(   s8    Helper to determine the node name of this machine.
    iˇˇˇˇN(   t   socketRÑ   t   gethostnameRZ   (   RÈ   R-  (    (    s   /usr/lib/python2.7/platform.pyt   _node¶  s    t   abspathc         C   s+   | |  É s! | | É  |  É }  n  | |  É S(   N(    (   R   t   isabsRå   t   getcwdt   normpath(    (    s   /usr/lib/python2.7/platform.pyt   _abspath∏  s    c         C   s_   t  |  É }  xL t j j |  É rZ t j j t j j t j j |  É t j |  É É É }  q W|  S(   sT    In case filepath is a symlink, follow it until a
        real file is reached.
    (   R4  R   R   t   islinkR3  Rå   t   dirnamet   readlink(   t   filepath(    (    s   /usr/lib/python2.7/platform.pyt   _follow_symlinks≈  s
    	1c         C   sà   t  j d k r | Sy t j d |  t f É } Wn t t j f k
 rM | SXt j | j	 É  É } | j
 É  } | s| | rÄ | S| Sd S(   s.    Interface to the system's uname command.
    R    R   R   R   s   uname %s 2> %sN(   R    s   win32s   win16s   os2(   RÖ   RÜ   R   RÄ   t   DEV_NULLR‹   RZ   R+   R-   R   R   (   t   optionRÈ   R   t   outputRx   (    (    s   /usr/lib/python2.7/platform.pyt   _syscmd_uname–  s    c         C   s©   d d l  } t j d k r | St |  É }  y+ | j d |  g d | j d	 | j É} Wn t t j	 f k
 rs | SX| j
 É  d
 } | j É  } | sù | r° | S| Sd S(   s&   Interface to the system's file command.

        The function uses the -b option of the file command to have it
        ommit the filename in its output and if possible the -L option
        to have the command follow symlinks. It returns default in
        case the command should fail.

    iˇˇˇˇNR    R   R   R   Rd   t   stdoutt   stderri    (   s   doss   win32s   win16s   os2(   t
   subprocessRÖ   RÜ   R9  t   Popent   PIPEt   STDOUTR‹   R   RZ   t   communicatet   wait(   t   targetRÈ   R@  t   procR<  Rx   (    (    s   /usr/lib/python2.7/platform.pyt   _syscmd_file‚  s    t	   WindowsPER  t   MSDOSs   [\s,]c   	      C   sª  | sb d d l  } y | j d É } Wn# | j k
 rJ | j d É } n Xt | d É d } n  |  rz t |  d É } n d } | r„ |  t j k r„ t j t k rŸ t t j \ } } | r« | } n  | rŸ | } qŸ n  | | f St	 | É d } d	 | k r	| | f Sd
 | k rd } n* d | k r3d } n d | k rHd } n  d | k r]d } nT d | k rád | k r~d } q±d } n* d | k rúd } n d | k r±d } n  | | f S(   sì   Queries the given executable (defaults to the Python interpreter
        binary) for various architecture information.

        Returns a tuple (bits,linkage) which contains information about
        the bit architecture and the linkage format used for the
        executable. Both values are returned as strings.

        Values that cannot be determined are returned as given by the
        parameter presets. If bits is given as '', the sizeof(pointer)
        (or sizeof(long) on Python version < 1.5.2) is used as
        indicator for the supported pointer size.

        The function relies on the system's "file" command to do the
        actual work. This is available on most if not all Unix
        platforms. On some non-Unix platforms where the "file" command
        does not exist and the executable is set to the Python interpreter
        binary defaults from _default_architecture are used.

    iˇˇˇˇNt   PRP   i   t   bitR   i   R   s   32-bitt   32bitt   N32t   n32bits   64-bitR  t   ELFt   PER  RI  t   COFFs   MS-DOSRJ  (
   t   structt   calcsizeRZ   Rã   RH  RÖ   R   RÜ   t   _default_architecturet   _architecture_split(	   R   t   bitst   linkageRS  RÀ   R<  t   bRP   t   fileout(    (    s   /usr/lib/python2.7/platform.pyt   architecture  sN    	

								c          C   s®  d }  t  d k	 r t  Sd } y t j É  \ } } } } } Wn t k
 rT d }  n X|  sz t d | | | | | f É rG|  rß t j } d } d } t É  } d } n  d } | d k rIt	 É  \ } } } }	 | r„ | r„ d } n  | s(d t j
 k rt j
 j d d É } q(t j
 j d d É } n  | sIt j
 j d | É } qIn  | rºt | É \ } } } | d k ryd	 } qº| d
 k rº| d	 k rºd	 } d | d  k r∞d } qπd } qºn  | d k rı| sÏ| d k r„d } qÏd } n  d	 } qG| d  d k rGt É  \ } }
 } } d } t j | d É } | sD|
 } qDqGn  | d k rœ| sf| d k ru| } d } n  y d d l } Wn t k
 ròqœX| j d d É \ } } | d k r∆d } qœd } n  | sÁt d d É } n  | d k r¸d } n  | d k rd } n  | d k r&d } n  | d k r;d } n  | d k rPd } n  | d k red } n  | d
 k rå| d	 k råd	 } d } n  | | | | | | f a  t  S(    si   Fairly portable uname interface. Returns a tuple
        of strings (system,node,release,version,machine,processor)
        identifying the underlying platform.

        Note that unlike the os.uname function this also returns
        possible processor information as an additional tuple entry.

        Entries which cannot be determined are set to ''.

    i    R   i   R   t   PROCESSOR_ARCHITEW6432t   PROCESSOR_ARCHITECTUREt   PROCESSOR_IDENTIFIERs   Microsoft WindowsR  t	   Microsofts   6.0i   Rú   R   RM  t   16biti   R  t   Javas   , t   OpenVMSt   0iˇˇˇˇNs   SYI$_CPUiÄ   t   Alphat   VAXs   -pR'  (   s   win32s   win16(   t   _uname_cacheRL   R   R  R‹   R(  RÖ   RÜ   R/  R„   RÅ   RÇ   Ró   R  R+   Rå   t   vms_libRÑ   t   getsyiR=  (   t   no_os_unamet	   processorRp   t   nodeRî   R   R˙   t   use_syscmd_verRﬂ   R‡   R
  R  R  Rg  t   csidt
   cpu_number(    (    s   /usr/lib/python2.7/platform.pyR  v  sú    
%																			c           C   s   t  É  d S(   sç    Returns the system/OS name, e.g. 'Linux', 'Windows' or 'Java'.

        An empty string is returned if the value cannot be determined.

    i    (   R  (    (    (    s   /usr/lib/python2.7/platform.pyRp   ˇ  s    c           C   s   t  É  d S(   sù    Returns the computer's network name (which may not be fully
        qualified)

        An empty string is returned if the value cannot be determined.

    i   (   R  (    (    (    s   /usr/lib/python2.7/platform.pyRk    s    c           C   s   t  É  d S(   sÅ    Returns the system's release, e.g. '2.2.0' or 'NT'

        An empty string is returned if the value cannot be determined.

    i   (   R  (    (    (    s   /usr/lib/python2.7/platform.pyRî     s    c           C   s   t  É  d S(   sá    Returns the system's release version, e.g. '#3 on degas'

        An empty string is returned if the value cannot be determined.

    i   (   R  (    (    (    s   /usr/lib/python2.7/platform.pyR     s    c           C   s   t  É  d S(   st    Returns the machine type, e.g. 'i386'

        An empty string is returned if the value cannot be determined.

    i   (   R  (    (    (    s   /usr/lib/python2.7/platform.pyR˙   $  s    c           C   s   t  É  d S(   s   Returns the (true) processor name, e.g. 'amdk6'

        An empty string is returned if the value cannot be
        determined. Note that many platforms do not provide this
        information or simply return the same value as for machine(),
        e.g.  NetBSD does this.

    i   (   R  (    (    (    s   /usr/lib/python2.7/platform.pyRj  -  s    
sL   ([\w.+]+)\s*\(#?([^,]+)(?:,\s*([\w ]*)(?:,\s*([\w :]*))?)?\)\s*\[([^\]]+)\]?s;   IronPython\s*([\d\.]+)(?: \(([\d\.]+)\))? on (.NET [\d\.]+)sU   ([\d.]+)\s*\(IronPython\s*[\d.]+\s*\(([\d.]+)\) on ([\w.]+ [\d.]+(?: \(\d+-bit\))?)\)sE   ([\w.+]+)\s*\(#?([^,]+),\s*([\w ]+),\s*([\w :]+)\)\s*\[PyPy [^\]]+\]?c         C   s‘  |  d k r t j }  n  t j |  d É } | d k	 r: | Sd |  k r≈ d } |  j d É rm t j |  É } n t j |  É } | d k r° t	 d t
 |  É É Ç n  | j É  \ } } } d } d } npt j j d É rMd } t j |  É } | d k rt	 d t
 |  É É Ç n  | j É  \ } } } }	 }
 | d k rAd } n  t j } nË d |  k r¥d } t j |  É } | d k rìt	 d t
 |  É É Ç n  | j É  \ } } } }	 d } nÅ t j |  É } | d k rËt	 d	 t
 |  É É Ç n  | j É  \ } } } }	 } d
 } | d k rd } n |	 r5| d |	 } n  t t d É rYt j \ }
 } } n d } d } t j | d É } t | É d k r´| j d É t j | d É } n  | | | | | | | f } | t |  <| S(   s€   Returns a parsed version of Python's sys.version as tuple
        (name, version, branch, revision, buildno, builddate, compiler)
        referring to the Python implementation name, version, branch,
        revision, build number, build date/time as string and the compiler
        identification string.

        Note that unlike the Python sys.version, the returned value
        for the Python version will always include the patchlevel (it
        defaults to '.0').

        The function returns empty strings for tuple entries that
        cannot be determined.

        sys_version may be given to parse an alternative version
        string, e.g. if the version was read from a different Python
        interpreter.

    t
   IronPythons*   failed to parse IronPython sys.version: %sR   R  t   Jythons&   failed to parse Jython sys.version: %st   PyPys$   failed to parse PyPy sys.version: %ss'   failed to parse CPython sys.version: %st   CPythonR  t
   subversionRá   i   Rc  N(   RL   RÖ   R   t   _sys_version_cacheRÇ   t
   startswitht   _ironpython_sys_version_parserRK   t    _ironpython26_sys_version_parserRl   t   reprR   RÜ   t   _sys_version_parsert   _pypy_sys_version_parserR
   Rs  R+   R,   R   Rà   Rå   (   t   sys_versiont   resultR    RK   R   t   alt_versiont   compilert   buildnot	   builddatet	   buildtimeR   t   brancht   revisionRP   (    (    s   /usr/lib/python2.7/platform.pyt   _sys_versionW  st    				
c           C   s   t  É  d S(   sR   Returns a string identifying the Python implementation.

        Currently, the following implementations are identified:
          'CPython' (C implementation of Python),
          'IronPython' (.NET implementation of Python),
          'Jython' (Java implementation of Python),
          'PyPy' (Python implementation of Python).

    i    (   RÑ  (    (    (    s   /usr/lib/python2.7/platform.pyt   python_implementationæ  s    c           C   s   t  É  d S(   s»    Returns the Python version as string 'major.minor.patchlevel'

        Note that unlike the Python sys.version, the returned value
        will always include the patchlevel (it defaults to 0).

    i   (   RÑ  (    (    (    s   /usr/lib/python2.7/platform.pyt   python_versionÀ  s    c           C   s   t  t j t É  d d É É S(   s›    Returns the Python version as tuple (major, minor, patchlevel)
        of strings.

        Note that unlike the Python sys.version, the returned value
        will always include the patchlevel (it defaults to 0).

    i   Rá   (   RM   R+   R,   RÑ  (    (    (    s   /usr/lib/python2.7/platform.pyt   python_version_tuple’  s    	c           C   s   t  É  d S(   sË    Returns a string identifying the Python implementation
        branch.

        For CPython this is the Subversion branch from which the
        Python binary was built.

        If not available, an empty string is returned.

    i   (   RÑ  (    (    (    s   /usr/lib/python2.7/platform.pyt   python_branch‡  s    c           C   s   t  É  d S(   sÏ    Returns a string identifying the Python implementation
        revision.

        For CPython this is the Subversion revision from which the
        Python binary was built.

        If not available, an empty string is returned.

    i   (   RÑ  (    (    (    s   /usr/lib/python2.7/platform.pyt   python_revisionÓ  s    c           C   s   t  É  d d !S(   sh    Returns a tuple (buildno, builddate) stating the Python
        build number and date as strings.

    i   i   (   RÑ  (    (    (    s   /usr/lib/python2.7/platform.pyt   python_build˚  s    c           C   s   t  É  d S(   sS    Returns a string identifying the compiler used for compiling
        Python.

    i   (   RÑ  (    (    (    s   /usr/lib/python2.7/platform.pyt   python_compiler  s    c      	   C   s[  t  j |  | f d É } | d k	 r( | St É  \ } } } } } } | | k rX d } n  |  r| t | | | É \ } } } n  | d k r– t | É \ }	 }
 } } | r∏ t | | É } qGt | | | | É } nw| d	 k rYt d É \ } } } | r"| r"t | | | | d | | | É } qGt t	 j
 É \ } } t | | | | d | | É } nÓ | d k r∆t É  \ } } } \ } } } | sê| r•t | | | É } qGt | | | d | | | É } nÅ | d k rˇ| rÍt | | É } qGt | | | É } nH | rt | | É } n0 t t	 j
 É \ } } t | | | | | | É } | t  |  | f <| S(
   sÀ   Returns a single string identifying the underlying platform
        with as much useful information as possible (but no more :).

        The output is intended to be human readable rather than
        machine parseable. It may look different on different
        platforms and this is intended.

        If "aliased" is true, the function will use aliases for
        various platforms that report system names which differ from
        their common names, e.g. SunOS will be reported as
        Solaris. The system_alias() function is used to implement
        this.

        Setting terse to true causes the function to return only the
        absolute minimum information needed to identify the platform.

    R   R  t   Linuxt   withRa  t   onRÂ   N(   Rå  (   t   _platform_cacheRÇ   RL   R  R  R„   R,  Rj   R"   RÖ   R   R  R[  (   t   aliasedt   terseR|  Rp   Rk  Rî   R   R˙   Rj  t   relt   versRﬂ   R‡   RÜ   R2   t   distversiont   distidt   libcnamet   libcversionRS   t   vR  R  R  R  RW  RX  (    (    s   /usr/lib/python2.7/platform.pyRÜ     sP    	t   __main__Rë  s   --terset
   nonaliaseds   --nonaliased(   s   doss   win32s   win16s   os2(   s   SuSER>   R?   R@   RA   RB   RC   RD   s	   slackwareRE   RF   RG   RH   RI   (    (   s   win32s   win16s   doss   os2(   i   i    (   i   i   (   i   i   (   i   N(   i   i    (   i   i   (   i   i   (   i   i   (   i   N(   i
   i    (   i
   N(   i   i   (   i   i    (   i   i   (   i   i   (   i   i   (   i   N(   R   R   R   (   R   R   R   (   R   R   R   (   R   s	   WindowsPE(   R   s   Windows(   R   s   MSDOS(Y   R{   t   __copyright__t   __version__RÖ   R+   R   t   ret   devnullR:  R‹   RÜ   t   compileR   R   R"   R=   R[   RJ   RN   t   _supported_distsRQ   t   IRT   RV   RW   Ri   Rj   Rk   RL   RÄ   Rê   Rì   Ró   R⁄   Rﬁ   RŒ   R„   RÎ   RÓ   R¸   R  R  R	  R  R  R,  R/  R
   R   R1  Rå   R2  R3  R4  R0  R9  R=  RH  RU  R,   RV  R[  Rf  R  Rp   Rk  Rî   R   R˙   Rj  Ry  Rv  Rw  Rz  Rt  RÑ  RÖ  RÜ  Rá  Rà  Râ  Rä  Rã  Rè  Ry   t   argvRë  Rê  t   exit(    (    (    s   /usr/lib/python2.7/platform.pyt   <module>
   s‹   h0	
3	2  		H	6!	2

	;/		)		#	6	$	3
W	â			
											g		
					
R
filename:/usr/lib/python2.7/functools.pyc
__doc__
Û
/0Xc           @   s\   d  Z  d d l m Z m Z d Z d Z e e d Ñ Z e e d Ñ Z d	 Ñ  Z d
 Ñ  Z	 d S(   sE   functools.py - Tools for working with functions and callable objects
iˇˇˇˇ(   t   partialt   reducet
   __module__t   __name__t   __doc__t   __dict__c         C   sa   x' | D] } t  |  | t | | É É q Wx0 | D]( } t |  | É j t | | i  É É q1 W|  S(   s  Update a wrapper function to look like the wrapped function

       wrapper is the function to be updated
       wrapped is the original function
       assigned is a tuple naming the attributes assigned directly
       from the wrapped function to the wrapper function (defaults to
       functools.WRAPPER_ASSIGNMENTS)
       updated is a tuple naming the attributes of the wrapper that
       are updated with the corresponding attribute from the wrapped
       function (defaults to functools.WRAPPER_UPDATES)
    (   t   setattrt   getattrt   update(   t   wrappert   wrappedt   assignedt   updatedt   attr(    (    s   /usr/lib/python2.7/functools.pyt   update_wrapper   s
    &c         C   s   t  t d |  d | d | ÉS(   sã  Decorator factory to apply update_wrapper() to a wrapper function

       Returns a decorator that invokes update_wrapper() with the decorated
       function as the wrapper argument and the arguments to wraps() as the
       remaining arguments. Default arguments are as for update_wrapper().
       This is a convenience function to simplify applying partial() to
       update_wrapper().
    R
   R   R   (   R    R   (   R
   R   R   (    (    s   /usr/lib/python2.7/functools.pyt   wraps'   s    c         C   sK  i d d Ñ  f d d Ñ  f d d Ñ  f g d 6d d Ñ  f d d	 Ñ  f d d
 Ñ  f g d 6d d Ñ  f d d Ñ  f d d Ñ  f g d 6d d Ñ  f d d Ñ  f d d Ñ  f g d 6} t  t |  É É t  | É @} | s„ t d É Ç n  t | É } xU | | D]I \ } } | | k r˙ | | _ t t | É j | _ t |  | | É q˙ q˙ W|  S(   s6   Class decorator that fills in missing ordering methodst   __gt__c         S   s   |  | k  p |  | k S(   N(    (   t   selft   other(    (    s   /usr/lib/python2.7/functools.pyt   <lambda>8   s    t   __le__c         S   s   |  | k  p |  | k S(   N(    (   R   R   (    (    s   /usr/lib/python2.7/functools.pyR   9   s    t   __ge__c         S   s   |  | k  S(   N(    (   R   R   (    (    s   /usr/lib/python2.7/functools.pyR   :   s    t   __lt__c         S   s   |  | k p |  | k S(   N(    (   R   R   (    (    s   /usr/lib/python2.7/functools.pyR   ;   s    c         S   s   |  | k o |  | k S(   N(    (   R   R   (    (    s   /usr/lib/python2.7/functools.pyR   <   s    c         S   s   |  | k S(   N(    (   R   R   (    (    s   /usr/lib/python2.7/functools.pyR   =   s    c         S   s   |  | k p |  | k S(   N(    (   R   R   (    (    s   /usr/lib/python2.7/functools.pyR   >   s    c         S   s   |  | k p |  | k S(   N(    (   R   R   (    (    s   /usr/lib/python2.7/functools.pyR   ?   s    c         S   s   |  | k S(   N(    (   R   R   (    (    s   /usr/lib/python2.7/functools.pyR   @   s    c         S   s   |  | k p |  | k S(   N(    (   R   R   (    (    s   /usr/lib/python2.7/functools.pyR   A   s    c         S   s   |  | k o |  | k S(   N(    (   R   R   (    (    s   /usr/lib/python2.7/functools.pyR   B   s    c         S   s   |  | k S(   N(    (   R   R   (    (    s   /usr/lib/python2.7/functools.pyR   C   s    s6   must define at least one ordering operation: < > <= >=(	   t   sett   dirt
   ValueErrort   maxR   R   t   intR   R   (   t   clst   convertt   rootst   roott   opnamet   opfunc(    (    s   /usr/lib/python2.7/functools.pyt   total_ordering5   s.    	c            s    d t  f á  f d Ü  É  Y} | S(   s,   Convert a cmp= function into a key= functiont   Kc              s}   e  Z d  g Z d Ñ  Z á  f d Ü  Z á  f d Ü  Z á  f d Ü  Z á  f d Ü  Z á  f d Ü  Z á  f d Ü  Z	 d Ñ  Z
 RS(	   t   objc         W   s   | |  _  d  S(   N(   R$   (   R   R$   t   args(    (    s   /usr/lib/python2.7/functools.pyt   __init__T   s    c            s   à  |  j  | j  É d k  S(   Ni    (   R$   (   R   R   (   t   mycmp(    s   /usr/lib/python2.7/functools.pyR   V   s    c            s   à  |  j  | j  É d k S(   Ni    (   R$   (   R   R   (   R'   (    s   /usr/lib/python2.7/functools.pyR   X   s    c            s   à  |  j  | j  É d k S(   Ni    (   R$   (   R   R   (   R'   (    s   /usr/lib/python2.7/functools.pyt   __eq__Z   s    c            s   à  |  j  | j  É d k S(   Ni    (   R$   (   R   R   (   R'   (    s   /usr/lib/python2.7/functools.pyR   \   s    c            s   à  |  j  | j  É d k S(   Ni    (   R$   (   R   R   (   R'   (    s   /usr/lib/python2.7/functools.pyR   ^   s    c            s   à  |  j  | j  É d k S(   Ni    (   R$   (   R   R   (   R'   (    s   /usr/lib/python2.7/functools.pyt   __ne__`   s    c         S   s   t  d É Ç d  S(   Ns   hash not implemented(   t	   TypeError(   R   (    (    s   /usr/lib/python2.7/functools.pyt   __hash__b   s    (   R   R   t	   __slots__R&   R   R   R(   R   R   R)   R+   (    (   R'   (    s   /usr/lib/python2.7/functools.pyR#   R   s   		(   t   object(   R'   R#   (    (   R'   s   /usr/lib/python2.7/functools.pyt
   cmp_to_keyP   s    N(   s
   __module__s   __name__s   __doc__(   s   __dict__(
   R   t
   _functoolsR    R   t   WRAPPER_ASSIGNMENTSt   WRAPPER_UPDATESR   R   R"   R.   (    (    (    s   /usr/lib/python2.7/functools.pyt   <module>   s   	
